<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="WSWvVPyzUsUM54ydNcrE1pUzdYt5xGKnqD1i7XpWVF8" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/images/site.webmanifest">


  <meta name="msapplication-config" content="/images/browserconfig.xml" />



  <meta name="keywords" content="数据库," />










<meta name="description" content="数据库相关读过MyBatis源码没有？可以参考本文 聊一聊对分库分表的理解。上面有 mysql有哪些索引类型？有哪些存储引擎？有什么区别- 索引类型     - FULLTEXT：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引">
<meta name="keywords" content="数据库">
<meta property="og:type" content="article">
<meta property="og:title" content="面试分享(三).数据库相关">
<meta property="og:url" content="https://dinghuang.github.io/2019/05/18/面试分享(三).数据库相关/index.html">
<meta property="og:site_name" content="一只病猫">
<meta property="og:description" content="数据库相关读过MyBatis源码没有？可以参考本文 聊一聊对分库分表的理解。上面有 mysql有哪些索引类型？有哪些存储引擎？有什么区别- 索引类型     - FULLTEXT：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/1343758042_8526.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/1343757655_1008.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225116942.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225333630.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225423934.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225728222.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225736738.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225756637.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/2019070822580935.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225823969.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225900770.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230031559.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230102585.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230139385.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/1.JPG">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/2.JPG">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/31.JPG">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/4.JPG">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/0.JPG">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/5.JPG">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/6.JPG">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111257402.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111258238.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111259913.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111300494.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20190706105542781.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20180727113023312.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20180727113110216.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/20180727113601623.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/2018072711355127.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/2018072711351276.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-ad0d50c44dc041be.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-ad0d50c44dc041be.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-b1ddc3677c81c9b5.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-1f499d02104728e0.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-35dc3a0aed8a0f9a.png">
<meta property="og:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-3e7aaef9e3865926.png">
<meta property="og:updated_time" content="2019-10-18T10:55:54.869Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试分享(三).数据库相关">
<meta name="twitter:description" content="数据库相关读过MyBatis源码没有？可以参考本文 聊一聊对分库分表的理解。上面有 mysql有哪些索引类型？有哪些存储引擎？有什么区别- 索引类型     - FULLTEXT：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引">
<meta name="twitter:image" content="https://minios.strongsickcat.com/dinghuang-blog-picture/1343758042_8526.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dinghuang.github.io/2019/05/18/面试分享(三).数据库相关/"/>





  <title>面试分享(三).数据库相关 | 一只病猫</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-108021384-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?00a1ba3f5c477c92d7c1ccbb00c6427b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一只病猫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">静坐常思己过，闲谈莫论人非</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'HcRPHRrBuwozvgUoLNyX','2.0.0');
</script>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/05/18/面试分享(三).数据库相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试分享(三).数据库相关</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T18:33:00+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/05/18/面试分享(三).数据库相关/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/05/18/面试分享(三).数据库相关/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <h1 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h1><h2 id="读过MyBatis源码没有？"><a href="#读过MyBatis源码没有？" class="headerlink" title="读过MyBatis源码没有？"></a>读过MyBatis源码没有？</h2><p><a href="https://www.cnblogs.com/zhjh256/p/8512392.html" target="_blank" rel="noopener">可以参考本文</a></p>
<h2 id="聊一聊对分库分表的理解。"><a href="#聊一聊对分库分表的理解。" class="headerlink" title="聊一聊对分库分表的理解。"></a>聊一聊对分库分表的理解。</h2><p>上面有</p>
<h2 id="mysql有哪些索引类型？有哪些存储引擎？有什么区别"><a href="#mysql有哪些索引类型？有哪些存储引擎？有什么区别" class="headerlink" title="mysql有哪些索引类型？有哪些存储引擎？有什么区别"></a>mysql有哪些索引类型？有哪些存储引擎？有什么区别</h2><pre><code>- 索引类型
    - FULLTEXT：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%&quot;这类针对文本的模糊查询效率较低的问题。
    - HASH：由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。
    - BTREE：BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。
    - RTREE：RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，RTREE的优势在于范围查找。
- 索引种类：
    - 普通索引：仅加速查询。
    - 唯一索引：加速查询 + 列值唯一（可以有null）
    - 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
    - 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
    - 全文索引：对文本的内容进行分词，进行搜索
- 存储引擎
    - InnoDB
</code></pre><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1343758042_8526.png" alt="image"></p>
<pre><code>    - InnoDB 也采用 B+Tree这种数据结构来实现 B-Tree索引。而很大的区别在于，InnoDB 存储引擎采用“聚集索引”的数据存储方式实现B-Tree索引，所谓“聚集”，就是指数据行和相邻的键值紧凑地存储在一起，注意 InnoDB 只能聚集一个叶子页（16K）的记录（即聚集索引满足一定的范围的记录），因此包含相邻键值的记录可能会相距甚远。
    - 当InnoDB做全表扫描时并不高效，因为 InnoDB 实际上并没有顺序读取,在大多情况下是在随机读取。做全表扫描时,InnoDB 会按主键顺序扫描页面和行。这应用于所有的InnoDB 表，包括碎片化的表。如果主键页表没有碎片（存储主键和行的页表),全表扫描是相当快，因为读取顺序接近物理存储顺序。但是当主键页有碎片时，该扫描就会变得十分缓慢
    - 遵循ACID原则(atomicity原子性，consistency一致性，isolation隔离性，durability持久性)，具有事务特性的能力：commit，rollback，crash-recovery。
        - 仅InnoDB和NDB(Network DB clustered database engine)支持事务和MVCC
    - 行级锁和Oracle风格的读一致性，提高多用户下的并发度和性能，提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”。
        - 只有通过索引条件检索数据，InnoDB才使用行级锁，否则仍然使用表锁
        - 读一致性：query时使用snapshot快照，允许其他事务进行修改，之后再根据undo log调整数据
        - 默认的隔离级别是可重复读，即同一个事务中多次读取，数据相同
    - 使用主键优化查询，主键索引是聚集索引(Clustered index，仅InnoDB支持)，使查询主键时的I/O最小化
        - 聚集索引是指整个表是按照这个索引来组织的，物理存储顺序与索引顺序相同，所以聚集索引字段的修改需要很大开销
        - InnoDB聚集索引的实现方式，同时也体现了一张 innoDB表的结构，可以看到，InnoDB 中，主键索引和数据是一体的，没有分开。
    - 支持外码约束
    - 崩溃后能很好地恢复
        - 未完成的事务将根据redo log的数据重做
        - 已提交但未写入的修改，将从doublewrite buffer重做
        - 系统闲时会purge buffer
    - 维护一个内存中的buffer pool缓冲池，数据被访问时，表和索引数据会被缓存
    - 对增删改的change buffering策略，如果被修改数据的页不在缓冲池中，则这个修改可以存在change buffer中，等相应页被放进缓冲池(发生对该页的访问)时，再写入修改，称为merge
    - adaptive hash index，经常被访问的页会自动在内存建立一个哈希索引，适于=和IN的查询。buffer pool中会预留这种索引需要的内存空间。建立在已有的B树索引基础上，哈希索引可以是部分的，B树索引不需要全部缓存在缓冲池中
    - 使用checksum校验和机制检测内存或硬盘的损坏
    - InnoDB是为处理巨大数据量的最大性能设计
    - 可以在一个查询中join混用InnoDB引擎的表和其他引擎的表
- MyISAM
</code></pre><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1343757655_1008.png" alt="image"></p>
<pre><code>    - 适用场景：read-only or read-mostly workloads in Web and data warehousing configurations(查询效率很高，适合大量读操作的场景)
    - 每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。MyISAM索引文件【.MYI (MYIndex)】和数据文件【.MYD (MYData)】是分离的，索引文件仅保存记录所在页的指针（物理位置），通过这些地址来读取页，进而读取被索引的行
    - MyISAM 默认会把索引读入内存，直接在内存中操作
    - Innodb强调多功能性，支持的拓展功能比较多，myisam主要侧重于性能
    - 将创建3个文件，一个.frm文件，一个.MYD(MYData)文件存数据，一个.MYI(MYIndex)文件存索引
    - 数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
    - 所有数据值都按小字节(low byte first)存储，因此独立于操作系统(可移植性)。但没有明显降低速度，只是需要多处理一下对齐问题，况且获取列值所花的时间不是最主要的
    - 所有数字键都按大字节(high byte first)存储，利于压缩
    - BLOB和TEXT列可以创建索引
    - 每一个character列可以使用不同的字符编码
    - 会保存表的具体行数
    - 使用B树索引，string索引会被压缩，当string是索引第一项时还会压缩前缀
    - 支持真正的变长字段varchar
    - 支持并发的insert
- 区别
    - InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；
    - InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
    - InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；
    - Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；
- 如何选择
    - 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；
    - 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。
    - 系统奔溃后，MyISAM恢复起来更困难，能否接受；
    - MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。
- ARCHIVE
    - 适用场景：作为仓库，存储大量的独立的作为历史记录的数据(插入速度快但查询支持较差）
    - 不支持索引
    - 没有存储大小限制(InnoDB是64TB)
    - 能很好地压缩数据
    - 使用行级锁
    - 支持INSERT, REPLACE, SELECT, 不支持 DELETE, UPDATE
    - 使用zlib 无损数据压缩。数据insert后即被压缩，放在一个压缩缓冲区中，select操作会导致清空缓冲区，此时数据被真正存储。支持批处理insert。
    - 行会根据需要解压，不设缓冲。select会导致全表扫描。select是读一致性的。大量查询during insertion会影响压缩。使用REPAIR TABLE或OPTIMIZE TABLE能获取更好的压缩。
- BLACKHOLE
    - 适用场景:转发器（会保存SQL语句的日志，并且复制给slave servers）
    - 过滤器（设置使用黑洞引擎的“dummy” slave进程，依据一定规则将master的日志进行过滤并在BLACKHOLE表写一个新的日志，再复制给slaves，这样只会导致很少的开销）
    - 像黑洞一样接受数据但不存储
    - 创建table A会生成一个A.frm表文件，没有其他文件
    - 支持所有索引
    - 会保存SQL语句的日志，并且复制给slave servers，适合做转发器或过滤器
    - 会导致错误，因为不论log文件是row-based还是statement-based，blackhole表不会存储自增列的数据，所以在slaves上insert时会出现重复的主码错误
    - 使用row-based replication时，如果slaves的表的字段比master少，那么过滤机制其实是在slaves上。如果缺失字段是私密的，不能给slaves获取的；或是有很多slaves，需要在发送数据前就把数据过滤掉以减少网络负载，就不适合这种方式。BLACKHOLE表就能实现在master上进行过滤。
- MRG_MYISAM
    - 适用场景：Good for VLDB environments such as data warehousing
    - 要求多个Mylsam表要有相同的列信息(包括顺序)和索引信息(包括索引的order)
    - 这些信息不同不会影响表合并
        - 列名和索引名
        - 所有的备注comment
        - 表的选项，例如 ``AVG_ROW_LENGTH``, ``MAX_ROWS``, or ``PACK_KEYS``
    - 创建merge表时会创建2个文件，一个是存数据的.frm文件，一个是.mrg文件(存储哪些表应当merge起来使用)
    - merge表中的表可以存于不同的数据库中
    - 支持merge表的增删改查，前提是必须拥有处理其中所有表的权限
    - drop table只是删除了merge表，实际存储数据的表不会被删除
    - 建表需要指定UNION=(list-of-tables)表明使用哪些表，以及INSERT_METHOD=LAST/FIRST表明在哪一个表中插入数据，否则无法执行insert操作
    - merge表没有主键，因为不能强制实行唯一索引
- FEDERATED
    - 适用场景：Very good for distributed or data mart environments
    - 数据不存储在本地，而是在远程数据库，本地访问时会pull远程数据库的数据
    - 远程数据库的表可以是任何存储引擎的表
    - 本地表和远程表应有相同的定义
    - 本地用.frm文件存储表定义，并且包含一个指向远程数据库的连接字符串
    - 本地执行操作时，会发送给远程去执行，使用MySQL client API
    - 远程表可以是一个FEDERATED表，但注意不要造成一个循环
    - FEDERATED表不支持一般意义上的索引，要远程表上有索引才有效
    - 如果一个查询语句不能使用远程表的索引，会导致全表扫描，本地数据库会获取全表数据（存在本地内存中，如果数据量过大会引起交换和挂起），再在本地进行过滤
    - 不支持alter table或drop table，执行drop table只会删除本地FEDERATED表
    - 不支持分区
    - 如果远程表改变，本地表无法获知
- PERFORMANCE_SCHEMA
    - 关注收集mysql server运行中的性能数据，会监视server的所有events
    - performance_schema数据库名及其表名都是小写的，查询时要用小写
    - 很多表都是只读的，对数据库所有表的GRANT ALL授权是不允许的
    - 数据库中表的更改不会写在日志中
    - 是完全in-memory的，不占用磁盘空间，mysql服务启动时表会被重新填充，关闭服务时便丢弃
    - 数据收集的实现是在源码中添加&quot;监控点&quot;(instrumentation)，没有用额外的线程(不像&quot;复制&quot;或&quot;事件调度&quot;)
    - 用户不能创建存储该类型的表
- MEMORY
    - 适用场景：存储临时、不重要的数据，例如作为缓存，适合大量读的情形 (limited updates)
    - 不支持变长的数据类型variable-length data types (including BLOB and TEXT)
    - 不支持外码约束
    - 不支持压缩
    - 不支持MVCC
    - 支持哈希索引和B树索引，不支持全文索引和T树索引
    - mysql服务关闭或重启，数据会消失(表还在)
    - 数据量不能超过内存大小
    - 性能限制
        - 单线程执行
        - 表更新用表级锁(高并发读写情形下，表级锁严重降低性能，还不如InnoDB快)
    - 内置的临时表(也在内存中)太大时会自动转成磁盘存储，但用户自创的内存表永远不会转化
    - 可以从persistent data source装载数据到内存表
    - 被删除的row会放进一个链表(不会回收内存)，等插入新数据时拿出来复用，只有整个表被删除后才会回收内存。采用定长的行存储，即使是varchar也是定长存储的。
    - 默认使用哈希索引，并且允许非唯一的哈希索引(但如果字段含大量重复值，性能会很低，这种情况最好用B树索引)，被索引字段可以有NULL。
- CSV
    - 创建一个csv表，除了.frm文件外，还创建一个.csv文件用于存储数据，还有一个.csm文件存储表状态、行数等信息，称为metafile
    - 所有字段都必须NOT NULL
    - 不支持索引、分区
</code></pre><h2 id="对索引的理解，组合索引，索引的最佳实践"><a href="#对索引的理解，组合索引，索引的最佳实践" class="headerlink" title="对索引的理解，组合索引，索引的最佳实践"></a>对索引的理解，组合索引，索引的最佳实践</h2><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul>
<li>B-Tree 索引：MySQL 中最主要的索引；</li>
<li>RTREE 索引：仅仅是 MyISAM，GIS；</li>
<li>哈希索引：MyISAM，5.6 开始的 Innodb。</li>
</ul>
<h3 id="BTREE-索引能做什么？"><a href="#BTREE-索引能做什么？" class="headerlink" title="BTREE 索引能做什么？"></a>BTREE 索引能做什么？</h3><ul>
<li>直接查看 KEY=5 的所有列；</li>
<li>找到 KEY &gt; 5 的列，范围查找；</li>
<li>查找 5&lt;KEY&lt;10 之间的所有列，封闭范围查找；</li>
<li>不能找到 KEY 的最后一个数字是 0 的列（这个不是范围查找）。</li>
</ul>
<h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><ul>
<li>字符串索引实际上也没什么不同，按照字典顺序排列，例如 ”AAAA” &lt; “AAAB”;</li>
<li>like 前缀是一个特殊排序，例如 LIKE “ABC%” 意味着 “ABC[LOWEST]”&lt;KEY&lt;“ABC[HIGHEST]”，但是 LIKE “%ABC” 不走索引。</li>
</ul>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><ul>
<li>按照定义的顺序从左往右进行比较，例如在 KEY(col1,col2,col3) 中，(1,2,3) &lt; (1,3,1)；</li>
<li>多列索引仍然是一个 BTREE 索引，但不是每列都是一个单独的 BTREE。</li>
</ul>
<h3 id="MySQL-怎么使用索引"><a href="#MySQL-怎么使用索引" class="headerlink" title="MySQL 怎么使用索引"></a>MySQL 怎么使用索引</h3><h4 id="在数据查询中使用索引"><a href="#在数据查询中使用索引" class="headerlink" title="在数据查询中使用索引"></a>在数据查询中使用索引</h4><p>用了索引 LAST_NAME<br><code>SELECT * FROM EMPLOYEES WHERE LAST_NAME=“Smith”;</code></p>
<p>用了索引 (DEPT,LAST_NAME)</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * <span class="keyword">FROM</span> EMPLOYEES WHERE</span><br><span class="line"> <span class="attribute">LAST_NAME</span>=“Smith” <span class="keyword">AND</span></span><br><span class="line"> <span class="attribute">DEPT</span>=“Accounting”</span><br></pre></td></tr></table></figure>
<p>这里虽然索引字段顺序和查询的顺序颠倒，依然会走索引，不是因为最左匹配不走索引。</p>
<p>多列索引会变的困难，对于索引 (A,B,C)：</p>
<ul>
<li>下面的条件会走索引:<ul>
<li>A&gt;5</li>
<li>A=5 AND B&gt;6</li>
<li>A=5 AND B=6 AND C=7</li>
<li>A=5 AND B IN (2,3) AND C&gt;5</li>
<li>下面的条件不走索引，因为不符合最左匹配，缺少第一列</li>
<li>B &gt; 5</li>
<li>B = 6 AND C = 7</li>
</ul>
</li>
</ul>
<blockquote>
<p>在 MySQL5.7 中使用 explain 执行了一下，发现还是会走索引的，估计 MySQL 底层做了什么优化？</p>
</blockquote>
<ul>
<li>下面条件会走部分索引<ul>
<li>A&gt;5 AND B=2</li>
<li>A=5 AND B&gt;6 AND C=2</li>
</ul>
</li>
</ul>
<p>SQL 优化的第一原则：</p>
<p>MySQL 在多列索引中，一遇到 （&lt;,&gt;,between）就会停止使用 key，然而能继续使用 key 直到 in 范围的右边。</p>
<h4 id="在排序中使用索引"><a href="#在排序中使用索引" class="headerlink" title="在排序中使用索引"></a>在排序中使用索引</h4><p>排序</p>
<p><code>SELECT * FROM PLAYERS ORDER BY SCORE DESC LIMIT 10</code></p>
<ul>
<li>该 SQL 会使用建立在 SCORE 列上的 索引；</li>
<li>如果排序的时候没有使用索引，将会导致非常耗时的文件排序；</li>
<li>在排序中经常会考虑组合索引， 例如下面的 SQL 可以考虑(COUNTRY,SCORE) 索引：</li>
</ul>
<p><code>SELECT * FROM PLAYERS WHERE COUNTRY=“US” ORDER BY   SCORE DESC LIMIT 10</code><br>使用多列索引进行高效的排序，在排序中使用索引有很多的限制，对于 KEY(A，B）:</p>
<ul>
<li>下面排序会使用索引：<ul>
<li>ORDER BY A：主列索引；</li>
<li>A=5 ORDER BY B：通过第一列过滤数据，第二列进行排序；</li>
<li>ORDER BY A DESC, B DESC：用相同的排序进行排序；</li>
<li>A&gt;5 ORDER BY A：主列上进行查询和排序</li>
</ul>
</li>
<li>下面的语句不会使用索引：<ul>
<li>ORDER BY B ：非主列索引排序；</li>
<li>A&gt;5 ORDER BY B：第一列上使用范围，第二列进行排序；</li>
<li>A IN(1,2) ORDER BY B：第一列上用 IN；</li>
<li>ORDER BY A ASC, B DESC：两列的排列顺序不同。</li>
</ul>
</li>
</ul>
<p>使用索引进行排序的规则</p>
<ul>
<li>两列的排列顺序不能不一致；</li>
<li>非排序的列中索引部分只能用 =，in 也不能用。</li>
</ul>
<h4 id="表中存在多个索引"><a href="#表中存在多个索引" class="headerlink" title="表中存在多个索引"></a>表中存在多个索引</h4><ul>
<li>MySQL 中可以存在多个索引：会有索引合并；</li>
<li>SELECT * FROM TBL WHERE A=5 AND B=6：该语句能分别使用在 A 和 B 上的索引，但是在 （A,B) 上建立索引是更好的；</li>
<li>SELECT * FROM TBL WHERE A=5 OR B=6：该语句使用两个独立的索引，但不会使用在（A,B) 上建立的索引</li>
</ul>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>可以在索引最左边一列上建立前缀索引：</p>
<ul>
<li>ALTER TABLE TITLE ADD KEY(TITLE(20));</li>
<li>需要在 BLOB/TEXT 上建立索引；</li>
<li>能显著的提升效率；</li>
<li>不能被用作覆盖索引；</li>
<li>选择合适的前缀长度是一个问题。</li>
</ul>
<h2 id="Explain命令详解"><a href="#Explain命令详解" class="headerlink" title="Explain命令详解"></a>Explain命令详解</h2><p><strong> EXPLAIN 输出格式</strong></p>
<p>EXPLAIN 命令的输出内容大致如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: <span class="literal">NULL</span></span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>各列的含义如下:</p>
<ul>
<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>
<li>select_type: SELECT 查询的类型.</li>
<li>table: 查询的是哪个表</li>
<li>partitions: 匹配的分区</li>
<li>type: join 类型</li>
<li>possible_keys: 此次查询中可能选用的索引</li>
<li>key: 此次查询中确切使用到的索引.</li>
<li>ref: 哪个字段或常数与 key 一起被使用</li>
<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>
<li>filtered: 表示此查询条件所过滤的数据的百分比</li>
<li>extra: 额外的信息</li>
</ul>
<p>接下来我们来重点看一下比较重要的几个字段.</p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>select_type 表示了查询的类型, 它的常用取值有:</p>
<ul>
<li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li>
<li>PRIMARY, 表示此查询是最外层的查询</li>
<li>UNION, 表示此查询是 UNION 的第二或随后的查询</li>
<li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li>
<li>UNION RESULT, UNION 的结果</li>
<li>SUBQUERY, 子查询中的第一个 SELECT</li>
<li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li>
</ul>
<p>最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型, 例如:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: <span class="literal">NULL</span></span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    -&gt; UNION</span><br><span class="line">    -&gt; (SELECT * FROM user_info WHERE id IN (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line">| <span class="type">id</span> | <span class="type">select_type</span>  | <span class="type">table</span>      | <span class="type">partitions</span> | <span class="type">type</span>  | <span class="type">possible_keys</span> | <span class="type">key</span>     | <span class="type">key_len</span> | <span class="type">ref</span>  | <span class="type">rows</span> | <span class="type">filtered</span> | <span class="type">Extra</span>           |<span class="type"></span></span><br><span class="line"><span class="type">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="type">|  1</span> | <span class="type">PRIMARY</span>      | <span class="type">user_info</span>  | <span class="type">NULL</span>       | <span class="type">range</span> | <span class="type">PRIMARY</span>       | <span class="type">PRIMARY</span> | <span class="type">8</span>       | <span class="type">NULL</span> |    <span class="type">3</span> |   <span class="type">100</span><span class="number">.00</span> | <span class="type">Using</span> <span class="keyword">where</span>     |<span class="type"></span></span><br><span class="line"><span class="type">|  2</span> | <span class="type">UNION</span>        | <span class="type">user_info</span>  | <span class="type">NULL</span>       | <span class="type">range</span> | <span class="type">PRIMARY</span>       | <span class="type">PRIMARY</span> | <span class="type">8</span>       | <span class="type">NULL</span> |    <span class="type">3</span> |   <span class="type">100</span><span class="number">.00</span> | <span class="type">Using</span> <span class="keyword">where</span>     |<span class="type"></span></span><br><span class="line"><span class="type">| NULL</span> | <span class="type">UNION</span> RESULT | <span class="type">&lt;union1</span>,<span class="number">2</span>&gt; | <span class="type">NULL</span>       | <span class="type">ALL</span>   | <span class="type">NULL</span>          | <span class="type">NULL</span>    | <span class="type">NULL</span>    | <span class="type">NULL</span> | <span class="type">NULL</span> |     <span class="type">NULL</span> | <span class="type">Using</span> temporary |<span class="type"></span></span><br><span class="line"><span class="type">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="type">3</span> rows <span class="built_in">in</span> <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示查询涉及的表或衍生表</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.</p>
<h4 id="type-常用类型"><a href="#type-常用类型" class="headerlink" title="type 常用类型"></a>type 常用类型</h4><p>type 常用的取值有:</p>
<ul>
<li>system: 表中只有一条数据. 这个类型是特殊的 const 类型.</li>
<li>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.</li>
<li><p>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: <span class="literal">NULL</span></span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">user_info,</span> <span class="string">order_info</span> <span class="string">WHERE</span> <span class="string">user_info.id</span> <span class="string">=</span> <span class="string">order_info.user_id\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">314</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">where;</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">2.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">eq_ref</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">test.order_info.user_id</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="number">2</span> <span class="string">rows</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.<br>例如下面这个例子中, 就使用到了 ref 类型的查询:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">user_info,</span> <span class="string">order_info</span> <span class="string">WHERE</span> <span class="string">user_info.id</span> <span class="string">=</span> <span class="string">order_info.user_id</span> <span class="string">AND</span> <span class="string">order_info.user_id</span> <span class="string">=</span> <span class="number">5</span><span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">const</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">const</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">2.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">ref</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">const</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">2</span> <span class="string">rows</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.01</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.</p>
</li>
</ul>
<p>例如下面的例子就是一个范围查询:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT *</span><br><span class="line">    -&gt;         <span class="keyword">FROM</span> user_info</span><br><span class="line">    -&gt;         WHERE id BETWEEN 2 <span class="keyword">AND</span> 8 \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: range</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: <span class="literal">NULL</span></span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.</li>
</ul>
<p>例如:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">name</span> <span class="string">FROM</span>  <span class="string">user_info</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">name_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">152</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure></p>
<p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.</p>
<ul>
<li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">age</span> <span class="string">FROM</span>  <span class="string">user_info</span> <span class="string">WHERE</span> <span class="string">age</span> <span class="string">=</span> <span class="number">20</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">ALL</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">10.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">where</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure>
<p><strong>type 类型的性能比较</strong></p>
<p>通常来说, 不同的 type 类型的性能关系如下:<br><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><br>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p>
<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><code>possible_keys</code> 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p>
<ul>
<li>字符串<ul>
<li>char(n): n 字节长度</li>
<li>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.</li>
</ul>
</li>
<li>数值类型:<ul>
<li>TINYINT: 1字节</li>
<li>SMALLINT: 2字节</li>
<li>MEDIUMINT: 3字节</li>
<li>INT: 4字节</li>
<li>BIGINT: 8字节 </li>
</ul>
</li>
<li>时间类型<ul>
<li>DATE: 3字节</li>
<li>TIMESTAMP: 4字节</li>
<li>DATETIME: 8字节</li>
</ul>
</li>
</ul>
<p>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p>
<p>我们来举两个简单的栗子:<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order_info <span class="keyword">WHERE</span> user_id &lt; <span class="number">3</span> <span class="keyword">AND</span> product_name = <span class="string">'p1'</span> <span class="keyword">AND</span> productor = <span class="string">'WHH'</span> \G</span><br><span class="line">*************************** <span class="number">1.</span> row ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         <span class="built_in">type</span>: range</span><br><span class="line">possible_keys: user_product_detail_index</span><br><span class="line">          <span class="keyword">key</span>: user_product_detail_index</span><br><span class="line">      key_len: <span class="number">9</span></span><br><span class="line">          ref: <span class="literal">NULL</span></span><br><span class="line">         rows: <span class="number">5</span></span><br><span class="line">     filtered: <span class="number">11.11</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span>; Using <span class="keyword">index</span></span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>上面的例子是从表 <code>order_info</code>中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 <code>order_info</code> 有一个联合索引:<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure></p>
<p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39;</code> 中, 因为先进行 <code>user_id</code> 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 <code>user_id</code>, 因此在 EXPLAIN 中, 显示的 <code>key_len</code> 为 9. 因为 <code>user_id</code> 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将<code>user_id</code> 字段改为 <code>BIGINT(20) NOT NULL DEFAULT &#39;0&#39;</code>, 则 <code>key_length</code> 应该是8.</p>
<p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p>
<p>接下来我们来看一下下一个例子:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">order_info</span> <span class="string">WHERE</span> <span class="string">user_id</span> <span class="string">=</span> <span class="number">1</span> <span class="string">AND</span> <span class="string">product_name</span> <span class="string">=</span> <span class="string">'p1'</span> <span class="string">\G;</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">ref</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">161</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">const,const</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure>
<p>这次的查询中, 我们没有使用到范围查询, <code>key_len</code> 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = &#39;p1&#39;</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>
<ul>
<li>Using filesort<ul>
<li>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li>
</ul>
</li>
</ul>
<p>例如下面的例子:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">order_info</span> <span class="string">ORDER</span> <span class="string">BY</span> <span class="string">product_name</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">253</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index;</span> <span class="string">Using</span> <span class="string">filesort</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure></p>
<p>我们的索引是<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure></p>
<p>但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.<br>如果我们将排序依据改为<code>ORDER BY user_id, product_name,</code> 那么就不会出现 <code>Using filesort</code> 了. 例如:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">order_info</span> <span class="string">ORDER</span> <span class="string">BY</span> <span class="string">user_id,</span> <span class="string">product_name</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">253</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>Using index<ul>
<li>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li>
</ul>
</li>
<li>Using temporary<ul>
<li>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>
</ul>
</li>
</ul>
<h2 id="数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？"><a href="#数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？" class="headerlink" title="数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？"></a>数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？</h2><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>主要有两种情况，会导致缓存和 DB 的一致性问题：</p>
<ul>
<li>并发的场景下，导致读取老的 DB 数据，更新到缓存中。</li>
<li>缓存和 DB 的操作，不在一个事务中，可能只有一个操作成功，而另一个操作失败，导致不一致。</li>
</ul>
<p>当然，有一点我们要注意，缓存和 DB 的一致性，我们指的更多的是最终一致性。我们使用缓存只要是提高读操作的性能，真正在写操作的业务逻辑，还是以数据库为准。例如说，我们可能缓存用户钱包的余额在缓存中，在前端查询钱包余额时，读取缓存，在使用钱包余额时，读取数据库。</p>
<h3 id="更新缓存的设计模式"><a href="#更新缓存的设计模式" class="headerlink" title="更新缓存的设计模式"></a>更新缓存的设计模式</h3><h4 id="Cache-Aside-Pattern-旁路缓存"><a href="#Cache-Aside-Pattern-旁路缓存" class="headerlink" title="Cache Aside Pattern(旁路缓存)"></a>Cache Aside Pattern(旁路缓存)</h4><p>这是最常用最常用的pattern了。其具体逻辑如下：</p>
<ul>
<li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li>命中：应用程序从cache中取数据，取到后返回。</li>
<li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225116942.png" alt="image"></p>
<p>一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。</p>
<blockquote>
<p>要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。</p>
</blockquote>
<h4 id="Read-Write-Through-Pattern"><a href="#Read-Write-Through-Pattern" class="headerlink" title="Read/Write Through Pattern"></a>Read/Write Through Pattern</h4><p>在上面的Cache Aside套路中，我们的应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。</p>
<p>Read Through</p>
<p>Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p>
<p>Write Through</p>
<p>Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）</p>
<p>下图自来Wikipedia的Cache词条。其中的Memory你可以理解为就是我们例子里的数据库。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225333630.png" alt="image"></p>
<h4 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h4><p>Write Behind 又叫 Write Back。write back就是Linux文件系统的Page Cache的算法。</p>
<p>Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。</p>
<blockquote>
<p>这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>
</blockquote>
<p>但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道Unix/Linux非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍Trade-Off。</p>
<p>另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。</p>
<p>在wikipedia上有一张write back的流程图，基本逻辑如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225423934.png" alt="image"></p>
<h3 id="缓存架构设计"><a href="#缓存架构设计" class="headerlink" title="缓存架构设计"></a>缓存架构设计</h3><h4 id="更新缓存-VS-淘汰缓存"><a href="#更新缓存-VS-淘汰缓存" class="headerlink" title="更新缓存 VS 淘汰缓存"></a>更新缓存 VS 淘汰缓存</h4><p>更新缓存：数据不但写入数据库，还会写入缓存；优点：缓存不会增加一次miss，命中率高</p>
<p>淘汰缓存：数据只会写入数据库，不会写入缓存，只会把数据淘汰掉；优点：简单</p>
<p>这两者的选择主要取决于“更新缓存的复杂度”。</p>
<p>例如，上述场景，只是简单的把余额money设置成一个值，那么：</p>
<p>（1）淘汰缓存的操作为deleteCache(uid)</p>
<p>（2）更新缓存的操作为setCache(uid, money)</p>
<p>更新缓存的代价很小，此时我们应该更倾向于更新缓存，以保证更高的缓存命中率</p>
<p>如果余额是通过很复杂的数据计算得出来的，例如业务上除了账户表account，还有商品表product，折扣表discount</p>
<p>account(uid, money)</p>
<p>product(pid, type, price, pinfo)</p>
<p>discount(type, zhekou)</p>
<p>业务场景是用户买了一个商品product，这个商品的价格是price，这个商品从属于type类商品，type类商品在做促销活动要打折扣zhekou，购买了商品过后，这个余额的计算就复杂了，需要：</p>
<p>（1）先把商品的品类，价格取出来：SELECT type, price FROM product WHERE pid=XXX</p>
<p>（2）再把这个品类的折扣取出来：SELECT zhekou FROM discount WHERE type=XXX</p>
<p>（3）再把原有余额从缓存中查询出来money = getCache(uid)</p>
<p>（4）再把新的余额写入到缓存中去setCache(uid, money-price*zhekou)</p>
<p>更新缓存的代价很大，此时我们应该更倾向于淘汰缓存。</p>
<p>总之，淘汰缓存操作简单，并且带来的副作用只是增加了一次cache miss，建议作为通用的处理方式。</p>
<h4 id="先操作数据库-vs-先操作缓存"><a href="#先操作数据库-vs-先操作缓存" class="headerlink" title="先操作数据库 vs 先操作缓存"></a>先操作数据库 vs 先操作缓存</h4><p>当写操作发生时，假设淘汰缓存作为对缓存通用的处理方式，又面临两种抉择：</p>
<p>（1）先写数据库，再淘汰缓存</p>
<p>（2）先淘汰缓存，再写数据库</p>
<p>对于一个不能保证事务性的操作，一定涉及“哪个任务先做，哪个任务后做”的问题，解决这个问题的方向是：如果出现不一致，谁先做对业务的影响较小，就谁先执行。</p>
<p>由于写数据库与淘汰缓存不能保证原子性，谁先谁后同样要遵循上述原则。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225728222.png" alt="image"></p>
<p>假设先写数据库，再淘汰缓存：第一步写数据库操作成功，第二步淘汰缓存失败，则会出现DB中是新数据，Cache中是旧数据，数据不一致。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225736738.png" alt="image"></p>
<p>假设先淘汰缓存，再写数据库：第一步淘汰缓存成功，第二步写数据库失败，则只会引发一次Cache miss。</p>
<p>结论：数据和缓存的操作时序：先淘汰缓存，再写数据库。</p>
<h4 id="缓存架构优化"><a href="#缓存架构优化" class="headerlink" title="缓存架构优化"></a>缓存架构优化</h4><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225756637.png" alt="image"></p>
<p>上述缓存架构有一个缺点：业务方需要同时关注缓存与DB，主要有两种优化方案：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2019070822580935.png" alt="image"></p>
<p>一种方案是服务化：加入一个服务层，向上游提供帅气的数据访问接口，向上游屏蔽底层数据存储的细节，这样业务线不需要关注数据是来自于cache还是DB。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225823969.png" alt="image"></p>
<p>另一种方案是异步缓存更新：业务线所有的写操作都走数据库，所有的读操作都总缓存，由一个异步的工具来做数据库与缓存之间数据的同步，具体细节是：</p>
<p>（1）要有一个init cache的过程，将需要缓存的数据全量写入cache</p>
<p>（2）如果DB有写操作，异步更新程序读取binlog，更新cache</p>
<p>在（1）和（2）的合作下，cache中有全部的数据，这样：</p>
<p>（a）业务线读cache，一定能够hit（很短的时间内，可能有脏数据），无需关注数据库</p>
<p>（b）业务线写DB，cache中能得到异步更新，无需关注缓存</p>
<p>这样将大大简化业务线的调用逻辑，存在的缺点是，如果缓存的数据业务逻辑比较复杂，async-update异步更新的逻辑可能也会比较复杂。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>（1）淘汰缓存是一种通用的缓存处理方式</p>
<p>（2）先淘汰缓存，再写数据库</p>
<p>（3）服务化是向业务方屏蔽底层数据库与缓存复杂性的一种通用方式</p>
<h3 id="缓存和DB一致性的解决方案"><a href="#缓存和DB一致性的解决方案" class="headerlink" title="缓存和DB一致性的解决方案"></a>缓存和DB一致性的解决方案</h3><h4 id="先淘汰缓存，再写数据库"><a href="#先淘汰缓存，再写数据库" class="headerlink" title="先淘汰缓存，再写数据库"></a>先淘汰缓存，再写数据库</h4><p>因为先淘汰缓存，所以数据的最终一致性是可以得到有效的保证的。因为先淘汰缓存，即使写数据库发生异常，也就是下次缓存读取时，多读取一次数据库。</p>
<p>但是，这种方案会存在缓存和 DB 的数据会不一致的情况，参照《缓存与数据库一致性优化》 所说。</p>
<p>我们需要解决缓存并行写，实现串行写。比较简单的方式，引入分布式锁。</p>
<ul>
<li>在写请求时，先淘汰缓存之前，获取该分布式锁。</li>
<li>在读请求时，发现缓存不存在时，先获取分布式锁。</li>
</ul>
<p>这样，缓存的并行写就成功的变成串行写落。写请求时，是否主动更新缓存，根据自己业务的需要，是否有，都没问题。</p>
<h4 id="先写数据库，再更新缓存"><a href="#先写数据库，再更新缓存" class="headerlink" title="先写数据库，再更新缓存"></a>先写数据库，再更新缓存</h4><p>按照“先写数据库，再更新缓存”，我们要保证 DB 和缓存的操作，能够在“同一个事务”中，从而实现最终一致性。</p>
<p>基于定时任务来实现</p>
<ul>
<li>首先，写入数据库。</li>
<li>然后，在写入数据库所在的事务中，插入一条记录到任务表。该记录会存储需要更新的缓存 KEY 和 VALUE 。</li>
<li>【异步】最后，定时任务每秒扫描任务表，更新到缓存中，之后删除该记录。</li>
</ul>
<p>基于消息队列来实现</p>
<ul>
<li>首先，写入数据库。</li>
<li>然后，发送带有缓存 KEY 和 VALUE 的事务消息。此时，需要有支持事务消息特性的消息队列，或者我们自己封装消息队列，支持事务消息。</li>
<li>【异步】最后，消费者消费该消息，更新到缓存中。</li>
</ul>
<p>这两种方式，可以进一步优化，可以先尝试更新缓存，如果失败，则插入任务表，或者事务消息。</p>
<p>另外，极端情况下，如果并发写执行时，先更新成功 DB 的，结果后更新缓存：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225900770.png" alt="image"></p>
<p>理论来说，希望的更新缓存顺序是，线程 1 快于线程 2 ，但是实际线程1 晚于线程 2 ，导致数据不一致。</p>
<p>图中一直是基于定时任务或消息队列来实现异步更新缓存，如果网络抖动，导致【插入任务表，或者事务消息】的顺序不一致。</p>
<p>那么怎么解决呢？需要做如下三件事情：</p>
<p>1、在缓存值中，拼接上数据版本号或者时间戳。例如说：value = {value: 原值, version: xxx} 。</p>
<p>2、在任务表的记录，或者事务消息中，增加上数据版本号或者时间戳的字段。</p>
<p>3、在定时任务或消息队列执行更新缓存时，先读取缓存，对比版本号或时间戳，大于才进行更新。 当然，此处也会有并发问题，所以还是得引入分布式锁或 CAS 操作。</p>
<p>关于 Redis 分布式锁，可以看看 <a href="http://svip.iocoder.cn/Redis/Interview" target="_blank" rel="noopener">《精尽 Redis 面试题》</a> 的 <a href="http://svip.iocoder.cn/Cache/Interview/#" target="_blank" rel="noopener">「如何使用 Redis 实现分布式锁？」 </a>问题。</p>
<p>关于 Redis CAS 操作，可以看看 <a href="http://svip.iocoder.cn/Redis/Interview" target="_blank" rel="noopener">《精尽 Redis 面试题》</a> 的 <a href="http://svip.iocoder.cn/Cache/Interview/#" target="_blank" rel="noopener">「什么是 Redis 事务？」 </a>问题。</p>
<h4 id="基于数据库的-binlog-日志"><a href="#基于数据库的-binlog-日志" class="headerlink" title="基于数据库的 binlog 日志"></a>基于数据库的 binlog 日志</h4><h5 id="重客户端"><a href="#重客户端" class="headerlink" title="重客户端"></a>重客户端</h5><p>写入缓存：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230031559.png" alt="image"></p>
<ul>
<li>应用同时更新数据库和缓存</li>
<li>如果数据库更新成功，则开始更新缓存，否则如果数据库更新失败，则整个更新过程失败。</li>
<li>判断更新缓存是否成功，如果成功则返回</li>
<li>如果缓存没有更新成功，则将数据发到MQ中</li>
<li>应用监控MQ通道，收到消息后继续更新Redis。</li>
</ul>
<p>问题点：如果更新Redis失败，同时在将数据发到MQ之前的时间，应用重启了，这时候MQ就没有需要更新的数据，如果Redis对所有数据没有设置过期时间，同时在读多写少的场景下，只能通过人工介入来更新缓存。</p>
<p>读缓存：</p>
<p>如何来解决这个问题？那么在写入Redis数据的时候，在数据中增加一个时间戳插入到Redis中。在从Redis中读取数据的时候，首先要判断一下当前时间有没有过期，如果没有则从缓存中读取，如果过期了则从数据库中读取最新数据覆盖当前Redis数据并更新时间戳。具体过程如下图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230102585.png" alt="image"></p>
<h5 id="客户端数据库与缓存解耦"><a href="#客户端数据库与缓存解耦" class="headerlink" title="客户端数据库与缓存解耦"></a>客户端数据库与缓存解耦</h5><p>上述方案对于应用的研发人员来讲比较重，需要研发人员同时考虑数据库和Redis是否成功来做不同方案，如何让研发人员只关注数据库层面，而不用关心缓存层呢？请看下图：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230139385.png" alt="image"></p>
<ul>
<li>应用直接写数据到数据库中。</li>
<li>数据库更新binlog日志。</li>
<li>利用Canal中间件读取binlog日志。</li>
<li>Canal借助于限流组件按频率将数据发到MQ中。</li>
<li>应用监控MQ通道，将MQ的数据更新到Redis缓存中。</li>
</ul>
<p>可以看到这种方案对研发人员来说比较轻量，不用关心缓存层面，而且这个方案虽然比较重，但是却容易形成统一的解决方案。</p>
<p>PS：下面这两种比较实用</p>
<p>“先淘汰缓存，再写数据库”的方案，并且无需引入分布式锁。</p>
<p>“先写数据库，再更新缓存”的方案，并且无需引入定时任务或者消息队列。</p>
<p>使用缓存过程中，经常会遇到缓存数据的不一致性和脏读现象。一般情况下，采取缓存双淘汰机制，在更新数据库的前淘汰缓存。此外，设定超时时间，例如三十分钟。</p>
<p>极端场景下，即使有脏数据进入缓存，这个脏数据也最存在一段时间后自动销毁。</p>
<h3 id="主从DB与cache一致性优化"><a href="#主从DB与cache一致性优化" class="headerlink" title="主从DB与cache一致性优化"></a><a href="https://www.w3cschool.cn/architectroad/architectroad-consistency-of-cache-with-master-and-slave-database.html" target="_blank" rel="noopener">主从DB与cache一致性优化</a></h3><h2 id="聚簇索引-非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？"><a href="#聚簇索引-非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？" class="headerlink" title="聚簇索引/非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？"></a>聚簇索引/非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p> 1.所有非叶子结点至多拥有两个儿子（Left和Right）；</p>
<p>2.所有结点存储一个关键字；</p>
<p>3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</p>
<p>如：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1.JPG" alt="image"></p>
<p>二叉搜索树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；</p>
<p>否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入</p>
<p>右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；</p>
<p>如果 二叉搜索树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么 二叉搜索树</p>
<p>的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变 二叉搜索树结构</p>
<p>（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；</p>
<p>如：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2.JPG" alt="image"></p>
<p>但 二叉搜索树在经过多次插入与删除后，有可能导致不同的结构：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/31.JPG" alt="image"></p>
<p>右边也是一个 二叉搜索树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的</p>
<p>树结构索引；所以，使用 二叉搜索树还要考虑尽可能让 二叉搜索树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；      </p>
<p>实际使用的 二叉搜索树都是在原二叉搜索树的基础上加上平衡算法，即“平衡二叉树”；如何保持 二叉搜索树</p>
<p>结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在 二叉搜索树中插入和删除结点的策略；</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>是一种多路搜索树（并不是二叉的）：</p>
<p>1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；</p>
<p>2.根结点的儿子数为[2, M]；</p>
<p>3.除根结点以外的非叶子结点的儿子数为[M/2, M]；</p>
<p>4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</p>
<p>5.非叶子结点的关键字个数=指向儿子的指针个数-1；</p>
<p>6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</p>
<p>7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</p>
<p>8.所有叶子结点位于同一层；</p>
<p>如：（M=3）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/4.JPG" alt="image"></p>
<p>  B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果</p>
<p>命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为</p>
<p>空，或已经是叶子结点；</p>
<p>B-树的特性：</p>
<p>1.关键字集合分布在整颗树中；</p>
<p>2.任何一个关键字出现且只出现在一个结点中；</p>
<p>3.搜索有可能在非叶子结点结束；</p>
<p>4.其搜索性能等价于在关键字全集内做一次二分查找；</p>
<p>5.自动层次控制；</p>
<p>由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少</p>
<p>利用率，其最底搜索性能为：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0.JPG" alt="image"></p>
<p>其中，M为设定的非叶子结点最多子树个数，N为关键字总数；</p>
<p>所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；</p>
<p>由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p> B+树是B-树的变体，也是一种多路搜索树：</p>
<p>1.其定义基本与B-树同，除了：</p>
<p>2.非叶子结点的子树指针与关键字个数相同；</p>
<p>3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树</p>
<p>（B-树是开区间）；</p>
<p>5.为所有叶子结点增加一个链指针；</p>
<p>6.所有关键字都在叶子结点出现；<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/5.JPG" alt="image"></p>
<p> B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在</p>
<p>非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<p>B+的特性：</p>
<p>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好</p>
<p>是有序的；</p>
<p>2.不可能在非叶子结点命中；</p>
<p>3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储</p>
<p>（关键字）数据的数据层；</p>
<p>4.更适合文件索引系统；</p>
<h3 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B*树"></a>B*树</h3><p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/6.JPG" alt="image"></p>
<p><code>B*</code>树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3</p>
<p>（代替B+树的1/2）；</p>
<p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据</p>
<p>复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父</p>
<p>结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分</p>
<p>数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字</p>
<p>（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之</p>
<p>间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</p>
<p>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p>
<p>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>
<p>B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>所谓聚簇索引，就是指主索引文件和数据文件为同一份文件，聚簇索引主要用在Innodb存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引，如下图所示：</p>
<p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
<h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引就是指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。主要用在MyISAM存储引擎中</p>
<p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111257402.png" alt="image"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111258238.png" alt="image"></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<p>InnoDB索引实现</p>
<p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111259913.png" alt="image"></p>
<p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111300494.png" alt="image"></p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<ul>
<li>MyisAM顺序储存数据，索引叶子节点保存对应数据行地址，辅助索引跟主键索引相差无几（主键索引key不能相同）；InnoDB主键节点同时保存数据行，其他辅助索引保存的是主键索引的值；</li>
</ul>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调(可能是指“非递增”的意思)的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调(可能是指“非递增”的意思)的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<h3 id="为什么选用B-Tree"><a href="#为什么选用B-Tree" class="headerlink" title="为什么选用B+/-Tree"></a>为什么选用B+/-Tree</h3><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</p>
<p>B-Tree：如果一次检索需要访问4个节点，数据库系统设计者利用磁盘预读原理，把节点的大小设计为一个页，那读取一个节点只需要一次I/O操作，完成这次检索操作，最多需要3次I/O(根节点常驻内存)。数据记录越小，每个节点存放的数据就越多，树的高度也就越小，I/O操作就少了，检索效率也就上去了。</p>
<p>B+Tree：非叶子节点只存key，大大滴减少了非叶子节点的大小，那么每个节点就可以存放更多的记录，树更矮了，I/O操作更少了。所以B+Tree拥有更好的性能。</p>
<h2 id="MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？"><a href="#MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？" class="headerlink" title="MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？"></a>MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？</h2><h3 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h3><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<ul>
<li>mysql 默认的隔离级别:可重复读</li>
<li>Oracle 默认的隔离</li>
<li>级别:读已提交</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>MVCC(Multi Version Concurrency Control的简称)，代表多版本并发控制。与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。<br>MVCC最大的优势：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能</p>
<p>了解MVCC前，我们先学习下Mysql架构和数据库事务隔离级别</p>
<h4 id="MYSQL-架构"><a href="#MYSQL-架构" class="headerlink" title="MYSQL 架构"></a>MYSQL 架构</h4><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190706105542781.png" alt="image"></p>
<p>MySQL从概念上可以分为四层，顶层是接入层，不同语言的客户端通过mysql的协议与mysql服务器进行连接通信，接入层进行权限验证、连接池管理、线程管理等。下面是mysql服务层，包括sql解析器、sql优化器、数据缓冲、缓存等。再下面是mysql中的存储引擎层，mysql中存储引擎是基于表的。最后是系统文件层，保存数据、索引、日志等。</p>
<h4 id="MVCC是为了解决什么问题"><a href="#MVCC是为了解决什么问题" class="headerlink" title="MVCC是为了解决什么问题?"></a>MVCC是为了解决什么问题?</h4><ul>
<li>大多数的MYSQL事务型存储引擎,如,InnoDB，Falcon以及PBXT都不使用一种简单的行锁机制.事实上,他们都和MVCC–多版本并发控制来一起使用。</li>
<li>大家都应该知道,锁机制可以控制并发操作,但是其系统开销较大,而MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销。</li>
</ul>
<h4 id="MVCC具体实现"><a href="#MVCC具体实现" class="headerlink" title="MVCC具体实现"></a>MVCC具体实现</h4><p>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。<br>下面看一下在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。</p>
<ul>
<li>SELECT<ul>
<li>InnoDB会根据以下两个条件检查每行记录：<ul>
<li>1、InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>
<li>2、行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li>
<li>只有符合上述两个条件的记录，才能返回作为查询结果。</li>
</ul>
</li>
</ul>
</li>
<li>INSERT<ul>
<li>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</li>
</ul>
</li>
<li>DELETE<ul>
<li>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</li>
</ul>
</li>
<li>UPDATE<ul>
<li>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</li>
<li>保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作</li>
</ul>
</li>
</ul>
<p>举例Demo<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> riemann( </span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment, </span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure></p>
<p>transaction 1:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> riemann <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'riemann'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> riemann <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'chow'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p>
<p>假设系统初始事务ID为1；</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>创建时间(事务ID)</th>
<th>过期时间(事务ID)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>riemann</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>chow</td>
<td>1</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p>transaction 2:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> riemann ;  //(1)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> riemann ;  //(2)</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>
<h5 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务3：</p>
<p>transaction 3:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> riemann <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'peng'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>创建时间(事务ID)</th>
<th>过期时间(事务ID)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>riemann</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>chow</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>3</td>
<td>peng</td>
<td>3</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p>事务3执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2的，所以事务3新增的记录在事务2中是查不出来的，这就通过乐观锁的方式避免了幻读的产生。</p>
<h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务4：</p>
<p>transaction session 4:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">update</span> riemann <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'edgar'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p>
<p>InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要UPDATE的行的删除时间。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>创建时间(事务ID)</th>
<th>过期时间(事务ID)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>riemann</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>chow</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>edgar</td>
<td>4</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p>事务4执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2的，所以事务修改的记录在事务2中是查不出来的，这样就保证了事务在两次读取时读取到的数据的状态是一致的。</p>
<h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务5：</p>
<p>transaction session 5:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> riemann <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>创建时间(事务ID)</th>
<th>过期时间(事务ID)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>riemann</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>chow</td>
<td>1</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>事务5执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2、并且过期时间大于等于2，所以id=2的记录在事务2 语句2中，也是可以查出来的,这样就保证了事务在两次读取时读取到的数据的状态是一致的。</p>
<h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h3><p>MVCC(Multi-Version Concurrent Control)：多版本并发控制，只作用于RC和RR隔离级别，主要是为了避免脏读、非重复读，而非幻读，很多文章说通过MVCC避免幻读，其实这种说法是不完善的，RR隔离级别是通过next-key lock 来避免幻读。</p>
<p>优点：避免了许多需要加锁的情形</p>
<p>缺点：需要维护每行记录版本号，造成额外资源消耗</p>
<p>怎么避免脏读、不可重复读、幻读？</p>
<p>采用RR隔离级别，结合MVCC特性，可以避免脏读、非重复读，有些文章说MVCC用来避免幻读，其实这是不准确的，MVCC通过多版本并发控制来避免非重复读，像幻读定义所说的情况即使有MVCC还是会存在。RR隔离级别是通过禁用innodb_locks_unsafe_for_binlog，在搜索和扫描索引的时候使用next-key locks来避免幻读（下面有对锁说明）。也就是为什么RR隔离级别下，非主键索引DML的操作并发性能会下降的原因了。</p>
<p>为了减少Next-key lock影响，可以设置innodb_locks_unsafe_for_binlog=1，就是disable Next-Key lock，但是并不建议。</p>
<p>想要真正避免幻读只能采取serializable串行化隔离级别，因为都要加表级共享锁或排他锁，所以性能会很差，一般不会采用。</p>
<p>MVCC如何避免非重复读：</p>
<p>MVCC为查询提供了一个基于时间的点的快照。这个查询只能看到在自己之前提交的数据，而在查询开始之后提交的数据是不可以看到的。</p>
<p>在每行记录后面记录两个隐藏的列，一个记录创建时间，一个记录删除时间，记录的是版本号，这里可以理解为事物号。</p>
<p>INSERT：Innodb 为新插入的每一行保存当前系统版本号作为行版本号；</p>
<p>DELETE：Innodb 为删除的每一行保存当前系统版本号作为行删除标识；</p>
<p>UPDATE：Innodb 为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
<h4 id="RR隔离级别下锁介绍"><a href="#RR隔离级别下锁介绍" class="headerlink" title="RR隔离级别下锁介绍"></a>RR隔离级别下锁介绍</h4><h5 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h5><p>在主键或唯一索引上对单行记录加锁</p>
<h5 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h5><p>针对非唯一索引而言，锁定一个范围的记录，但不包括记录本身。锁加在未使用的空闲空间上，可能是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。</p>
<p>如果更新两端的记录会影响到间隙锁，那么操作会被挂起，等待间隙锁释放。</p>
<p>比如锁定范围（4，7），update table set v1=6 where v1=1; 虽然1不在此范围，但是6在（4，7）范围还是会锁定。</p>
<h5 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h5><p>针对非唯一索引而言，行记录锁与间隙锁组合起来用就叫做Next-Key Lock。锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</p>
<p>通过一个例子介绍间隙锁</p>
<p>表test5中存在如下数据：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180727113023312.png" alt="image"></p>
<p>select * from test5 where v1=45 for update; 对v1=45的行加X锁，此时会对(40,45][45,50)加间隙锁，其他事物不能操作在此范围内的数据。</p>
<p>但是为什么在左侧值为40，右侧值为50的时候，有时候操作会被挂起，有时候操作不会挂起呢？</p>
<p>update table set v1=41 where v1=40;41在(40，50)范围会被锁定。</p>
<p>update table set v1=39 where v1=40; 39不在(40，50)范围不会被锁定。</p>
<p>update table set v1=42 where v1=1; 42在(40，50)范围会被锁定。</p>
<p>update table set v1=30 where v1=45; 30不在(40，50)范围，但是45行上面存在的行级record lock，45行记录也被加了锁。</p>
<p>insert into table(id,name) values(14,40);可以插入</p>
<p>insert into table(id,name) values(20,40);不可以插入</p>
<p>insert into table(id,name) values(13,50);不可以插入</p>
<p>insert into table(id,name) values(21,40);可以插入</p>
<p>当插入左侧值的时候，即插入v1=40的时候，要求插入的id值小于id=16的范围。当v1=40的记录有多条的时候，插入的id值要小于其中的最大id值。则可以成功插入；</p>
<p>当插入右侧值的时候，即插入v1=50的时候，要求插入的id值要大于id=18的范围。当v1=50的记录有多条的时候，插入的id值要大于其中的最小id值。则可以成功插入。</p>
<p>所以为什么RR隔离级别下并发性能会有所下降，就是因为存在间隙锁。我们应该尽量使用主键或唯一索引，因为唯一索引会把Next-Key Lock降级为Record Lock。</p>
<h5 id="AUTO-INC-Lock"><a href="#AUTO-INC-Lock" class="headerlink" title="AUTO-INC Lock"></a>AUTO-INC Lock</h5><p>只针对存在主键的insert操作，由innodb_autoinc_lock_mode参数决定锁粒度。</p>
<p>在了解自增锁前需要知道mysql都有哪些insert操作：</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSERT-like</td>
<td>所有可以向表中增加行的语句</td>
</tr>
<tr>
<td>Simple inserts</td>
<td>可以预先确定要插入的行数insert…values…</td>
</tr>
<tr>
<td>Bulk inserts</td>
<td>事先不知道要插入的行数（INSERT…SELECT,REPLACE…SELECT,LOAD  DATA）</td>
</tr>
<tr>
<td>Mixed-mode inserts</td>
<td>一些是“Simple  inserts”语句但是有一些是null的自增值</td>
</tr>
</tbody>
</table>
<p>innodb_autoinc_lock_mode= 0 传统锁定模式（所有insert采用传统AUTO-INC机制），所有“INSERT-like”语句获得一个特殊的表级AUTO-INC锁，在存在自增列的表获得一个特殊的表级AUTO-INC锁，(statement-based replication)操作是安全。</p>
<p>innodb_autoinc_lock_mode= 1 默认锁定模式（bulk-insert采用表级锁）</p>
<p>“bulk inserts”仍然使用AUTO-INC表级锁,并保持到语句结束；“Simple inserts”（要插入的行数事先已知）通过在mutex（轻量锁）的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁，只在分配的时间内持有，不是整个语句，(statement-based replication)操作是安全。</p>
<p>innodb_autoinc_lock_mode= 2 轻量锁定模式(所有insert采用轻量级）</p>
<p>所有类INSERT(“INSERT-like” )语句都不会使用表级AUTO-INC lock，”批量插入”时，在由任何给定语句分配的自动递增值中可能存在间隙，(statement-based replication)操作是不安全。</p>
<p>可以汇总为如下表格：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180727113110216.png" alt="image"></p>
<p>示例：innodb_autoinc_lock_mode= 1时不连续</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">创建一个表id为自增主键：</span><br><span class="line"></span><br><span class="line">CREATE TABLE `test6` (</span><br><span class="line"></span><br><span class="line">id int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">name int(11),</span><br><span class="line">modified TIMESTAMP<span class="built_in"> DEFAULT </span>CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) <span class="attribute">ENGINE</span>=InnoDB <span class="attribute">AUTO_INCREMENT</span>=1<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
<p>先插入一条记录，然后再多次自插入数据，发现id没有5、10~12，如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180727113601623.png" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2018072711355127.png" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2018072711351276.png" alt="image"></p>
<p>这种情况就是上面锁说的，insert…select…属于Bulk insert，不能预判要插入多少条数据，所以在自增值分配上每次都会按照2^n-1分配：</p>
<p>第一次，先分配一个自增值，因为只有一条数据，正好</p>
<p>第二次，先分配一个自增值3，发现还有数据，继续按2^n-1分配，分配4、5，此时只剩一条数据4，但5已经被分配出去。</p>
<p>第三次，因为5已经被分配出去，此时只能从6开始，以此类推。</p>
<h5 id="Dead-lock"><a href="#Dead-lock" class="headerlink" title="Dead lock"></a>Dead lock</h5><p>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。</p>
<p>死锁检测开关innodb_deadlock_detect 5.7.15后引入，关闭会提升性能，一般应用在秒杀等场景。</p>
<p>出现死锁场景很多，绝大多数是高并发下同时操作一行数据，加锁顺序相反引起。</p>
<p>先删再插，两条insert当需要进行唯一性冲突检测时，需要先加一个S锁，也会产生死锁。</p>
<p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</p>
<h3 id="MySQL-中RC和RR隔离级别的区别"><a href="#MySQL-中RC和RR隔离级别的区别" class="headerlink" title="MySQL 中RC和RR隔离级别的区别"></a>MySQL 中RC和RR隔离级别的区别</h3><p>MySQL数据库中默认隔离级别为RR，但是实际情况是使用RC 和 RR隔离级别的都不少。好像淘宝、网易都是使用的 RC 隔离级别。那么在MySQL中 RC 和 RR有什么区别呢？我们该如何选择呢？为什么MySQL将RR作为默认的隔离级别呢？</p>
<h4 id="RC-与-RR-在锁方面的区别"><a href="#RC-与-RR-在锁方面的区别" class="headerlink" title="RC 与 RR 在锁方面的区别"></a>RC 与 RR 在锁方面的区别</h4><p>1&gt; 显然 RR 支持 gap lock(next-key lock)，而RC则没有gap lock。因为MySQL的RR需要gap lock来解决幻读问题。而RC隔离级别则是允许存在不可重复读和幻读的。所以RC的并发一般要好于RR；</p>
<p>2&gt; RC 隔离级别，通过 where 条件过滤之后，不符合条件的记录上的行锁，会释放掉(虽然这里破坏了“两阶段加锁原则”)；但是RR隔离级别，即使不符合where条件的记录，也不会是否行锁和gap lock；所以从锁方面来看，RC的并发应该要好于RR；另外 insert into t select … from s where 语句在s表上的锁也是不一样的，参见下面的例子2；</p>
<p>下面是来自 <a href="http://www.itpub.net/thread-1941624-1-1.html" target="_blank" rel="noopener">github</a> 的一个例子：</p>
<p>MySQL5.6, 隔离级别RR，autocommit=off;</p>
<p>表结构：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">create</span> table t1\G</span><br><span class="line">*************************** <span class="number">1.</span> row ***************************</span><br><span class="line">       Table: t1</span><br><span class="line"><span class="keyword">Create</span> Table: <span class="keyword">CREATE</span> TABLE <span class="symbol">`t1`</span> (</span><br><span class="line">  <span class="symbol">`a`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="symbol">`b`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="symbol">`c`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="symbol">`d`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="symbol">`e`</span> varchar(<span class="number">20</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="symbol">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="symbol">`idx_t1_bcd`</span> (<span class="symbol">`b`</span>,<span class="symbol">`c`</span>,<span class="symbol">`d`</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>表数据：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select <span class="symbol">*</span> from t1;</span><br><span class="line">+---+---+---+---+------+</span><br><span class="line">|<span class="string"> a </span>|<span class="string"> b </span>|<span class="string"> c </span>|<span class="string"> d </span>|<span class="string"> e    </span>|</span><br><span class="line">+---+---+---+---+------+</span><br><span class="line">|<span class="string"> 1 </span>|<span class="string"> 1 </span>|<span class="string"> 1 </span>|<span class="string"> 1 </span>|<span class="string"> a    </span>|</span><br><span class="line">|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> b    </span>|</span><br><span class="line">|<span class="string"> 3 </span>|<span class="string"> 3 </span>|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> c    </span>|</span><br><span class="line">|<span class="string"> 4 </span>|<span class="string"> 3 </span>|<span class="string"> 1 </span>|<span class="string"> 1 </span>|<span class="string"> d    </span>|</span><br><span class="line">|<span class="string"> 5 </span>|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 5 </span>|<span class="string"> e    </span>|</span><br><span class="line">|<span class="string"> 6 </span>|<span class="string"> 6 </span>|<span class="string"> 4 </span>|<span class="string"> 4 </span>|<span class="string"> f    </span>|</span><br><span class="line">|<span class="string"> 7 </span>|<span class="string"> 4 </span>|<span class="string"> 5 </span>|<span class="string"> 5 </span>|<span class="string"> g    </span>|</span><br><span class="line">|<span class="string"> 8 </span>|<span class="string"> 8 </span>|<span class="string"> 8 </span>|<span class="string"> 8 </span>|<span class="string"> h    </span>|</span><br><span class="line">+---+---+---+---+------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>session 1:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from <span class="built_in">t1</span> where <span class="keyword">b&gt;2 </span><span class="keyword">and </span><span class="keyword">b&lt;5 </span><span class="keyword">and </span>c=<span class="number">2</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>执行计划如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> t1 where b&gt;2 <span class="keyword">and</span> b&lt;5 <span class="keyword">and</span> <span class="attribute">c</span>=2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: idx_t1_bcd</span><br><span class="line">          key: idx_t1_bcd</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: <span class="literal">NULL</span></span><br><span class="line">         rows: 2</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">1 row <span class="keyword">in</span> <span class="builtin-name">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>session 2:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span> <span class="built_in">from</span> t1 where <span class="keyword">a</span>=<span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>结果 session 2 被锁住。<br>session 3:<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select <span class="symbol">*</span> from information_schema.innodb_locks;</span><br><span class="line">+---------------+-------------+-----------+-----------+-------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">|<span class="string"> lock_id       </span>|<span class="string"> lock_trx_id </span>|<span class="string"> lock_mode </span>|<span class="string"> lock_type </span>|<span class="string"> lock_table  </span>|<span class="string"> lock_index </span>|<span class="string"> lock_space </span>|<span class="string"> lock_page </span>|<span class="string"> lock_rec </span>|<span class="string"> lock_data </span>|</span><br><span class="line">+---------------+-------------+-----------+-----------+-------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">|<span class="string"> 38777:390:3:5 </span>|<span class="string"> 38777       </span>|<span class="string"> X         </span>|<span class="string"> RECORD    </span>|<span class="string"> `test`.`t1` </span>|<span class="string"> PRIMARY    </span>|<span class="string">        390 </span>|<span class="string">         3 </span>|<span class="string">        5 </span>|<span class="string"> 4         </span>|</span><br><span class="line">|<span class="string"> 38771:390:3:5 </span>|<span class="string"> 38771       </span>|<span class="string"> X         </span>|<span class="string"> RECORD    </span>|<span class="string"> `test`.`t1` </span>|<span class="string"> PRIMARY    </span>|<span class="string">        390 </span>|<span class="string">         3 </span>|<span class="string">        5 </span>|<span class="string"> 4         </span>|</span><br><span class="line">+---------------+-------------+-----------+-----------+-------------+------------+------------+-----------+----------+-----------+</span><br></pre></td></tr></table></figure></p>
<p>根据锁及ICP的知识，此时加锁的情况应该是在索引  <code>idx_t1_bcd</code> 上的<code>b&gt;2 and b&lt;5</code>之间加<code>gap lock</code>, <code>idx_t1_bcd</code>上的c=2 加 X锁主键 a=3 加 x 锁。<br>应该a=4上是没有加X锁的，可以进行删除与更改。<br>但是从session3上的结果来，此时a=4上被加上了X锁。<br>求大牛解惑，谢谢。</p>
<p>要理解这里为什么 a=4 被锁住了，需要理解 gap lock，锁处理 RR 隔离级别和RC隔离级别的区别等等。</p>
<p>这里的原因如下：</p>
<p>很简单，我们注意到：<code>key_len</code>: 4 和 Extra: Using index condition<br>这说明了，仅仅使用了索引 <code>idx_t1_bcd</code> 中的 b 一列，没有使用到 c 这一列。c 这一列是在ICP时进行过滤的。所以：</p>
<p><code>delete from t1 where b&gt;2 and b&lt;5 and c=2</code> 其实锁定的行有：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 where b&gt;2 and b&lt;=6;</span><br><span class="line"><span class="code">+---+</span>---<span class="code">+---+</span>---<span class="code">+------+</span></span><br><span class="line">| a | b | c | d | e    |</span><br><span class="line"><span class="code">+---+</span>---<span class="code">+---+</span>---<span class="code">+------+</span></span><br><span class="line">| 3 | 3 | 2 | 2 | c    |</span><br><span class="line">| 4 | 3 | 1 | 1 | d    |</span><br><span class="line">| 6 | 6 | 4 | 4 | f    |</span><br><span class="line">| 7 | 4 | 5 | 5 | g    |</span><br><span class="line"><span class="code">+---+</span>---<span class="code">+---+</span>---<span class="code">+------+</span></span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>所以显然 <code>delete from t1 where a=4</code>就被阻塞了。那么为什么 <code>delete from t1 where a=6</code> 也会被阻塞呢？？？</p>
<p>这里 <code>b&lt;=6</code>的原因是，b 列中没有等于 5 的记录，所以 <code>and b&lt;5</code> 实现为锁定 <code>b&lt;=6</code> 的所有索引记录，这里有等于号的原因是，如果我们不锁定 =6 的索引记录，那么怎么实现锁定 <code>&lt;5</code> 的gap 呢？也就是说锁定 b=6 的索引记录，是为了实现锁定 <code>b&lt; 5</code> 的gap。也就是不能删除 b=6 记录的原因。<br>而这里 b &gt;2 没有加等于号(b&gt;=2) 的原因，是因为 b&gt;2的这个gap 是由 b=3这个索引记录(的gap)来实现的，不是由 b=2索引记录(的gap) 来实现的，b=2的索引记录的gap lock只能实现锁定<code>&lt;2</code>的gap，b&gt;2的gap锁定功能，需要由 b=3的索引记录对应的gap来实现(b&gt;2，<code>b&lt;3</code>的gap)。<br>所以我们在session2中可以删除：a=1,2,5,8的记录，但是不能删除 a=6(因为该行的b=6)的记录。</p>
<p>如果我们使用 RC 隔离级别时，则不会发生阻塞，其原因就是：</p>
<p>RC和RR隔离级别中的锁处理不一样，RC隔离级别时，在使用c列进行ICP where条件过滤时，对于不符合条件的记录，锁会释放掉，而RR隔离级别时，即使不符合条件的记录，锁也不会释放(虽然违反了“2阶段锁”原则)。所以RC隔离级别时session 2不会被阻塞。</p>
<p>Gap lock: This is a lock on a gap between index records, or a lock on the gap before the first or after the last index record.</p>
<p>例子2：<code>insert into t select ... from s where</code> 在RC 和 RR隔离级别下的加锁过程</p>
<p>下面是官方文档中的<a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-locks-set.html" target="_blank" rel="noopener">说明</a>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T <span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> S <span class="keyword">WHERE</span> ... <span class="keyword">sets</span> an exclusive <span class="keyword">index</span> <span class="built_in">record</span> <span class="keyword">lock</span> (<span class="keyword">without</span> a gap <span class="keyword">lock</span>) <span class="keyword">on</span> <span class="keyword">each</span> <span class="keyword">row</span> inserted <span class="keyword">into</span> T. <span class="keyword">If</span> the <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">READ</span> COMMITTED, <span class="keyword">or</span> innodb_locks_unsafe_for_binlog <span class="keyword">is</span> enabled <span class="keyword">and</span> the <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">SERIALIZABLE</span>, <span class="keyword">InnoDB</span> does the <span class="keyword">search</span> <span class="keyword">on</span> S <span class="keyword">as</span> a <span class="keyword">consistent</span> <span class="keyword">read</span> (<span class="keyword">no</span> locks). Otherwise, <span class="keyword">InnoDB</span> <span class="keyword">sets</span> <span class="keyword">shared</span> <span class="keyword">next</span>-<span class="keyword">key</span> locks <span class="keyword">on</span> <span class="keyword">rows</span> <span class="keyword">from</span> S. <span class="keyword">InnoDB</span> has <span class="keyword">to</span> <span class="keyword">set</span> locks <span class="keyword">in</span> the latter <span class="keyword">case</span>: <span class="keyword">In</span> roll-forward <span class="keyword">recovery</span> <span class="keyword">from</span> a <span class="keyword">backup</span>, every <span class="keyword">SQL</span> <span class="keyword">statement</span> must be executed <span class="keyword">in</span> exactly the same way it was done originally.</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ... <span class="keyword">SELECT</span> ... performs the <span class="keyword">SELECT</span> <span class="keyword">with</span> <span class="keyword">shared</span> <span class="keyword">next</span>-<span class="keyword">key</span> locks <span class="keyword">or</span> <span class="keyword">as</span> a <span class="keyword">consistent</span> <span class="keyword">read</span>, <span class="keyword">as</span> <span class="keyword">for</span> <span class="keyword">INSERT</span> ... SELECT.</span><br><span class="line"></span><br><span class="line"><span class="keyword">When</span> a <span class="keyword">SELECT</span> <span class="keyword">is</span> used <span class="keyword">in</span> the constructs <span class="keyword">REPLACE</span> <span class="keyword">INTO</span> t <span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> s <span class="keyword">WHERE</span> ... <span class="keyword">or</span> <span class="keyword">UPDATE</span> t ... <span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> s ...), <span class="keyword">InnoDB</span> <span class="keyword">sets</span> <span class="keyword">shared</span> <span class="keyword">next</span>-<span class="keyword">key</span> locks <span class="keyword">on</span> <span class="keyword">rows</span> <span class="keyword">from</span> <span class="keyword">table</span> s.</span><br></pre></td></tr></table></figure>
<p><code>insert inot t select ... from s where ...</code>语句和 <code>create table ... select ... from s where</code>加锁过程是相似的(RC 和 RR 加锁不一样)：</p>
<p>1&gt; RC 隔离级别时和 RR隔离级别但是设置<code>innodb_locks_unsafe_for_binlog=1</code> 时，<code>select ... from s where</code>对 s 表进行的是一致性读，所以是无需加锁的；</p>
<p>2&gt; 如果是RR隔离级别(默认<code>innodb_locks_unsafe_for_binlog</code>=0)，或者是 serializable隔离级别，那么对 s 表上的每一行都要加上 <code>shared next-key lock</code>.</p>
<p>这个区别是一个很大的不同，下面是生成中的一个 <code>insert into t select ... from s where</code>导致的系统宕机的案例：</p>
<p>一程序猿执行一个分表操作：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_async_src_acct_201508 <span class="keyword">select</span> * <span class="keyword">from</span> tb_async_src_acct </span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> src_status=<span class="number">3</span> <span class="keyword">and</span> create_time&gt;=<span class="string">'2015-08-01 00:00:00'</span> <span class="keyword">and</span> create_time &lt;= <span class="string">'2015-08-31 23:59:59'</span>;</span><br></pre></td></tr></table></figure></p>
<p>表 <code>tb_async_src_acct</code>有4000W数据。分表的目的是想提升下性能。结果一执行该语句，该条SQL被卡住，然后所有向 <code>tb_async_src_acct</code>的写操作，要么是 get lock fail, 要么是 lost connection，全部卡住，然后主库就宕机了。</p>
<p>显然这里的原因，就是不知道默认RR隔离级别中 <code>insert into t select ... from s where</code>语句的在 s 表上的加锁过程，该语句一执行，所有符合 where 条件的 s 表中的行记录都会加上 <code>shared next-key lock</code>(如果没有使用到索引，还会锁住表中所有行)，在整个事务过程中一直持有，因为表 <code>tb_async_src_acct</code> 数据很多，所以运行过程是很长的，所以加锁过程也是很长，所以其它所有的对<code>tb_async_src_acct</code> 的insert, delete, update, DDL 都会被阻塞掉，这样被阻塞的事务就越来越多，而事务也会申请其它的表中的行锁，结果就是系统中被卡住的事务越来越多，系统自然就宕机了。</p>
<h4 id="RC-与-RR-在复制方面的区别"><a href="#RC-与-RR-在复制方面的区别" class="headerlink" title="RC 与 RR 在复制方面的区别"></a>RC 与 RR 在复制方面的区别</h4><ul>
<li>RC 隔离级别不支持 statement 格式的bin log，因为该格式的复制，会导致主从数据的不一致；只能使用 mixed 或者 row 格式的bin log; 这也是为什么MySQL默认使用RR隔离级别的原因。复制时，我们最好使用：<code>binlog_format=row</code></li>
<li>MySQL5.6 的早期版本，RC隔离级别是可以设置成使用statement格式的bin log，后期版本则会直接报错；</li>
</ul>
<h4 id="RC-与-RR-在一致性读方面的区别"><a href="#RC-与-RR-在一致性读方面的区别" class="headerlink" title="RC 与 RR 在一致性读方面的区别"></a>RC 与 RR 在一致性读方面的区别</h4><p>简单而且，RC隔离级别时，事务中的每一条select语句会读取到他自己执行时已经提交了的记录，也就是每一条select都有自己的一致性读ReadView; 而RR隔离级别时，事务中的一致性读的ReadView是以第一条select语句的运行时，作为本事务的一致性读snapshot的建立时间点的。只能读取该时间点之前已经提交的数据。</p>
<h4 id="RC-支持半一致性读，RR不支持"><a href="#RC-支持半一致性读，RR不支持" class="headerlink" title="RC 支持半一致性读，RR不支持"></a>RC 支持半一致性读，RR不支持</h4><p>RC隔离级别下的update语句，使用的是半一致性读(semi consistent)；而RR隔离级别的update语句使用的是当前读；当前读会发生锁的阻塞。</p>
<p>1&gt; 半一致性读：</p>
<blockquote>
<p>A type of read operation used for UPDATE statements, that is a combination of read committed and consistent read. When an UPDATE statement examines a row that is already locked, InnoDB returns the latest committed version to MySQL so that MySQL can determine whether the row matches the WHERE condition of the UPDATE. If the row matches (must be updated), MySQL reads the row again, and this time InnoDB either locks it or waits for a lock on it. This type of read operation can only happen when the transaction has the read committed isolation level, or when the innodb_locks_unsafe_for_binlog option is enabled.</p>
</blockquote>
<p>简单来说，semi-consistent read是read committed与consistent read两者的结合。一个update语句，如果读到一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足 update的where条件。若满足(需要更新)，则MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)。semi-consistent read只会发生在read committed隔离级别下，或者是参数<code>innodb_locks_unsafe_for_binlog</code>被设置为true(该参数即将被废弃)。</p>
<p>对比RR隔离级别，update语句会使用当前读，如果一行被锁定了，那么此时会被阻塞，发生锁等待。而不会读取最新的提交版本，然后来判断是否符合where条件。</p>
<p>半一致性读的优点：</p>
<p>减少了update语句时行锁的冲突；对于不满足update更新条件的记录，可以提前放锁，减少并发冲突的概率。</p>
<p>具体可以<a href="http://hedengcheng.com/?p=220" target="_blank" rel="noopener">参见</a>：</p>
<p>Oracle中的update好像有“重启动”的概念。</p>
<h2 id="MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁"><a href="#MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁" class="headerlink" title="MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁"></a>MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁</h2><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>之前我们介绍了排他锁，其实innodb下的记录锁（也叫行锁），间隙锁，next-key锁统统属于排他锁。</p>
<p>行锁<br>记录锁其实很好理解，对表中的记录加锁，叫做记录锁，简称行锁。</p>
<p>生活中的间隙锁<br>编程的思想源于生活，生活中的例子能帮助我们更好的理解一些编程中的思想。<br>生活中排队的场景，小明，小红，小花三个人依次站成一排，此时，如何让新来的小刚不能站在小红旁边，这时候只要将小红和她前面的小明之间的空隙封锁，将小红和她后面的小花之间的空隙封锁，那么小刚就不能站到小红的旁边。<br>这里的小红，小明，小花，小刚就是数据库的一条条记录。<br>他们之间的空隙也就是间隙，而封锁他们之间距离的锁，叫做间隙锁。</p>
<p>Mysql中的间隙锁<br>下表中（见图一），id为主键，number字段上有非唯一索引的二级索引，有什么方式可以让该表不能再插入number=5的记录？<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-ad0d50c44dc041be.png" alt="image"></p>
<p>图一<br>根据上面生活中的例子，我们自然而然可以想到，只要控制几个点，number=5之前不能插入记录，number=5现有的记录之间不能再插入新的记录，number=5之后不能插入新的记录，那么新的number=5的记录将不能被插入进来。</p>
<p>那么，mysql是如何控制number=5之前，之中，之后不能有新的记录插入呢（防止幻读）？<br>答案是用间隙锁，在RR级别下，mysql通过间隙锁可以实现锁定number=5之前的间隙，number=5记录之间的间隙，number=5之后的间隙，从而使的新的记录无法被插入进来。</p>
<p>间隙是怎么划分的？</p>
<p>注：为了方面理解，我们规定（id=A,number=B）代表一条字段id=A,字段number=B的记录，（C，D）代表一个区间，代表C-D这个区间范围。</p>
<p>图一中，根据number列，我们可以分为几个区间：（无穷小，2），（2，4），（4，5），（5，5），（5,11），（11，无穷大）。<br>只要这些区间对应的两个临界记录中间可以插入记录，就认为区间对应的记录之间有间隙。<br>例如：区间（2，4）分别对应的临界记录是（id=1,number=2），（id=3，number=4），这两条记录中间可以插入（id=2,number=3）等记录，那么就认为（id=1,number=2）与（id=3，number=4）之间存在间隙。</p>
<p>很多人会问，那记录（id=6，number=5）与（id=8，number=5）之间有间隙吗？<br>答案是有的，（id=6，number=5）与（id=8，number=5）之间可以插入记录（id=7，number=5），因此（id=6,number=5）与（id=8,number=5）之间有间隙的，</p>
<p>间隙锁锁定的区域<br>根据检索条件向左寻找最靠近检索条件的记录值A，作为左区间，向右寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为（A，B）。<br>图一中，where number=5的话，那么间隙锁的区间范围为（4,11）；</p>
<p>间隙锁的目的是为了防止幻读，其主要通过两个方面实现这个目的：<br>（1）防止间隙内有新数据被插入<br>（2）防止已存在的数据，更新成间隙内的数据（例如防止numer=3的记录通过update变成number=5）</p>
<p>innodb自动使用间隙锁的条件：<br>（1）必须在RR级别下<br>（2）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）</p>
<p>接下来，通过实际操作观察下间隙锁的作用范围</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-ad0d50c44dc041be.png" alt="image"></p>
<h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line"></span><br><span class="line">session 2:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">4</span>);#（阻塞）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">2</span>);#（阻塞）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">4</span>);#（阻塞）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">5</span>);#（阻塞）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">7</span>,<span class="number">5</span>);#（执行成功）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">9</span>,<span class="number">5</span>);#（执行成功）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">11</span>,<span class="number">5</span>);#（执行成功）</span><br></pre></td></tr></table></figure>
<p>检索条件number=4,向左取得最靠近的值2作为左区间，向右取得最靠近的5作为右区间，因此，session 1的间隙锁的范围（2，4），（4，5），如下图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-b1ddc3677c81c9b5.png" alt="image"></p>
<p>间隙锁锁定的区间为（2，4），（4，5），即记录（id=1,number=2）和记录（id=3,number=4）之间间隙会被锁定，记录（id=3,number=4）和记录（id=6,number=5）之间间隙被锁定。</p>
<p>因此记录（id=2,number=4），（id=2,number=2），（id=4,number=4），（id=4,number=5）正好处在（id=3,number=4）和（id=6,number=5）之间，所以插入不了，需要等待锁的释放，而记录(id=7,number=5)，（id=9,number=5），（id=11,number=5）不在上述锁定的范围内，因此都会插入成功。</p>
<h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">13</span> <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line"></span><br><span class="line">session 2:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">11</span>,<span class="number">5</span>);#(执行成功)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">12</span>,<span class="number">11</span>);#(执行成功)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">14</span>,<span class="number">11</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">15</span>,<span class="number">12</span>);#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">14</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">11</span>;#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">11</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">11</span>;#(执行成功)</span><br></pre></td></tr></table></figure>
<p>检索条件number=13,向左取得最靠近的值11作为左区间，向右由于没有记录因此取得无穷大作为右区间，因此，session 1的间隙锁的范围（11，无穷大），如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-1f499d02104728e0.png" alt="image"></p>
<p>此表中没有number=13的记录的，innodb依然会为该记录左右两侧加间隙锁，间隙锁的范围（11，无穷大）。</p>
<p>有人会问，为啥update news set id=14 where number=11会阻塞，但是update news set id=11 where number=11却执行成功呢？</p>
<p>间隙锁采用在指定记录的前面和后面以及中间的间隙上加间隙锁的方式避免数据被插入，此图间隙锁锁定的区域是（11，无穷大），也就是记录（id=13,number=11）之后不能再插入记录，update news set id=14 where number=11这条语句如果执行的话，将会被插入到（id=13,number=11）的后面，也就是在区间（11，无穷大）之间，由于该区间被间隙锁锁定，所以只能阻塞等待，而update news set id=11 where number=11执行后是会被插入到（id=13,number=11）的记录前面，也就不在（11，无穷大）的范围内，所以无需等待，执行成功。</p>
<h4 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">session 2:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">4</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">5</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">5</span>,<span class="number">5</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">7</span>,<span class="number">11</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">9</span>,<span class="number">12</span>);#(执行成功)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">12</span>,<span class="number">11</span>);#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> <span class="keyword">number</span>=<span class="number">5</span> <span class="keyword">where</span> id=<span class="number">1</span>;#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">11</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">11</span>;#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> ;#（执行成功）</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">4</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> ;#（阻塞）</span><br></pre></td></tr></table></figure>
<p>检索条件number=5,向左取得最靠近的值4作为左区间，向右取得11为右区间，因此，session 1的间隙锁的范围（4，5），（5，11），如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-35dc3a0aed8a0f9a.png" alt="image"></p>
<p>有人会问，为啥<code>insert into news value(9,12)</code>会执行成功？间隙锁采用在指定记录的前面和后面以及中间的间隙上加间隙锁的方式避免数据被插入，（id=9,number=12）很明显在记录（13,11）的后面，因此不再锁定的间隙范围内。</p>
<p>为啥u<code>pdate news set number=5 where id=1</code>会阻塞？<br>number=5的记录的前面，后面包括中间都被封锁了，你这个update news set number=5 where id=1根本没法执行，因为innodb已经把你可以存放的位置都锁定了，因为只能等待。</p>
<p>同理，<code>update news set id=11 where number=11</code>由于记录（id=10,number=5）与记录（id=13,number=11）中间的间隙被封锁了，你这句sql也没法执行，必须等待，因为存放的位置被封锁了。</p>
<h4 id="案例四"><a href="#案例四" class="headerlink" title="案例四"></a>案例四</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">start  transaction;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">number</span>&gt;<span class="number">4</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">session 2:</span><br><span class="line">start  transaction;</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> ;#(执行成功)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">4</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> ;#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">5</span> ;#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">3</span>);#(执行成功)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="literal">null</span>,<span class="number">13</span>);#(阻塞)</span><br></pre></td></tr></table></figure>
<p>检索条件number&gt;4,向左取得最靠近的值4作为左区间，向右取无穷大，因此，session 1的间隙锁的范围（4，无穷大），如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-3e7aaef9e3865926.png" alt="image"></p>
<p>session2中之所以有些阻塞，有些执行成功，其实就是因为插入的区域被锁定，从而阻塞。</p>
<p>next-key锁</p>
<p>next-key锁其实包含了记录锁和间隙锁，即锁定一个范围，并且锁定记录本身，InnoDB默认加锁方式是next-key 锁。<br>上面的案例一session 1中的sql是：select * from news where number=4 for update ;<br>next-key锁锁定的范围为间隙锁+记录锁，即区间（2，4），（4，5）加间隙锁，同时number=4的记录加记录锁。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>MySQL有三种锁的级别：页级、表级、行级。</p>
<p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p>
<p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p>
<p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<p>算法：</p>
<p>next KeyLocks锁，同时锁住记录(数据)，并且锁住记录前面的Gap<br>Gap锁，不锁记录，仅仅记录前面的Gap</p>
<p>Recordlock锁（锁数据，不锁Gap）</p>
<p>所以其实 Next-KeyLocks=Gap锁+ Recordlock锁</p>
<h5 id="什么情况下会造成死锁"><a href="#什么情况下会造成死锁" class="headerlink" title="什么情况下会造成死锁"></a>什么情况下会造成死锁</h5><p>所谓死锁<code>&lt;DeadLock&gt;</code>: 是指两个或两个以上的进程在执行过程中,<br>因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.<br>此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.<br>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.</p>
<p>死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。</p>
<p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序</p>
<h4 id="一些常见的死锁案例"><a href="#一些常见的死锁案例" class="headerlink" title="一些常见的死锁案例"></a>一些常见的死锁案例</h4><h5 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h5><p>需求：将投资的钱拆成几份随机分配给借款人。</p>
<p>起初业务程序思路是这样的：</p>
<p>投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条<code>select for update</code> 去更新借款人表里面的余额等。</p>
<p>抽象出来就是一个session通过for循环会有几条如下的语句：<br><code>Select * from xxx where id=&#39;随机id&#39; for update</code></p>
<p>基本来说，程序开启后不一会就死锁。<br>这可以是说最经典的死锁情形了。</p>
<p>例如两个用户同时投资，A用户金额随机分为2份，分给借款人1，2<br>B用户金额随机分为2份，分给借款人2，1由于加锁的顺序不一样，死锁当然很快就出现了。</p>
<p>对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。</p>
<p><code>Select * from xxx where id in (xx,xx,xx) for update</code></p>
<p>在in里面的列表值mysql是会自动从小到大排序，加锁也是一条条从小到大加的锁<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">例如（以下会话<span class="built_in">id</span>为主键）：</span><br><span class="line"></span><br><span class="line">Session1:</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (<span class="number">8</span>,<span class="number">9</span>) <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">| <span class="built_in">id</span> | course | <span class="built_in">name</span> | ctime               |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">|  <span class="number">8</span> | WA     | f    | <span class="number">2016</span><span class="number">-03</span><span class="number">-02</span> <span class="number">11</span>:<span class="number">36</span>:<span class="number">30</span> |</span><br><span class="line"></span><br><span class="line">|  <span class="number">9</span> | JX     | f    | <span class="number">2016</span><span class="number">-03</span><span class="number">-01</span> <span class="number">11</span>:<span class="number">36</span>:<span class="number">30</span> |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line">rows <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session2:</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (<span class="number">10</span>,<span class="number">8</span>,<span class="number">5</span>) <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">锁等待中……</span><br><span class="line"></span><br><span class="line">其实这个时候<span class="built_in">id</span>=<span class="number">10</span>这条记录没有被锁住的，但<span class="built_in">id</span>=<span class="number">5</span>的记录已经被锁住了，锁的等待在<span class="built_in">id</span>=<span class="number">8</span>的这里。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">不信请看</span><br><span class="line"></span><br><span class="line">Session3:</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span>=<span class="number">5</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">锁等待中</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session4:</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span>=<span class="number">10</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">| <span class="built_in">id</span> | course | <span class="built_in">name</span> | ctime               |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">| <span class="number">10</span> | JB     | g    | <span class="number">2016</span><span class="number">-03</span><span class="number">-10</span> <span class="number">11</span>:<span class="number">45</span>:<span class="number">05</span> |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line">row <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">在其它session中<span class="built_in">id</span>=<span class="number">5</span>是加不了锁的，但是<span class="built_in">id</span>=<span class="number">10</span>是可以加上锁的。</span><br></pre></td></tr></table></figure></p>
<h5 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h5><p>在开发中，经常会做这类的判断需求：根据字段值查询（有索引），如果不存在，则插入；否则更新。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">以id为主键为例，目前还没有id=22的行</span><br><span class="line"></span><br><span class="line">Session1:</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">22</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">session2:</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">23</span>  <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session1:</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t3 <span class="keyword">values</span>(<span class="number">22</span>,<span class="string">'ac'</span>,<span class="string">'a'</span>,<span class="keyword">now</span>());</span><br><span class="line"></span><br><span class="line">锁等待中……</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session2:</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t3 <span class="keyword">values</span>(<span class="number">23</span>,<span class="string">'bc'</span>,<span class="string">'b'</span>,<span class="keyword">now</span>());</span><br><span class="line"></span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get <span class="keyword">lock</span>; try restarting transaction</span><br></pre></td></tr></table></figure>
<p>当对存在的行进行锁的时候(主键)，mysql就只有行锁。</p>
<p>当对未存在的行进行锁的时候(即使条件为主键)，mysql是会锁住一段范围（有gap锁）</p>
<p>锁住的范围为：</p>
<p>(无穷小或小于表中锁住id的最大值，无穷大或大于表中锁住id的最小值)</p>
<p>如：如果表中目前有已有的id为（11 ， 12）</p>
<p>那么就锁住（12，无穷大）</p>
<p>如果表中目前已有的id为（11 ， 30）</p>
<p>那么就锁住（11，30）</p>
<p>对于这种死锁的解决办法是：</p>
<p><code>insert into t3(xx,xx) on duplicate key update `xx`=&#39;XX&#39;;</code></p>
<p>用mysql特有的语法来解决此问题。因为insert语句对于主键来说，插入的行不管有没有存在，都会只有行锁。</p>
<h5 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span>=<span class="number">9</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">| <span class="built_in">id</span> | course | <span class="built_in">name</span> | ctime               |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">|  <span class="number">9</span> | JX     | f    | <span class="number">2016</span><span class="number">-03</span><span class="number">-01</span> <span class="number">11</span>:<span class="number">36</span>:<span class="number">30</span> |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line">row <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session2:</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span>&lt;<span class="number">20</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">锁等待中</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session1:</span><br><span class="line"></span><br><span class="line">mysql&gt; insert <span class="keyword">into</span> t3 values(<span class="number">7</span>,'ae','a',now());</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock found when trying <span class="keyword">to</span> <span class="keyword">get</span> lock; <span class="keyword">try</span> restarting <span class="keyword">transaction</span></span><br></pre></td></tr></table></figure>
<p>这个跟案例一其它是差不多的情况，只是session1不按常理出牌了，</p>
<p>Session2在等待Session1的id=9的锁，session2又持了1到8的锁（注意9到19的范围并没有被session2锁住），最后，session1在插入新行时又得等待session2,故死锁发生了。</p>
<p>这种一般是在业务需求中基本不会出现，因为你锁住了id=9，却又想插入id=7的行，这就有点跳了，当然肯定也有解决的方法，那就是重理业务需求，避免这样的写法。</p>
<h2 id="有两个表，table-a，table-b，写SQL查询出仅在table-a中的数据、仅在table-b中的数据、既在table-a-又在table-b-中的数据？"><a href="#有两个表，table-a，table-b，写SQL查询出仅在table-a中的数据、仅在table-b中的数据、既在table-a-又在table-b-中的数据？" class="headerlink" title="有两个表，table a，table b，写SQL查询出仅在table a中的数据、仅在table b中的数据、既在table a 又在table b 中的数据？"></a>有两个表，table a，table b，写SQL查询出仅在table a中的数据、仅在table b中的数据、既在table a 又在table b 中的数据？</h2>
      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    强壮的病猫
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://dinghuang.github.io/2019/05/18/面试分享(三).数据库相关/" title="面试分享(三).数据库相关">https://dinghuang.github.io/2019/05/18/面试分享(三).数据库相关/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/18/面试分享(一).JAVA知识/" rel="next" title="面试分享(一).JAVA知识">
                <i class="fa fa-chevron-left"></i> 面试分享(一).JAVA知识
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/18/面试分享(二).框架相关(Spring)/" rel="prev" title="面试分享(二).框架相关(Spring)">
                面试分享(二).框架相关(Spring) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/dinghuang.png"
                alt="强壮的病猫" />
            
              <p class="site-author-name" itemprop="name">强壮的病猫</p>
              <p class="site-description motion-element" itemprop="description">学习、生活、闲谈、足球</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dinghuang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库相关"><span class="nav-number">1.</span> <span class="nav-text">数据库相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#读过MyBatis源码没有？"><span class="nav-number">1.1.</span> <span class="nav-text">读过MyBatis源码没有？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#聊一聊对分库分表的理解。"><span class="nav-number">1.2.</span> <span class="nav-text">聊一聊对分库分表的理解。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql有哪些索引类型？有哪些存储引擎？有什么区别"><span class="nav-number">1.3.</span> <span class="nav-text">mysql有哪些索引类型？有哪些存储引擎？有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对索引的理解，组合索引，索引的最佳实践"><span class="nav-number">1.4.</span> <span class="nav-text">对索引的理解，组合索引，索引的最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#索引类型"><span class="nav-number">1.4.1.</span> <span class="nav-text">索引类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BTREE-索引能做什么？"><span class="nav-number">1.4.2.</span> <span class="nav-text">BTREE 索引能做什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串索引"><span class="nav-number">1.4.3.</span> <span class="nav-text">字符串索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多列索引"><span class="nav-number">1.4.4.</span> <span class="nav-text">多列索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-怎么使用索引"><span class="nav-number">1.4.5.</span> <span class="nav-text">MySQL 怎么使用索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在数据查询中使用索引"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">在数据查询中使用索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在排序中使用索引"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">在排序中使用索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表中存在多个索引"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">表中存在多个索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#前缀索引"><span class="nav-number">1.4.5.4.</span> <span class="nav-text">前缀索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Explain命令详解"><span class="nav-number">1.5.</span> <span class="nav-text">Explain命令详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select-type"><span class="nav-number">1.5.1.</span> <span class="nav-text">select_type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#table"><span class="nav-number">1.5.2.</span> <span class="nav-text">table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type"><span class="nav-number">1.5.3.</span> <span class="nav-text">type</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#type-常用类型"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">type 常用类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#possible-keys"><span class="nav-number">1.5.4.</span> <span class="nav-text">possible_keys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#key"><span class="nav-number">1.5.5.</span> <span class="nav-text">key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#key-len"><span class="nav-number">1.5.6.</span> <span class="nav-text">key_len</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rows"><span class="nav-number">1.5.7.</span> <span class="nav-text">rows</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Extra"><span class="nav-number">1.5.8.</span> <span class="nav-text">Extra</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？"><span class="nav-number">1.6.</span> <span class="nav-text">数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#产生原因"><span class="nav-number">1.6.1.</span> <span class="nav-text">产生原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新缓存的设计模式"><span class="nav-number">1.6.2.</span> <span class="nav-text">更新缓存的设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache-Aside-Pattern-旁路缓存"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">Cache Aside Pattern(旁路缓存)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Read-Write-Through-Pattern"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">Read/Write Through Pattern</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Write-Behind-Caching-Pattern"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">Write Behind Caching Pattern</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存架构设计"><span class="nav-number">1.6.3.</span> <span class="nav-text">缓存架构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#更新缓存-VS-淘汰缓存"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">更新缓存 VS 淘汰缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#先操作数据库-vs-先操作缓存"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">先操作数据库 vs 先操作缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存架构优化"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">缓存架构优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结论"><span class="nav-number">1.6.3.4.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存和DB一致性的解决方案"><span class="nav-number">1.6.4.</span> <span class="nav-text">缓存和DB一致性的解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#先淘汰缓存，再写数据库"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">先淘汰缓存，再写数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#先写数据库，再更新缓存"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">先写数据库，再更新缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于数据库的-binlog-日志"><span class="nav-number">1.6.4.3.</span> <span class="nav-text">基于数据库的 binlog 日志</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#重客户端"><span class="nav-number">1.6.4.3.1.</span> <span class="nav-text">重客户端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#客户端数据库与缓存解耦"><span class="nav-number">1.6.4.3.2.</span> <span class="nav-text">客户端数据库与缓存解耦</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主从DB与cache一致性优化"><span class="nav-number">1.6.5.</span> <span class="nav-text">主从DB与cache一致性优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#聚簇索引-非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？"><span class="nav-number">1.7.</span> <span class="nav-text">聚簇索引/非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉搜索树"><span class="nav-number">1.7.1.</span> <span class="nav-text">二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-树"><span class="nav-number">1.7.2.</span> <span class="nav-text">B-树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-树-1"><span class="nav-number">1.7.3.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-树-2"><span class="nav-number">1.7.4.</span> <span class="nav-text">B*树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">1.7.5.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚簇索引"><span class="nav-number">1.7.6.</span> <span class="nav-text">聚簇索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非聚簇索引"><span class="nav-number">1.7.7.</span> <span class="nav-text">非聚簇索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么选用B-Tree"><span class="nav-number">1.7.8.</span> <span class="nav-text">为什么选用B+/-Tree</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？"><span class="nav-number">1.8.</span> <span class="nav-text">MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL事务隔离级别"><span class="nav-number">1.8.1.</span> <span class="nav-text">MySQL事务隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC"><span class="nav-number">1.8.2.</span> <span class="nav-text">MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MYSQL-架构"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">MYSQL 架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC是为了解决什么问题"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">MVCC是为了解决什么问题?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC具体实现"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">MVCC具体实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SELECT"><span class="nav-number">1.8.2.3.1.</span> <span class="nav-text">SELECT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UPDATE"><span class="nav-number">1.8.2.3.2.</span> <span class="nav-text">UPDATE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DELETE"><span class="nav-number">1.8.2.3.3.</span> <span class="nav-text">DELETE</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RR"><span class="nav-number">1.8.3.</span> <span class="nav-text">RR</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RR隔离级别下锁介绍"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">RR隔离级别下锁介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Record-Lock"><span class="nav-number">1.8.3.1.1.</span> <span class="nav-text">Record Lock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Gap-Lock"><span class="nav-number">1.8.3.1.2.</span> <span class="nav-text">Gap Lock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Next-Key-Lock"><span class="nav-number">1.8.3.1.3.</span> <span class="nav-text">Next-Key Lock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AUTO-INC-Lock"><span class="nav-number">1.8.3.1.4.</span> <span class="nav-text">AUTO-INC Lock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Dead-lock"><span class="nav-number">1.8.3.1.5.</span> <span class="nav-text">Dead lock</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-中RC和RR隔离级别的区别"><span class="nav-number">1.8.4.</span> <span class="nav-text">MySQL 中RC和RR隔离级别的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RC-与-RR-在锁方面的区别"><span class="nav-number">1.8.4.1.</span> <span class="nav-text">RC 与 RR 在锁方面的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RC-与-RR-在复制方面的区别"><span class="nav-number">1.8.4.2.</span> <span class="nav-text">RC 与 RR 在复制方面的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RC-与-RR-在一致性读方面的区别"><span class="nav-number">1.8.4.3.</span> <span class="nav-text">RC 与 RR 在一致性读方面的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RC-支持半一致性读，RR不支持"><span class="nav-number">1.8.4.4.</span> <span class="nav-text">RC 支持半一致性读，RR不支持</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁"><span class="nav-number">1.9.</span> <span class="nav-text">MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#间隙锁"><span class="nav-number">1.9.1.</span> <span class="nav-text">间隙锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#案例一"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">案例一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例二"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">案例二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例三"><span class="nav-number">1.9.1.3.</span> <span class="nav-text">案例三</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例四"><span class="nav-number">1.9.1.4.</span> <span class="nav-text">案例四</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">1.9.2.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#什么情况下会造成死锁"><span class="nav-number">1.9.2.1.1.</span> <span class="nav-text">什么情况下会造成死锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一些常见的死锁案例"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">一些常见的死锁案例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#案例一-1"><span class="nav-number">1.9.2.2.1.</span> <span class="nav-text">案例一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#案例2"><span class="nav-number">1.9.2.2.2.</span> <span class="nav-text">案例2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#案例3"><span class="nav-number">1.9.2.2.3.</span> <span class="nav-text">案例3</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有两个表，table-a，table-b，写SQL查询出仅在table-a中的数据、仅在table-b中的数据、既在table-a-又在table-b-中的数据？"><span class="nav-number">1.10.</span> <span class="nav-text">有两个表，table a，table b，写SQL查询出仅在table a中的数据、仅在table b中的数据、既在table a 又在table b 中的数据？</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">强壮的病猫</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://dinghuang-1.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://dinghuang.github.io/2019/05/18/面试分享(三).数据库相关/';
          this.page.identifier = '2019/05/18/面试分享(三).数据库相关/';
          this.page.title = '面试分享(三).数据库相关';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dinghuang-1.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  
  


  

  

</body>
</html>
