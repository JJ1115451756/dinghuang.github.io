<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="WSWvVPyzUsUM54ydNcrE1pUzdYt5xGKnqD1i7XpWVF8" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/images/site.webmanifest">


  <meta name="msapplication-config" content="/images/browserconfig.xml" />



  <meta name="keywords" content="Welcome" />










<meta name="description" content="学习、生活、闲谈、足球">
<meta property="og:type" content="website">
<meta property="og:title" content="一只病猫">
<meta property="og:url" content="https://dinghuang.github.io/index.html">
<meta property="og:site_name" content="一只病猫">
<meta property="og:description" content="学习、生活、闲谈、足球">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一只病猫">
<meta name="twitter:description" content="学习、生活、闲谈、足球">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dinghuang.github.io/"/>





  <title>一只病猫</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-108021384-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?00a1ba3f5c477c92d7c1ccbb00c6427b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一只病猫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">静坐常思己过，闲谈莫论人非</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'HcRPHRrBuwozvgUoLNyX','2.0.0');
</script>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/10/18/面试分享/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/18/面试分享/" itemprop="url">面试题目分享</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-18T18:00:00+08:00">
                2019-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/18/面试分享/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/10/18/面试分享/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试题目分享"><a href="#面试题目分享" class="headerlink" title="面试题目分享"></a>面试题目分享</h1><h2 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h2><h3 id="聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图。"><a href="#聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图。" class="headerlink" title="聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图。"></a>聊项目，画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务，每个服务做什么事情的流程图。</h3><h3 id="你个人有什么优势"><a href="#你个人有什么优势" class="headerlink" title="你个人有什么优势"></a>你个人有什么优势</h3><h3 id="讲项目中的难点、挑战，如何解决的，项目这一块会问的特别细"><a href="#讲项目中的难点、挑战，如何解决的，项目这一块会问的特别细" class="headerlink" title="讲项目中的难点、挑战，如何解决的，项目这一块会问的特别细"></a>讲项目中的难点、挑战，如何解决的，项目这一块会问的特别细</h3><h3 id="线上有没有遇到其他问题，如何处理的"><a href="#线上有没有遇到其他问题，如何处理的" class="headerlink" title="线上有没有遇到其他问题，如何处理的"></a>线上有没有遇到其他问题，如何处理的</h3><h3 id="说一个你了解最多的框架，说出你的理解"><a href="#说一个你了解最多的框架，说出你的理解" class="headerlink" title="说一个你了解最多的框架，说出你的理解"></a>说一个你了解最多的框架，说出你的理解</h3><h3 id="项目中监控报警机制如何做的，说说你的了解"><a href="#项目中监控报警机制如何做的，说说你的了解" class="headerlink" title="项目中监控报警机制如何做的，说说你的了解"></a>项目中监控报警机制如何做的，说说你的了解</h3><h3 id="服务A调用服务B，用户请求服务A，发现返回较慢，如何定位这个问题"><a href="#服务A调用服务B，用户请求服务A，发现返回较慢，如何定位这个问题" class="headerlink" title="服务A调用服务B，用户请求服务A，发现返回较慢，如何定位这个问题"></a>服务A调用服务B，用户请求服务A，发现返回较慢，如何定位这个问题</h3><h3 id="防止服务器雪崩"><a href="#防止服务器雪崩" class="headerlink" title="防止服务器雪崩"></a>防止服务器雪崩</h3><p>服务雪崩效应是一种因 服务提供者 的不可用导致 服务调用者 的不可用,并将不可用 逐渐放大 的过程.如果所示:<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/4178518469-578b40005071a_articlex.png" alt="image"></p>
<p>上图中, A为服务提供者, B为A的服务调用者, C和D是B的服务调用者. 当A的不可用,引起B的不可用,并将不可用逐渐放大C和D时, 服务雪崩就形成了.</p>
<h4 id="服务雪崩效应形成的原因"><a href="#服务雪崩效应形成的原因" class="headerlink" title="服务雪崩效应形成的原因"></a>服务雪崩效应形成的原因</h4><p>我把服务雪崩的参与者简化为 服务提供者 和 服务调用者, 并将服务雪崩产生的过程分为以下三个阶段来分析形成的原因:</p>
<ol>
<li>服务提供者不可用</li>
<li>重试加大流量</li>
<li>服务调用者不可用</li>
</ol>
<p>服务雪崩的每个阶段都可能由不同的原因造成, 比如造成 服务不可用 的原因有:</p>
<ul>
<li>硬件故障</li>
<li>程序Bug</li>
<li>缓存击穿</li>
<li>用户大量请求</li>
</ul>
<p>硬件故障可能为硬件损坏造成的服务器主机宕机, 网络硬件故障造成的服务提供者的不可访问.<br>缓存击穿一般发生在缓存应用重启, 所有缓存被清空时,以及短时间内大量缓存失效时. 大量的缓存不命中, 使请求直击后端,造成服务提供者超负荷运行,引起服务不可用.<br>在秒杀和大促开始前,如果准备不充分,用户发起大量请求也会造成服务提供者的不可用.</p>
<p>而形成 重试加大流量 的原因有:</p>
<ul>
<li>用户重试</li>
<li>代码逻辑重试</li>
</ul>
<p>在服务提供者不可用后, 用户由于忍受不了界面上长时间的等待,而不断刷新页面甚至提交表单.<br>服务调用端的会存在大量服务异常后的重试逻辑.<br>这些重试都会进一步加大请求流量.</p>
<p>最后, 服务调用者不可用 产生的主要原因是:</p>
<ul>
<li>同步等待造成的资源耗尽</li>
</ul>
<p>当服务调用者使用 同步调用 时, 会产生大量的等待线程占用系统资源. 一旦线程资源被耗尽,服务调用者提供的服务也将处于不可用状态, 于是服务雪崩效应产生了.</p>
<h4 id="服务雪崩的应对策略"><a href="#服务雪崩的应对策略" class="headerlink" title="服务雪崩的应对策略"></a>服务雪崩的应对策略</h4><p>针对造成服务雪崩的不同原因, 可以使用不同的应对策略:</p>
<ul>
<li>流量控制</li>
<li>改进缓存模式</li>
<li>服务自动扩容</li>
<li>服务调用者降级服务</li>
</ul>
<p>流量控制 的具体措施包括:</p>
<ul>
<li>网关限流</li>
<li>用户交互限流</li>
<li>关闭重试</li>
</ul>
<p>因为Nginx的高性能, 目前一线互联网公司大量采用Nginx+Lua的网关进行流量控制, 由此而来的OpenResty也越来越热门.</p>
<p>用户交互限流的具体措施有:</p>
<ul>
<li>采用加载动画,提高用户的忍耐等待时间.</li>
<li>提交按钮添加强制等待时间机制.</li>
</ul>
<p>改进缓存模式 的措施包括:</p>
<ul>
<li>缓存预加载</li>
<li>同步改为异步刷新</li>
</ul>
<p>服务自动扩容 的措施主要有:</p>
<ul>
<li>AWS的auto scaling</li>
</ul>
<p>服务调用者降级服务 的措施包括:<br>资源隔离</p>
<ul>
<li>对依赖服务进行分类</li>
<li>不可用服务的调用快速失败</li>
<li>资源隔离主要是对调用服务的线程池进行隔离.</li>
</ul>
<p>我们根据具体业务,将依赖服务分为: 强依赖和若依赖. 强依赖服务不可用会导致当前业务中止,而弱依赖服务的不可用不会导致当前业务的中止.</p>
<p>不可用服务的调用快速失败一般通过 超时机制, 熔断器 和熔断后的 降级方法 来实现.</p>
<h3 id="缓存穿透，缓存击穿，缓存雪崩解决方案分析"><a href="#缓存穿透，缓存击穿，缓存雪崩解决方案分析" class="headerlink" title="缓存穿透，缓存击穿，缓存雪崩解决方案分析"></a>缓存穿透，缓存击穿，缓存雪崩解决方案分析</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p>
<p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><h6 id="使用互斥锁-mutex-key"><a href="#使用互斥锁-mutex-key" class="headerlink" title="使用互斥锁(mutex key)"></a>使用互斥锁(mutex key)</h6><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p>
<p>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。在redis2.6.1之前版本未实现setnx的过期时间，所以这里给出两种版本代码参考：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//2.6.1前单机版本锁</span></span><br><span class="line"><span class="keyword">String</span> <span class="built_in">get</span>(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;  </span><br><span class="line">   <span class="keyword">String</span> value = redis.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">   <span class="keyword">if</span> (value  == <span class="keyword">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="string">"1"</span>)) &#123;  </span><br><span class="line">        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">        redis.expire(key_mutex, <span class="number">3</span> * <span class="number">60</span>)  </span><br><span class="line">        value = db.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">        redis.<span class="built_in">set</span>(<span class="built_in">key</span>, value);  </span><br><span class="line">        redis.delete(key_mutex);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//其他线程休息50毫秒后重试  </span></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);  </span><br><span class="line">        <span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最新版本代码：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> <span class="built_in">get</span>(<span class="built_in">key</span>) &#123;</span><br><span class="line">      <span class="keyword">String</span> value = redis.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">          <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">		  <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功</span></span><br><span class="line">               value = db.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">                      redis.<span class="built_in">set</span>(<span class="built_in">key</span>, value, expire_secs);</span><br><span class="line">                      redis.del(key_mutex);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">                      sleep(<span class="number">50</span>);</span><br><span class="line">                      <span class="built_in">get</span>(<span class="built_in">key</span>);  <span class="comment">//重试</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> value;      </span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>memcache代码<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (memcache.<span class="built_in">get</span>(<span class="built_in">key</span>) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">    <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">    <span class="keyword">if</span> (memcache.<span class="built_in">add</span>(key_mutex, <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>) == <span class="keyword">true</span>) &#123;  </span><br><span class="line">        value = db.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">        memcache.<span class="built_in">set</span>(<span class="built_in">key</span>, value);  </span><br><span class="line">        memcache.delete(key_mutex);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        sleep(<span class="number">50</span>);  </span><br><span class="line">        retry();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="“提前”使用互斥锁-mutex-key"><a href="#“提前”使用互斥锁-mutex-key" class="headerlink" title="“提前”使用互斥锁(mutex key)"></a>“提前”使用互斥锁(mutex key)</h6><p>在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。伪代码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">v = memcache.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line"><span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (memcache.<span class="built_in">add</span>(key_mutex, <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>) == <span class="keyword">true</span>) &#123;  </span><br><span class="line">        value = db.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">        memcache.<span class="built_in">set</span>(<span class="built_in">key</span>, value);  </span><br><span class="line">        memcache.delete(key_mutex);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        sleep(<span class="number">50</span>);  </span><br><span class="line">        retry();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (v.timeout &lt;= now()) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (memcache.<span class="built_in">add</span>(key_mutex, <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>) == <span class="keyword">true</span>) &#123;  </span><br><span class="line">            <span class="comment">// extend the timeout for other threads  </span></span><br><span class="line">            v.timeout += <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>;  </span><br><span class="line">            memcache.<span class="built_in">set</span>(<span class="built_in">key</span>, v, KEY_TIMEOUT * <span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// load the latest value from db  </span></span><br><span class="line">            v = db.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">            v.timeout = KEY_TIMEOUT;  </span><br><span class="line">            memcache.<span class="built_in">set</span>(<span class="built_in">key</span>, value, KEY_TIMEOUT * <span class="number">2</span>);  </span><br><span class="line">            memcache.delete(key_mutex);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            sleep(<span class="number">50</span>);  </span><br><span class="line">            retry();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="“永远不过期”"><a href="#“永远不过期”" class="headerlink" title="“永远不过期”"></a>“永远不过期”</h6><p>这里的“永远不过期”包含两层意思：</p>
<p>(1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。</p>
<p>(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期</p>
<p>从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">get</span>(<span class="keyword">final</span> <span class="keyword">String</span> <span class="built_in">key</span>) &#123;  </span><br><span class="line">        V v = redis.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">        <span class="keyword">String</span> value = v.getValue();  </span><br><span class="line">        <span class="keyword">long</span> timeout = v.getTimeout();  </span><br><span class="line">        <span class="keyword">if</span> (v.timeout &lt;= System.currentTimeMillis()) &#123;  </span><br><span class="line">            <span class="comment">// 异步更新后台异常执行  </span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;  </span><br><span class="line">                    <span class="keyword">String</span> keyMutex = <span class="string">"mutex:"</span> + <span class="built_in">key</span>;  </span><br><span class="line">                    <span class="keyword">if</span> (redis.setnx(keyMutex, <span class="string">"1"</span>)) &#123;  </span><br><span class="line">                        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">                        redis.expire(keyMutex, <span class="number">3</span> * <span class="number">60</span>);  </span><br><span class="line">                        <span class="keyword">String</span> dbValue = db.<span class="built_in">get</span>(<span class="built_in">key</span>);  </span><br><span class="line">                        redis.<span class="built_in">set</span>(<span class="built_in">key</span>, dbValue);  </span><br><span class="line">                        redis.delete(keyMutex);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="资源保护"><a href="#资源保护" class="headerlink" title="资源保护"></a>资源保护</h6><p>采用netflix的hystrix，可以做资源的隔离保护主线程池，如果把这个应用到缓存的构建也未尝不可。</p>
<p>四种解决方案：没有最佳只有最合适</p>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单分布式互斥锁（mutex key）</td>
<td>1. 思路简单2. 保证一致性</td>
<td>1. 代码复杂度增大2. 存在死锁的风险3. 存在线程池阻塞的风险</td>
</tr>
<tr>
<td>“提前”使用互斥锁</td>
<td>保证一致性</td>
<td>同上  </td>
</tr>
<tr>
<td>不过期(本文)</td>
<td>异步构建缓存，不会阻塞线程池</td>
<td>1.不保证一致性。2. 代码复杂度增大(每个value都要维护一个timekey)。3. 占用一定的内存空间(每个value都要维护一个timekey)。 </td>
</tr>
<tr>
<td>资源隔离组件hystrix(本文)</td>
<td>1.hystrix技术成熟，有效保证后端。2. hystrix监控强大。</td>
<td>部分访问存在降级策略。</td>
</tr>
</tbody>
</table>
<h3 id="怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？"><a href="#怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？" class="headerlink" title="怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？"></a>怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1428026-20180627155226400-2110957179.png" alt="image"><br>优点</p>
<p>1:提升开发交流，每个服务足够内聚，足够小，代码容易理解；</p>
<p>2:服务独立测试、部署、升级、发布；</p>
<p>3:按需定制的DFX，资源利用率，每个服务可以各自进行x扩展和z扩展，而且，每个服务可以根据自己的需要部署到合适的硬件服务器上；每个服务按4:需要选择HA的模式，选择接受服务的实例个数；</p>
<p>5:容易扩大开发团队，可以针对每个服务（service）组件开发团队；</p>
<p>6:提高容错性（fault isolation），一个服务的内存泄露并不会让整个系统瘫痪；</p>
<p>7:新技术的应用，系统不会被长期限制在某个技术栈上；</p>
<p>缺点</p>
<p>没有银弹，微服务提高了系统的复杂度；开发人员要处理分布式系统的复杂性；服务之间的分布式通信问题；服务的注册与发现问题；服务之间的分布式事务问题；数据隔离再来的报表处理问题；服务之间的分布式一致性问题；服务管理的复杂性，服务的编排；不同服务实例的管理。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1428026-20180627155304978-2139783031.png" alt="image"></p>
<p>Chris Richardson提出的微服务的三维扩展模型：</p>
<p>X轴，服务实例水平扩展，保证可靠性与性能；</p>
<p>Y轴，功能的扩展，服务单一职责，功能独立；</p>
<p>Z轴，数据分区，数据独立，可靠性保证；</p>
<h4 id="拆分例子"><a href="#拆分例子" class="headerlink" title="拆分例子"></a>拆分例子</h4><h5 id="姿势一"><a href="#姿势一" class="headerlink" title="姿势一"></a>姿势一</h5><p>新浪微博微服务专家胡忠想从纵横两个维度来划分，简单粗暴：</p>
<p>1.1 纵向拆分</p>
<p>　　从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。</p>
<p>1.2 横向拆分</p>
<p>　　从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</p>
<p>　　纵向以业务为基准，关系铁的在一起；横向功能独立的在一起。我想如果拆分这么简单，你有底气拆，敢拆吗？所以我们又继续比对一下其他专家的言论。<br>　　<img src="https://minios.strongsickcat.com/dinghuang-blog-picture/127185-20190513142607150-1816607466.png" alt="image"></p>
<h5 id="姿势二"><a href="#姿势二" class="headerlink" title="姿势二"></a>姿势二</h5><p>阿里的小伙伴从综合的维度来看，部分维度和上面会有重合。</p>
<p>2.1 服务拆分要迎合业务的需要</p>
<p>　　充分考虑业务独立性和专业性，避免以团队来定义服务边界，从而出现“土匪”抢地盘，影响团队信任。</p>
<p>　　这个维度和上面的类似，但是强调的是业务和团队成员的各自独立性，对上面是一种很好的补充。</p>
<p>2.2 拆分后的维护成本要低于拆分前</p>
<p>　　这里的维护成本包括：人力、物力、时间。</p>
<p>　　这里的成本对大部分中小团队来说都是必须要考虑的重要环节，如果投入和收益不能成正比，或者超出领导的预算或者市场窗口，那么先进的技术就是绊脚石，千万不要迷恋技术，所谓工程师思维千万要不得。</p>
<p>2.3 拆分不仅仅是架构的调整，组织结构上也要做响应的适应性优化</p>
<p>　　确保拆分后的服务由相对独立的团队负责维护。</p>
<p>　　这句话怎么理解呢？传统的团队划分是按照产品部、前端、后端横向划分，微服务化以后的团队可能就会是吃一张披萨饼的人数，产品、前端、后端被归类到服务里面，以服务为中心来分配人数。</p>
<p>2.4 拆分最有价值的结果是提高了系统的可扩展性</p>
<p>　　把具有不同扩展性要求的服务拆分出来，分别进行部署，降低成本，提高效率。比如全文搜索服务。</p>
<p>　　这点和上面的按功能独立性来拆分有点类似，功能独立其实就是面向可扩展性。</p>
<p>2.5 考虑软件发布频率</p>
<p>　　比如把20%经常变动的部分进行抽离，80%不经常变动的单独部署和管理。说白了就是按照8/2原则进行拆分。这个拆分的好处很明显，可以尽可能的减少发布产生的后遗症，比如用户体验、服务相互干扰等。</p>
<p>　　但是这里有一个问题，假如20%的服务分属于不同的业务层面，那该怎么办？所以这里的拆分应该有个优先级，在拆分相互冲突的时候应该要优先考虑权重比较高的那个。<br>　　<img src="https://minios.strongsickcat.com/dinghuang-blog-picture/127185-20190513142644719-478728417.png" alt="image">
　　</p>
<h5 id="姿势三"><a href="#姿势三" class="headerlink" title="姿势三"></a>姿势三</h5><p>资深技术专家李运华在他的架构书中给出的拆分：</p>
<p>3.1 基于业务逻辑</p>
<p>　　将系统中的业务按照职责范围进行识别，职责相同的划分为一个单独的服务。这种业务优先的方式在前面两种姿势当中都出现过，可见是最基本，最重要的划分方式（没有之一）。</p>
<p>3.2 基于稳定性</p>
<p>　　将系统中的业务模块按照稳定性进行排序。稳定的、不经常修改的划分一块；将不稳定的，经常修改的划分为一个独立服务。比如日志服务、监控服务都是相对稳定的服务，可以归到一起。这个很类似上面提到的2/8原则，80%的业务是稳定的。</p>
<p>　　至此你会发现服务的拆分真的没有绝对的标准，只有合理才是标准。</p>
<p>3.3 基于可靠性</p>
<p>　　同样，将系统中的业务模块按照可靠性进行排序。对可靠性要求比较高的核心模块归在一起，对可靠性要求不高的非核心模块归在一块。</p>
<p>　　这种拆分的高明可以很好的规避因为一颗老鼠屎坏了一锅粥的单体弊端，同时将来要做高可用方案也能很好的节省机器或带宽的成本。</p>
<p>3.4 基于高性能</p>
<p>　　同上，将系统中的业务模块按照对性能的要求进行优先级排序。把对性能要求较高的模块独立成一个服务，对性能要求不高的放在一起。比如全文搜索，商品查询和分类，秒杀就属于高性能的核心模块。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/127185-20190513142705705-752555217.png" alt="image"></p>
<h3 id="如何理解网关，网关带来的好处和坏处，如何解决"><a href="#如何理解网关，网关带来的好处和坏处，如何解决" class="headerlink" title="如何理解网关，网关带来的好处和坏处，如何解决"></a>如何理解网关，网关带来的好处和坏处，如何解决</h3><p>API网关我的分析中会用到以下三种场景。</p>
<ul>
<li>Open API。企业需要将自身数据、能力等作为开发平台向外开放，通常会以rest的方式向外提供，最好的例子就是淘宝开放平台、腾讯公司的QQ开放平台、微信开放平台。 Open API开放平台必然涉及到客户应用的接入、API权限的管理、调用次数管理等，必然会有一个统一的入口进行管理，这正是API网关可以发挥作用的时候。</li>
<li>微服务网关。微服务的概念最早在2012年提出，在Martin Fowler的大力推广下，微服务在2014年后得到了大力发展。 在微服务架构中，有一个组件可以说是必不可少的，那就是微服务网关，微服务网关处理了负载均衡，缓存，路由，访问控制，服务代理，监控，日志等。API网关在微服务架构中正是以微服务网关的身份存在。</li>
<li>API服务管理平台。上述的微服务架构对企业来说有可能实施上是困难的，企业有很多遗留系统，要全部抽取为微服务器改动太大，对企业来说成本太高。但是由于不同系统间存在大量的API服务互相调用，因此需要对系统间服务调用进行管理，清晰地看到各系统调用关系，对系统间调用进行监控等。 API网关可以解决这些问题，我们可以认为如果没有大规模的实施微服务架构，那么对企业来说微服务网关就是企业的API服务管理平台。</li>
</ul>
<p>一个企业随着信息系统复杂度的提高，必然出现外部合作伙伴应用、企业自身的公网应用、企业内网应用等，在架构上应该将这三种应用区别开，三种应用的安排级别、访问方式也不一样。 因此在我的设计中将这三种应用分别用不同的网关进行API管理，分别是：API网关（OpenAPI合伙伙伴应用）、API网关（内部应用）、API网关（内部公网应用）。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/388861-20180104153322409-925270442.png" alt="image"></p>
<p>对于OpenAPI使用的API网关来说，一般合作伙伴要以应用的形式接入到OpenAPI平台，合作伙伴需要到 OpenAPI平台申请应用。 因此在OpenAPI网关之外，需要有一个面向合作伙伴的使用的平台用于合作伙伴，这就要求OpenAPI网关需要提供API给这个用户平台进行访问。 如下架构:</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/388861-20180104153600440-801781810.jpg" alt="image"></p>
<p>对于内网的API网关，在起到的作用上来说可以认为是微服务网关，也可以认为是内网的API服务治理平台。 当企业将所有的应用使用微服务的架构管理起来，那么API网关就起到了微服务网关的作用。 而当企业只是将系统与系统之间的调用使用rest api的方式进行访问时使用API网关对调用进行管理，那么API网关起到的就是API服务治理的作用。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/388861-20180104153752409-751696404.jpg" alt="image"><br>对于公司内部公网应用（如APP、公司的网站），如果管理上比较细致，在架构上是可能由独立的API网关来处理这部分内部公网应用，如果想比较简单的处理，也可以是使用面向合作伙伴的API网关。 如果使用独立的API网关，有以下的好处：</p>
<ul>
<li>面向合作伙伴和面向公司主体业务的优先级不一样，不同的API网关可以做到业务影响的隔离。</li>
<li>内部API使用的管理流程和面向合作伙伴的管理流程可能不一样。</li>
<li>内部的API在功能扩展等方面的需求一般会大于OpenAPI对于功能的要求。<br>基于以上的分析，如果公司有能力，那么还是建议分开使用合作伙伴OPEN API网关和内部公网应用网关</li>
</ul>
<h4 id="API网关有哪些竞争方案"><a href="#API网关有哪些竞争方案" class="headerlink" title="API网关有哪些竞争方案"></a>API网关有哪些竞争方案</h4><p>1、对于Open API平台的API网关，我分析只能选择API网关作为解决方案，业界没有发现比较好的可以用来作为Open API平台的入口的其他方案。</p>
<p>2、对于作为微服务网关的API网关，业界的选择可以选择的解决方案比较多，也取决于微服务器的实现方案，有一些微服务架构的实现方案是不需要微服务网关的。</p>
<ul>
<li>Service Mesh，这是新兴的基于无API网关的架构，通过在客户端上的代理完成屏蔽网络层的访问，这样达到对应用层最小的改动，当前Service Mesh的产品还正在开发中，并没有非常成熟可直接应用的产品。 发展最迅速的产品是Istio。 建议大家密切关注相关产品的研发、业务使用进展。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/388861-20180104154202112-182791105.png" alt="image"></li>
<li>基于duboo架构，在这个架构中通常是不需要网关的，是由客户端直接访问服务提供方，由注册中心向客户端返回服务方的地址。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/388861-20180104154443503-595466474.jpg" alt="image"></li>
</ul>
<h4 id="API网关解决方案"><a href="#API网关解决方案" class="headerlink" title="API网关解决方案"></a>API网关解决方案</h4><p>私有云开源解决方案如下：</p>
<ul>
<li>Kong kong是基于Nginx+Lua进行二次开发的方案， <a href="https://konghq.com/" target="_blank" rel="noopener">https://konghq.com/</a></li>
<li>Netflix Zuul，zuul是spring cloud的一个推荐组件，<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">https://github.com/Netflix/zuul</a></li>
<li>orange,这个开源程序是国人开发的， <a href="http://orange.sumory.com/" target="_blank" rel="noopener">http://orange.sumory.com/</a></li>
</ul>
<p>公有云解决方案：</p>
<ul>
<li>Amazon API Gateway，<a href="https://aws.amazon.com/cn/api-gateway/" target="_blank" rel="noopener">https://aws.amazon.com/cn/api-gateway/</a></li>
<li>阿里云API网关，<a href="https://www.aliyun.com/product/apigateway/" target="_blank" rel="noopener">https://www.aliyun.com/product/apigateway/</a></li>
<li>腾讯云API网关， <a href="https://cloud.tencent.com/product/apigateway" target="_blank" rel="noopener">https://cloud.tencent.com/product/apigateway</a></li>
</ul>
<p>自开发解决方案：</p>
<ul>
<li>基于Nginx+Lua+ OpenResty的方案，可以看到Kong,orange都是基于这个方案</li>
<li>基于Netty、非阻塞IO模型。 通过网上搜索可以看到国内的宜人贷等一些公司是基于这种方案，是一种成熟的方案。</li>
<li>基于Node.js的方案。 这种方案是应用了Node.js天生的非阻塞的特性。</li>
<li>基于java Servlet的方案。 zuul基于的就是这种方案，这种方案的效率不高，这也是zuul总是被诟病的原因。</li>
</ul>
<h4 id="怎么选择API网关"><a href="#怎么选择API网关" class="headerlink" title="怎么选择API网关"></a>怎么选择API网关</h4><p>如果是要选择一款已有的API网关，那么需要从以下几个方面去考虑。</p>
<p>1、性能与可用性<br>如果一旦采用了API网关，那么API网关就会作为企业应用核心，因此性能和可用性是必须要求的。</p>
<p>从性能上来说，需要让网关增加的时间消耗越短越好，个人觉得需要10ms以下。 系统需要采用非阻塞的IO，如epoll，NIO等。网关和各种依赖的交互也需要是非阻塞的，这样才能保证整体系统的高可用性，如：Node.js的响应式编程和基于java体现的RxJava和Future。<br>网关必须支持集群部署，任务一台服务器的crash都应该不影响整体系统的可用性。</p>
<p>多套网关应该支持同一管理平台和同一监控中心。 如： 一个企业的OpenAPI网关和内部应用的多个系统群的不同的微服务网关可以在同一监控中心进行监控。</p>
<p>2、可扩展性、可维护性</p>
<p>一款产品总有不能满足生产需求的地方，因此需求思考产品在如何进行二次开发和维护，是否方便公司团队接手维护产品。</p>
<p>3、需求匹配度</p>
<p>需要评估各API网关在需求上是否能满足，如： 如果是OpenAPI平台需要使用API网关，那么需要看API网关在合作伙伴应用接入、合作伙伴门户集成、访问次数限额等OpenAPI核心需求上去思考产品是否能满足要求。 如果是微服务网关，那么要从微服务的运维、监控、管理等方面去思考产品是否足够强大。</p>
<p>4、是否开源？公司是否有自开发的能力？</p>
<p>现有的开源产品如kong，zuul，orange都有基础的API网关的核心功能，这些开源产品大多离很好的使用有一定的距离，如：没有提供管理功能的UI界面、监控功能弱小，不支持OpenAPI平台，没有公司运营与运维的功能等。 当然开源产品能获取源代码，如果公司有比较强的研发能力，能hold住这些开源产品，经过二次开发kong、zuul应该还是适应一些公司，不过需求注意以下一些点：</p>
<p>kong是基于ngnix+lua的，从公司的角度比较难于找到能去维护这种架构产品的人。 需求评估当前公司是否有这个能力去维护这个产品。</p>
<p>zuul因为架构的原因在高并发的情况下性能不高，同时需要去基于研究整合开源的适配zuul的监控和管理系统。<br>orange由于没有被大量使用，同时是国内个人在开源，在可持续性和社区资源上不够丰富，出了问题后可能不容易找到人问。<br>另外kong提供企业版本的API网关，当然也是基于ngnix+lua的，企业版本可以购买他们的技术支持、培训等服务、以及拥有界面的管理、监控等功能。</p>
<p>5、公有云还是私有云</p>
<p>现在的亚马逊、阿里、腾讯云都在提供基础公有云的API网关，当然这些网关的基础功能肯定是没有问题，但是二次开发，扩展功能、监控功能可能就不能满足部分用户的定制需求了。另外很多企业因为自身信息安全的原因，不能使用外网公有网的API网关服务，这样就只有选择私有云的方案了。<br>在需求上如果基于公有云的API网关只能做到由内部人员为外网人员申请应用，无法做到定制的合作伙伴门户，这也不适合于部分企业的需求。<br>如果作为微服务网关，大多数情况下是希望网关服务器和服务提供方服务器是要在内网的，在这里情况下也只有私有云的API网关才能满足需求。</p>
<p>综合上面的分析，基础公有云的API网关只有满足一部分简单客户的需求，对于很多企业来说私有云的API网关才是正确的选择。</p>
<h3 id="项目中如何保证接口的幂等操作"><a href="#项目中如何保证接口的幂等操作" class="headerlink" title="项目中如何保证接口的幂等操作"></a>项目中如何保证接口的幂等操作</h3><ul>
<li>调用者给消息一个唯一请求ID标识。ID标识一个工作单元，这个工作单元只应执行一次，工作单元ID可以是Schema的一部分，也可以是一个定制的SOAP Header，服务的Contract 可以说明这个唯一请求ID标识是必须的</li>
<li>接收者在执行一个工作单元必须先检验该工作单元是否已经执行过。检查是否执行的逻辑通常是根据唯一请求ID ，在服务端查询请求是否有记录，是否有对应的响应信息，如果有，直接把响应信息查询后返回；如果没有，那么就当做新请求去处理</li>
</ul>
<h3 id="遇到过线上服务器CPU飙高的情况没有，如何处理的？"><a href="#遇到过线上服务器CPU飙高的情况没有，如何处理的？" class="headerlink" title="遇到过线上服务器CPU飙高的情况没有，如何处理的？"></a>遇到过线上服务器CPU飙高的情况没有，如何处理的？</h3><ul>
<li><p>登录服务器，执行top命令，查看CPU占用情况（top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器，通过以上命令，我们可以看到，进程ID为1893的Java进程的CPU占用率达到了181%，基本可以定位到是我们的Java应用导致整个服务器的CPU占用率飙升）</p>
  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$top</span></span><br><span class="line">PID<span class="built_in"> USER </span>     PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">1893 admin     20   0 7127m 2.6g  38m S 181.7 32.6  10:20.26 java</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java是单进程多线程的，那么，我们接下来看看PID=1893的这个Java进程中的各个线程的CPU使用情况，同样是用top命令,通过top -Hp 1893命令，我们可以发现，当前1893这个进程中，ID为4519的线程占用CPU最高。</p>
  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$top</span> -Hp 1893</span><br><span class="line">PID<span class="built_in"> USER </span>     PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">4519 admin     20   0 7127m 2.6g  38m R 18.6 32.6   0:40.11 java</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过top命令，我们目前已经定位到导致CPU使用率较高的具体线程， 那么我么接下来就定位下到底是哪一行代码存在问题。首先，我们需要把4519这个线程转成16进制</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">printf</span> %x 4519</span></span><br><span class="line">11a7</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，通过jstack命令，查看栈信息(通过以上代码，我们可以清楚的看到，BeanValidator.java的第30行是有可能存在问题的)：</p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$sudo -u admin  jstack <span class="number">1893</span> |grep -A <span class="number">200</span> <span class="number">11</span>a7</span><br><span class="line"><span class="string">"HSFBizProcessor-DEFAULT-8-thread-5"</span> <span class="comment">#500 daemon prio=10 os_prio=0 tid=0x00007f632314a800 nid=0x11a2 runnable [0x000000005442a000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">  <span class="keyword">at</span> sun.misc.URLClassPath$Loader.findResource(URLClassPath.java:<span class="number">684</span>)</span><br><span class="line">  <span class="keyword">at</span> sun.misc.URLClassPath.findResource(URLClassPath.java:<span class="number">188</span>)</span><br><span class="line">  <span class="keyword">at</span> java.net.URLClassLoader$<span class="number">2.</span><span class="built_in">run</span>(URLClassLoader.java:<span class="number">569</span>)</span><br><span class="line">  <span class="keyword">at</span> java.net.URLClassLoader$<span class="number">2.</span><span class="built_in">run</span>(URLClassLoader.java:<span class="number">567</span>)</span><br><span class="line">  <span class="keyword">at</span> java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">  <span class="keyword">at</span> java.net.URLClassLoader.findResource(URLClassLoader.java:<span class="number">566</span>)</span><br><span class="line">  <span class="keyword">at</span> java.lang.ClassLoader.getResource(ClassLoader.java:<span class="number">1093</span>)</span><br><span class="line">  <span class="keyword">at</span> java.net.URLClassLoader.getResourceAsStream(URLClassLoader.java:<span class="number">232</span>)</span><br><span class="line">  <span class="keyword">at</span> org.hibernate.validator.internal.xml.ValidationXmlParser.getInputStreamForPath(ValidationXmlParser.java:<span class="number">248</span>)</span><br><span class="line">  <span class="keyword">at</span> org.hibernate.validator.internal.xml.ValidationXmlParser.getValidationConfig(ValidationXmlParser.java:<span class="number">191</span>)</span><br><span class="line">  <span class="keyword">at</span> org.hibernate.validator.internal.xml.ValidationXmlParser.parseValidationXml(ValidationXmlParser.java:<span class="number">65</span>)</span><br><span class="line">  <span class="keyword">at</span> org.hibernate.validator.internal.engine.ConfigurationImpl.parseValidationXml(ConfigurationImpl.java:<span class="number">287</span>)</span><br><span class="line">  <span class="keyword">at</span> org.hibernate.validator.internal.engine.ConfigurationImpl.buildValidatorFactory(ConfigurationImpl.java:<span class="number">174</span>)</span><br><span class="line">  <span class="keyword">at</span> javax.validation.Validation.buildDefaultValidatorFactory(Validation.java:<span class="number">111</span>)</span><br><span class="line">  <span class="keyword">at</span> com.test.common.util.BeanValidator.validate(BeanValidator.java:<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>线上问题排查还可以使用Alibaba开源的工具Arthas进行排查，以上问题，可以使用一下命令定位<code>thread -n 3</code>。</p>
</li>
</ul>
<h3 id="如果线上一个功能是用栈结构实现的，使用过程中要注意哪些问题，为什么？"><a href="#如果线上一个功能是用栈结构实现的，使用过程中要注意哪些问题，为什么？" class="headerlink" title="如果线上一个功能是用栈结构实现的，使用过程中要注意哪些问题，为什么？"></a>如果线上一个功能是用栈结构实现的，使用过程中要注意哪些问题，为什么？</h3><ul>
<li>stack栈：是自动分配变量，以及函数调用的时候所使用的一些空间。地址是由高向低减少的。由编译器自动分配内存空间，代码结束，自动释放内存空间。它的内部结构是一个容器式，只有一个进口，并且也作为出口。这就是导致，先进来的数据在“容器”底部，后进来的数据在“容器顶部”，出栈的时候，就应验了“后进先出，先进后出”的这句话。</li>
<li>对于栈来说，理论上线性表的操作特性它都具备，可由于它的特殊性，所以针对它的操作上会有些变化。特别是插入和删除操作，我们改名为push和pop，进栈和出栈。</li>
<li>主要用途：函数调用和返回，数字转字符，表达式求值，走迷宫等等。只要数据的保存满足先进后出的原理，都优先考虑使用栈，所以栈是计算机中不可缺的机制。</li>
<li>建立Stack数组时需要为每一个Stack元素初始化一个对象<h3 id="分布式锁的实现、对比Redis分布式锁-amp-ZK分布式锁"><a href="#分布式锁的实现、对比Redis分布式锁-amp-ZK分布式锁" class="headerlink" title="分布式锁的实现、对比Redis分布式锁 &amp; ZK分布式锁"></a>分布式锁的实现、对比Redis分布式锁 &amp; ZK分布式锁</h3></li>
<li>redis分布式锁<ul>
<li>简单算法：是redis官方支持的分布式锁算法。这个分布式锁有3个重要的考量点，互斥（只能有一个客户端获取锁），不能死锁，容错（大部分redis节点或者这个锁就可以加可以释放），第一个最普通的实现方式，如果就是在redis里创建一个key算加锁。SET my:lock 随机值 NX PX 30000，这个命令就ok，这个的NX的意思就是只有key不存在的时候才会设置成功，PX 30000的意思是30秒后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。为啥要用随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除key的话会有问题，所以得用随机值加上面的lua脚本来释放锁。但是这样是肯定不行的。因为如果是普通的redis单实例，那就是单点故障。或者是redis普通主从，那redis主从异步复制，如果主节点挂了，key还没同步到从节点，此时从节点切换为主节点，别人就会拿到锁。<ul>
<li>RedLock算法：这个场景是假设有一个redis cluster，有5个redis master实例。然后执行如下步骤获取一把锁<pre><code>1. 获取当前时间戳，单位是毫秒；
2. 跟上面类似，轮流尝试在每个master节点上创建锁，过期时间较短，一般就几十毫秒；
3. 尝试在大多数节点上建立一个锁，比如5个节点就要求是3个节点（n / 2 +1）；
4. 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；
5. 要是锁建立失败了，那么就依次删除这个锁；
6. 只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li>zk分布式锁<ul>
<li>zk分布式锁，其实可以做的比较简单，就是某个节点尝试创建临时znode，此时创建成功了就获取了这个锁；这个时候别的客户端来创建锁会失败，只能注册个监听器监听这个锁。释放锁就是删除这个znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新枷锁。</li>
</ul>
</li>
<li>redis分布式锁和zk分布式锁的对比：redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能；zk分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。另外一点就是，如果是redis获取锁的那个客户端bug了或者挂了，那么只能等待超时时间之后才能释放锁；而zk的话，因为创建的是临时znode，只要客户端挂了，znode就没了，此时就自动释放锁。redis分布式锁大家每发现好麻烦吗？遍历上锁，计算时间等等。zk的分布式锁语义清晰实现简单。所以先不分析太多的东西，就说这两点，我个人实践认为zk的分布式锁比redis的分布式锁牢靠、而且模型简单易用。</li>
</ul>
<h3 id="项目中系统监控怎么做的"><a href="#项目中系统监控怎么做的" class="headerlink" title="项目中系统监控怎么做的"></a>项目中系统监控怎么做的</h3><ul>
<li>集中式日志系统<ul>
<li>Elasticsearch</li>
<li>Logstash</li>
<li>Kibana</li>
<li>Beats</li>
</ul>
</li>
<li>集中式度量系统<ul>
<li>Prometheus</li>
<li>Cat</li>
</ul>
</li>
<li>分布式追踪系统<ul>
<li>Zipkin</li>
<li>Pinpoint</li>
<li>Skywalking</li>
<li>Jaeger</li>
</ul>
</li>
</ul>
<h3 id="如何实现的，Snowflake实现原理，Snowflake有哪些问题，如何避免根据订单号可以推算出今天的订单量"><a href="#如何实现的，Snowflake实现原理，Snowflake有哪些问题，如何避免根据订单号可以推算出今天的订单量" class="headerlink" title="如何实现的，Snowflake实现原理，Snowflake有哪些问题，如何避免根据订单号可以推算出今天的订单量"></a>如何实现的，Snowflake实现原理，Snowflake有哪些问题，如何避免根据订单号可以推算出今天的订单量</h3><ul>
<li>正数位（占1比特）+时间戳（占41比特）+机械id（占5比特）+数据中心（占5比特）+自增值（占12比特），总共64比特组成的一个Long类型。</li>
<li>时间戳（占41个比特）：毫秒数，大约可以使使用69年</li>
<li>机械id（占5个比特）：即2的5次方等于32个机器</li>
<li>数据中心id（占5个比特）：即2的5次方等于32个数据中心</li>
<li>自增值（占12比特）：2的12次方等于4096。也就是说每毫秒最多可以生成4096个id，如果cpu生产id的速度大于每毫秒4096个，那么需要使线程进行等待到下一毫秒，重新计数获取自增值。</li>
<li>好处<ul>
<li>生成的id是一个数字的Long类型</li>
<li>无需链接数据库或者redis，超高性能</li>
</ul>
</li>
<li>弊端<ul>
<li>每毫秒只能生成4096个id。随着cpu不断的进步，每毫秒4096个id将不能满足。可以不用担心，即便cpu性能超过了这个值，那么只需等待到下一个毫秒</li>
<li>只能使用69年</li>
<li>每毫秒重新计数，空闲时间会浪费很多id空间</li>
<li>系统时间不可回退，回退将会导致id重复。另：系统时间可以前进，不受影响</li>
</ul>
</li>
</ul>
<h3 id="如何设计一个秒杀系统？"><a href="#如何设计一个秒杀系统？" class="headerlink" title="如何设计一个秒杀系统？"></a>如何设计一个秒杀系统？</h3><ul>
<li>同样是高并发场景，三类业务的架构挑战不一样<ul>
<li>QQ类业务，用户主要读写自己的数据，访问基本带有uid属性，数据访问锁冲突较小</li>
<li>微博类业务，用户的feed主页由别人发布的消息构成，数据读写有一定锁冲突</li>
<li>12306类业务，并发量很高，几乎所有的读写锁冲突都集中在少量数据上，难度最大</li>
</ul>
</li>
<li>将请求尽量拦截在系统上游，而不要让锁冲突落到数据库。传统秒杀系统之所以挂，是因为请求都压到了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，访问流量大，下单成功的有效流量小。一趟火车2000张票，200w个人同时来买，没有人能买成功，请求有效率为0。画外音：此时系统的效率，还不如线下售票窗口。</li>
<li>充分利用缓存,秒杀买票，这是一个典型的读多写少的业务场景：<ul>
<li>车次查询，读，量大</li>
<li>余票查询，读，量大</li>
<li>下单和支付，写，量小<br>一趟火车2000张票，200w个人同时来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%，非常适合使用缓存来优化。</li>
</ul>
</li>
<li>秒杀业务，常见的系统分层架构</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG242.png" alt="image"></p>
<ul>
<li><p>秒杀业务，可以使用典型的服务化分层架构</p>
<ul>
<li>端（浏览器/APP），最上层，面向用户<ul>
<li>JS层面，可以限制用户在x秒之内只能提交一次请求，从而降低系统负载。</li>
<li>APP层面，可以做类似的事情，虽然用户疯狂的在摇微信抢红包，但其实x秒才向后端发起一次请求。</li>
<li>不过，端上的拦截只能挡住普通用户（99%的用户是普通用户），程序员firebug一抓包，写个for循环直接调用后端http接口，js拦截根本不起作用，这下怎么办？</li>
</ul>
</li>
<li>站点层，访问后端数据，拼装html/json返回，如何抗住程序员写for循环调用http接口，首先要确定用户的唯一标识，对于频繁访问的用户予以拦截。<ul>
<li>购票类业务都需要登录，用uid就能标识用户，在站点层，对同一个uid的请求进行计数和限速，例如：一个uid，5秒只准透过1个请求，这样又能拦住99%的for循环请求。</li>
<li>一个uid，5s只透过一个请求，其余的请求怎么办，缓存，页面缓存，5秒内到达站点层的其他请求，均返回上次返回的页面。</li>
<li>OK，通过计数、限速、页面缓存拦住了99%的普通程序员，但仍有些高端程序员，例如黑客，控制了10w个肉鸡，手里有10w个uid，同时发请求，这下怎么办</li>
</ul>
</li>
<li><p>服务层的请求拦截</p>
<ul>
<li><p>服务层非常清楚业务的库存，非常清楚数据库的抗压能力，可以根据这两者进行削峰限速。例如，业务服务很清楚的知道，一列火车只有2000张车票，此时透传10w个请求去数据库，是没有意义的。用什么削峰？请求队，对于写请求，做请求队列，每次只透传有限的写请求去数据层（下订单，支付这样的写业务）。只有2000张火车票，即使10w个请求过来，也只透传2000个去访问数据库：</p>
<ul>
<li>如果前一批请求均成功，再放下一批</li>
<li><p>如果前一批请求库存已经不足，则后续请求全部返回“已售罄”</p>
<p>对于读请求，怎么优化？<br>cache抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的。<br>如此削峰限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有99%的请求被拦住了。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据库层,<br>经过前三层的优化：</p>
<ul>
<li>浏览器拦截了80%请求</li>
<li>站点层拦截了99%请求，并做了页面缓存</li>
<li><p>服务层根据业务库存，以及数据库抗压能力，做了写请求队列与数据缓存</p>
<p>你会发现，每次透到数据库层的请求都是可控的。<br>db基本就没什么压力了，闲庭信步。此时，透2000个到数据库，全部成功，请求有效率100%。</p>
</li>
</ul>
</li>
<li>按照上面的优化方案，其实压力最大的反而是站点层，假设真实有效的请求数是每秒100w，这部分的压力怎么处理？<ul>
<li>站点层水平扩展，通过加机器扩容，一台抗5000，200台搞定；</li>
<li>服务降级，抛弃请求，例如抛弃50%；</li>
<li>原则是要保护系统，不能让所有用户都失败。</li>
</ul>
</li>
<li>站点层限速，是个每个uid的请求计数放到redis里么？吞吐量很大情况下，高并发访问redis，网络带宽会不会成为瓶颈？<ul>
<li>同一个uid计数与限速，如果担心访问redis带宽成为瓶颈，可以这么优化<ul>
<li>计数直接放在内存，这样就省去了网络请求；</li>
<li>在nginx层做7层均衡，让一个uid的请求落到同一个机器上；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>除了系统上的优化，产品与业务还能够做一些折衷，降低架构难度。<ul>
<li>业务折衷一,一般来说，下单和支付放在同一个流程里，能够提高转化率。对于秒杀场景，产品上，下单流程和支付流程异步，放在两个环节里，能够降低数据库写压力。以12306为例，下单成功后，系统占住库存，45分钟之内支付即可。</li>
<li>业务折衷二,一般来说，所有用户规则相同，体验会更好。对于秒杀场景，产品上，不同地域分时售票，虽然不是所有用户规则相同，但能够极大降低系统压力。北京9:00开始售票，上海9:30开始售票，广州XX开始售票，能够分担系统压力。</li>
<li>业务折衷三,秒杀场景，由于短时间内并发较大，系统返回较慢，用户心情十分焦急，可能会频繁点击按钮，对系统造成压力。产品上可以优化为，一旦点击，不管系统是否返回，按钮立刻置灰，不给用户机会频繁点击。</li>
<li>业务折衷四,一般来说，显示具体的库存数量，能够加强用户体验。对于秒杀场景，产品上，只显示有/无车票，而不是显示具体票数目，能够降低缓存淘汰率。<br>画外音：显示库存会淘汰N次，显示有无只会淘汰1次。更多的，用户关注是否有票，而不是票有几张。</li>
</ul>
</li>
<li>总结,对于秒杀系统，除了产品和业务上的折衷，架构设计上主要有两大优化方向<ul>
<li>尽量将请求拦截在系统上游；</li>
<li>读多写少用缓存；</li>
</ul>
</li>
</ul>
<h3 id="如果我现在就是要实现每秒10w请求，不能熔断限流，如何去设计？"><a href="#如果我现在就是要实现每秒10w请求，不能熔断限流，如何去设计？" class="headerlink" title="如果我现在就是要实现每秒10w请求，不能熔断限流，如何去设计？"></a>如果我现在就是要实现每秒10w请求，不能熔断限流，如何去设计？</h3><ul>
<li>Cache住所有查询，两层cache：除了使用ckv做全量缓存，还在数据访问层dao中增加本机内存cache做二级缓存，cache住所有读请求。查询失败或者查询不存在时，降级内存cache；内存cache查询失败或记录不存在时降级DB。DB本身不做读写分离。</li>
<li>DB写同步cache，容忍少量不一致。DB写操作完成后，dao中同步内存cache，业务服务层同步ckv，失败由异步队列补偿，定时的ckv与DB备机对账，保证最终数据一致。</li>
</ul>
<h3 id="服务A调用服务B中一个接口，服务B调用服务C中一个接口，如何实现若服务B响应服务A成功，则服务C一定响应服务B成功，需要考虑系统性能问题？"><a href="#服务A调用服务B中一个接口，服务B调用服务C中一个接口，如何实现若服务B响应服务A成功，则服务C一定响应服务B成功，需要考虑系统性能问题？" class="headerlink" title="服务A调用服务B中一个接口，服务B调用服务C中一个接口，如何实现若服务B响应服务A成功，则服务C一定响应服务B成功，需要考虑系统性能问题？"></a>服务A调用服务B中一个接口，服务B调用服务C中一个接口，如何实现若服务B响应服务A成功，则服务C一定响应服务B成功，需要考虑系统性能问题？</h3><p>欢迎补充。。。。。</p>
<h3 id="假设现在双十一零点，大量下单请求，如何对这些订单进行分库分表，为什么？"><a href="#假设现在双十一零点，大量下单请求，如何对这些订单进行分库分表，为什么？" class="headerlink" title="假设现在双十一零点，大量下单请求，如何对这些订单进行分库分表，为什么？"></a>假设现在双十一零点，大量下单请求，如何对这些订单进行分库分表，为什么？</h3><h4 id="大众点评设计案例"><a href="#大众点评设计案例" class="headerlink" title="大众点评设计案例"></a>大众点评设计案例</h4><p>原大众点评的订单单表早就已经突破两百G，由于查询维度较多，即使加了两个从库，优化索引，仍然存在很多查询不理想的情况。去年大量抢购活动的开展，使数据库达到瓶颈，应用只能通过限速、异步队列等对其进行保护；业务需求层出不穷，原有的订单模型很难满足业务需求，但是基于原订单表的DDL又非常吃力，无法达到业务要求。随着这些问题越来越突出，订单数据库的切分就愈发急迫了。这次切分，我们的目标是未来十年内不需要担心订单容量的问题。先对订单库进行垂直切分，将原有的订单库分为基础订单库、订单流程库等。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1b24c0df.png" alt="image"><br>垂直切分缓解了原来单集群的压力，但是在抢购时依然捉襟见肘。原有的订单模型已经无法满足业务需求，于是我们设计了一套新的统一订单模型，为同时满足C端用户、B端商户、客服、运营等的需求，我们分别通过用户ID和商户ID进行切分，并通过PUMA（我们内部开发的MySQL binlog实时解析服务）同步到一个运营库。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/8aff3f22.png" alt="image"></p>
<ul>
<li>切分策略<ul>
<li>查询切分：将ID和库的Mapping关系记录在一个单独的库中。优点：ID和库的Mapping算法可以随意更改。缺点：引入额外的单点。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/ddb1ceb8.png" alt="image"></li>
<li>范围切分：比如按照时间区间或ID区间来切分。优点：单表大小可控，天然水平扩展。缺点：无法解决集中写入瓶颈的问题。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/f80cafa2.png" alt="image"></li>
<li>Hash切分：一般采用Mod来切分，下面着重讲一下Mod的策略。数据水平切分后我们希望是一劳永逸或者是易于水平扩展的，所以推荐采用mod 2^n这种一致性Hash。以统一订单库为例，我们分库分表的方案是32*32的，即通过UserId后四位mod 32分到32个库中，同时再将UserId后四位Div 32 Mod 32将每个库分为32个表，共计分为1024张表。线上部署情况为8个集群(主从)，每个集群4个库。为什么说这种方式是易于水平扩展的呢？我们分析如下两个场景。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/52610d6d.png" alt="image"><ul>
<li>场景一：数据库性能达到瓶颈<ul>
<li>方法一：按照现有规则不变，可以直接扩展到32个数据库集群。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/b301cb95.png" alt="image"></li>
<li>方法二：如果32个集群也无法满足需求，那么将分库分表规则调整为(32<em>2^n)</em>(32⁄2^n)，可以达到最多1024个集群。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/c573941e.png" alt="image"></li>
</ul>
</li>
<li>场景二：单表容量达到瓶颈（或者1024已经无法满足你）<br>  方法：假如单表都已突破200G，200<em>1024=200T（按照现有的订单模型算了算，大概一万千亿订单，相信这一天，嗯，指日可待！），没关系，32     </em>(32 <em>2^n)，这时分库规则不变，单库里的表再进行裂变，当然，在目前订单这种规则下（用userId后四位 mod）还是有极限的，因为只有四位，所以最多拆8192个表，至于为什么只取后四位，后面会有篇幅讲到。另外一个维度是通过ShopID进行切分，规则8 </em>8和UserID比较类似，就不再赘述，需要注意的是Shop库我们仅存储了订单主表，用来满足Shop维度的查询。<br>  <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/494ebd9e.png" alt="image"></li>
</ul>
</li>
</ul>
</li>
<li><p>唯一ID方案：这个方案也很多，主流的有那么几种:</p>
<ul>
<li>利用数据库自增ID：优点：最简单。 缺点：单点风险、单机性能瓶颈。</li>
<li>利用数据库集群并设置相应的步长（Flickr方案）：优点：高可用、ID较简洁。 缺点：需要单独的数据库集群。</li>
<li>Twitter Snowflake：优点：高性能高可用、易拓展。 缺点：需要独立的集群以及ZK。</li>
<li>一大波GUID、Random算法：优点：简单。 缺点：生成ID较长，有重复几率。</li>
<li><p>我们的方案：为了减少运营成本并减少额外的风险我们排除了所有需要独立集群的方案，采用了带有业务属性的方案： &gt; 时间戳+用户标识码+随机数有下面几个好处：</p>
<ul>
<li>方便、成本低。</li>
<li>基本无重复的可能。</li>
<li>自带分库规则，这里的用户标识码即为用户ID的后四位，在查询的场景下，只需要订单号就可以匹配到相应的库表而无需用户ID，只取四位是希望订单号尽可能的短一些，并且评估下来四位已经足够。</li>
<li>可排序，因为时间戳在最前面。</li>
</ul>
<p>当然也有一些缺点，比如长度稍长，性能要比int/bigint的稍差等。</p>
</li>
</ul>
</li>
<li>其他问题<ul>
<li>事务支持：我们是将整个订单领域聚合体切分，维度一致，所以对聚合体的事务是支持的。</li>
<li>复杂查询：垂直切分后，就跟join说拜拜了；水平切分后，查询的条件一定要在切分的维度内，比如查询具体某个用户下的各位订单等；禁止不带切分的维度的查询，即使中间件可以支持这种查询，可以在内存中组装，但是这种需求往往不应该在</li>
<li>在线库查询，或者可以通过其他方法转换到切分的维度来实现。</li>
</ul>
</li>
<li><p>数据迁移</p>
<p>  数据库拆分一般是业务发展到一定规模后的优化和重构，为了支持业务快速上线，很难一开始就分库分表，垂直拆分还好办，改改数据源就搞定了，一旦开始水平拆分，数据清洗就是个大问题，为此，我们经历了以下几个阶段。</p>
<ul>
<li>第一阶段<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2ae1ba98.png" alt="image"><ul>
<li>数据库双写（事务成功以老模型为准），查询走老模型。</li>
<li>每日job数据对账（通过DW），并将差异补平。</li>
<li>通过job导历史数据。</li>
</ul>
</li>
<li>第二阶段<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0a93304e.png" alt="image"><ul>
<li>历史数据导入完毕并且数据对账无误。</li>
<li>依然是数据库双写，但是事务成功与否以新模型为准，在线查询切新模型。</li>
<li>每日job数据对账，将差异补平。</li>
</ul>
</li>
<li>第三阶段<br>  <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/a8d54b30.png" alt="image"><ul>
<li>老模型不再同步写入，仅当订单有终态时才会异步补上。</li>
<li>此阶段只有离线数据依然依赖老的模型，并且下游的依赖非常多，待DW改造完就可以完全废除老模型了。</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<p>  并非所有表都需要水平拆分，要看增长的类型和速度，水平拆分是大招，拆分后会增加开发的复杂度，不到万不得已不使用。在大规模并发的业务上，尽量做到在线查询和离线查询隔离，交易查询和运营/客服查询隔离。拆分维度的选择很重要，要尽可能在解决拆分前问题的基础上，便于开发。数据库没你想象的那么坚强，需要保护，尽量使用简单的、良好索引的查询，这样数据库整体可控，也易于长期容量规划以及水平扩展。</p>
</li>
</ul>
<h4 id="亿级数据下的分库分表方案"><a href="#亿级数据下的分库分表方案" class="headerlink" title="亿级数据下的分库分表方案"></a>亿级数据下的分库分表方案</h4><pre><code>- 分区
    分区表是由多个相关的底层表实现，这些底层表也是由句柄对象表示，所以我们也可以直接访问各个分区，存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），分区表的索引只是在各个底层表上各自加上一个相同的索引，从存储引擎的角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。这个方案也不错，它对用户屏蔽了sharding的细节，即使查询条件没有sharding column，它也能正常工作（只是这时候性能一般）。不过它的缺点很明显：很多的资源都受到单机的限制，例如连接数，网络吞吐等。如何进行分区，在实际应用中是一个非常关键的要素之一。在我们的项目中，以客户信息为例，客户数据量5000万加，项目背景要求保存客户的银行卡绑定关系，客户的证件绑定关系，以及客户绑定的业务信息。此业务背景下，该如何设计数据库呢。项目一期的时候，我们建立了一张客户业务绑定关系表，里面冗余了每一位客户绑定的业务信息。基本结构大致如下：
    ![](https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1086caaj20fa06m761.jpg)
    查询时，对银行卡做索引，业务编号做索引，证件号做索引。随着需求大增多，这张表的索引会达到10个以上。而且客户解约再签约，里面会保存两条数据，只是绑定的状态不同。假设我们有5千万的客户，5个业务类型，每位客户平均2张卡，那么这张表的数据量将会达到惊人的5亿，事实上我们系统用户量还没有过百万时就已经不行了。mysql数据库中的数据是以文件的形势存在磁盘上的，默认放在/mysql/data下面（可以通过my.cnf中的datadir来查看）， 一张表主要对应着三个文件，一个是frm存放表结构的，一个是myd存放表数据的，一个是myi存表索引的。这三个文件都非常的庞大，尤其是.myd文件，快5个G了。 下面进行第一次分区优化 ，Mysql支持的分区方式有四种：
    ![](https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e11m0q1wj20fa066tbt.jpg)
    在我们的项目中，range分区和list分区没有使用场景，如果基于绑定编号做range或者list分区，绑定编号没有实际的业务含义，无法通过它进行查询，因此，我们就剩下 HASH 分区和 KEY 分区了， HASH 分区仅支持int类型列的分区，且是其中的一列。看看我们的库表结构，发现没有哪一列是int类型的，如何做分区呢？可以增加一列，绑定时间列，将此列设置为int类型，然后按照绑定时间进行分区，将每一天绑定的用户分到同一个区里面去。这次优化之后，我们的插入快了许多，但是查询依然很慢，为什么，因为在做查询的时候，我们也只是根据银行卡或者证件号进行查询，并没有根据时间查询，相当于每次查询，mysql都会将所有的分区表查询一遍。

    然后进行第二次方案优化，既然hash分区和key分区要求其中的一列必须是int类型的，那么创造出一个int类型的列出来分区是否可以。分析发现，银行卡的那串数字有秘密。银行卡一般是16位到19位不等的数字串，我们取其中的某一位拿出来作为表分区是否可行呢，通过分析发现，在这串数字中，其中确实有一位是0到9随机生成的，不同的卡串长度，这一位不同，绝不是最后一位，最后位数字一般都是校验位，不具有随机性。我们新设计的方案，基于银行卡号+随机位进行KEY分区，每次查询的时候，通过计算截取出这位随机位数字，再加上卡号，联合查询，达到了分区查询的目的，需要说明的是，分区后，建立的索引，也必须是分区列，否则的话，Mysql还是会在所有的分区表中查询数据。那么通过银行卡号查询绑定关系的问题解决了，那么证件号呢，如何通过证件号来查询绑定关系。前面已经讲过，做索引一定是要在分区健上进行，否则会引起全表扫描。我们再创建了一张新表，保存客户的证件号绑定关系，每位客户的证件号都是唯一的，新的证件号绑定关系表里，证件号作为了主键，那么如何来计算这个分区健呢，客户的证件信息比较庞杂，有身份证号，港澳台通行证，机动车驾驶证等等，如何在无序的证件号里找到分区健。为了解决这个问题，我们将证件号绑定关系表一分为二，其中的一张表专用于保存身份证类型的证件号，另一张表则保存其他证件类型的证件号，在身份证类型的证件绑定关系表中，我们将身份证号中的月数拆分出来作为了分区健，将同一个月出生的客户证件号保存在同一个区，这样分成了12个区，其他证件类型的证件号，数据量不超过10万，就没有必要进行分区了。这样每次查询时，首先通过证件类型确定要去查询哪张表，再计算分区健进行查询。

    作了分区设计之后，保存2000万用户数据的时候，银行卡表的数据保存文件就分成了10个小文件，证件表的数据保存文件分成了12个小文件，解决了这两个查询的问题，还剩下一个问题就是，业务编号呢，怎么办，一个客户有多个签约业务，如何进行保存，这时候，采用分区的方案就不太合适了，它需要用到分表的方案。
- 分库分表

    如何进行分库分表，目前互联网上有许多的版本，比较知名的一些方案：
    - 阿里的TDDL，DRDS和cobar
    - 京东金融的sharding-jdbc
    - 民间组织的MyCAT
    - 360的Atlas
    - 美团的zebra
    - 其他比如网易，58，京东等公司都有自研的中间件。

    ![](https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0f0ubx3knj20oc0fd45s.jpg)

    百花齐放的景象。但是这么多的分库分表中间件方案，归总起来，就两类： client模式和proxy模式 。

    - client模式
    ![](https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1osp6e3j20fa0c2ta5.jpg)
    - 和proxy模式
    ![](https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1v26i8nj20fa0gxmyt.jpg)

    无论是client模式，还是proxy模式，几个核心的步骤是一样的：SQL解析，重写，路由，执行，结果归并。个人比较倾向于采用client模式，它架构简单，性能损耗也比较小，运维成本低。如果在项目中引入mycat或者cobar，他们的单机模式无法保证可靠性，一旦宕机则服务就变得不可用，你又不得不引入HAProxy来实现它的高可用集群部署方案， 为了解决HAProxy的高可用问题，又需要采用Keepalived来实现。

    ![](https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e2eu3bjvj20fa0gy0zk.jpg)

    我们在项目中放弃了这个方案，采用了shardingjdbc的方式。回到刚才的业务问题，如何对业务类型进行分库分表。分库分表第一步也是最重要的一步，即sharding column的选取，sharding column选择的好坏将直接决定整个分库分表方案最终是否成功。而sharding column的选取跟业务强相关。在我们的项目场景中，sharding column无疑最好的选择是业务编号。通过业务编号，将客户不同的绑定签约业务保存到不同的表里面去，查询时，根据业务编号路由到相应的表中进行查询，达到进一步优化sql的目的。

    前面我们讲到了基于客户签约绑定业务场景的数据库优化，下面我们再聊一聊，对于海量数据的保存方案。

- 垂直拆分
    - 垂直分表

    也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。

    - 垂直分库

    垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。如下图：
    ![](https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ezns2ifaj20bf08kgml.jpg)

    优点

    数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于 Web 和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破 IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。

    缺点

    - 跨库 join 的问题
    - 跨库事务（分布式事务）的问题

    解决方式

    - 全局表
        - 所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库 join 查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。
    - 字段冗余
        - 这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免 join 查询。
    - 数据同步
        - 定时 A 库中的 tab_a 表和 B 库中 tbl_b 有关联，可以定时将指定的表做同步。当然，同步本来会对数据库带来一定的影响，需要性能影响和数据时效性中取得一个平衡。这样来避免复杂的跨库查询。例如ETL工具。
    - 系统层组装
        - 在系统层面，通过调用不同模块的组件或者服务，获取到数据并进行字段拼装。说起来很容易，但实践起来可真没有这么简单，尤其是数据库设计上存在问题但又无法轻易调整的时候。

    对于每分钟要处理近1000万的流水，每天流水近1亿的量，如何高效的写入和查询，是一项比较大的挑战。还是老办法，分库分表分区，读写分离，只不过这一次，我们先分表，再分库，最后分区。我们将消息流水按照不同的业务类型进行分表，相同业务的消息流水进入同一张表，分表完成之后，再进行分库。我们将流水相关的数据单独保存到一个库里面去，这些数据，写入要求高，查询和更新到要求低，将它们和那些更新频繁的数据区分开。分库之后，再进行分区。

    ![](https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e30hgeqaj20fa06c75g.jpg)

    这是基于业务垂直度进行的分库操作，垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库，以达到系统资源的饱和利用率。这样的分库方案结合应用的微服务治理，每个微服务系统使用独立的一个数据库。将不同模块的数据分库存储，模块间不能进行相互关联查询，如果有，要么通过数据冗余解决，要么通过应用代码进行二次加工进行解决。若不能杜绝跨库关联查询，则将小表到数据冗余到大数据量大库里去。假如，流水大表中查询需要关联获得渠道信息，渠道信息在基础管理库里面，那么，要么在查询时，代码里二次查询基础管理库中的渠道信息表，要么将渠道信息表冗余到流水大表中。

    将每天过亿的流水数据分离出去之后，流水库中单表的数据量还是太庞大，我们将单张流水表继续分区，按照一定的业务规则，（一般是查询索引列）将单表进行分区，一个表编程N个表，当然这些变化对应用层是无法感知的。

    ![](https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e5r0z2zoj20fa0lgjw2.jpg)

    分区表的设置，一般是以查询索引列进行分区，例如，对于流水表A，查询需要根据手机号和批次号进行查询，所以我们在创建分区的时候，就选择以手机号和批次号进行分区，这样设置后，查询都会走索引，每次查询Mysql都会根据查询条件计算出来，数据会落在那个分区里面，直接到对应的分区表中检索即可，避免了全表扫描。

    对于每天流水过亿的数据，当然是要做历史表进行数据迁移的工作了。客户要求流水数据需要保存半年的时间，有的关键流水需要保存一年。删数据是不可能的了，也跑不了路，虽然当时非常有想删数据跑路的冲动。其实即时是删数据也是不太可能的了，delete的拙劣表演先淘汰了，truncate也快不了多少，我们采用了一种比较巧妙方法，具体步骤如下：

    - 创建一个原表一模一样的临时表1 ``create table test_a_serial_1 like test_a_serial``;
    - 将原表命名为临时表2 ``alter table test_a_serial rename test_a_serial_{date}``;
    - 将临时表1改为原表 ``alter table able test_a_serial_1 rename able test_a_serial``; 此时，当日流水表就是一张新的空表了，继续保存当日的流水，而临时表2则保存的是昨天的数据和部分今天的数据，临时表2到名字中的date时间是通过计算获得的昨日的日期；每天会产生一张带有昨日日期的临时表2，每个表内的数据大约是有1000万。
    - 将当日表中的历史数据迁移到昨日流水表中去 这样的操作都是用的定时任务进行处理，定时任务触发一般会选择凌晨12点以后，这个操作即时是几秒内完成，也有可能会有几条数据落入到当日表中去。因此我们最后还需要将当日表内的历史流水数据插入到昨日表内； ``insert into test_a_serial_{date}(cloumn1,cloumn2….) select(cloumn1,cloumn2….) from test_a_serial where LEFT(create_time,8) &gt; CONCAT(date); commit``;

    如此，便完成了流水数据的迁移；
    根据业务需要，有些业务数据需要保存半年，超过半年的进行删除,在进行删除的时候，就可以根据表名中的_{date}筛选出大于半年的流水直接删表；

    半年的时间，对于一个业务流水表大约就会有180多张表，每张表又有20个分区表，那么如何进实时计算统计行查询呢？由于我们的项目对于流水的查询实时性要求不是特别高，因此我们在做查询时，进行了根据查询时间区间段进行路由查询的做法。大致做法时，根据客户选择的时间区间段，带上查询条件，分别去时间区间段内的每一张表内查询，将查询结果保存到一张临时表内，然后，再去查询临时表获得最终的查询结果。

    半年的时间，对于一个业务流水表大约就会有180多张表，每张表又有20个分区表，那么如何进行查询呢？由于我们的项目对于流水的查询实时性要求不是特别高，因此我们在做查询时，进行了根据查询时间区间段进行路由查询的做法。大致做法时，根据客户选择的时间区间段，带上查询条件，分别去时间区间段内的每一张表内查询，将查询结果保存到一张临时表内，然后，再去查询临时表获得最终的查询结果。

    以上便是我们面对大数据量的场景下，数据库层面做的相应的优化，一张每天一亿的表，经过拆分后，每个表分区内的数据在500万左右。
- 水平拆分
    - 水平分表

        针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用。

        ![](https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ezurxr0cj20bk07hwhl.jpg)

        某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破 IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。

    - 水平分库分表

        将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。

    - 水平分库分表切分规则
        - RANGE
            - 从0到10000一个表，10001到20000一个表；
        - HASH取模
            - 一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 取用户id，然后hash取模，分配到不同的数据库上。
        - 地理区域
            - 比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。
        - 时间
            - 按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。
</code></pre><h3 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h3><p>一致性哈希（Consistent hashing）算法是由 MIT 的Karger 等人与1997年在一篇学术论文（《Consistent hashing and random trees: distributed caching protocols for relieving hot spots on the World Wide Web》）中提出来的，用于解决分布式缓存数据分布问题。在传统的哈希算法下，每条缓存数据落在那个节点是通过哈希算法和服务器节点数量计算出来的，一旦服务器节点数量发生增加或者介绍，哈希值需要重新计算，此时几乎所有的数据和服务器节点的对应关系也会随之发生变化，进而会造成绝大多数缓存的失效。一致性哈希算法通过环形结构和虚拟节点的概念，确保了在缓存服务器节点数量发生变化时大部分数据保持原地不动，从而大幅提高了缓存的有效性。下面我们通过例子来解释一致性哈希的原理。</p>
<p>比如有 n 个节点，对于缓存 数据（k，v）具体存在哪个节点往往 hash(k) % n 来计算处理，举一个例子如下表所示，一共有个3个节点，hash函数采用 md5 。</p>
<table>
<thead>
<tr>
<th>缓存key</th>
<th>hash(k) % n</th>
<th>服务器节点</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_nick_rommel</td>
<td>1</td>
<td>192.168.56.101</td>
</tr>
<tr>
<td>user_nick_pandy</td>
<td>0</td>
<td>192.168.56.100</td>
</tr>
<tr>
<td>user_nick_sam</td>
<td>2</td>
<td>192.168.56.102</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Md5 的计算结果一般是一串32位的16进制字符串，做取模运算时原始数字较长，实际使用时，可以只截取最后4位或者8位使用，因为hash函数具有随机性，当数据量足球大时，截取部分数据也能保证数据的均匀分布。比如 md5(‘user_nick_rommel’)，对应字符串为 29e4fd2a0f05bd63343ae2276ca5038e，取最后4位 038e 转成10进制整数在进行取模运算，038e 对应的10进制数为 910，取模计算得 1 (9102 % 3 = 1)。</p>
</blockquote>
<p> 如果此时对缓存服务器进行扩容，添加一个新节点如 192.168.56.103，那么按照上面的计算方式，n 变为4， 得到的结果如下：</p>
<table>
<thead>
<tr>
<th>缓存key</th>
<th>hash(k) % n</th>
<th>服务器节点</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_nick_rommel</td>
<td>2</td>
<td>192.168.56.102</td>
</tr>
<tr>
<td>user_nick_pandy</td>
<td>2</td>
<td>192.168.56.102</td>
</tr>
<tr>
<td>user_nick_sam</td>
<td>3</td>
<td>192.168.56.103</td>
</tr>
</tbody>
</table>
<p>从结果中可见，缓存对应关系完全发生改变，比如 user_nick_rommel 这个可以，添加节点钱可以从 192.168.56.101 中读到，添加节点后却读不到了，。一般缓存失效时应用程序都会重新从后端服务加载数据（比如数据库），以这种这种方式分配缓存，当缓节点数量发生改变时，会造成大面积的缓存失效，这回造成后端服务瞬间压力上升，压力过大会造成服务不可以用，如果服务出于关键节点，甚至还会引发雪崩效应（TODO）。</p>
<p>在实际应用中，缓存节点由于故障挂掉，或者空间不足而进行扩容，缓存节点的增减是比较常见的事情，但上面传统方式会使服务的不可靠，下面看下一致性哈希是如何解决这个问题的。</p>
<p>在一致性哈希算法中，首先将哈希空间映射到一个虚拟的环上，环上的数值分从 0 到 2^32-1（哈希值的范围），如下图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/D2CFEC7D-5ACB-49C3-B67F-12BA52254454.png" alt="image"></p>
<blockquote>
<p>在一致性哈希算法刚提出来的时候，32位系统还是主流，2^32-1 相当于最大Integer，现在的应用服务器普遍都是64位系统，在使用使用一致性哈希算法时可以根据实际情况适当变通，比如将哈希值空间放大到 2^64-1。</p>
</blockquote>
<p> 然后使用同样的哈希算法将缓存服务节点（通常通过服务器IP+端口作为节点的key）和数据键映射到环上的位置。再决定数据落在那台服务器上时，使用一致的方向（比如顺时针方向）沿环查找，遇到的第一个有效服务器就是缓存保存的地方，如图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/7D4C84D6-8843-42FC-AAB4-C5D5EA308C1B.png" alt="image"></p>
<p>当有新的服务器节点加入时，按照同样的哈希算法将新节点映射到环上的某处位置，和新节点相邻的数据逆时针节点会进行迁移，其他节点保持不变。如下图，当新加入一台新服务器 192.168.56.104 时，user_nick_pandy 这条缓存数据的请求根据算法会落在192.168.56.104 这台及其上，其他节点不受任何影响。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/A026DF6E-060A-4295-83CB-FC4A7D229A03.png" alt="image"></p>
<p>另外，由于哈希计算的记过通常都比较随机，如果缓存服务器比较少的话，可能会出现数据分配冷热不均的问题，如下图所示，大部分数据都会存储在 node3 节点上。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/26145228-2DA8-4168-BBE9-DA99F4BD0016.png" alt="image"></p>
<p>为了解决这个问题，我们引入虚拟节点的概念，在实体服务器不增加的情况下，用多个虚拟节点替代原来的单个实体节点，一台服务服务器在环上就对应多个位置，这样可以让数据存储更加均匀，各服务器的负载页更加平衡，如图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9B7CB81A-434E-4C33-B65E-3821C19E3B70.png" alt="image"></p>
<p>使用 Java 代码实现一致性哈希的例子如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.SortedMap;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.DigestUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class ConsistentHashingTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真实缓存地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">String</span>[] cacheServers = &#123; <span class="string">"192.168.56.101:11211"</span>, <span class="string">"192.168.56.102:11211"</span>, <span class="string">"192.168.56.103:11211"</span> &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 保存虚拟节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Long, <span class="keyword">String</span>&gt; nodes = <span class="keyword">new</span> TreeMap&lt;Long, <span class="keyword">String</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个虚拟节点的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="built_in">int</span> VIRTUAL_NODE_NUM = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConsistentHashingTest()&#123;</span><br><span class="line">       <span class="comment">//初始化</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">String</span> eachServer : cacheServers) &#123;</span><br><span class="line">           <span class="keyword">this</span>.addNode(eachServer);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建虚拟节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> addNode(<span class="keyword">String</span> nodeKey) &#123;</span><br><span class="line">       <span class="comment">//为每一个实体节点创建3个虚拟节点</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_NUM; i++) &#123;</span><br><span class="line">           <span class="keyword">long</span> eachHashCode = <span class="keyword">this</span>.hash(nodeKey + <span class="string">":"</span> + i);</span><br><span class="line">           nodes.put(eachHashCode, nodeKey);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hash 函数 可以使用 md5, sha-1, sha-256 等</span></span><br><span class="line">    <span class="comment">// 虽然 md5, sha-1 哈希算法在签名领域已经不再安全，但运算速度比较快，在非安全领域是可以使用的。</span></span><br><span class="line">    <span class="comment">// DigestUtils 是来自于 apache 中的 org.apache.commons.codec.digest 中的工具类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> hash(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">       Stringmd5key = DigestUtils.md5Hex(<span class="built_in">key</span>);</span><br><span class="line">       <span class="keyword">return</span> Long.parseLong(md5key.substring(<span class="number">0</span>, <span class="number">15</span>), <span class="number">16</span>) % ((<span class="keyword">long</span>) Math.<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">32</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照同一个方向寻找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> getRealServer(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">       <span class="keyword">long</span> hashCode = <span class="keyword">this</span>.hash(<span class="built_in">key</span>);</span><br><span class="line">       SortedMap&lt;Long,<span class="keyword">String</span>&gt; tailMap =</span><br><span class="line">              nodes.tailMap(hashCode);</span><br><span class="line">       <span class="keyword">long</span> serverKey = tailMap.isEmpty() ? nodes.firstKey() : tailMap.firstKey(); </span><br><span class="line">       <span class="keyword">return</span> nodes.<span class="built_in">get</span>(serverKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">       ConsistentHashingTestt = <span class="keyword">new</span> ConsistentHashingTest();</span><br><span class="line">       System.out.<span class="built_in">println</span>(t.getRealServer(<span class="string">"my-cache-key"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，前文提到的（TODO 章节）Guava Cache 框架支持一致性哈希，实例代码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体缓存服务器</span></span><br><span class="line"><span class="keyword">String</span>[]cacheServers = &#123; <span class="string">"192.168.56.101:11211"</span>, <span class="string">"192.168.56.102:11211"</span>, <span class="string">"192.168.56.103:11211"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存数据的key</span></span><br><span class="line"><span class="keyword">String</span> <span class="built_in">key</span> = <span class="string">"my-test-cache-key"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算缓存 key 对应的 hash 值，这里使用 MurmurHash 算法，MurmurHash 是一种高性能低碰撞的算法。此外，还支持  md5、sha1/sha256/sha512、orc32、adler32 等哈希算法。 </span></span><br><span class="line">HashCode hashCode = Hashing.murmur3_32().newHasher().putString(<span class="built_in">key</span>, Charsets.UTF_8).hash();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一致性哈希方式计算，缓存key对应的服务器主机是那一台，bucket 的范围在 0 ~ cacheServers.length -1</span></span><br><span class="line"><span class="built_in">int</span> bucket = Hashing.consistentHash(hashCode, cacheServers.length);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/D2CFEC7D-5ACB-49C3-B67F-12BA52254454.png" alt="image"></p>
<h3 id="多路复用的几种方式以及区别？"><a href="#多路复用的几种方式以及区别？" class="headerlink" title="多路复用的几种方式以及区别？"></a>多路复用的几种方式以及区别？</h3><ul>
<li>select的优缺点<ul>
<li>优点<ul>
<li>select的可移植性好，在某些unix下不支持poll。</li>
<li>select对超时值提供了很好的精度，精确到微秒，而poll式毫秒。</li>
</ul>
</li>
<li>缺点<ul>
<li>单个进程可监视的fd数量被限制，默认是1024。</li>
<li>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li>
<li>对fd进行扫描时是线性扫描，fd剧增后，IO效率降低，每次调用都对fd进行线性扫描遍历，随着fd的增加会造成遍历速度慢的问题。</li>
<li>select函数超时参数在返回时也是未定义的，考虑到可移植性，每次超时之后进入下一个select之前都要重新设置超时参数。</li>
</ul>
</li>
</ul>
</li>
<li>poll的优缺点<ul>
<li>优点<ul>
<li>不要求计算最大文件描述符+1的大小。</li>
<li>应付大数量的文件描述符时比select要快。</li>
<li>没有最大连接数的限制是基于链表存储的。</li>
</ul>
</li>
<li>缺点<ul>
<li>大量的fd数组被整体复制于内核态和用户态之间，而不管这样的复制是不是有意义。</li>
<li>同select相同的是调用结束后需要轮询来获取就绪描述符。</li>
</ul>
</li>
</ul>
</li>
<li><p>epoll的优缺点（epoll详解）</p>
<ul>
<li><p>支持一个进程打开大数目的socket描述符(FD)</p>
<p>  select 最不能忍受的是一个进程所打开的FD是有一定限制的，由FD_SETSIZE设置，默认值是2048。对于那些需要支持的上万连接数目的IM服务器来说显 然太少了。这时候你一是可以选择修改这个宏然后重新编译内核，不过资料也同时指出这样会带来网络效率的下降，二是可以选择多进程的解决方案(传统的 Apache方案)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完 美的方案。不过 epoll则没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</p>
</li>
<li><p>IO效率不随FD数目增加而线性下降</p>
<p>  传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是”活跃”的， 但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对”活跃”的socket进行 操作—这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有”活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个”伪”AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的—比如一个高速LAN环境，epoll并不比select/poll有什么效率，相 反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。</p>
</li>
<li><p>epoll工作的两种模式</p>
<p>  EPOLL事件分发系统可以运转在两种模式下：边缘触发Edge Triggered (ET)、水平触发Level Triggered (LT)。<br>  LT 是缺省的工作方式：同时支持block和no-block socket；在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。<br>  ET是高速工作方式：它只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述 符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知。<br>  对于LT模式<code>epoll_wait</code>清空就绪链表之后会检查该文件描述符是哪一种模式，如果为LT模式，且必须该节点确实有事件未处理，那么就会把该节点重新放入到刚刚删除掉的且刚准备好的就绪链表，<code>epoll_wait</code>马上返回。而ET模式不会检查，只会调用一次，只通知就绪通知一次 。 </p>
</li>
<li>epoll函数底层实现过程<br>  首先<code>epoll_create</code>创建一个epoll文件描述符，底层同时创建一个红黑树，和一个就绪链表；红黑树存储所监控的文件描述符的节点数据，就绪链表存储就绪的文件描述符的节点数据；<code>epoll_ctl</code>将会添加新的描述符，首先判断是红黑树上是否有此文件描述符节点，如果有，则立即返回。如果没有， 则在树干上插入新的节点，并且告知内核注册回调函数。当接收到某个文件描述符过来数据时，那么内核将该节点插入到就绪链表里面。<code>epoll_wait</code>将会接收到消息，并且将数据拷贝到用户空间，清空链表。对于LT模式<code>epoll_ctl</code>清空就绪链表之后会检查该文件描述符是哪一种模式，如果为LT模式，且必须该节点确实有事件未处理，那么就会把该节点重新放入到刚刚删除掉的且刚准备好的就绪链表，<code>epoll_wait</code>马上返回。ET模式不会检查，只会调用一次</li>
</ul>
</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="怎么理解命令模式和观察者模式，手写一个观察者模式或者命令模式的代码，策略模式也行"><a href="#怎么理解命令模式和观察者模式，手写一个观察者模式或者命令模式的代码，策略模式也行" class="headerlink" title="怎么理解命令模式和观察者模式，手写一个观察者模式或者命令模式的代码，策略模式也行"></a>怎么理解命令模式和观察者模式，手写一个观察者模式或者命令模式的代码，策略模式也行</h3><ul>
<li><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
<ul>
<li>意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</li>
<li>主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</li>
<li>何时使用：在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</li>
<li>如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。</li>
<li>应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</li>
<li>优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。</li>
<li>缺点：使用命令模式可能会导致某些系统有过多的具体命令类。</li>
<li>使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。</li>
<li>注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</li>
<li>我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。Broker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo，我们的演示类使用 Broker 类来演示命令模式。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/command_pattern_uml_diagram.jpg" alt="image"><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> Order &#123;</span><br><span class="line">   <span class="keyword">void</span> execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Stock &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name = <span class="string">"ABC"</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> quantity = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> buy()&#123;</span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">"Stock [ Name: "</span>+name+<span class="string">", </span></span><br><span class="line"><span class="string">         Quantity: "</span> + quantity +<span class="string">" ] bought"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> sell()&#123;</span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">"Stock [ Name: "</span>+name+<span class="string">", </span></span><br><span class="line"><span class="string">         Quantity: "</span> + quantity +<span class="string">" ] sold"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> BuyStock implements Order &#123;</span><br><span class="line">   <span class="keyword">private</span> Stock abcStock;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> BuyStock(Stock abcStock)&#123;</span><br><span class="line">      <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> execute() &#123;</span><br><span class="line">      abcStock.buy();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> SellStock implements Order &#123;</span><br><span class="line">   <span class="keyword">private</span> Stock abcStock;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> SellStock(Stock abcStock)&#123;</span><br><span class="line">      <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> execute() &#123;</span><br><span class="line">      abcStock.sell();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Broker &#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Order&gt; orderList = <span class="keyword">new</span> ArrayList&lt;Order&gt;(); </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> takeOrder(Order order)&#123;</span><br><span class="line">      orderList.add(order);      </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> placeOrders()&#123;</span><br><span class="line">      <span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">         order.execute();</span><br><span class="line">      &#125;</span><br><span class="line">      orderList.clear();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> CommandPatternDemo &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">      Stock abcStock = <span class="keyword">new</span> Stock();</span><br><span class="line"> </span><br><span class="line">      BuyStock buyStockOrder = <span class="keyword">new</span> BuyStock(abcStock);</span><br><span class="line">      SellStock sellStockOrder = <span class="keyword">new</span> SellStock(abcStock);</span><br><span class="line"> </span><br><span class="line">      Broker broker = <span class="keyword">new</span> Broker();</span><br><span class="line">      broker.takeOrder(buyStockOrder);</span><br><span class="line">      broker.takeOrder(sellStockOrder);</span><br><span class="line"> </span><br><span class="line">      broker.placeOrders();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock [ Name: ABC, Quantity: <span class="number">10</span> ] bought</span><br><span class="line">Stock [ Name: ABC, Quantity: <span class="number">10</span> ] sold</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>观察者模式，当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。</p>
<ul>
<li>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li>
<li>主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</li>
<li>何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</li>
<li>如何解决：使用面向对象技术，可以将这种依赖关系弱化。</li>
<li>关键代码：在抽象类里有一个 ArrayList 存放观察者们。</li>
<li>应用实例：1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</li>
<li>优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</li>
<li>缺点：1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
<li>使用场景：1、一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。2、一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。3、一个对象必须通知其他对象，而并不知道这些对象是谁。4、需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
<li>实现：观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。ObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/observer_pattern_uml_diagram.jpg" alt="image"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> List&lt;Observer&gt; observers </span><br><span class="line">      = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">      notifyAllObservers();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">      observers.add(observer);      </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">         observer.update();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> Subject subject;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"Binary String: "</span> </span><br><span class="line">      + Integer.toBinaryString( subject.getState() ) ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">OctalObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println( <span class="string">"Octal String: "</span> </span><br><span class="line">     + Integer.toOctalString( subject.getState() ) ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HexaObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"Hex String: "</span> </span><br><span class="line">      + Integer.toHexString( subject.getState() ).toUpperCase() ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">new</span> HexaObserver(subject);</span><br><span class="line">      <span class="keyword">new</span> OctalObserver(subject);</span><br><span class="line">      <span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">"First state change: 15"</span>);   </span><br><span class="line">      subject.setState(<span class="number">15</span>);</span><br><span class="line">      System.out.println(<span class="string">"Second state change: 10"</span>);  </span><br><span class="line">      subject.setState(<span class="number">10</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>策略模式:在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p>
<ul>
<li>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</li>
<li>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</li>
<li>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。</li>
<li>如何解决：将这些算法封装成一个一个的类，任意地替换。</li>
<li>应用实例：1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT中的LayoutManager。</li>
<li>优点： 1、算法可以自由切换。2、避免使用多重条件判断。3、扩展性良好。</li>
<li>缺点：1、策略类会增多。2、所有策略类都需要对外暴露。</li>
<li>使用场景：1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。2、一个系统需要动态地在几种算法中选择一种。3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
<li>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</li>
<li>实现:我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/strategy_pattern_uml_diagram.jpg" alt="image"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 - num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 * num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());    </span><br><span class="line">      System.out.println(<span class="string">"10 + 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());      </span><br><span class="line">      System.out.println(<span class="string">"10 - 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());    </span><br><span class="line">      System.out.println(<span class="string">"10 * 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="设计模式在项目中哪个地方用到了，怎么使用的，能不能画一个你熟悉的设计模式的UML图，手写单例模式，手写静态内部类实现的单例模式。"><a href="#设计模式在项目中哪个地方用到了，怎么使用的，能不能画一个你熟悉的设计模式的UML图，手写单例模式，手写静态内部类实现的单例模式。" class="headerlink" title="设计模式在项目中哪个地方用到了，怎么使用的，能不能画一个你熟悉的设计模式的UML图，手写单例模式，手写静态内部类实现的单例模式。"></a>设计模式在项目中哪个地方用到了，怎么使用的，能不能画一个你熟悉的设计模式的UML图，手写单例模式，手写静态内部类实现的单例模式。</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式"><a href="#掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式" class="headerlink" title="掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式"></a>掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式</h3><ul>
<li>设计模式：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式、适配器模式、桥接模式、过滤器模式、组合模式、装饰器模式、外观模式、享元模式、代理模式、责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、空对象模式、策略模式、模板模式、访问者模式、MVC模式、业务代表模式、组合实体模式、数据访问对象模式、前端控制器模式、拦截过滤器模式、服务定位器模式、传输对象模式。</li>
<li>线程安全的单例模式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="JAVA相关"><a href="#JAVA相关" class="headerlink" title="JAVA相关"></a>JAVA相关</h2><h3 id="ArrayList和LinkList有什么区别"><a href="#ArrayList和LinkList有什么区别" class="headerlink" title="ArrayList和LinkList有什么区别"></a>ArrayList和LinkList有什么区别</h3><ul>
<li>ArrayList是数组实现的集合操作，而LinkedList是链表实现的集合操作,（LinkedList是双向链表，有next也有previous）。</li>
<li>只是用List集合中的get()方法根据索引取数据的时候，ArrayList的时间复杂度为“O(1)”,而LinkedList的时间复杂度为“O(n)”(n为集合的长度)，因为LinkedList要移动指针。 </li>
<li>ArrayList在使用的时候默认的初始化数组的长度为10，如果空间不足则会采用2倍的形式进行容量的扩充，如果保存大数据的时候有可能造成垃圾的产生以及性能的下降，这个时候就可以用LinkedList子类保存。对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</li>
</ul>
<h3 id="JDK动态代理与CGLib动态代理的区别"><a href="#JDK动态代理与CGLib动态代理的区别" class="headerlink" title="JDK动态代理与CGLib动态代理的区别"></a>JDK动态代理与CGLib动态代理的区别</h3><ul>
<li>区别<ul>
<li>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</li>
<li>而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li>
<li>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP </li>
<li>如果目标对象实现了接口，可以强制使用CGLIB实现AOP </li>
<li>如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</li>
</ul>
</li>
<li>如何强制使用CGLIB实现AOP？<ul>
<li>添加CGLIB库，<code>SPRING_HOME/cglib/*.jar</code></li>
<li>在spring配置文件中加入<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code></li>
</ul>
</li>
<li><p>JDK动态代理和CGLIB字节码生成的区别</p>
<ul>
<li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法<br>因为是继承，所以该类或方法最好不要声明成final </li>
</ul>
</li>
<li><p>代码实现</p>
</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lf.shejimoshi.proxy.entity;</span><br><span class="line"><span class="comment">//用户管理接口</span></span><br><span class="line"><span class="keyword">public</span> interface UserManager &#123;</span><br><span class="line">    <span class="comment">//新增用户抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> addUser(<span class="keyword">String</span> userName,<span class="keyword">String</span> password);</span><br><span class="line">    <span class="comment">//删除用户抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> delUser(<span class="keyword">String</span> userName);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.lf.shejimoshi.proxy.entity;</span><br><span class="line"><span class="comment">//用户管理实现类,实现用户管理接口</span></span><br><span class="line"><span class="keyword">public</span> class UserManagerImpl implements UserManager&#123;</span><br><span class="line">    <span class="comment">//重写新增用户方法</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> addUser(<span class="keyword">String</span> userName, <span class="keyword">String</span> password) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"调用了新增的方法！"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"传入参数为 userName: "</span>+userName+<span class="string">" password: "</span>+password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写删除用户方法</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> delUser(<span class="keyword">String</span> userName) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"调用了删除的方法！"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"传入参数为 userName: "</span>+userName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK动态代理</span></span><br><span class="line"><span class="keyword">package</span> com.lf.shejimoshi.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lf.shejimoshi.proxy.entity.UserManager;</span><br><span class="line"><span class="keyword">import</span> com.lf.shejimoshi.proxy.entity.UserManagerImpl;</span><br><span class="line"><span class="comment">//JDK动态代理实现InvocationHandler接口</span></span><br><span class="line"><span class="keyword">public</span> class JdkProxy implements InvocationHandler &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> target ;<span class="comment">//需要代理的目标对象</span></span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Object</span> invoke(<span class="keyword">Object</span> proxy, Method method, <span class="keyword">Object</span>[] args) <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"JDK动态代理，监听开始！"</span>);</span><br><span class="line">        <span class="keyword">Object</span> result = method.invoke(target, args);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"JDK动态代理，监听结束！"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义获取代理对象方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> getJDKProxy(<span class="keyword">Object</span> targetObject)&#123;</span><br><span class="line">        <span class="comment">//为目标对象target赋值</span></span><br><span class="line">        <span class="keyword">this</span>.target = targetObject;</span><br><span class="line">        <span class="comment">//JDK动态代理只能针对实现了接口的类进行代理，newProxyInstance 函数所需参数就可看出</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        JdkProxy jdkProxy = <span class="keyword">new</span> JdkProxy();<span class="comment">//实例化JDKProxy对象</span></span><br><span class="line">        UserManager user = (UserManager) jdkProxy.getJDKProxy(<span class="keyword">new</span> UserManagerImpl());<span class="comment">//获取代理对象</span></span><br><span class="line">        user.addUser(<span class="string">"admin"</span>, <span class="string">"123123"</span>);<span class="comment">//执行新增方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Cglib动态代理（需要导入两个jar包，asm-5.2.jar,cglib-3.2.5.jar。版本自行选择）</span></span><br><span class="line"><span class="keyword">package</span> com.lf.shejimoshi.proxy.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lf.shejimoshi.proxy.entity.UserManager;</span><br><span class="line"><span class="keyword">import</span> com.lf.shejimoshi.proxy.entity.UserManagerImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Cglib动态代理，实现MethodInterceptor接口</span></span><br><span class="line"><span class="keyword">public</span> class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> target;<span class="comment">//需要代理的目标对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写拦截方法</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Object</span> intercept(<span class="keyword">Object</span> obj, Method method, <span class="keyword">Object</span>[] arr, MethodProxy proxy) <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Cglib动态代理，监听开始！"</span>);</span><br><span class="line">        <span class="keyword">Object</span> invoke = method.invoke(target, arr);<span class="comment">//方法执行，参数：target 目标对象 arr参数数组</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Cglib动态代理，监听结束！"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义获取代理对象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Object</span> getCglibProxy(<span class="keyword">Object</span> objectTarget)&#123;</span><br><span class="line">        <span class="comment">//为目标对象target赋值</span></span><br><span class="line">        <span class="keyword">this</span>.target = objectTarget;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置父类,因为Cglib是针对指定的类生成一个子类，所以需要指定父类</span></span><br><span class="line">        enhancer.setSuperclass(objectTarget.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);<span class="comment">// 设置回调 </span></span><br><span class="line">        <span class="keyword">Object</span> result = enhancer.create();<span class="comment">//创建并返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        CglibProxy cglib = <span class="keyword">new</span> CglibProxy();<span class="comment">//实例化CglibProxy对象</span></span><br><span class="line">        UserManager user =  (UserManager) cglib.getCglibProxy(<span class="keyword">new</span> UserManagerImpl());<span class="comment">//获取代理对象</span></span><br><span class="line">        user.delUser(<span class="string">"admin"</span>);<span class="comment">//执行删除方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java中序列化有哪些方式"><a href="#Java中序列化有哪些方式" class="headerlink" title="Java中序列化有哪些方式"></a>Java中序列化有哪些方式</h3><h4 id="Java原生序列化"><a href="#Java原生序列化" class="headerlink" title="Java原生序列化"></a>Java原生序列化</h4><p>Java原生序列化方法即通过Java原生流(InputStream和OutputStream之间的转化)的方式进行转化。需要注意的是JavaBean实体类必须实现Serializable接口，否则无法序列化。Java原生序列化代码示例如下所示：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package serialize<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">import <span class="keyword">java.io.BufferedInputStream;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.io.ByteArrayOutputStream;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.io.IOException;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.io.ObjectInputStream;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.io.ObjectOutputStream;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.util.ArrayList;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.util.List;</span></span><br><span class="line"><span class="keyword">/**</span></span><br><span class="line"><span class="keyword"> </span>* </span><br><span class="line"> * @author liqqc</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class <span class="keyword">JavaSerialize </span>&#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IOException &#123;</span><br><span class="line">        new <span class="keyword">JavaSerialize().start();</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line"></span><br><span class="line">    public void start() throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        User u = new User()<span class="comment">;</span></span><br><span class="line">        List&lt;User&gt; friends = new ArrayList&lt;&gt;()<span class="comment">;</span></span><br><span class="line">        u.setUserName(<span class="string">"张三"</span>)<span class="comment">;</span></span><br><span class="line">        u.setPassWord(<span class="string">"123456"</span>)<span class="comment">;</span></span><br><span class="line">        u.setUserInfo(<span class="string">"张三是一个很牛逼的人"</span>)<span class="comment">;</span></span><br><span class="line">        u.setFriends(friends)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        User f1 = new User()<span class="comment">;</span></span><br><span class="line">        f1.setUserName(<span class="string">"李四"</span>)<span class="comment">;</span></span><br><span class="line">        f1.setPassWord(<span class="string">"123456"</span>)<span class="comment">;</span></span><br><span class="line">        f1.setUserInfo(<span class="string">"李四是一个很牛逼的人"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        User f2 = new User()<span class="comment">;</span></span><br><span class="line">        f2.setUserName(<span class="string">"王五"</span>)<span class="comment">;</span></span><br><span class="line">        f2.setPassWord(<span class="string">"123456"</span>)<span class="comment">;</span></span><br><span class="line">        f2.setUserInfo(<span class="string">"王五是一个很牛逼的人"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        friends.<span class="keyword">add(f1);</span></span><br><span class="line"><span class="keyword"> </span>       friends.<span class="keyword">add(f2);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>       Long <span class="built_in">t1</span> = System.currentTimeMillis()<span class="comment">;</span></span><br><span class="line">        <span class="keyword">ByteArrayOutputStream </span>out = new <span class="keyword">ByteArrayOutputStream();</span></span><br><span class="line"><span class="keyword"> </span>       ObjectOutputStream obj = new ObjectOutputStream(out)<span class="comment">;</span></span><br><span class="line">        for(int i = <span class="number">0</span><span class="comment">; i&lt;10; i++) &#123;</span></span><br><span class="line">            obj.writeObject(u)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"java serialize: "</span> +(System.currentTimeMillis() - <span class="built_in">t1</span>) + <span class="string">"ms; 总大小："</span> + out.toByteArray().length )<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        Long <span class="built_in">t2</span> = System.currentTimeMillis()<span class="comment">;</span></span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new <span class="keyword">BufferedInputStream(new </span><span class="keyword">java.io.ByteArrayInputStream(out.toByteArray())));</span></span><br><span class="line"><span class="keyword"> </span>       User user = (User) ois.readObject()<span class="comment">;</span></span><br><span class="line">        System.out.println(<span class="string">"java deserialize: "</span> + (System.currentTimeMillis() - <span class="built_in">t2</span>) + <span class="string">"ms; User: "</span> + user)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Json序列化"><a href="#Json序列化" class="headerlink" title="Json序列化"></a>Json序列化</h4><p>Json序列化一般会使用jackson包，通过ObjectMapper类来进行一些操作，比如将对象转化为byte数组或者将json串转化为对象。现在的大多数公司都将json作为服务器端返回的数据格式。比如调用一个服务器接口，通常的请求为xxx.json?a=xxx&amp;b=xxx的形式。Json序列化示例代码如下所示：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package serialize<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">import <span class="keyword">java.io.IOException;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.util.ArrayList;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.util.List;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">import </span>com.fasterxml.<span class="keyword">jackson.databind.ObjectMapper;</span></span><br><span class="line"><span class="keyword">/**</span></span><br><span class="line"><span class="keyword"> </span>* </span><br><span class="line"> * @author liqqc</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class <span class="keyword">JsonSerialize </span>&#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        new <span class="keyword">JsonSerialize().start();</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line"></span><br><span class="line">    public void start() throws IOException &#123;</span><br><span class="line">        User u = new User()<span class="comment">;</span></span><br><span class="line">        List&lt;User&gt; friends = new ArrayList&lt;&gt;()<span class="comment">;</span></span><br><span class="line">        u.setUserName(<span class="string">"张三"</span>)<span class="comment">;</span></span><br><span class="line">        u.setPassWord(<span class="string">"123456"</span>)<span class="comment">;</span></span><br><span class="line">        u.setUserInfo(<span class="string">"张三是一个很牛逼的人"</span>)<span class="comment">;</span></span><br><span class="line">        u.setFriends(friends)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        User f1 = new User()<span class="comment">;</span></span><br><span class="line">        f1.setUserName(<span class="string">"李四"</span>)<span class="comment">;</span></span><br><span class="line">        f1.setPassWord(<span class="string">"123456"</span>)<span class="comment">;</span></span><br><span class="line">        f1.setUserInfo(<span class="string">"李四是一个很牛逼的人"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        User f2 = new User()<span class="comment">;</span></span><br><span class="line">        f2.setUserName(<span class="string">"王五"</span>)<span class="comment">;</span></span><br><span class="line">        f2.setPassWord(<span class="string">"123456"</span>)<span class="comment">;</span></span><br><span class="line">        f2.setUserInfo(<span class="string">"王五是一个很牛逼的人"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        friends.<span class="keyword">add(f1);</span></span><br><span class="line"><span class="keyword"> </span>       friends.<span class="keyword">add(f2);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>       ObjectMapper mapper = new ObjectMapper()<span class="comment">;</span></span><br><span class="line">        Long <span class="built_in">t1</span> = System.currentTimeMillis()<span class="comment">;</span></span><br><span class="line">        <span class="keyword">byte[] </span>writeValueAsBytes = null<span class="comment">;</span></span><br><span class="line">        for (int i = <span class="number">0</span><span class="comment">; i &lt; 10; i++) &#123;</span></span><br><span class="line">            writeValueAsBytes = mapper.writeValueAsBytes(u)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"json serialize: "</span> + (System.currentTimeMillis() - <span class="built_in">t1</span>) + <span class="string">"ms; 总大小："</span> + writeValueAsBytes.length)<span class="comment">;</span></span><br><span class="line">        Long <span class="built_in">t2</span> = System.currentTimeMillis()<span class="comment">;</span></span><br><span class="line">        User user = mapper.readValue(writeValueAsBytes, User.class)<span class="comment">;</span></span><br><span class="line">        System.out.println(<span class="string">"json deserialize: "</span> + (System.currentTimeMillis() - <span class="built_in">t2</span>) + <span class="string">"ms; User: "</span> + user)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FastJson序列化"><a href="#FastJson序列化" class="headerlink" title="FastJson序列化"></a>FastJson序列化</h4><p>fastjson 是由阿里巴巴开发的一个性能很好的Java 语言实现的 Json解析器和生成器。特点：速度快，测试表明fastjson具有极快的性能，超越任其他的java json parser。功能强大，完全支持java bean、集合、Map、日期、Enum，支持范型和自省。无依赖，能够直接运行在Java SE 5.0以上版本<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author liqqc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class FastJsonSerialize &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">new</span> FastJsonSerialize().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> start()&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        List&lt;User&gt; friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        u.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">        u.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        u.setUserInfo(<span class="string">"张三是一个很牛逼的人"</span>);</span><br><span class="line">        u.setFriends(friends);</span><br><span class="line"></span><br><span class="line">        User f1 = <span class="keyword">new</span> User();</span><br><span class="line">        f1.setUserName(<span class="string">"李四"</span>);</span><br><span class="line">        f1.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f1.setUserInfo(<span class="string">"李四是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        User f2 = <span class="keyword">new</span> User();</span><br><span class="line">        f2.setUserName(<span class="string">"王五"</span>);</span><br><span class="line">        f2.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f2.setUserInfo(<span class="string">"王五是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        friends.<span class="built_in">add</span>(f1);</span><br><span class="line">        friends.<span class="built_in">add</span>(f2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化  </span></span><br><span class="line">        Long t1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">text</span> = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">text</span> = JSON.toJSONString(u); </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"fastJson serialize: "</span> +(System.currentTimeMillis() - t1) + <span class="string">"ms; 总大小："</span> + <span class="built_in">text</span>.getBytes().length);</span><br><span class="line">        <span class="comment">//反序列化  </span></span><br><span class="line">        Long t2 = System.currentTimeMillis();</span><br><span class="line">        User user = JSON.parseObject(<span class="built_in">text</span>, User.class);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"fastJson serialize: "</span> + (System.currentTimeMillis() -t2) + <span class="string">"ms; User: "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="ProtoBuff序列化"><a href="#ProtoBuff序列化" class="headerlink" title="ProtoBuff序列化"></a>ProtoBuff序列化</h4><p>ProtocolBuffer是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化。适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p>
<ul>
<li>优点：跨语言；序列化后数据占用空间比JSON小，JSON有一定- 的格式，在数据量上还有可以压缩的空间。</li>
</ul>
<p>缺点：它以二进制的方式存储，无法直接读取编辑，除非你有 .proto 定义，否则无法直接读出 Protobuffer的任何内容。</p>
<p>其与thrift的对比：两者语法类似，都支持版本向后兼容和向前兼容，thrift侧重点是构建跨语言的可伸缩的服务，支持的语言多，同时提供了全套RPC解决方案，可以很方便的直接构建服务，不需要做太多其他的工作。 Protobuffer主要是一种序列化机制，在数据序列化上进行性能比较，Protobuffer相对较好。</p>
<p>ProtoBuff序列化对象可以很大程度上将其压缩，可以大大减少数据传输大小，提高系统性能。对于大量数据的缓存，也可以提高缓存中数据存储量。原始的ProtoBuff需要自己写.proto文件，通过编译器将其转换为java文件，显得比较繁琐。百度研发的jprotobuf框架将Google原始的protobuf进行了封装，对其进行简化，仅提供序列化和反序列化方法。其实用上也比较简洁，通过对JavaBean中的字段进行注解就行，不需要撰写.proto文件和实用编译器将其生成.java文件，百度的jprotobuf都替我们做了这些事情了。</p>
<p>一个带有jprotobuf注解的JavaBean如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.FieldType;</span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.annotation.Protobuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7890663945232864573L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.INT32, required = <span class="keyword">false</span>, order = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.STRING, required = <span class="keyword">false</span>, order = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.STRING, required = <span class="keyword">false</span>, order = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.STRING, required = <span class="keyword">false</span>, order = <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">private</span> String userInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.OBJECT, required = <span class="keyword">false</span>, order = <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; friends;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassWord</span><span class="params">(String passWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserInfo</span><span class="params">(String userInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userInfo = userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getFriends</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> friends;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFriends</span><span class="params">(List&lt;User&gt; friends)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.friends = friends;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User [userId="</span> + userId + <span class="string">", userName="</span> + userName + <span class="string">", passWord="</span> + passWord + <span class="string">", userInfo="</span> + userInfo</span><br><span class="line">                + <span class="string">", friends="</span> + friends + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.Codec;</span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.ProtobufProxy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liqqc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBuffSerialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProtoBuffSerialize().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Codec&lt;User&gt; studentClassCodec = ProtobufProxy.create(User.class, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        User u2 = <span class="keyword">new</span> User();</span><br><span class="line">        List&lt;User&gt; friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        u2.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">        u2.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        u2.setUserInfo(<span class="string">"张三是一个很牛逼的人"</span>);</span><br><span class="line">        u2.setFriends(friends);</span><br><span class="line"></span><br><span class="line">        User f1 = <span class="keyword">new</span> User();</span><br><span class="line">        f1.setUserName(<span class="string">"李四"</span>);</span><br><span class="line">        f1.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f1.setUserInfo(<span class="string">"李四是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        User f2 = <span class="keyword">new</span> User();</span><br><span class="line">        f2.setUserName(<span class="string">"王五"</span>);</span><br><span class="line">        f2.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f2.setUserInfo(<span class="string">"王五是一个很牛逼的人"</span>);</span><br><span class="line">        friends.add(f1);</span><br><span class="line">        friends.add(f2);</span><br><span class="line"></span><br><span class="line">        Long stime_jpb_encode = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            bytes = studentClassCodec.encode(u2);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"jprotobuf序列化耗时："</span> + (System.currentTimeMillis() - stime_jpb_encode) + <span class="string">"ms; 总大小："</span> + bytes.length);</span><br><span class="line"></span><br><span class="line">        Long stime_jpb_decode = System.currentTimeMillis();</span><br><span class="line">        User user = studentClassCodec.decode(bytes);</span><br><span class="line">        Long etime_jpb_decode = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"jprotobuf反序列化耗时："</span>+ (etime_jpb_decode-stime_jpb_decode) + <span class="string">"ms; User: "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="序列化底层实现"><a href="#序列化底层实现" class="headerlink" title="序列化底层实现"></a>序列化底层实现</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">	    <span class="comment">//序列化</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="string">"object.out"</span>);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> <span class="type">ObjectOutputStream</span>(fos);</span><br><span class="line">        User user1 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"xuliugen"</span>, <span class="string">"123456"</span>, <span class="string">"male"</span>);</span><br><span class="line">        oos.writeObject(user1);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">		<span class="comment">//反序列化</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"object.out"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> <span class="type">ObjectInputStream</span>(fis);</span><br><span class="line">        User user2 = (User) ois.readObject();</span><br><span class="line">        System.out.println(user2.getUserName()+ <span class="string">" "</span> + </span><br><span class="line">	        user2.getPassword() + <span class="string">" "</span> + user2.getSex());</span><br><span class="line">        <span class="comment">//反序列化的输出结果为：xuliugen 123456 male</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Serializable</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> sex;</span><br><span class="line">    <span class="comment">//全参构造方法、get和set方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>object.out文件如下<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180407130515728.png" alt="image"><br>注：上图中0000000h-000000c0h表示行号；0-f表示列；行后面的文字表示对这行16进制的解释；对上述字节码所表述的内容感兴趣的可以对照相关的资料，查阅一下每一个字符代表的含义，这里不在探讨！</p>
<p>类似于我们Java代码编译之后的.class文件，每一个字符都代表一定的含义。序列化和反序列化的过程就是生成和解析上述字符的过程！</p>
<p>序列化图示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180408163613978.jpeg" alt="image"><br>反序列化图示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180408163634701.jpeg" alt="image"></p>
<h5 id="相关注意事项"><a href="#相关注意事项" class="headerlink" title="相关注意事项"></a>相关注意事项</h5><p>1、序列化时，只对对象的状态进行保存，而不管对象的方法；</p>
<p>2、当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</p>
<p>3、当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</p>
<p>4、并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如：</p>
<p>安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；</p>
<p>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；</p>
<p>5、声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。</p>
<p>6、序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途：</p>
<p>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</p>
<p>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p>
<p>7、Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的；</p>
<p>8、如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存！这是能用序列化解决深拷贝的重要原因；</p>
<h3 id="并发编程的包，AQS和普通锁相比有什么好处"><a href="#并发编程的包，AQS和普通锁相比有什么好处" class="headerlink" title="并发编程的包，AQS和普通锁相比有什么好处"></a>并发编程的包，AQS和普通锁相比有什么好处</h3><p>队列同步器AbstractQueuedSynchronizer，是用来构建锁或者其他同步组件的基础框架，它使用一个int成员表示同步状态，通过内部的FIFO队列来完成资源获取线程的排序工作。</p>
<h4 id="AQS的设计"><a href="#AQS的设计" class="headerlink" title="AQS的设计"></a>AQS的设计</h4><p> AQS的设计是基于模板方法模式的，也就是说，使用者需要继承AQS并重写指定的方法，随后将AQS组合在自定义同步组件的实现中，并调用AQS提供的模板方法，而这些模板方法将会调用使用者重写的方法。<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile int <span class="keyword">state</span>;</span><br></pre></td></tr></table></figure></p>
<p>AQS使用一个int的成员变量来表示同步状态。<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final void <span class="built_in">set</span>State(int newState) &#123;</span><br><span class="line">    <span class="keyword">state</span> = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>setState方法用来设置同步状态<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getState方法用来获取同步状态<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, stateOffset, expect, update)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>compareAndSetState方法使用CAS操作来讲同步状态设置为给定的值</p>
<h4 id="AQS中的同步队列"><a href="#AQS中的同步队列" class="headerlink" title="AQS中的同步队列"></a>AQS中的同步队列</h4><p>最开始就提到过AQS内部维护着一个FIFO的队列。而AQS就是依赖这个同步队列来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点Node，并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<p>同步队列中节点属性<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//共享锁对应的节点</span><br><span class="line">static final <span class="keyword">Node</span> <span class="title">SHARED</span> = new <span class="keyword">Node</span><span class="title">();</span></span><br></pre></td></tr></table></figure></p>
<p> 因为如果是共享锁，线程可以被多个线程获得。所以将这个属性定义为一个常量。<br> <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//独占锁对应的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>   独占锁因为只能对一个线程获得，所以设置为null，当某个线程获得锁时，将该线程对应的赋予这个属性<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点的等待状态</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br></pre></td></tr></table></figure></p>
<p>节点的等待状态有4个</p>
<ul>
<li>CANCELLED：值为1，由于在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消等待，节点进入该状态将不会变化</li>
<li>SINGAL：值为-1，后继节点的线程处于等待状态，当前节点如果释放了同步状态，将会通知后继节点，使后继节点得以运行</li>
<li>CONDITION：值为-2，节点在等待队列中（这个在Condition的博客里会讲到），节点线程等待在Condition上，当其他线程对Condition调用了singal后，该节点会从等待队列转移到同步队列，加入到对同步状态的获取中去</li>
<li>PROPAGEATE：值为-3，表示下一次共享式同步状态获取将会无条件被传播下去<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//前驱节点，当节点加入同步队列时被设置（尾部添加）</span><br><span class="line">volatile <span class="keyword">Node</span> <span class="title">prev</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>同步队列中某个节点的前驱节点<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//后继节点</span><br><span class="line">volatile <span class="keyword">Node</span> <span class="title">next</span>;</span><br></pre></td></tr></table></figure></p>
<p>同步队列中某个节点的后继节点<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//等待队列的后继节点。如果当前节点是共享的，那么这个字段将是一个SHARED常量</span><br><span class="line"><span class="keyword">Node</span> <span class="title">nextWaiter</span>;</span><br></pre></td></tr></table></figure></p>
<p>这个是等待队列的后继节点（不是同步队列）<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取同步状态的线程</span></span><br><span class="line">volatile <span class="keyword">Thread</span> <span class="keyword">thread</span>;</span><br></pre></td></tr></table></figure></p>
<p>当前获取到同步状态的线程</p>
<p>节点时构成同步队列的基础，AQS拥有首节点和尾节点，没有成功获取到同步状态的节点会加入到同步队列的尾部，同步队列的结构如下图所示<br> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180509004159305.png" alt="image"><br> 同步器AQS包含两个节点类型的引用，一个指向头结点，一个指向尾节点。</p>
<h4 id="同步队列的操作"><a href="#同步队列的操作" class="headerlink" title="同步队列的操作"></a>同步队列的操作</h4><ul>
<li>将节点加入到同步队列：当一个线程成功获取了同步状态（或者锁），其他线程将无法获取到同步状态，转而被构造成节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全。AQS提供了一个基于CAS的设置尾节点的方法：compareAndSerTail，它需要传递当前线程认为的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180509005738767.png" alt="image"></li>
<li>将节点设置为首节点：同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180509005820225.png" alt="image"><br>设置首节点是通过成功获取同步状态的线程完成的，由于只有一个线程能成功获取到同步状态，因此设置头节点并不需要使用CAS来保证，它只需要将首节点设置为原首节点的后继节点并断开原首节点的next引用即可。</li>
</ul>
<h3 id="synchronized底层实现，加在方法上和加在同步代码块中编译后的区别、类锁、对象锁。"><a href="#synchronized底层实现，加在方法上和加在同步代码块中编译后的区别、类锁、对象锁。" class="headerlink" title="synchronized底层实现，加在方法上和加在同步代码块中编译后的区别、类锁、对象锁。"></a>synchronized底层实现，加在方法上和加在同步代码块中编译后的区别、类锁、对象锁。</h3><p><a href="https://blog.csdn.net/luoweifu/article/details/46613015" target="_blank" rel="noopener">原文链接</a></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</p>
<ul>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象。</li>
</ul>
<p>一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> SyncThread() &#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>  <span class="keyword">void</span> run() &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (count++));</span><br><span class="line">               Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> getCount() &#123;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SyncThread的调用</span></span><br><span class="line">SyncThread syncThread = <span class="keyword">new</span> SyncThread();</span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(syncThread, <span class="string">"SyncThread1"</span>);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(syncThread, <span class="string">"SyncThread2"</span>);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line"><span class="comment">//结果如下</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">0</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">1</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">2</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">3</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">4</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">5</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">6</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">7</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">8</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">9</span>*</span><br></pre></td></tr></table></figure>
<p>当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。Thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。</p>
<p>我们再把SyncThread的调用稍微改一下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SyncThread(), <span class="string">"SyncThread1"</span>);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SyncThread(), <span class="string">"SyncThread2"</span>);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line"><span class="comment">//结果如下：</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">0</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">1</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">2</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">3</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">4</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">5</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">6</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">7</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">8</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>不是说一个线程执行synchronized代码块时其它的线程受阻塞吗？为什么上面的例子中thread1和thread2同时在执行。这是因为synchronized只锁定对象，每个对象只有一个锁（lock）与之相关联，而上面的代码等同于下面这段代码：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SyncThread </span><span class="keyword">syncThread1 </span>= new <span class="keyword">SyncThread();</span></span><br><span class="line"><span class="keyword">SyncThread </span><span class="keyword">syncThread2 </span>= new <span class="keyword">SyncThread();</span></span><br><span class="line"><span class="keyword">Thread </span>thread1 = new Thread(<span class="keyword">syncThread1, </span><span class="string">"SyncThread1"</span>)<span class="comment">;</span></span><br><span class="line">Thread thread2 = new Thread(<span class="keyword">syncThread2, </span><span class="string">"SyncThread2"</span>)<span class="comment">;</span></span><br><span class="line">thread1.start()<span class="comment">;</span></span><br><span class="line">thread2.start()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>这时创建了两个SyncThread的对象syncThread1和syncThread2，线程thread1执行的是syncThread1对象中的synchronized代码(run)，而线程thread2执行的是syncThread2对象中的synchronized代码(run)；我们知道synchronized锁定的是对象，这时会有两把锁分别锁定syncThread1对象和syncThread2对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。</p>
<p>当一个线程访问对象的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块。</p>
<p>多个线程访问synchronized和非synchronized代码块<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Counter() &#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> countAdd() &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (count++));</span><br><span class="line">               Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//非synchronized代码块，未对count进行读写操作，所以可以不用synchronized</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> printCount() &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count:"</span> + count);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">      String threadName = Thread.currentThread().getName();</span><br><span class="line">      <span class="keyword">if</span> (threadName.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">         countAdd();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (threadName.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">         printCount();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用代码</span></span><br><span class="line">Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(counter, <span class="string">"A"</span>);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(counter, <span class="string">"B"</span>);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line"><span class="comment">//结果如下</span></span><br><span class="line"><span class="string">A:</span><span class="number">0</span></span><br><span class="line">B <span class="string">count:</span><span class="number">1</span></span><br><span class="line"><span class="string">A:</span><span class="number">1</span></span><br><span class="line">B <span class="string">count:</span><span class="number">2</span></span><br><span class="line"><span class="string">A:</span><span class="number">2</span></span><br><span class="line">B <span class="string">count:</span><span class="number">3</span></span><br><span class="line"><span class="string">A:</span><span class="number">3</span></span><br><span class="line">B <span class="string">count:</span><span class="number">4</span></span><br><span class="line"><span class="string">A:</span><span class="number">4</span></span><br><span class="line">B <span class="string">count:</span><span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中countAdd是一个synchronized的，printCount是非synchronized的。从上面的结果中可以看出一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。</p>
<h4 id="指定要给某个对象加锁"><a href="#指定要给某个对象加锁" class="headerlink" title="指定要给某个对象加锁"></a>指定要给某个对象加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 银行账户类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">   <span class="keyword">float</span> amount;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String name, <span class="keyword">float</span> amount)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.amount = amount;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//存钱</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">float</span> amt)</span> </span>&#123;</span><br><span class="line">      amount += amt;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//取钱</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">float</span> amt)</span> </span>&#123;</span><br><span class="line">      amount -= amt;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> amount;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户操作类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountOperator</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Account account;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AccountOperator</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.account = account;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">         account.deposit(<span class="number">500</span>);</span><br><span class="line">         account.withdraw(<span class="number">500</span>);</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + account.getBalance());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用代码</span></span><br><span class="line">Account account = <span class="keyword">new</span> Account(<span class="string">"zhang san"</span>, <span class="number">10000.0f</span>);</span><br><span class="line">AccountOperator accountOperator = <span class="keyword">new</span> AccountOperator(account);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUM = <span class="number">5</span>;</span><br><span class="line">Thread threads[] = <span class="keyword">new</span> Thread[THREAD_NUM];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i ++) &#123;</span><br><span class="line">   threads[i] = <span class="keyword">new</span> Thread(accountOperator, <span class="string">"Thread"</span> + i);</span><br><span class="line">   threads[i].start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果如下</span></span><br><span class="line">Thread3:<span class="number">10000.0</span></span><br><span class="line">Thread2:<span class="number">10000.0</span></span><br><span class="line">Thread1:<span class="number">10000.0</span></span><br><span class="line">Thread4:<span class="number">10000.0</span></span><br><span class="line">Thread0:<span class="number">10000.0</span></span><br></pre></td></tr></table></figure>
<p>在AccountOperator 类中的run方法里，我们用synchronized 给account对象加了锁。这时，当一个线程访问account对象时，其他试图访问account对象的线程将会阻塞，直到该线程访问account对象结束。也就是说谁拿到那个锁谁就可以运行它所控制的那段代码。<br>当有一个明确的对象作为锁时，就可以用类似下面这样的方式写程序。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> method3(SomeObject obj)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//obj 锁定的对象</span></span><br><span class="line">   <span class="keyword">synchronized</span>(obj)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的对象来充当锁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">byte</span>[] lock = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];  <span class="comment">// 特殊的instance变量</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">         <span class="comment">// todo 同步代码块</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。</p>
<h4 id="修饰一个方法"><a href="#修饰一个方法" class="headerlink" title="修饰一个方法"></a>修饰一个方法</h4><p>Synchronized修饰一个方法很简单，就是在方法的前面加synchronized，public synchronized void method(){//todo}; synchronized修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。如将【Demo1】中的run方法改成如下的方式，实现的效果一样。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (count++));</span><br><span class="line">         Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Synchronized作用于整个方法的写法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写法一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> method()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写法二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> method()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写法一修饰的是一个方法，写法二修饰的是一个代码块，但写法一与写法二是等价的，都是锁定了整个方法时的内容。</p>
<p>在用synchronized修饰方法时要注意以下几点：</p>
<ol>
<li>synchronized关键字不能继承。<br>虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。这两种方式的例子代码如下：<br>在子类方法中加上synchronized关键字<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   public synchronized void method() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   public synchronized void method() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在子类方法中调用父类的同步方法<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   public synchronized void method() &#123;   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   public void method() &#123; <span class="keyword">super</span>.method();   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在定义接口方法时不能使用synchronized关键字。</li>
<li>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</li>
</ul>
<h4 id="修饰一个静态的方法"><a href="#修饰一个静态的方法" class="headerlink" title="修饰一个静态的方法"></a>修饰一个静态的方法</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class <span class="keyword">SyncThread </span>implements Runnable &#123;</span><br><span class="line">   private static int <span class="built_in">count</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">   public <span class="keyword">SyncThread() </span>&#123;</span><br><span class="line">      <span class="built_in">count</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public <span class="keyword">synchronized </span>static void method() &#123;</span><br><span class="line">      for (int i = <span class="number">0</span><span class="comment">; i &lt; 5; i ++) &#123;</span></span><br><span class="line">         try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (<span class="built_in">count</span>++))<span class="comment">;</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>)<span class="comment">;</span></span><br><span class="line">         &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace()<span class="comment">;</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public <span class="keyword">synchronized </span>void run() &#123;</span><br><span class="line">      method()<span class="comment">;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SyncThread </span><span class="keyword">syncThread1 </span>= new <span class="keyword">SyncThread();</span></span><br><span class="line"><span class="keyword">SyncThread </span><span class="keyword">syncThread2 </span>= new <span class="keyword">SyncThread();</span></span><br><span class="line"><span class="keyword">Thread </span>thread1 = new Thread(<span class="keyword">syncThread1, </span><span class="string">"SyncThread1"</span>)<span class="comment">;</span></span><br><span class="line">Thread thread2 = new Thread(<span class="keyword">syncThread2, </span><span class="string">"SyncThread2"</span>)<span class="comment">;</span></span><br><span class="line">thread1.start()<span class="comment">;</span></span><br><span class="line">thread2.start()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SyncThread1:0</span></span><br><span class="line"><span class="keyword">SyncThread1:1</span></span><br><span class="line"><span class="keyword">SyncThread1:2</span></span><br><span class="line"><span class="keyword">SyncThread1:3</span></span><br><span class="line"><span class="keyword">SyncThread1:4</span></span><br><span class="line"><span class="keyword">SyncThread2:5</span></span><br><span class="line"><span class="keyword">SyncThread2:6</span></span><br><span class="line"><span class="keyword">SyncThread2:7</span></span><br><span class="line"><span class="keyword">SyncThread2:8</span></span><br><span class="line"><span class="keyword">SyncThread2:9</span></span><br></pre></td></tr></table></figure>
<p>syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。这与Demo1是不同的。</p>
<h4 id="修饰一个类"><a href="#修饰一个类" class="headerlink" title="修饰一个类"></a>修饰一个类</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> SyncThread <span class="keyword">implements</span> Runnable &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> SyncThread() &#123;</span><br><span class="line">      <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> method() &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(SyncThread.<span class="keyword">class</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.<span class="keyword">println</span>(Thread.currentThread().getName() + <span class="string">":"</span> + (<span class="keyword">count</span>++));</span><br><span class="line">               Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">      method();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其效果和【Demo5】是一样的，synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。</li>
<li>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。<br>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li>
</ul>
<h3 id="锁升级的过程。"><a href="#锁升级的过程。" class="headerlink" title="锁升级的过程。"></a>锁升级的过程。</h3><ul>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象</li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象</li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象</li>
</ul>
<p>Java中提供了两种实现同步的基础语义：synchronized方法和synchronized块</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SyncTest</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncBlock</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        synchronized (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"hello block"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">syncMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当SyncTest.java被编译成class文件的时候，synchronized关键字和synchronized方法的字节码略有不同，我们可以用javap -v 命令查看class文件对应的JVM字节码信息，部分信息如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="literal">void</span> syncBlock();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      <span class="built_in">stack</span>=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter                      <span class="comment">// monitorenter指令进入同步块</span></span><br><span class="line">         <span class="number">4</span>: getstatic     #2                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">7</span>: ldc           #3                  <span class="comment">// String hello block</span></span><br><span class="line">         <span class="number">9</span>: invokevirtual #4                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">12</span>: aload_1</span><br><span class="line">        <span class="number">13</span>: monitorexit                       <span class="comment">// monitorexit指令退出同步块</span></span><br><span class="line">        <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">        <span class="number">17</span>: astore_2</span><br><span class="line">        <span class="number">18</span>: aload_1</span><br><span class="line">        <span class="number">19</span>: monitorexit                       <span class="comment">// monitorexit指令退出同步块</span></span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        <span class="number">21</span>: athrow</span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    <span class="keyword">to</span>  target <span class="keyword">type</span></span><br><span class="line">             <span class="number">4</span>    <span class="number">14</span>    <span class="number">17</span>   any</span><br><span class="line">            <span class="number">17</span>    <span class="number">20</span>    <span class="number">17</span>   any</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> synchronized <span class="literal">void</span> syncMethod();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED      <span class="comment">//添加了ACC_SYNCHRONIZED标记</span></span><br><span class="line">    Code:</span><br><span class="line">      <span class="built_in">stack</span>=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #2                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #5                  <span class="comment">// String hello method</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #4                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的中文注释处可以看到，对于<code>synchronized</code>关键字而言，javac在编译时，会生成对应的<code>monitorenter</code>和<code>monitorexit</code>指令分别对应<code>synchronized</code>同步块的进入和退出，有两个<code>monitorexit</code>指令的原因是：为了保证抛异常的情况下也能释放锁，所以javac为同步代码块添加了一个隐式的<code>try-finally</code>，在<code>finally</code>中会调用<code>monitorexit</code>命令释放锁。而对于<code>synchronized</code>方法而言，javac为其生成了一个<code>ACC_SYNCHRONIZED</code>关键字，在JVM进行方法调用时，发现调用的方法被<code>ACC_SYNCHRONIZED</code>修饰，则会先尝试获得锁。</p>
<p>在JVM底层，对于这两种synchronized语义的实现大致相同。</p>
<h4 id="锁的几种形式"><a href="#锁的几种形式" class="headerlink" title="锁的几种形式"></a>锁的几种形式</h4><p>传统的锁（也就是下文要说的重量级锁）依赖于系统的同步函数，在linux上使用<code>mutex</code>互斥锁，最底层实现依赖于<code>futex</code>，关于<code>futex</code>可以看我之前的文章，这些同步函数都涉及到用户态和内核态的切换、进程的上下文切换，成本较高。对于加了<code>synchronized</code>关键字但运行时并没有多线程竞争，或两个线程接近于交替执行的情况，使用传统锁机制无疑效率是会比较低的。</p>
<p>在JDK 1.6之前,<code>synchronized</code>只有传统的锁机制，因此给开发者留下了<code>synchronized</code>关键字相比于其他同步机制性能不好的印象。</p>
<p>在JDK 1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。</p>
<p>在看这几种锁机制的实现前，我们先来了解下对象头，它是实现多种锁机制的基础。</p>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>因为在Java中任意对象都可以用作锁，因此必定要有一个映射关系，存储该对象以及其对应的锁信息（比如当前哪个线程持有锁，哪些线程在等待）。一种很直观的方法是，用一个全局map，来存储这个映射关系，但这样会有一些问题：需要对map做线程安全保障，不同的synchronized之间会相互影响，性能差；另外当同步对象较多时，该map可能会占用比较多的内存。</p>
<p>所以最好的办法是将这个映射关系存储在对象头中，因为对象头本身也有一些hashcode、GC相关的数据，所以如果能将锁信息与这些信息共存在对象头中就好了。</p>
<p>在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：mark word和类型指针。另外对于数组而言还会有一份记录数组长度的数据。</p>
<p>类型指针是指向该对象所属类对象的指针，<code>mark word</code>用于存储对象的<code>HashCode</code>、GC分代年龄、锁状态等信息。在32位系统上<code>mark word</code>长度为32字节，64位系统上长度为64字节。为了能在有限的空间里存储下更多的数据，其存储格式是不固定的，在32位系统上各状态的格式如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG252.png" alt="image"></p>
<p>可以看到锁信息也是存在于对象的<code>mark word</code>中的。当对象状态为偏向锁（biasable）时，<code>mark word</code>存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，<code>mark word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁是我们常说的传统意义上的锁，其利用操作系统底层的同步机制去实现Java中的线程同步。</p>
<p>重量级锁的状态下，对象的<code>mark word</code>为指向一个堆中monitor对象的指针。</p>
<p>一个monitor对象包括这么几个关键字段：cxq（下图中的ContentionList），EntryList ，WaitSet，owner。</p>
<p>其中cxq ，EntryList ，WaitSet都是由ObjectWaiter的链表结构，owner指向持有锁的线程。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG253.png" alt="image"></p>
<p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列尾部，然后暂停当前线程。当持有锁的线程释放锁前，会将cxq中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p>
<p>如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p>
<p>以上只是对重量级锁流程的一个简述，其中涉及到的很多细节，比如ObjectMonitor对象从哪来？释放锁时是将cxq中的元素移动到EntryList的尾部还是头部？notfiy时，是将ObjectWaiter移动到EntryList的尾部还是头部？</p>
<p>关于具体的细节，会在重量级锁的文章中分析。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>JVM的开发者发现在很多情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。</p>
<p>线程在执行同步块之前，JVM会先在当前的线程的栈帧中创建一个Lock Record，其包括一个用于存储对象头中的 mark word（官方称之为Displaced Mark Word）以及一个指向对象的指针。下图右边的部分就是一个Lock Record。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG254.png" alt="image"></p>
<h4 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h4><ol>
<li><p>在线程栈中创建一个Lock Record，将其obj（即上图的Object reference）字段指向锁对象。</p>
</li>
<li><p>直接通过CAS指令将Lock Record的地址存储在对象头的mark word中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。如果失败，进入到步骤3。</p>
</li>
<li><p>如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分（Displaced Mark Word）为null，起到了一个重入计数器的作用。然后结束。</p>
</li>
<li><p>走到这一步说明发生了竞争，需要膨胀为重量级锁。</p>
</li>
</ol>
<h4 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h4><ol>
<li><p>遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record。</p>
</li>
<li><p>如果Lock Record的Displaced Mark Word为null，代表这是一次重入，将obj设置为null后continue。</p>
</li>
<li><p>如果Lock Record的Displaced Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为Displaced Mark Word。如果成功，则continue，否则膨胀为重量级锁。</p>
</li>
</ol>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>Java是支持多线程的语言，因此在很多二方包、基础库中为了保证代码在多线程的情况下也能正常运行，也就是我们常说的线程安全，都会加入如synchronized这样的同步语义。但是在应用在实际运行时，很可能只有一个线程会调用相关同步方法。比如下面这个demo：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo1</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncDemo1 syncDemo1 = <span class="keyword">new</span> SyncDemo1();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            syncDemo1.addString(<span class="string">"test:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">addString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">list</span>.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个demo中为了保证对list操纵时线程安全，对addString方法加了synchronized的修饰，但实际使用时却只有一个线程调用到该方法，对于轻量级锁而言，每次调用addString时，加锁解锁都有一个CAS操作；对于重量级锁而言，加锁也会有一个或多个CAS操作（这里的’一个‘、’多个‘数量词只是针对该demo，并不适用于所有场景）。</p>
<p>在JDK1.6中为了提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能，引入了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只会执行几个简单的命令，而不是开销相对较大的CAS命令。我们来看看偏向锁是如何做的。</p>
<h4 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h4><p>当JVM启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式（什么时候会关闭一个class的偏向模式下文会说，默认所有class的偏向模式都是是开启的），那新创建对象的mark word将是可偏向状态，此时mark word中的thread id（参见上文偏向状态下的mark word格式）为0，表示未偏向任何线程，也叫做匿名偏向(anonymously biased)。</p>
<h4 id="加锁过程-1"><a href="#加锁过程-1" class="headerlink" title="加锁过程"></a>加锁过程</h4><p>case 1：当该对象第一次被线程获得锁的时候，发现是匿名偏向状态，则会用CAS指令，将mark word中的thread id由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则，将偏向锁撤销，升级为轻量级锁。</p>
<p>case 2：当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程，在通过一些额外的检查后（细节见后面的文章），会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，synchronized关键字带来的性能开销基本可以忽略。</p>
<p>case 3.当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到撤销偏向锁的逻辑里，一般来说，会在safepoint中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的mark word改为无锁状态（unlocked），之后再升级为轻量级锁。</p>
<p>由此可见，偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p>
<h4 id="解锁过程-1"><a href="#解锁过程-1" class="headerlink" title="解锁过程"></a>解锁过程</h4><p>当有其他线程尝试获得锁时，是根据遍历偏向线程的lock record来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条lock record的obj字段设置为null。需要注意的是，偏向锁的解锁步骤中并不会修改对象头中的thread id。</p>
<p>下图展示了锁状态的转换流程：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG255.png" alt="image"></p>
<p>另外，偏向锁默认不是立即就启动的，在程序启动后，通常有几秒的延迟，可以通过命令 <code>-XX:BiasedLockingStartupDelay=0</code>来关闭延迟。</p>
<h4 id="批量重偏向与撤销"><a href="#批量重偏向与撤销" class="headerlink" title="批量重偏向与撤销"></a>批量重偏向与撤销</h4><p>从上文偏向锁的加锁解锁过程中可以看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。safe point这个词我们在GC中经常会提到，其代表了一个状态，在该状态下所有线程都是暂停的（大概这么个意思），详细可以看这篇文章。总之，偏向锁的撤销是有一定成本的，如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。</p>
<p>存在如下两种情况:</p>
<ol>
<li><p>一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</p>
</li>
<li><p>存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</p>
</li>
</ol>
<p>批量重偏向（bulk rebias）机制是为了解决第一种场景。批量撤销（bulk revoke）则是为了解决第二种场景。</p>
<p>其做法是：以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的mark word中也有该字段，其初始值为创建该对象时，class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其mark word的Thread Id 改成当前线程Id。</p>
<p>当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>
<h3 id="Java运行时区域及各个区域的作用、对GC的了解、Java内存模型及为什么要这么设计？"><a href="#Java运行时区域及各个区域的作用、对GC的了解、Java内存模型及为什么要这么设计？" class="headerlink" title="Java运行时区域及各个区域的作用、对GC的了解、Java内存模型及为什么要这么设计？"></a>Java运行时区域及各个区域的作用、对GC的了解、Java内存模型及为什么要这么设计？</h3><h4 id="Java运行时区域及各个区域的作用"><a href="#Java运行时区域及各个区域的作用" class="headerlink" title="Java运行时区域及各个区域的作用"></a>Java运行时区域及各个区域的作用</h4><p>Java虚拟机所管理的内存将会包括一下几个运行时数据区域</p>
<p><img src="https://images2015.cnblogs.com/blog/1182497/201706/1182497-20170616192740650-1039521219.png" alt="image"></p>
<h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p> 程序计数器（Program Counter Register） 是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条执行字节码指令。</p>
<p>每条线程都有一个独立的程序计数器。</p>
<p>如果执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址。如果是native方法，计数器为空。此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h5 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h5><p>同样是线程私有，描述Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法对应一个栈帧。</p>
<p>局部变量表存放了各种基本类型、对象引用和returnAddress类型（指向了一条字节码指令地址）。其中64位长度long 和 double占两个局部变量空间，其他只占一个。</p>
<p>规定的异常情况有两种：1.线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；2.如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就抛出OutOfMemoryError异常。</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p> 和Java虚拟机栈很类似，不同的是本地方法栈为Native方法服务。</p>
<h5 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h5><p>是Java虚拟机所管理的内存中最大的一块。由所有线程共享，在虚拟机启动时创建。堆区唯一目的就是存放对象实例。</p>
<p>堆中可细分为新生代和老年代，再细分可分为Eden空间、From Survivor空间、To Survivor空间。</p>
<p>堆无法扩展时，抛出OutOfMemoryError异常</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>所有线程共享，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>当方法区无法满足内存分配需求时，抛出OutOfMemoryError</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>它是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池（Const Pool Table），用于存放编译期生成的各种字面量和符号引用。并非预置入Class文件中常量池的内容才进入方法运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
<p>当方法区无法满足内存分配需求时，抛出OutOfMemoryError</p>
<h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。</p>
<p>JDK1.4加入了NIO，引入一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。因为避免了在Java堆和Native堆中来回复制数据，提高了性能。</p>
<p>当各个内存区域总和大于物理内存限制，抛出OutOfMemoryError异常。</p>
<h4 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a>GC相关</h4><p>jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。</p>
<p><img src="https://img2018.cnblogs.com/blog/1489669/201810/1489669-20181016185255493-478123409.png" alt="image"></p>
<h5 id="GC的对象"><a href="#GC的对象" class="headerlink" title="GC的对象"></a>GC的对象</h5><p>需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：引用计数和可达分析。</p>
<ul>
<li>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</li>
<li>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在Java语言中，GC <span class="keyword">Roots</span>包括：</span><br><span class="line"></span><br><span class="line">虚拟机栈中引用的对象。</span><br><span class="line"></span><br><span class="line">方法区中类静态属性实体引用的对象。</span><br><span class="line"></span><br><span class="line">方法区中常量引用的对象。</span><br><span class="line"></span><br><span class="line">本地方法栈中JNI引用的对象。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="什么时候触发GC"><a href="#什么时候触发GC" class="headerlink" title="什么时候触发GC"></a>什么时候触发GC</h5><ul>
<li>程序调用System.gc时可以触发</li>
<li>系统自身来决定GC触发的时机（根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程）</li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GC又分为 minor GC 和 <span class="keyword">Full</span> GC (也称为 Major GC )</span><br><span class="line"></span><br><span class="line">Minor GC触发条件：当Eden区满时，触发Minor GC。</span><br><span class="line"></span><br><span class="line"><span class="keyword">Full</span> GC触发条件：</span><br><span class="line"></span><br><span class="line">  a.调用System.gc时，系统建议执行<span class="keyword">Full</span> GC，但是不必然执行</span><br><span class="line"></span><br><span class="line">  b.老年代空间不足</span><br><span class="line"></span><br><span class="line">  c.方法去空间不足</span><br><span class="line"></span><br><span class="line">  d.通过Minor GC后进入老年代的平均大小大于老年代的可用内存</span><br><span class="line"></span><br><span class="line">  e.由Eden区、From <span class="keyword">Space</span>区向To <span class="keyword">Space</span>区复制时，对象大小大于To <span class="keyword">Space</span>可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</span><br></pre></td></tr></table></figure>
<h5 id="GC常用算法"><a href="#GC常用算法" class="headerlink" title="GC常用算法"></a>GC常用算法</h5><p>GC常用算法有：标记-清除算法，标记-压缩算法，复制算法，分代收集算法。<br>目前主流的JVM（HotSpot）采用的是分代收集算法。</p>
<h6 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h6><p>为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 GC 操作。</p>
<ul>
<li><p>优点</p>
<p>  最大的优点是，标记—清除算法中每个活着的对象的引用只需要找到一个即可，找到一个就可以判断它为活的。此外，更重要的是，这个算法并不移动对象的位置。</p>
</li>
<li><p>缺点<br>  它的缺点就是效率比较低（递归与全堆对象遍历）。每个活着的对象都要在标记阶段遍历一遍；所有对象都要在清除阶段扫描一遍，因此算法复杂度较高。没有移动对象，导致可能出现很多碎片空间无法利用的情况。</p>
</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016192344776-1456921556.png" alt="image"></p>
<h6 id="标记-压缩算法（标记-整理）"><a href="#标记-压缩算法（标记-整理）" class="headerlink" title="标记-压缩算法（标记-整理）"></a>标记-压缩算法（标记-整理）</h6><p>标记-压缩法是标记-清除法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。</p>
<ul>
<li>优点<br>  该算法不会像标记-清除算法那样产生大量的碎片空间。</li>
<li>缺点<br>  如果存活的对象过多，整理阶段将会执行较多复制操作，导致算法效率降低。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016192808209-1144011671.png" alt="image"></li>
</ul>
<p>左边是标记阶段，右边是整理之后的状态。可以看到，该算法不会产生大量碎片内存空间。</p>
<h6 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h6><p>该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。</p>
<p>注意：</p>
<p>这个算法与标记-整理算法的区别在于，该算法不是在同一个区域复制，而是将所有存活的对象复制到另一个区域内。</p>
<ul>
<li>优点<br>  实现简单；不产生内存碎片</li>
<li>缺点<br>  每次运行，总有一半内存是空的，导致可使用的内存空间只有原来的一半。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016193120797-694786115.png" alt="image"></li>
</ul>
<h6 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h6><p>现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</p>
<p> 具体过程：新生代(Young)分为Eden区，From区与To区</p>
<p> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016194033050-1554933093.png" alt="image"></p>
<p> 当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次YoungGC，也就是年轻代的垃圾回收。一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。 </p>
<p> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016194136097-936358657.png" alt="image"></p>
<p> 这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，会将Eden区与From区还在被使用的对象复制到To区， </p>
<p> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016194207606-298577682.png" alt="image"></p>
<p> 再下一次YoungGC的时候，则是将Eden区与To区中的还在被使用的对象复制到From区。</p>
<p> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016194236007-1428408352.png" alt="image"></p>
<p> 经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。 </p>
<p> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016194302974-1844734331.png" alt="image"></p>
<p> 老年代经过这么几次折腾，也就扛不住了（空间被用完），好，那就来次集体大扫除（Full GC），也就是全量回收。如果Full GC使用太频繁的话，无疑会对系统性能产生很大的影响。所以要合理设置年轻代与老年代的大小，尽量减少Full GC的操作。</p>
<h5 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h5><p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p>
<h6 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h6><p>串行收集器是最古老，最稳定以及效率高的收集器<br>可能会产生较长的停顿，只使用一个线程去回收<br>-XX:+UseSerialGC</p>
<ul>
<li>新生代、老年代使用串行回收</li>
<li>新生代复制算法</li>
<li>老年代标记-压缩</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016195304547-1979156977.png" alt="image"></p>
<h6 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h6><ul>
<li><p>ParNew<br>-XX:+UseParNewGC（new代表新生代，所以适用于新生代）</p>
<ul>
<li>新生代并行</li>
<li>老年代串行<br>Serial收集器新生代的并行版本<br>在新生代回收时使用复制算法<br>多线程，需要多核支持</li>
</ul>
</li>
</ul>
<p>-XX:ParallelGCThreads 限制线程数量<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016195337336-1777000798.png" alt="image"></p>
<ul>
<li>Parallel收集器<br>类似ParNew<br>新生代复制算法<br>老年代标记-压缩<br>更加关注吞吐量<br>-XX:+UseParallelGC  <ul>
<li>使用Parallel收集器+ 老年代串行<br>-XX:+UseParallelOldGC </li>
<li>使用Parallel收集器+ 老年代并行</li>
</ul>
</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016195404250-2142909553.png" alt="image"></p>
<p>其他GC参数</p>
<p>-XX:MaxGCPauseMills</p>
<pre><code>- 最大停顿时间，单位毫秒
- GC尽力保证回收时间不超过设定值
</code></pre><p>-XX:GCTimeRatio </p>
<pre><code>- 0-100的取值范围
- 垃圾收集时间占总时间的比
- 默认99，即最大允许1%时间做GC
</code></pre><p>这两个参数是矛盾的。因为停顿时间和吞吐量不可能同时调优</p>
<h6 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h6><ul>
<li>Concurrent Mark Sweep 并发标记清除（应用程序线程和GC线程交替执行）</li>
<li>使用标记-清除算法</li>
<li>并发阶段会降低吞吐量（停顿时间减少，吞吐量降低）</li>
<li>老年代收集器（新生代使用ParNew）</li>
<li>-XX:+UseConcMarkSweepGC</li>
</ul>
<p>CMS运行过程比较复杂，着重实现了标记的过程，可分为</p>
<ol>
<li>初始标记（会产生全局停顿）<ul>
<li>根可以直接关联到的对象</li>
<li>速度快</li>
</ul>
</li>
<li>并发标记（和用户线程一起） <ul>
<li>主要标记过程，标记全部对象</li>
</ul>
</li>
<li>重新标记 （会产生全局停顿）<ul>
<li>由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正</li>
</ul>
</li>
<li>并发清除（和用户线程一起） <ul>
<li>基于标记结果，直接清理对象</li>
</ul>
</li>
</ol>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016195447698-597277595.png" alt="image"></p>
<p>这里就能很明显的看出，为什么CMS要使用标记清除而不是标记压缩，如果使用标记压缩，需要多对象的内存位置进行改变，这样程序就很难继续执行。但是标记清除会产生大量内存碎片，不利于内存分配。 </p>
<p>CMS收集器特点：</p>
<ul>
<li>尽可能降低停顿</li>
<li>会影响系统整体吞吐量和性能<ul>
<li>比如，在用户线程运行过程中，分一半CPU去做GC，系统性能在GC阶段，反应速度就下降一半</li>
</ul>
</li>
<li>清理不彻底 <ul>
<li>因为在清理阶段，用户线程还在运行，会产生新的垃圾，无法清理</li>
</ul>
</li>
<li>因为和用户线程一起运行，不能在空间快满时再清理（因为也许在并发GC的期间，用户线程又申请了大量内存，导致内存不够） <ul>
<li>-XX:CMSInitiatingOccupancyFraction设置触发GC的阈值</li>
<li>如果不幸内存预留空间不够，就会引起concurrent mode failure<br>一旦 concurrent mode failure产生，将使用串行收集器作为后备。</li>
</ul>
</li>
</ul>
<p>CMS也提供了整理碎片的参数：</p>
<pre><code>- -XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次整理
</code></pre><p>整理过程是独占的，会引起停顿时间变长</p>
<p>-XX:+CMSFullGCsBeforeCompaction</p>
<pre><code>- 设置进行几次Full GC后，进行一次碎片整理
</code></pre><p>-XX:ParallelCMSThreads</p>
<pre><code>- 设定CMS的线程数量（一般情况约等于可用CPU数量）
</code></pre><p>CMS的提出是想改善GC的停顿时间，在GC过程中的确做到了减少GC时间，但是同样导致产生大量内存碎片，又需要消耗大量时间去整理碎片，从本质上并没有改善时间。 </p>
<h6 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h6><p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。</p>
<p>与CMS收集器相比G1收集器有以下特点：</p>
<p>(1) 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p>
<p>(2)可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
<p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p>
<p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。</p>
<p>和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
<p>步骤：</p>
<p>(1)标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p>
<p>(2)Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p>
<p>(3)Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016195748885-635394429.png" alt="image"></p>
<p>(4)Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
<p>(5)Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016195818822-811200159.png" alt="image"></p>
<p>(6)复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p>
<h5 id="finalize-方法详解"><a href="#finalize-方法详解" class="headerlink" title="finalize()方法详解"></a>finalize()方法详解</h5><h6 id="finalize的作用"><a href="#finalize的作用" class="headerlink" title="finalize的作用"></a>finalize的作用</h6><p>(1)finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</p>
<p>(2)finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性</p>
<p>(3)不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：</p>
<p>① 清理本地对象(通过JNI创建的对象)；</p>
<p>② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法</p>
<h6 id="finalize的问题"><a href="#finalize的问题" class="headerlink" title="finalize的问题"></a>finalize的问题</h6><p>(1)一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法</p>
<p>(2)System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们</p>
<p>(3)Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行</p>
<p>(4)finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行</p>
<p>(5)对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的</p>
<p>(6)finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为)</p>
<h6 id="finalize的执行过程-生命周期"><a href="#finalize的执行过程-生命周期" class="headerlink" title="finalize的执行过程(生命周期)"></a>finalize的执行过程(生命周期)</h6><p>(1) 首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p>
<p>(2) 具体的finalize流程：<br> 对象可由两种状态，涉及到两类状态空间，一是终结状态空间 F = {unfinalized, finalizable, finalized}；二是可达状态空间 R = {reachable, finalizer-reachable, unreachable}。各状态含义如下：</p>
<ul>
<li>unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的</li>
<li>finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行</li>
<li>finalized: 表示GC已经对该对象执行过finalize方法<br>reachable: 表示GC Roots引用可达</li>
<li>finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达</li>
<li>unreachable：对象不可通过上面两种途径可达</li>
</ul>
<p>状态变迁图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016201012220-784045144.png" alt="image"></p>
<p>变迁说明：</p>
<p>(1)新建对象首先处于[reachable, unfinalized]状态(A)</p>
<p>(2)随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态</p>
<p>(3)若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。</p>
<p>(4)在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N)</p>
<p>(5)处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因</p>
<p>(6)程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为</p>
<p>(7)若JVM检测到finalized状态的对象变成unreachable，回收其内存(I)</p>
<p>(8)若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O）</p>
<p>(9)注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>根据GC的工作原理，我们可以通过一些技巧和方式，让GC运行更加有效率，更加符合应用程序的要求。一些关于程序设计的几点建议：</p>
<p>1.最基本的建议就是尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域（scope）后，自动设置为 null.我们在使用这种方式时候，必须特别注意一些复杂的对象图，例如数组，队列，树，图等，这些对象之间有相互引用关系较为复杂。对于这类对象，GC 回收它们一般效率较低。如果程序允许，尽早将不用的引用对象赋为null.这样可以加速GC的工作。</p>
<p>2.尽量少用finalize函数。finalize函数是Java提供给程序员一个释放对象或资源的机会。但是，它会加大GC的工作量，因此尽量少采用finalize方式回收资源。</p>
<p>3.如果需要使用经常使用的图片，可以使用soft应用类型。它可以尽可能将图片保存在内存中，供程序调用，而不引起OutOfMemory.</p>
<p>4.注意集合数据类型，包括数组，树，图，链表等数据结构，这些数据结构对GC来说，回收更为复杂。另外，注意一些全局的变量，以及一些静态变量。这些变量往往容易引起悬挂对象（dangling reference），造成内存浪费。</p>
<p>5.当程序有一定的等待时间，程序员可以手动执行System.gc（），通知GC运行，但是Java语言规范并不保证GC一定会执行。使用增量式GC可以缩短Java程序的暂停时间。</p>
<h3 id="countDownLatch用过没有，在项目中如何使用的，对AQS的了解。"><a href="#countDownLatch用过没有，在项目中如何使用的，对AQS的了解。" class="headerlink" title="countDownLatch用过没有，在项目中如何使用的，对AQS的了解。"></a>countDownLatch用过没有，在项目中如何使用的，对AQS的了解。</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>countDownLatch是在java1.5被引入，跟它一起被引入的工具类还有CyclicBarrier、Semaphore、concurrentHashMap和BlockingQueue。</li>
<li>存在于java.util.cucurrent包下。</li>
<li>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</li>
<li>是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</li>
</ul>
<p>类中有三个方法是最重要的<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;   </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  </span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CountDownLatchTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        final CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"主线程开始执行…… ……"</span>);</span><br><span class="line">        <span class="comment">//第一个子线程执行</span></span><br><span class="line">        ExecutorService es1 = Executors.newSingleThreadExecutor();</span><br><span class="line">        es1.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"子线程："</span>+Thread.currentThread().getName()+<span class="string">"执行"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es1.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二个子线程执行</span></span><br><span class="line">        ExecutorService es2 = Executors.newSingleThreadExecutor();</span><br><span class="line">        es2.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"子线程："</span>+Thread.currentThread().getName()+<span class="string">"执行"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es2.shutdown();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"等待两个线程执行完毕…… ……"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.<span class="keyword">await</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"两个子线程都执行完毕，继续执行主线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">主线程开始执行…… ……</span><br><span class="line">等待两个线程执行完毕…… ……</span><br><span class="line">子线程：pool<span class="number">-1</span>-thread<span class="number">-1</span>执行</span><br><span class="line">子线程：pool<span class="number">-2</span>-thread<span class="number">-1</span>执行</span><br><span class="line">两个子线程都执行完毕，继续执行主线程</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟并发示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Parallellimit</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">        CountDownLatch cdl = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            CountRunnable runnable = <span class="keyword">new</span> CountRunnable(cdl);</span><br><span class="line">            pool.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title">CountRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountRunnable</span>(<span class="params">CountDownLatch countDownLatch</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            synchronized (countDownLatch) &#123;</span><br><span class="line">                <span class="comment">/*** 每次减少一个容量*/</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"thread counts = "</span> + (countDownLatch.getCount()));</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.<span class="keyword">await</span>();</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"concurrency counts = "</span> + (<span class="number">100</span> - countDownLatch.getCount()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CountDownLatch和CyclicBarrier区别："><a href="#CountDownLatch和CyclicBarrier区别：" class="headerlink" title="CountDownLatch和CyclicBarrier区别："></a>CountDownLatch和CyclicBarrier区别：</h4><ul>
<li>countDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次</li>
<li>CyclicBarrier的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供reset功能，可以多次使用</li>
</ul>
<h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><ul>
<li>AQS的全称：AbstractQueuedSynchronizer，抽象队列同步器</li>
<li>java并发包下很多API都是基于AQS来实现的加锁和释放锁等功能的，AQS是java并发包的基础类。ReentrantLock、ReentrantReadWriteLock底层都是基于AQS来实现的。</li>
<li>看一下ReentrantLock和AQS之间的关系<br>ReentrantLock内部包含了一个AQS对象，也就是AbstractQueuedSynchronizer类型的对象。这个AQS对象就是ReentrantLock可以实现加锁和释放锁的关键性的核心组件。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190422101506890.png" alt="image"></li>
</ul>
<h5 id="ReentrantLock加锁和释放锁的底层原理"><a href="#ReentrantLock加锁和释放锁的底层原理" class="headerlink" title="ReentrantLock加锁和释放锁的底层原理"></a>ReentrantLock加锁和释放锁的底层原理</h5><ul>
<li>如果有一个线程过来尝试用ReentrantLock的lock()方法进行加锁，这个AQS对象内部有一个核心的变量叫做state，是int类型的，代表了加锁的状态。初始状态下，这个state的值是0。</li>
<li>另外，这个AQS内部还有一个关键变量，用来记录当前加锁的是哪个线程，初始化状态下，这个变量是null。</li>
<li><p>接着线程1跑过来调用ReentrantLock的lock()方法尝试进行加锁，这个加锁的过程，直接就是用CAS操作将state值从0变为1。如果之前没人加过锁，那么state的值肯定是0，此时线程1就可以加锁成功。一旦线程1加锁成功了之后，就可以设置当前加锁线程是自己。所以大家看下面的图，就是线程1跑过来加锁的一个过程。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2019042210300768.png" alt="image"><br>看到这儿，大家应该对所谓的AQS有感觉了。说白了，就是并发包里的一个核心组件，里面有state变量、加锁线程变量等核心的东西，维护了加锁状态。ReentrantLock这种东西只是一个外层的API，内核中的锁机制实现都是依赖AQS组件的。</p>
</li>
<li><p>这个ReentrantLock之所以用Reentrant打头，意思就是他是一个可重入锁。可重入锁的意思，就是你可以对一个ReentrantLock对象多次执行lock()加锁和unlock()释放锁，也就是可以对一个锁加多次，叫做可重入加锁。</p>
</li>
<li>大家看明白了那个state变量之后，就知道了如何进行可重入加锁！<br>其实每次线程1可重入加锁一次，会判断一下当前加锁线程就是自己，那么他自己就可以可重入多次加锁，每次加锁就是把state的值给累加1，别的没啥变化。</li>
<li>接着，如果线程1加锁了之后，线程2跑过来加锁会怎么样呢？<br>我们来看看锁的互斥是如何实现的？线程2跑过来一下看到，哎呀！state的值不是0啊？所以CAS操作将state从0变为1的过程会失败，因为state的值当前为1，说明已经有人加锁了！</li>
<li>接着线程2会看一下，是不是自己之前加的锁啊？当然不是了，“加锁线程”这个变量明确记录了是线程1占用了这个锁，所以线程2此时就是加锁失败。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190422104629928.png" alt="image"></li>
<li>接着，线程2会将自己放入AQS中的一个等待队列，因为自己尝试加锁失败了，此时就要将自己放入队列中来等待，等待线程1释放锁之后，自己就可以重新尝试加锁了</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190422104805138.png" alt="image"></p>
<ul>
<li><p>接着，线程1在执行完自己的业务逻辑代码之后，就会释放锁！他释放锁的过程非常的简单，就是将AQS内的state变量的值递减1，如果state值为0，则彻底释放锁，会将“加锁线程”变量也设置为null！<br>整个过程，参见下图：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190422104853687.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=root%2F20191014%2F%2Fs3%2Faws4_request&amp;X-Amz-Date=20191014T060907Z&amp;X-Amz-Expires=432000&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=638f7fb742371f0c113b37a6a8abc01546a7bddc14b87542561efd06b210836f" alt="image"></p>
</li>
<li><p>接下来，线程1会从等待队列的队头唤醒线程2重新尝试加锁。<br>线程2现在就重新尝试加锁，这时还是用CAS操作将state从0变为1，- - 此时就会成功，成功之后代表加锁成功，就会将state设置为1；此外，还要把“加锁线程”设置为线程2自己，同时线程2自己就从等待队列中出队了。</p>
</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190422105125131.png" alt="image"></p>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>其实一句话总结AQS就是一个并发包的基础组件，用来实现各种锁，各种同步组件的。它包含了state变量、加锁线程、等待队列等并发中的核心组件。</p>
<ul>
<li>写生产者消费者问题，考虑高并发的情况，可以使用Java 类库，白纸写代码。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span></span>&#123; <span class="comment">// 定义信息类  </span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"name"</span>;<span class="comment">//定义name属性，为了与下面set的name属性区别开  </span></span><br><span class="line">    <span class="keyword">private</span> String content = <span class="string">"content"</span> ;<span class="comment">// 定义content属性，为了与下面set的content属性区别开  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span> ;   <span class="comment">// 设置标志位,初始时先生产  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name,String content)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">while</span>(!flag)&#123;  </span><br><span class="line">            <span class="keyword">try</span>&#123;  </span><br><span class="line">                <span class="keyword">super</span>.wait() ;  </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">                e.printStackTrace() ;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">this</span>.setName(name) ;    <span class="comment">// 设置名称  </span></span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            Thread.sleep(<span class="number">300</span>) ;  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">            e.printStackTrace() ;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">this</span>.setContent(content) ;  <span class="comment">// 设置内容  </span></span><br><span class="line">        flag  = <span class="keyword">false</span> ; <span class="comment">// 改变标志位，表示可以取走  </span></span><br><span class="line">        <span class="keyword">super</span>.notify();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;  </span><br><span class="line">            <span class="keyword">try</span>&#123;  </span><br><span class="line">                <span class="keyword">super</span>.wait() ;  </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">                e.printStackTrace() ;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            Thread.sleep(<span class="number">300</span>) ;  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">            e.printStackTrace() ;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName() +   </span><br><span class="line">            <span class="string">" --&gt; "</span> + <span class="keyword">this</span>.getContent()) ;  </span><br><span class="line">        flag  = <span class="keyword">true</span> ;  <span class="comment">// 改变标志位，表示可以生产  </span></span><br><span class="line">        <span class="keyword">super</span>.notify();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.content = content ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123; <span class="comment">// 通过Runnable实现多线程  </span></span><br><span class="line">    <span class="keyword">private</span> Info info = <span class="keyword">null</span> ;      <span class="comment">// 保存Info引用  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Info info)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.info = info ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span> ;   <span class="comment">// 定义标记位  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;  </span><br><span class="line">                <span class="keyword">this</span>.info.set(<span class="string">"姓名--1"</span>,<span class="string">"内容--1"</span>) ;    <span class="comment">// 设置名称  </span></span><br><span class="line">                flag = <span class="keyword">false</span> ;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="keyword">this</span>.info.set(<span class="string">"姓名--2"</span>,<span class="string">"内容--2"</span>) ;    <span class="comment">// 设置名称  </span></span><br><span class="line">                flag = <span class="keyword">true</span> ;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Info info = <span class="keyword">null</span> ;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Info info)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.info = info ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line">            <span class="keyword">this</span>.info.get() ;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCaseDemo03</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        Info info = <span class="keyword">new</span> Info(); <span class="comment">// 实例化Info对象  </span></span><br><span class="line">        Producer pro = <span class="keyword">new</span> Producer(info) ; <span class="comment">// 生产者  </span></span><br><span class="line">        Consumer con = <span class="keyword">new</span> Consumer(info) ; <span class="comment">// 消费者  </span></span><br><span class="line">        <span class="keyword">new</span> Thread(pro).start() ;  </span><br><span class="line">        <span class="comment">//启动了生产者线程后，再启动消费者线程  </span></span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            Thread.sleep(<span class="number">500</span>) ;  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">            e.printStackTrace() ;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">new</span> Thread(con).start() ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="有没有排查过线上OOM的问题，如何排查的？"><a href="#有没有排查过线上OOM的问题，如何排查的？" class="headerlink" title="有没有排查过线上OOM的问题，如何排查的？"></a>有没有排查过线上OOM的问题，如何排查的？</h3><p>查看当前路径，oom.out文件已经生成了，该文件就是应用在发生OOM异常时自动导出的堆文件。那我们此时需要对该文件进行分析，因为其中记录了是什么对象导出了应用程OOM的发生。</p>
<p>分析OOM的工具推荐使用MAT，下载地址为<a href="https://projects.eclipse.org/projects/tools.mat，在配置好Java环境的电脑中，直接打开即可，不需要安装，然后通过MAT打开已经生成的OOM文件oom.out，出现如下提示，选择“Leak" target="_blank" rel="noopener">https://projects.eclipse.org/projects/tools.mat，在配置好Java环境的电脑中，直接打开即可，不需要安装，然后通过MAT打开已经生成的OOM文件oom.out，出现如下提示，选择“Leak</a> Suspects Report”执行内存泄漏检查分析：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2018091318062115.png" alt="image"></p>
<p>点击Finish按钮后，MAT会将可疑的内存泄漏的对象都展现出来：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180913181010465.png" alt="image"></p>
<p>可以看到线程java.lang.Thread @ 0xff617e80 的main方法中，有一个本地变量占用了96.43%的堆内存，实际内存占用的是char[]数组，因而被检测出来为OOM可疑的元凶。点击红色框中的“See stacktrace”，可以直接看到该对象所在线程的堆栈信息：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180913182035623.png" alt="image"></p>
<p>直接定位到了发生OOM的代码所在位置，至此该示例分析完成，MAT工具本身还有其它许多的功能，这里就不一一细说了。</p>
<p>下一篇会写服务器由于时间戳不一致，导致有些服务器可以访问，有些服务器却不能够访问的问题，如果感兴趣，请继续观注。</p>
<h3 id="有没有使用过JVM自带的工具，如何使用的？"><a href="#有没有使用过JVM自带的工具，如何使用的？" class="headerlink" title="有没有使用过JVM自带的工具，如何使用的？"></a>有没有使用过JVM自带的工具，如何使用的？</h3><p><code>%JAVA_HOME/bin%</code>下就是安装java时为我们自带的可运行程序的文件夹。</p>
<h4 id="jps命令"><a href="#jps命令" class="headerlink" title="jps命令"></a>jps命令</h4><p>jps(java process status)：用于查看java进程。</p>
<table>
<thead>
<tr>
<th>option</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>查看java进程</td>
</tr>
<tr>
<td>-l</td>
<td>显示全类名</td>
</tr>
<tr>
<td>-m</td>
<td>带参显示</td>
</tr>
<tr>
<td>-v</td>
<td>JVM参数</td>
</tr>
</tbody>
</table>
<h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><ul>
<li><code>jstat -gcutil pid</code></li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190401203922492.png" alt="image"></p>
<p>其中的<code>pid</code>是你关注的<code>java</code>进程号，可根据<code>jps</code>查询。<br><code>-gcutil</code>是关心的指标，更多详尽信息请参看官方文档。</p>
<ul>
<li><p><code>options</code><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190401203945843.png" alt="image"></p>
</li>
<li><p><code>description</code>(后面也有详尽的字段说明)<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190401204007393.png" alt="image"></p>
</li>
<li><p><code>jstat -option pid peroid times</code>(周期监控)<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190401204040778.png" alt="image"></p>
</li>
</ul>
<h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p><code>jinfo</code>进行指定参数的查询。</p>
<h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p><code>jmap</code>用于内存管理。</p>
<ul>
<li><code>jmap -histo pid</code>（类数量 / 实例数量）</li>
<li><code>jmap -dump:format=b,file=file</code>导出运行信息以便于后续线下分析。</li>
</ul>
<h4 id="jhat（JVM-Heap-Analysis-Tool）"><a href="#jhat（JVM-Heap-Analysis-Tool）" class="headerlink" title="jhat（JVM Heap Analysis Tool）"></a>jhat（JVM Heap Analysis Tool）</h4><ul>
<li><code>jhat a.bin</code>分析导出数据</li>
</ul>
<h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><table>
<thead>
<tr>
<th>options</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>打印方法栈</td>
</tr>
<tr>
<td>-F</td>
<td>强制打印</td>
</tr>
<tr>
<td>-m</td>
<td>本地方法栈</td>
</tr>
<tr>
<td>-l</td>
<td>打印锁信息</td>
</tr>
</tbody>
</table>
<ul>
<li><code>jstack pid</code></li>
<li><code>jstack -l pid</code>(锁信息，能看见线程状态)</li>
</ul>
<h4 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h4><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190401204425551.png" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190401204446766.png" alt="image"></p>
<h3 id="假设有下图所示的一个Full-GC-的图，纵向是内存使用情况，横向是时间，你如何排查这个Full-GC-的问题，怎么去解决你说出来的这些问题？"><a href="#假设有下图所示的一个Full-GC-的图，纵向是内存使用情况，横向是时间，你如何排查这个Full-GC-的问题，怎么去解决你说出来的这些问题？" class="headerlink" title="假设有下图所示的一个Full GC 的图，纵向是内存使用情况，横向是时间，你如何排查这个Full GC 的问题，怎么去解决你说出来的这些问题？"></a>假设有下图所示的一个Full GC 的图，纵向是内存使用情况，横向是时间，你如何排查这个Full GC 的问题，怎么去解决你说出来的这些问题？</h3><p> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG232.jpeg" alt="image"></p>
<h4 id="Full-GC的原因"><a href="#Full-GC的原因" class="headerlink" title="Full GC的原因"></a>Full GC的原因</h4><p>我们知道Full GC的触发条件大致情况有以下几种情况：</p>
<ol>
<li>程序执行了System.gc() //建议jvm执行fullgc，并不一定会执行</li>
<li>执行了jmap -histo:live pid命令 //这个会立即触发fullgc</li>
<li><p>在执行minor gc的时候进行的一系列检查</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行Minor GC的时候，JVM会检查老年代中最大连续可用空间是否大于了当前新生代所有对象的总大小。</span><br><span class="line">如果大于，则直接执行Minor GC（这个时候执行是没有风险的）。</span><br><span class="line">如果小于了，JVM会检查是否开启了空间分配担保机制，如果没有开启则直接改为执行<span class="literal">Full</span> GC。</span><br><span class="line">如果开启了，则JVM会检查老年代中最大连续可用空间是否大于了历次晋升到老年代中的平均大小，如果小于则执行改为执行<span class="literal">Full</span> GC。</span><br><span class="line">如果大于则会执行Minor GC，如果Minor GC执行失败则会执行<span class="literal">Full</span> GC</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用了大对象 //大对象会直接进入老年代</p>
</li>
<li>在程序中长期持有了对象的引用 //对象年龄达到指定阈值也会进入老年代</li>
</ol>
<p>对于我们的情况，可以初步排除1，2两种情况，最有可能是4和5这两种情况。为了进一步排查原因，我们在线上开启了 -XX:+HeapDumpBeforeFullGC。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">    JVM在执行dump操作的时候是会发生<span class="built_in">stop</span> <span class="keyword">the</span> <span class="built_in">word</span>事件的，也就是说此时所有的用户线程都会暂停运行。</span><br><span class="line">    为了在此期间也能对外正常提供服务，建议采用分布式部署，并采用合适的负载均衡算法</span><br></pre></td></tr></table></figure>
<h4 id="JVM参数的设置："><a href="#JVM参数的设置：" class="headerlink" title="JVM参数的设置："></a>JVM参数的设置：</h4><p>线上这个dubbo服务是分布式部署，在其中一台机子上开启了 -XX:HeapDumpBeforeFullGC，总体JVM参数如下：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">Xmx2g </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>+HeapDumpBeforeFullGC </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>HeapDumpPath=. </span></span><br><span class="line"><span class="ruby">-<span class="symbol">Xloggc:</span>gc.log </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>+PrintGC </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>+PrintGCDetails </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>+PrintGCDateStamps </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>+UseGCLogFileRotation </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>NumberOfGCLogFiles=<span class="number">10</span> </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>GCLogFileSize=<span class="number">100</span>m </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>HeapDumpOnOutOfMemoryError</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Dump文件分析"><a href="#Dump文件分析" class="headerlink" title="Dump文件分析"></a>Dump文件分析</h4><p>dump下来的文件大约1.8g，用jvisualvm查看，发现用char[]类型的数据占用了41%内存，同时另外一个com.alibaba.druid.stat.JdbcSqlStat类型的数据占用了35%的内存，也就是说整个堆中几乎全是这两类数据。如下图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20170411171801782.png" alt="image"></p>
<p>查看char[]类型数据，发现几乎全是sql语句。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20170411171833819.png" alt="image"></p>
<p>接下来查看char[]的引用情况：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20170411171909424.png" alt="image"></p>
<p>找到了JdbcSqlStat类，在代码中查看这个类的代码，关键代码如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数只有这一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcSqlStat</span>(<span class="params">String sql</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sql = sql;</span><br><span class="line">    <span class="keyword">this</span>.id = DruidDriver.createSqlStatId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看这个函数的调用情况，找到com.alibaba.druid.stat.JdbcDataSourceStat#createSqlStat方法：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> JdbcSqlStat <span class="title">createSqlStat</span>(<span class="params">String sql</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>.writeLock().<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JdbcSqlStat sqlStat = sqlStatMap.<span class="keyword">get</span>(sql);</span><br><span class="line">        <span class="keyword">if</span> (sqlStat == <span class="literal">null</span>) &#123;</span><br><span class="line">            sqlStat = <span class="keyword">new</span> JdbcSqlStat(sql);</span><br><span class="line">            sqlStat.setDbType(<span class="keyword">this</span>.dbType);</span><br><span class="line">            sqlStat.setName(<span class="keyword">this</span>.name);</span><br><span class="line">            sqlStatMap.put(sql, sqlStat);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sqlStat;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里用了一个map来存放所有的sql语句。</span></span><br></pre></td></tr></table></figure></p>
<p>其实到这里也就知道什么原因造成了这个问题，因为我们使用的数据源是阿里巴巴的druid，这个druid提供了一个sql语句监控功能，同时我们也开启了这个功能。只需要在配置文件中把这个功能关掉应该就能消除这个问题，事实也的确如此，关掉这个功能后到目前为止线上没再触发FullGC</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p> 如果用mat工具查看，建议把 “Keep unreachable objects” 勾上，否则mat会把堆中不可达的对象去除掉，这样我们的分析也许会变得没有意义。如下图：Window–&gt;References 。另外jvisualvm对ool的支持不是很好，如果需要oql建议使用mat。<br> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180713093200563.png" alt="image"></p>
<h3 id="说说对Java中集合类的理解，项目中用过哪些，哪个地方用的，如何使用的？"><a href="#说说对Java中集合类的理解，项目中用过哪些，哪个地方用的，如何使用的？" class="headerlink" title="说说对Java中集合类的理解，项目中用过哪些，哪个地方用的，如何使用的？"></a>说说对Java中集合类的理解，项目中用过哪些，哪个地方用的，如何使用的？</h3><p>从数据结构开始了解</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h5><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626162657335-766064343.png" alt="image"></p>
<ul>
<li>顺序存储结构(也叫顺序表)：一个线性表是n个具有相同特性的数据元素的有限序列。数据元素是一个抽象的符号，其具体含义在不同的情况下一般不同。</li>
<li>链表：链表里面节点的地址不是连续的，是通过指针连起来的。</li>
</ul>
<h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><p>解释一:<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626163141411-168462787.png" alt="image"><br>哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。</p>
<p>解释二:</p>
<p>数组的特点是：寻址容易，插入和删除困难；</p>
<p>而链表的特点是：寻址困难，插入和删除容易。</p>
<p>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法——拉链法，我们可以理解为“链表的数组”，如图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626163257503-1905188703.png" alt="image"></p>
<p>左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。</p>
<p>Hash 表的查询速度非常的快，几乎是O(1)的时间复杂度。</p>
<p>hash就是找到一种数据内容和数据存放地址之间的映射关系。</p>
<p>散列法：元素特征转变为数组下标的方法。</p>
<p>我想大家都在想一个很严重的问题：“如果两个字符串在哈希表中对应的位置相同怎么办？”,毕竟一个数组容量是有限的，这种可能性很大。解决该问题的方法很多，我首先想到的就是用“链表”。我遇到的很多算法都可以转化成链表来解决，只要在哈希表的每个入口挂一个链表，保存所有对应的字符串就OK了。</p>
<p>散列表的查找步骤 </p>
<p>当存储记录时，通过散列函数计算出记录的散列地址</p>
<p>当查找记录时，我们通过同样的是散列函数计算记录的散列地址，并按此散列地址访问该记录</p>
<p>优缺点</p>
<ul>
<li><p>优点：不论哈希表中有多少数据，查找、插入、删除（有时包括删除）只需要接近常量的时间即0(1）的时间级。实际上，这只需要几条机器指令。</p>
<p>  哈希表运算得非常快，在计算机程序中，如果需要在一秒种内查找上千条记录通常使用哈希表（例如拼写检查器)哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。</p>
<p>  如果不需要有序遍历数据，并且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。</p>
</li>
<li><p>缺点：它是基于数组的，数组创建后难于扩展，某些哈希表被基本填满时，性能下降得非常严重，所以程序员必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。</p>
</li>
</ul>
<h6 id="哈希表的原理："><a href="#哈希表的原理：" class="headerlink" title="哈希表的原理："></a>哈希表的原理：</h6><p>　　 1，对对象元素中的关键字(对象中的特有数据)，进行哈希算法的运算，并得出一个具体的算法值，这个值 称为哈希值。</p>
<p>　　2，哈希值就是这个元素的位置。</p>
<p>　　3，如果哈希值出现冲突，再次判断这个关键字对应的对象是否相同。如果对象相同，就不存储，因为元素重复。如果对象不同，就存储，在原来对象的哈希值基础 +1顺延。</p>
<p>　　4，存储哈希值的结构，我们称为哈希表。</p>
<p>　　5，既然哈希表是根据哈希值存储的，为了提高效率，最好保证对象的关键字是唯一的。</p>
<p>　　这样可以尽量少的判断关键字对应的对象是否相同，提高了哈希表的操作效率。</p>
<h6 id="扩展"><a href="#扩展" class="headerlink" title="扩展:"></a>扩展:</h6><p>相同的字符串如果存进去，哈希值相同并且equals方法为true，不会存入相同的</p>
<p>只要哈希值相同或者equals方法为true都成立才不会存入，只要其中一条不满足，都会储存</p>
<h6 id="哈希表存储过程："><a href="#哈希表存储过程：" class="headerlink" title="哈希表存储过程："></a>哈希表存储过程：</h6><p>1.调用对象的哈希值(通过一个函数f()得到哈希值):存储位置 = f(关键字)</p>
<p>2.集合在容器内搜索有没有重复的哈希值，如果没有，存入新元素，记录哈希值</p>
<p>3.再次存储，重复上边的过程</p>
<p>4.如果有重复的哈希值，调用后来者的equals方法，参数为前来者，结果得到true，集合判断为重复元素，不存入</p>
<h6 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h6><p>然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？</p>
<h6 id="哈希冲突的解决方案有多种"><a href="#哈希冲突的解决方案有多种" class="headerlink" title="哈希冲突的解决方案有多种:"></a>哈希冲突的解决方案有多种:</h6><p>开放定址法（发生冲突，继续寻找下一块未被占用的存储地址）</p>
<p>再散列函数法</p>
<p>链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式</p>
<p>关于hashcode和equals的一些问题，在面试中会问道：</p>
<p>1.两个对象哈希值相同，那么equals方法一定返回true吗？</p>
<p>不一定:取决于如何重写equals，如果重写固定了它返回false，结果就一定是false</p>
<p>2.equals方法返回true，那么哈希值一定相同吗？</p>
<p>一定:如果类中定义一个静态变量（static int a = 1），然后重写hashcode返回a+1，那么每一个对象的哈希值都不一样,不过java中规定：对象相等，必须具有相同的哈希码值，所以这里是一定的</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n) </p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>1.数组</p>
<ul>
<li><p>优点：(1)随机访问效率高(根据下标查询)，(2)搜索效率较高(可使用折半方法)。</p>
</li>
<li><p>缺点：(1)内存连续且固定，存储效率低。(2)插入和删除效率低(可能会进行数组拷贝或扩容)。</p>
</li>
</ul>
<p>2.链表</p>
<ul>
<li><p>优点：(1)不要求连续内存，内存利用率高，(2)插入和删除效率高(只需要改变指针指向)。</p>
</li>
<li><p>缺点：(1)不支持随机访问，(2)搜索效率低(需要遍历)。</p>
</li>
</ul>
<p>3.Hash表</p>
<ul>
<li><p>优点：(1)搜索效率高，(2)插入和删除效率较高，</p>
</li>
<li><p>缺点：(1)内存利用率低(基于数组)，(2)存在散列冲突。</p>
</li>
</ul>
<h4 id="集合类种重要概念词解释"><a href="#集合类种重要概念词解释" class="headerlink" title="集合类种重要概念词解释"></a>集合类种重要概念词解释</h4><h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><p>java中很重要的概念, 集合里面应用很多.</p>
<p>集合的元素，可以是任意类型对象的引用，如果把某个对象放入集合，则会忽略它的类型，就会把它当做Object类型处理.</p>
<p>泛型则是规定了某个集合只可以存放特定类型的对象的引用，会在编译期间进行类型检查,可以直接指定类型来获取集合元素</p>
<p>在泛型集合中有能够存入泛型类型的对象实例还可以存入泛型的子类型的对象实例</p>
<p>注意：</p>
<p>1 泛型集合中的限定类型，不能使用基本数据类型</p>
<p>2 可以通过使用包装类限定允许存放基本数据类型</p>
<p>泛型的好处</p>
<p>1 提高了安全性（将运行期的错误转换到编译期）</p>
<p>2 省去强转的麻烦</p>
<h5 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h5><p>1 就是一个十进制的整数，有操作系统随机给出</p>
<p>2 可以使用Object类中的方法hashCode获取哈希值</p>
<p>3 Object中源码: int hashCode()返回该对象的哈希码值；</p>
<p>　　源码：</p>
<p>　　　　public native int hashCode();</p>
<p>　　　　native:指调用了本地操作系统的方法实现</p>
<h5 id="平衡二叉树-称AVL树"><a href="#平衡二叉树-称AVL树" class="headerlink" title="平衡二叉树(称AVL树)"></a>平衡二叉树(称AVL树)</h5><p>其特点是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个子节点，其左右子树的高度都相近。</p>
<p>注意:</p>
<p>关键点是左子树和右子树的深度的绝对值不超过1</p>
<p>那什么是左子树深度和右子树深度呢?</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626163747154-56316670.png" alt="image"><br>如上图中:</p>
<p>如果插入6元素, 则8的左子树深度就为2, 右子树深度就为0,绝对值就为2, 就不是一个平很二叉树</p>
<h6 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h6><p>1若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
<p>2若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>3左、右子树也分别为二叉排序树</p>
<p>解释一:</p>
<p>现在有a[10] = {3, 2, 1, 4, 5, 6, 7, 10, 9, 8}需要构建二叉排序树。在没有学习平衡二叉树之前，根据二叉排序树的特性，通常会将它构建成如下左图。虽然完全符合二叉排序树的定义，但是对这样高度达到8的二叉树来说，查找是非常不利的。因此，更加期望构建出如下右图的样子，高度为4的二叉排序树，这样才可以提供高效的查找效率。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626163840863-763737563.png" alt="image"><br>平衡二叉树是一种二叉排序树，是一种高度平衡的二叉树，其中每个结点的左子树和右子树的高度至多等于1.意味着：要么是一棵空树，要么左右都是平衡二叉树，且左子树和右子树深度之绝对值不超过1. 将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p>
<p>平衡二叉树的前提是它是一棵二叉排序树。</p>
<h6 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h6><p>假设一颗 AVL 树的某个节点为 r，有四种操作会使 r 的左右子树高度差大于 1，从而破坏了原有 AVL 树的平衡性。使用旋转达到平衡性</p>
<p>1.对 r 的左儿子的左子树进行一次插入（左旋转 LL）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626163919941-1822754534.png" alt="image"><br>2.对 r 的左儿子的右子树进行一次插入（LR）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626164125162-953176289.png" alt="image"><br>3.对 r 的右儿子的左子树进行一次插入（RL）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626164216908-1934757880.png" alt="image"><br>4.对 r 的右儿子的右子树进行一次插入（RR）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626164301670-331612976.png" alt="image"></p>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>红黑树（Red Black Tree） 是一种自平衡二叉查找树</p>
<p>(1) 检索效率O(log n)</p>
<p>(2) 红黑树的五点规定：</p>
<p>1.每个结点要么是红的要么是黑的</p>
<p>2.根结点是黑的</p>
<p>3.每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的</p>
<p>4.如果一个结点是红的，那么它的两个儿子都是黑的（反之不一定）</p>
<p>5.对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点</p>
<p>它的每个结点都额外有一个颜色的属性，颜色只有两种：红色和黑色。</p>
<p>示例:(这块难度比较大, 建议自行百度,查阅相关文档)</p>
<p>红黑树插入操作</p>
<p>如果是第一次插入,由于原树为空,所以只会违反红黑树的规则2,所以只要把根节点涂黑即可；</p>
<p>如果插入节点的父节点是黑色的，那不会违背红-黑树的规则，什么也不需要做；</p>
<p>但是遇到如下三种情况时，我们就要开始变色和旋转了：</p>
<pre><code>1. 插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色的；

2. 插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的右子节点；

3. 插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点。

下面我们先挨个分析这三种情况都需要如何操作:

对于情况1：插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色的。此时，肯定存在祖父节点，但是不知道父节点是其左子节点还是右子节点，但是由于对称性，我们只要讨论出一边的情况，另一种情况自然也与之对应。
</code></pre><p>这里考虑父节点是祖父节点的左子节点的情况(即插入一个4节点,插入的节点一般为红色,不然可能违反规则5.),如下左图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626164550259-105010205.jpg" alt="image"></p>
<p>对于这种情况，我们要做的操作有：将当前节点(4)的父节点(5)和叔叔节点(8)涂黑，将祖父节点(7)涂红，变成上右图所示的情况。再将当前节点指向其祖父节点，再次从新的当前节点开始算法。这样上右图就变成了情况2了。</p>
<p>对于情况2：插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的右子节点。我们要做的操作有：将当前节点(7)的父节点(2)作为新的节点，以新的当前节点为支点做左旋操作。完成后如左下图所示，这样左下图就变成情况3了。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626164758729-301674609.jpg" alt="image"></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626164805332-951627135.jpg" alt="image"></p>
<p>   对于情况3：插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点。我们要做的操作有：将当前节点的父节点(7)涂黑，将祖父节点(11)涂红，在祖父节点为支点做右旋操作。最后把根节点涂黑，整个红-黑树重新恢复了平衡，如右上图所示。至此，插入操作完成！</p>
<p>我们可以看出，如果是从情况1开始发生的，必然会走完情况2和3，也就是说这是一整个流程，当然咯，实际中可能不一定会从情况1发生，如果从情况2开始发生，那再走个情况3即可完成调整，如果直接只要调整情况3，那么前两种情况均不需要调整了。故变色和旋转之间的先后关系可以表示为：变色-&gt;左旋-&gt;右旋。</p>
<h6 id="红黑树删除操作"><a href="#红黑树删除操作" class="headerlink" title="红黑树删除操作"></a>红黑树删除操作</h6><p>我们现在约定：后继节点的子节点称为“当前节点”.</p>
<p>删除节点有三种情况分析：</p>
<p>a. 叶子节点；(直接删除即可)<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626164943173-2121042227.jpg" alt="image"><br>b. 仅有左或右子树的节点；（上移子树即可）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626165004166-642012957.jpg" alt="image">　<br>c. 左右子树都有的节点。( 用删除节点的直接前驱或者直接后继来替换当前节点，调整直接前驱或者直接后继的位置)<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626165016051-1231487357.jpg" alt="image"><br>删除操作后，如果当前节点是黑色的根节点，那么不用任何操作，因为并没有破坏树的平衡性，即没有违背红-黑树的规则，这很好理解。如果当前节点是红色的，说明刚刚移走的后继节点是黑色的，那么不管后继节点的父节点是啥颜色，我们只要将当前节点涂黑就可以了，红-黑树的平衡性就可以恢复。但是如果遇到以下四种情况，我们就需要通过变色或旋转来恢复红-黑树的平衡了。</p>
<ol>
<li><p>当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）；</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的；</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点时黑色的；</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的右子节点是红色，左子节点任意颜色。</p>
</li>
</ol>
<p>以上四种情况中，我们可以看出2,3,4其实是“当前节点是黑色的，且兄弟节点是黑色的”的三种子集，等会在程序中可以体现出来。现在我们假设当前节点是左子节点（当然也可能是右子节点，跟左子节点相反即可，我们讨论一边就可以了），分别解决上面四种情况：</p>
<p>对于情况1：当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）。如左下图所示：A节点表示当前节点。针对这种情况，我们要做的操作有：将父节点（B）涂红，将兄弟节点（D）涂黑，然后将当前节点（A）的父节点（B）作为支点左旋，然后当前节点的兄弟节点就变成黑色的情况了（自然就转换成情况2，3,4的公有特征了），如右下图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626165124764-1792079285.jpg" alt="image"></p>
<p>对于情况2：当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的。如左下图所示，A表示当前节点。针对这种情况，我们要做的操作有：将兄弟节点（D）涂红，将当前节点指向其父节点（B），将其父节点指向当前节点的祖父节点，继续新的算法（具体见下面的程序），不需要旋转。这样变成了右下图所示的情况：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626165221571-2091816346.jpg" alt="image"></p>
<p>  对于情况3：当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点时黑色的。如左下图所示，A是当前节点。针对这种情况，我们要做的操作有：把当前节点的兄弟节点（D）涂红，把兄弟节点的左子节点（C）涂黑，然后以兄弟节点作为支点做右旋操作。然后兄弟节点就变成黑色的，且兄弟节点的右子节点变成红色的情况（情况4）了。如右下图：<br>  <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626165301994-226570115.jpg" alt="image"></p>
<p>对于情况4：当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的右子节点是红色，左子节点任意颜色。如左下图所示：A为当前节点，针对这种情况，我们要做的操作有：把兄弟节点（D）涂成父节点的颜色，再把父节点（B）涂黑，把兄弟节点的右子节点（E）涂黑，然后以当前节点的父节点为支点做左旋操作。至此，删除修复算法就结束了，最后将根节点涂黑即可。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626165338024-2048461274.jpg" alt="image"><br>我们可以看出，如果是从情况1开始发生的，可能情况2，3，4中的一种：如果是情况2，就不可能再出现3和4；如果是情况3，必然会导致情况4的出现；如果2和3都不是，那必然是4。当然咯，实际中可能不一定会从情况1发生，这要看具体情况了。</p>
<h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><h6 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h6><p>把访问逻辑从不同类型的集合类中抽取出来，从而避免向外部暴露集合的内部结构。在java中它是一个对象，其目的是遍历并选中其中的每个元素，而使用者（客户端）无需知道里面的具体细节。</p>
<h6 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h6><p>Collection集合元素的通用获取方式：在取出元素之前先判断集合中有没有元素。如果有，就把这个元素取出来，继续再判断，如果还有就再取出来，一直把集合中的所有元素全部取出来，这种取出元素的方式专业术语称为迭代。</p>
<p>java.util.Iterator:在Java中Iterator为一个接口，它只提供了迭代的基本规则。在JDK中它是这样定义的：对Collection进行迭代的迭代器。迭代器取代了Java Collection Framework中的Enumeration。</p>
<p>Collection中有一个抽象方法iterator方法，所有的Collection子类都实现了这个方法；返回一个Iterator对象</p>
<p>定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;<span class="comment">//判断是否存在下一个对象元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;<span class="comment">//获取下一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;<span class="comment">//移除元素</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用Iterator的时候禁止对所遍历的容器进行改变其大小结构的操作。例如: 在使用Iterator进行迭代时，如果对集合进行了add、remove操作就会出现ConcurrentModificationException异常。</p>
<p>在进行集合元素取出的时候，如果集合中没有元素了，还继续使用next()方法的话，将发生NoSuchElementException没有集合元素的错误</p>
<p>修改并发异常：在迭代集合中元素的过程中，集合的长度发生改变（进行了元素增加或者元素删除的操作), 增强for的底层原理也是迭代器，所以也需要避免这种操作；</p>
<p>解决以上异常的方法:使用ListIterator</p>
<p>任何集合都有迭代器。</p>
<p>任何集合类，都必须能以某种方式存取元素，否则这个集合容器就没有任何意义。</p>
<p>迭代器，也是一种模式（也叫迭代器模式）。迭代器要足够的“轻量”——创建迭代器的代价小。</p>
<h6 id="Iterable-1-5"><a href="#Iterable-1-5" class="headerlink" title="Iterable(1.5)"></a>Iterable(1.5)</h6><p>Java中还提供了一个Iterable接口，Iterable接口实现后的功能是‘返回’一个迭代器，我们常用的实现了该接口的子接口有:<code>Collection&lt;E&gt;</code>、<code>List&lt;E&gt;</code>、<code>Set&lt;E&gt;</code>等。该接口的iterator()方法返回一个标准的Iterator实现。实现Iterable接口允许对象成为Foreach语句的目标。就可以通过foreach语句来遍历你的底层序列。</p>
<p>Iterable接口包含一个能产生Iterator对象的方法，并且Iterable被foreach用来在序列中移动。因此如果创建了实现Iterable接口的类，都可以将它用于foreach中。</p>
<p>定义:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Package java.lang; import java.util.Iterator; public<span class="built_in"> interface </span>Iterable&lt;T&gt; &#123;    Iterator&lt;T&gt; iterator(); &#125;</span><br></pre></td></tr></table></figure>
<p>Iterable是Java 1.5的新特性, 主要是为了支持forEach语法, 使用容器的时候, 如果不关心容器的类型, 那么就需要使用迭代器来编写代码. 使代码能够重用.</p>
<p>使用方法很简单:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">String</span>&gt; strs = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>); <span class="keyword">for</span> (<span class="keyword">String</span> <span class="built_in">str</span>: strs) &#123;    out.<span class="built_in">println</span>(<span class="built_in">str</span>); &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>好处：代码减少，方便遍历</li>
<li>弊端：没有索引，不能操作容器里的元素</li>
</ul>
<p>增强for循环底层也是使用了迭代器获取的，只不过获取迭代器由jvm完成，不需要我们获取迭代器而已，所以在使用增强for循环变量元素的过程中不准使用集合对象对集合的元素个数进行修改；</p>
<h6 id="forEach-1-8"><a href="#forEach-1-8" class="headerlink" title="forEach()(1.8)"></a>forEach()(1.8)</h6><p>使用接收lambda表达式的forEach方法进行快速遍历.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; strs = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>); <span class="comment">// 使用Java 1.8的lambda表达式 strs.forEach(out::println);</span></span><br></pre></td></tr></table></figure>
<h6 id="Spliterator迭代器"><a href="#Spliterator迭代器" class="headerlink" title="Spliterator迭代器"></a>Spliterator迭代器</h6><p>Spliterator是1.8新增的迭代器,属于并行迭代器,可以将迭代任务分割交由多个线程来进行。</p>
<p>Spliterator可以理解为Iterator的Split版本（但用途要丰富很多）。使用Iterator的时候，我们可以顺序地遍历容器中的元素，使用Spliterator的时候，我们可以将元素分割成多份，分别交于不于的线程去遍历，以提高效率。使用 Spliterator 每次可以处理某个元素集合中的一个元素 — 不是从 Spliterator 中获取元素，而是使用 tryAdvance() 或 forEachRemaining() 方法对元素应用操作。但Spliterator 还可以用于估计其中保存的元素数量，而且还可以像细胞分裂一样变为一分为二。这些新增加的能力让流并行处理代码可以很方便地将工作分布到多个可用线程上完成</p>
<h6 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h6><p>ListIterator是一个更强大的Iterator子类型，能用于各种List类访问，前面说过Iterator支持单向取数据，ListIterator可以双向移动，所以能指出迭代器当前位置的前一个和后一个索引，可以用set方法替换它访问过的最后一个元素。我们可以通过调用listIterator方法产生一个指向List开始处的ListIterator，并且还可以用过重载方法listIterator(n)来创建一个指定列表索引为n的元素的ListIterator。</p>
<p>ListIterator可以往前遍历，添加元素，设置元素</p>
<p>Iterator和ListIterator的区别：</p>
<p>两者都有next()和hasNext()，可以实现向后遍历，但是ListIterator有previous()和hasPrevious()方法，即可以实现向前遍历</p>
<p>ListIterator可以定位当前位置，nextIndex()和previous()可以实现</p>
<p>ListIterator有add()方法，可以向list集合中添加数据</p>
<p>都可以实现删除操作，但是ListIterator可以实现对对象的修改，set()可以实现，Iterator仅能遍历，不能修改</p>
<h6 id="Fail-Fast"><a href="#Fail-Fast" class="headerlink" title="Fail-Fast"></a>Fail-Fast</h6><p>类中的iterator()方法和listIterator()方法返回的iterators迭代器是fail-fast的：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<p>迭代器与枚举有两点不同:</p>
<p>　　1. 迭代器在迭代期间可以从集合中移除元素。</p>
<p>　　2. 方法名得到了改进，Enumeration的方法名称都比较长。</p>
<p>迭代器的好处：屏蔽了集合之间的不同，可以使用相同的方式取出</p>
<h4 id="集合类概念"><a href="#集合类概念" class="headerlink" title="集合类概念"></a>集合类概念</h4><h5 id="集合类的作用"><a href="#集合类的作用" class="headerlink" title="集合类的作用"></a>集合类的作用</h5><p>集合类也叫做容器类，和数组一样，用于存储数据，但数组类型单一，并且长度固定，限制性很大，而集合类可以动态增加长度。</p>
<p>集合存储的元素都是对象(引用地址)，所以集合可以存储不同的数据类型，但如果是需要比较元素来排序的集合，则需要类型一致。</p>
<p>集合中提供了统一的增删改查方法，使用方便。</p>
<p>支持泛型，避免数据不一致和转换异常，还对常用的数据结构进行了封装。</p>
<p>所有的集合类的都在java.util包下。</p>
<h5 id="集合框架体系的组成"><a href="#集合框架体系的组成" class="headerlink" title="集合框架体系的组成"></a>集合框架体系的组成</h5><p>集合框架体系是由Collection、Map(映射关系)和Iterator(迭代器)组成，各部分的作用如下所示。</p>
<h6 id="Collection体系中有三种集合：Set、List、Queue"><a href="#Collection体系中有三种集合：Set、List、Queue" class="headerlink" title="Collection体系中有三种集合：Set、List、Queue"></a>Collection体系中有三种集合：Set、List、Queue</h6><p> Set(集)： 元素是无序的且不可重复。</p>
<p> List(列表)：元素是有序的且可重复。</p>
<p> Queue(队列)：封装了数据结构中的队列。</p>
<h6 id="Map体系"><a href="#Map体系" class="headerlink" title="Map体系"></a>Map体系</h6><p> Map用于保存具有映射关系的数据，即key-value(键值对)。Map集合的key是唯一的，不可重复，而value可以重复。所以一个value可以对应多个key。</p>
<p> Map体系除了常用类之外，还有Properties（属性类）也属于Map体系。</p>
<h6 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator(迭代器)"></a>Iterator(迭代器)</h6><p>请查看上面!</p>
<h5 id="Collection的由来"><a href="#Collection的由来" class="headerlink" title="Collection的由来"></a>Collection的由来</h5><p>  由于数组中存放对象，对对象操作起来不方便。java中有一类容器，专门用来存储对象。</p>
<p> 集合可以存储多个元素,但我们对多个元素也有不同的需求</p>
<p> 多个元素,不能有相同的</p>
<p> 多个元素,能够按照某个规则排序</p>
<p> 针对不同的需求：java就提供了很多集合类，多个集合类的数据结构不同。但是，结构不重要，重要  的是能够存储东西,能够判断,获取.</p>
<p>把集合共性的内容不断往上提取,最终形成集合的继承体系—-&gt;Collection</p>
<p>并且所有的Collection实现类都重写了toString()方法.</p>
<h5 id="集合和数组"><a href="#集合和数组" class="headerlink" title="集合和数组"></a>集合和数组</h5><p>集合与数组的区别：</p>
<ul>
<li>数组的长度固定的，而集合长度时可变的<br>数组只能储存同一类型的元素，而且能存基本数据类型和引用数据类型。集合可以存储不同类型的元素，只能存储引用数据类型</li>
</ul>
<p>集合类和数组不一样,数组元素既可以是基本类型的值,也可以是对象(实际上保存的是对象的引用变量);而集合只能保存对象。</p>
<p>数组和集合的主要区别包括以下几个方面：</p>
<ul>
<li>数组声明了它容纳的元素的类型，而集合不声明。这是由于集合以object形式来存储它们的元素。</li>
<li>一个数组实例具有固定的大小，不能伸缩。集合则可根据需要动态改变大小。</li>
<li>数组是一种可读/可写数据结构没有办法创建一个只读数组。然而可以使用集合提供的ReadOnly方   只读方式来使用集合。该方法将返回一个集合的只读版本。</li>
</ul>
<p>集合的作用：</p>
<p>如果一个类的内部有很多相同类型的属性，并且他们的作用与意义是一样的，比如说学生能选课学生类就有很多课程类型的属性，或者工厂类有很多机器类型的属性，我们用一个类似于容器的集合去盛装他们，这样在类的内部就变的井然有序———这就是：</p>
<ul>
<li>在类的内部，对数据进行组织的作用。</li>
<li>简单而快速的搜索查找其中的某一条元素</li>
<li>有的集合接口，提供了一系列排列有序的元素，并且可以在序列中间快速的插入或者删除有关元素。</li>
<li>有的集合接口在其内部提供了映射关系的结构，可以通过关键字(key)去快速查找对应的唯一对象，而这个关键可以是任意类型的。</li>
</ul>
<h5 id="泛型与集合的区别"><a href="#泛型与集合的区别" class="headerlink" title="泛型与集合的区别"></a>泛型与集合的区别</h5><p>泛型听起来很高深的一个词，但实际上它的作用很简单，就是提高java程序的性能。 </p>
<p>比如在计算机中经常用到一些数据结构，如队列，链表等，而其中的元素以前一般这么定义：object a=new object(); </p>
<p>这样就带来一个严重的问题，用object来表示元素没有逻辑问题，但每次拆箱、封箱就占用了大量的计算机资源，导致程序性能低下，而这部分内容恰恰一般都是程序的核心部分，如果使用object，那么程序的表现就比较糟糕。</p>
<p>而使用泛型则很好的解决这个问题，本质就是在编译阶段就告诉编译器，数据结构中元素的种类，既然编译器知道了元素的种类，自然就避免了拆箱、封箱的操作，从而显著提高java程序的性能。 </p>
<p>比如<code>List&lt;string&gt;</code>就直接使用string对象作为List的元素，而避免使用object对象带来的封箱、拆箱操作，从而提高程序性能。</p>
<h4 id="集合接口与类"><a href="#集合接口与类" class="headerlink" title="集合接口与类"></a>集合接口与类</h4><h5 id="数组和集合一般就用到下面接口和集合"><a href="#数组和集合一般就用到下面接口和集合" class="headerlink" title="数组和集合一般就用到下面接口和集合"></a>数组和集合一般就用到下面接口和集合</h5><p>Array  数组</p>
<p>Arrays  数组工具</p>
<p>Collection 最基本的集合接口</p>
<p>Collections  集合工具类</p>
<p>List  接口</p>
<p>ArrayList 一种可以动态增长和缩减的索引序列</p>
<p>LinkedList 一种可以在任何位置进行高效地插入和删除操作的有序序列</p>
<p>Vector</p>
<p>Set</p>
<p>HashSet 一种没有重复元素的无序集合</p>
<p>TreeSet 一种有序集</p>
<p>LinkHashSet 一种可以记住元素插入次序的集合</p>
<p>map</p>
<p>HashMap 一种存储key：value关联的映射</p>
<p>HashTable</p>
<p>TreeMap 一种key有序的映射</p>
<p>LinkedHashMap 一种可以记住插入次序的映射</p>
<p>Deque</p>
<p>Stack</p>
<p>ArrayDeque  一种用循环数组实现的双端队列</p>
<p>Queue</p>
<p>PriorityQueue 一种可以高效删除最小元素的集合</p>
<h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><p>数组：是以一段连续内存保存数据的；随机访问是最快的,但不支持插入,删除,迭代等操作。</p>
<p>Array可以包含基本类型和对象类型</p>
<p>Array大小是固定的</p>
<p>指定数组引用为 null，则此类中的方法都会抛出 NullPointerException。</p>
<p>所创建的对象都放在堆中。</p>
<p>够对自身进行枚举(因为都实现了IEnumerable接口)。</p>
<p>具有索引(index),即可以通过index来直接获取和修改任意项。</p>
<p>Array类型的变量在声明的同时必须进行实例化(至少得初始化数组的大小)，而ArrayList可以只是先声明。</p>
<p> Array只能存储同构的对象，而ArrayList可以存储异构的对象。</p>
<p>在CLR托管对中的存放方式</p>
<p>Array是始终是连续存放的，而ArrayList的存放不一定连续。</p>
<p>Array不能够随意添加和删除其中的项，而ArrayList可以在任意位置插入和删除项。</p>
<p>采用数组存在的一些缺陷：</p>
<p>   1.数组长度固定不变，不能很好地适应元素数量动态变化的情况。</p>
<p>   2.可通过数组名.length获取数组的长度，却无法直接获取数组中真实存储的个数。</p>
<p>   3.在进行频繁插入、删除操作时同样效率低下。</p>
<h5 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h5><p>数组的工具类,里面都是操作数组的工具.</p>
<p>常用方法:</p>
<p>1、数组的排序:Arrays.sort(a);//实现了对数组从小到大的排序//注：此类中只有升序排序，而无降序排序。</p>
<p>2、数组元素的定位查找:Arrays.binarySearch(a,8);//二分查找法</p>
<p>3、数组的打印:Arrays.toString(a);//String 前的a和括号中的a均表示数组名称</p>
<p>4、 查看数组中是否有特定的值:Arrays.asList(a).contains(1);</p>
<h5 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h5><p>Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些 Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java SDK不提供直接继承自Collection的类， Java SDK提供的类都是继承自Collection的“子接口”如List和Set。</p>
<p>所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个Collection参数的构造函数用于创建一个新的 Collection，这个新的Collection与传入的Collection有相同的元素。后一个构造函数允许用户复制一个Collection。</p>
<p>如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：</p>
<p>　　　　Iterator it = collection.iterator(); // 获得一个迭代子</p>
<p>　　　　while(it.hasNext()) {</p>
<p>　　　　　　Object obj = it.next(); // 得到下一个元素</p>
<p>由Collection接口派生的两个接口是List和Set。</p>
<p>Collection返回的是Iterator迭代器接口，而List中又有它自己对应的实现–&gt;ListIterator接口 Collection。标识所含元素的序列，这里面又包含多种集合类，比如List，Set，Queue；它们都有各自的特点，比如List是按顺序插入元素，Set是不重复元素集合，Queue则是典型的FIFO结构</p>
<p>Collection接口描述：</p>
<p>　　Collection接口常用的子接口有List 接口和Set接口</p>
<p>　　List接口中常用的子类有：ArrayList类（数组列表）和LinkedList（链表）</p>
<p>　　Set接口中常用的子类有：HashSet （哈希表）和LinkedHashSet（基于链表的哈希表）</p>
<p>Collection 层次结构 中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接 实现：它提供更具体的子接口（如 Set和 List）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。（面向接口的编程思想）</p>
<h5 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h5><h6 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h6><p>Collections提供以下方法对List进行排序操作</p>
<p>void reverse(List list)：反转</p>
<p>void shuffle(List list),随机排序</p>
<p>void sort(List list),按自然排序的升序排序</p>
<p>void sort(List list, Comparator c);定制排序，由Comparator控制排序逻辑</p>
<p>void swap(List list, int i , int j),交换两个索引位置的元素</p>
<p>void rotate(List list, int distance),旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。</p>
<h6 id="查找，替换操作"><a href="#查找，替换操作" class="headerlink" title="查找，替换操作"></a>查找，替换操作</h6><p>int binarySearch(List list, Object key), 对List进行二分查找，返回索引，注意List必须是有序的</p>
<p>int max(Collection coll),根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</p>
<p>int max(Collection coll, Comparator c)，根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</p>
<p>void fill(List list, Object obj),用元素obj填充list中所有元素</p>
<p>int frequency(Collection c, Object o)，统计元素出现次数</p>
<p>int indexOfSubList(List list, List target), 统计targe在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</p>
<p>boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素。</p>
<h6 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h6><p>Collections中几乎对每个集合都定义了同步控制方法, 这些方法，来将集合包装成线程安全的集合</p>
<p> SynchronizedList(List);</p>
<p> SynchronizedSet(Set;</p>
<p>  SynchronizedMap(Map);</p>
<p>SynchronizedMap和ConcurrentHashMap 区别</p>
<p>Collections.synchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步，而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁。所以，只要要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。这样，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。同时，同步操作精确控制到桶，所以，即使在遍历map时，其他线程试图对map进行数据修改，也不会抛出ConcurrentModificationException。</p>
<p>ConcurrentHashMap从类的命名就能看出，它必然是个HashMap。而Collections.synchronizedMap()可以接收任意Map实例，实现Map的同步</p>
<p>线程安全，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hashtable，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</p>
<p>List本身是Collection接口的子接口，具备了Collection的所有方法。</p>
<p>List的特有方法都有索引，这是该集合最大的特点。</p>
<p>List集合支持对元素的增、删、改、查。</p>
<p>List中存储的元素实现类排序，而且可以重复的存储相关元素。</p>
<p>次序是List最重要的特点：它保证维护元素特定的顺序。</p>
<p>List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。</p>
<p>和下面要提到的Set不同，List允许有相同的元素。</p>
<p>除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个 ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历。</p>
<p>优点：操作读取操作效率高，基于数组实现的，可以为null值，可以允许重复元素，有序，异步。</p>
<p>缺点：由于它是由动态数组实现的，不适合频繁的对元素的插入和删除操作，因为每次插入和删除都需要移动数组中的元素。</p>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p>ArrayList 是基于数组实现，内存中分配连续的空间，需要维护容量大小。随机访问.</p>
<p>ArrayList就是动态数组，也是一个对象。</p>
<p>ArrayList不自定义位置添加元素和LinkedList性能没啥区别，ArrayList默认元素追加到数组后面，而LinkedList只需要移动指针，所以两者性能相差无几。</p>
<p>如果ArrayList自定义位置插入元素，越靠前，需要重写排序的元素越多，性能消耗越大，LinkedList无论插入任何位置都一样，只需要创建一个新的表项节点和移动一下指针，性能消耗很低。</p>
<p>ArrayList是基于数组，所以查看任意位置元素只需要获取当前位置的下标的数组就可以，效率很高，然而LinkedList获取元素需要从最前面或者最后面遍历到当前位置元素获取，如果集合中元素很多，就会效率很低，性能消耗大。</p>
<p>频繁遍历查看元素,使用 ArrayList 集合,ArrayList 查询快，增删慢</p>
<p>ArrayList线程不安全的</p>
<p>1、ArrayList是用数组实现的，该对象存放在堆内存中，这个数组的内存是连续的，不存在相邻元素之间还隔着其他内存。底层是一个可动态扩容的数组</p>
<p>2、索引ArrayList时，速度比原生数组慢是因为你要用get方法，这是一个函数调用，而数组直接用[ ]访问，相当于直接操作内存地址，速度当然比函数调用快。</p>
<p>3、新建ArrayList的时候，JVM为其分配一个默认或指定大小的连续内存区域（封装为数组）。</p>
<p>4、每次增加元素会检查容量，不足则创建新的连续内存区域（大小等于初始大小+步长），也用数组形式封装，并将原来的内存区域数据复制到新的内存区域，然后再用ArrayList中引用原来封装的数组对象的引用变量引用到新的数组对象：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">elementData</span> = Arrays.copyOf(elementData, newCapacity);</span><br></pre></td></tr></table></figure>
<p>　　ArrayList里面的removeIf方法就接受一个Predicate参数，采用如下Lambda表达式就能把，所有null元素删除:</p>
<figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>.removeIf(e -&gt; e == <span class="literal">null</span>)；</span><br></pre></td></tr></table></figure>
<p>　　　　</p>
<p>ArrayList：每次添加元素之前会检查是否需要扩容,是按照原数组的1.5倍延长。构造一个初始容量为 10 的空列表。</p>
<p>使用for适合循环ArrayLIst以及数组，当大批量的循环LinkedList时程序将会卡死，for适合循环数组结构，通过下标去遍历。</p>
<p>get访问List内部任意元素时，ArrayList的性能要比LinkedList性能好。LinkedList中的get方法是要按照顺序从列表的一端开始检查，直到另一端。</p>
<p>在ArrayList的 中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；</p>
<p>ArrayList的空 间浪费主要体现在在list列表的结尾预留一定的容量空间</p>
<p>ArrayList只能包含对象类型。</p>
<p>ArrayList的大小是动态变化的。 </p>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量</p>
<p>够对自身进行枚举(因为实现了IEnumerable接口)。</p>
<p>具有索引(index),即可以通过index来直接获取和修改任意项。</p>
<p>ArrayList允许存放（不止一个）null元素</p>
<p>允许存放重复数据，存储时按照元素的添加顺序存储</p>
<p>ArrayList可以存放任何不同类型的数据（因为它里面存放的都是被装箱了的Object型对象，实际上ArrayList内部就是使用”object[] _items;”这样一个私有字段来封装对象的）</p>
<p>ArrayList不是一个线程安全的集合，如果集合的增删操作需要保证线程的安全性，可以考虑使用CopyOWriteArrayList或者使用collections.synchronizedList(Lise l)函数返回一个线程安全的ArrayList类。</p>
<p> 实现了RandomAccess接口，底层又是数组，get读取元素性能很好</p>
<p> 顺序添加很方便</p>
<p> 删除和插入需要复制数组 性能很差（可以使用LinkindList）</p>
<p>为什么ArrayList的elementData是用transient修饰的？</p>
<p>transient修饰的属性意味着不会被序列化，也就是说在序列化ArrayList的时候，不序列化elementData。</p>
<p>为什么要这么做呢？</p>
<p> elementData不总是满的，每次都序列化，会浪费时间和空间</p>
<p> 重写了writeObject 保证序列化的时候虽然不序列化全部 但是有的元素都序列化</p>
<p>所以说不是不序列化 而是不全部序列化。</p>
<p>elementData属性采用了transient来修饰，不使用Java默认的序列化机制来实例化，自己实现了序列化writeObject()和反序列化readObject()的方法。</p>
<p>每次对下标的操作都会进行安全性检查，如果出现数组越界就立即抛出异常。</p>
<p>如果提前知道数组元素较多，可以在添加元素前通过调用ensureCapacity()方法提前增加容量以减小后期容量自动增长的开销。</p>
<p>当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。</p>
<p>ArrayList基于数组方式实现，容量限制不大于Integer.MAX_VALUE的小大，每次扩容1.5倍。有序，可以为null,允许重复，非线程安全。</p>
<p>增加和删除会修改modCount,在迭代的时候需要保持单线程的唯一操作，如果期间进行了插入或者删除操作，就会被迭代器检查获知，从而出现运行时异常。</p>
<p>一般建议在单线程中使用ArrayList。</p>
<p> 当在index处放置一个元素的时候，会将数组index处右边的元素全部右移</p>
<p> 当在index处删除一个元素的时候，会将数组index处右边的元素全部左移</p>
<p>ArrayList底层是数组结构，因为数组有维护索引，所以查询效率高；而做插入、删除操作时，因为要判断扩容（复制一份新数组）且数组中的元素可能要大规模的后移或前移一个索引位置，所以效率差。</p>
<p>Arrays.asList()方法返回的List集合是一个固定长度的List集合，不是ArrayList实例，也不是Vector的实例</p>
<p>ArrayList也采用了快速失败(Fail-Fast机制)的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。具体介绍请参考HashMap的实现原理中的Fail-Fast机制。</p>
<h5 id="linkedList"><a href="#linkedList" class="headerlink" title="linkedList"></a>linkedList</h5><p>LinkedList 是基于循环双向链表数据结构，不需要维护容量大小。顺序访问。</p>
<p>频繁插入删除元素 使用 LinkedList 集合</p>
<p>LinkedList 线程不安全的</p>
<p>LinkedList在随机访问方面相对比较慢，但是它的特性集较ArrayList 更大。</p>
<p>LinkedList提供了大量的首尾操作</p>
<p>LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。</p>
<p>LinkedList：底层基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。链表增删快，查找慢 </p>
<p>LinkedList由双链表实现，增删由于不需要移动底层数组数据，其底层是链表实现的，只需要修改链表节点指针，对元素的插入和删除效率较高。</p>
<p>LinkedList缺点是遍历效率较低。HashMap和双链表也有关系。</p>
<p>LinkedList是一个继承于AbstractSequentialList的双向链表，它可以被当做堆栈、队列或双端队列进行操作</p>
<p>LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</p>
<p>使用foreach适合循环LinkedList，使用双链表结构实现的应当使用foreach循环。</p>
<p>LinkedList实现了List接口，允许null元素。</p>
<p>LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> <span class="built_in">list</span> = Collections.synchronizedList(<span class="literal">new</span> LinkedList(…));</span><br></pre></td></tr></table></figure>
<p>在LinkedList的中间插入或删除一个元素的开销是固定的。 </p>
<p>LinkedList不支持高效的随机元素访问。 </p>
<p>LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间 </p>
<p>LinkedList是List和Deque接口的双向链表的实现。实现了所有可选列表操作，并允许包括null值。</p>
<p> Fail-Fast机制:LinkedList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>
<p>LinkedList因为底层为链表结构，查询时需要从头节点（或尾节点）开始遍历所以查询效率差；但同时也因为是链表结构，做插入、删除操作时只要断开当前删除节点前驱、后驱引用，并将原来的前、后节点的引用链接起来，所以效率高。</p>
<p>千万不要使用普通for循环遍历LinkedList，这么做会让你崩溃！可以选择使用foreach或迭代器来进行遍历操作</p>
<p> LinedList适合用迭代遍历；</p>
<p>基于链表结构的集合 LinkedList。LinkedList 属于 java.util 包下面，也实现Iterable接口，说明可以使用迭代器遍历；LinkedList 还实现 <code>Deque&lt;E&gt;</code>，<code>Queue&lt;E&gt;</code>操作。Deque 和 Queue 是 LinkedList 的父接口，那么 LinkedList 也可以看成一种 Deque 或者 Queue；Queue表示一种队列，也是一种数据结构，它的特点是先进先出，因此在队列这个接口里面提供了一些操作队列的方法，同时LinkedList也具有这些方法；Deque(Double ended queues双端队列)，支持在两端插入或者移除元素; 那也应该具有操作双端队列的一些方法；LinkedList 是他们的子类，说明都具有他们两者的方法；LinkedList也可以充当队列，双端队列，堆栈多个角色。</p>
<h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><p>Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。</p>
<p>Vector：是按照原数组的2倍延长。</p>
<p>Vector是基于线程安全的，效率低 元素有放入顺序，元素可重复 </p>
<p>Vector可以由我们自己来设置增长的大小，ArrayList没有提供相关的方法。</p>
<p>Vector相对ArrayList查询慢(线程安全的)</p>
<p>Vector相对LinkedList增删慢(数组结构)</p>
<p>以前还能见到Vector和Stack，但Vector太过古老，被ArrayList取代，所以这里不讲；而Stack已经被ArrayDeque取代。</p>
<p>对于想在迭代器迭代过程中针对集合进行增删改的，可以通过返回ListIterator来操作。</p>
<p>Vector：底层结构是数组，线程是安全的，添加删除慢，查找快，（同ArrayList）</p>
<p>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。</p>
<p>Vector 是矢量队列，它是JDK1.0版本添加的类。继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口。</p>
<p>Vector 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。</p>
<p>Vector 实现了Cloneable接口，即实现clone()函数。它能被克隆。</p>
<p>由Vector创建的Iterator，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。</p>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。</p>
<p>元素无放入顺序，元素不可重复（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的）</p>
<p>Set具有与Collection完全一样的接口，因此没有任何额外的功能,只是行为不同。这是继承与多态思想的典型应用：表现不同的行为。</p>
<p>Set不保存重复的元素(至于如何判断元素相同则较为负责)</p>
<p>存入Set的每个元素都必须是唯一的，因为Set不保存重复元素,加入Set的元素必须定义equals()方法以确保对象的唯一性。</p>
<p>Set 是基于对象的值来确定归属性的。</p>
<p>Set本身有去重功能是因为String内部重写了hashCode()和equals()方法，在add里实现了去重, Set集合是不允许重复元素的，但是集合是不知道我们对象的重复的判断依据的，默认情况下判断依据是判断两者是否为同一元素（euqals方法，依据是元素==元素），如果要依据我们自己的判断来判断元素是否重复，需要重写元素的equals方法（元素比较相等时调用）hashCode()的返回值是元素的哈希码，如果两个元素的哈希码相同，那么需要进行equals判断。【所以可以自定义返回值作为哈希码】 equals()返回true代表两元素相同，返回false代表不同。</p>
<p>set集合没有索引，只能用迭代器或增强for循环遍历</p>
<p>set的底层是map集合</p>
<p>Set最多有一个null元素</p>
<p>必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。</p>
<p>Set具有与Collection完全一样的接口，没有额外的任何功能。所以把Set就是Collection，只是行为不同（这就是多态）；Set是基于对象的值来判断归属的，由于查询速度非常快速，HashSet使用了散列，HashSet维护的顺序与TreeSet或LinkedHashSet都不同，因为它们的数据结构都不同，元素存储方式自然也不同。TreeSet的数据结构是“红-黑树”，HashSet是散列函数，LinkedHashSet也用了散列函数；如果想要对结果进行排序，那么选择TreeSet代替HashSet是个不错的选择</p>
<h5 id="Hashset"><a href="#Hashset" class="headerlink" title="Hashset"></a>Hashset</h5><p>HashSet : 为快速查找设计的Set。存入HashSet的对象必须定义hashCode()。</p>
<p>Hashset实现set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set的迭代顺序,别是它不保证该顺序恒久不变。此类允许使用Null元素</p>
<p>对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet的实现比较简单，相关HashSet的操作，基本上都说调用HashMap的相关方法来实现的</p>
<p>对于HashSet中保存的对象，请注意正确重写其equals和hashCode方法，以保证放入的对象的唯一性。</p>
<p>HashSet: 哈希表结构的集合 利用哈希表结果构成的集合查找速度会很快。</p>
<p>HashSet ： 底层数据结构是哈希表，线程 是不同步的 。 无序，高效；HashSet 集合保证元素唯一性 ：通过元素的 hashCode 方法，和 equals 方法完成的。当元素的 hashCode 值相同时，才继续判断元素的 equals 是否为 true。如果为 true，那么视为相同元素，不存。如果为 false，那么存储。如果 hashCode 值不同，那么不判断 equals，从而提高对象比较的速度。</p>
<p>HashSet类直接实现了Set接口， 其底层其实是包装了一个HashMap去实现的。HashSet采用HashCode算法来存取集合中的元素，因此具有比较好的读取和查找性能。</p>
<p>元素值可以为NULL,但只能放入一个null</p>
<p>　         HashSet集合保证元素唯一性：通过元素的hashCode方法，和equals方法完成的。</p>
<p>当元素的hashCode值相同时，才继续判断元素的equals是否为true。</p>
<p>如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。</p>
<p>对于HashSet集合，判断元素是否存在，或者删除元素，底层依据的是hashCode方法和equals方法。　　</p>
<p>特点：存储取出都比较快</p>
<p>1、不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。</p>
<p>2、HashSet不是同步的，必须通过代码来保证其同步。</p>
<p>3、集合元素可以是null.</p>
<p>原理：简单说就是链表数组结合体</p>
<p>对象的哈希值：普通的一个整数,可以理解为身份证号，是hashset存储的依据</p>
<p>HashSet按Hash算法来存储集合中的元素。在存取和查找上有很好的性能。</p>
<p>当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据该hashCode值决定该hashCode值决定该对象在HashSet中存储的位置。</p>
<p>如果有两个元素通过equals()方法比较返回true,但它们的hashCode()方法返回值不相等,hashSet将会把它们存储在不同位置，依然可以添加成功。如果两个对象的hashCode()方法返回的hashCode值相同，当它们的equals()方法返回false时，会在hashCode所在位置采用链式结构保存多个对象。这样会降低hashSet的查询性能。</p>
<p>在使用HashSet中重写hashCode()方法的基本原则</p>
<p>1、在程序运行过过程中，同一个对象多次调用hashCode()方法应该返回相同的值。</p>
<p>2、当两个对象的equals()方法比较返回true时，这个两个对象的hashCode()方法返回相同的值。</p>
<p>3、对象中用作equals()方法比较标准的实例变量，都应该用于计算hashCode值。 </p>
<p>把对象内的每个意义的实例变量(即每个参与equals()方法比较标准的实例变量)计算出一个int类型的hashCode值。用第1步计算出来的多个hashCode值组合计算出一个hashCode值返回 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> f1.hashCode()+(<span class="keyword">int</span>)f2;</span><br></pre></td></tr></table></figure>
<p>为了避免直接相加产生的偶然相等(两个对象的f1、f2实例变量并不相等，但他们的hashCode的和恰好相等)，可以通过为各个实例变量的hashCode值乘以一个质数后再相加</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">return</span> <span class="built_in">f1</span>.hashCode()*<span class="number">19</span>+<span class="built_in">f2</span>.hashCode()*<span class="number">37</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>如果向HashSet中添加一个可变的对象后，后面的程序修改了该可变对想的实例变量，则可能导致它与集合中的其他元素的相同（即两个对象的equals()方法比较返回true,两个对象的hashCode值也相等），这就有可能导致HashSet中包含两个相同的对象。</p>
<h5 id="Linkedhashset"><a href="#Linkedhashset" class="headerlink" title="Linkedhashset"></a>Linkedhashset</h5><p>LinkedHashSet : 具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序</p>
<p> LinkedHashSet 综合了链表+哈希表，根据元素的hashCode值来决定元素的存储位置，它同时使用链表维护元素的次序。</p>
<p>当遍历该集合时候，LinkedHashSet 将会以元素的添加顺序访问集合的元素。</p>
<p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。</p>
<p>这个相对于HashSet来说有一个很大的不一样是LinkedHashSet是有序的。LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p>
<p>与HashSet相比，特点：</p>
<p> 对集合迭代时，按增加顺序返回元素。</p>
<p> 性能略低于HashSet，因为需要维护元素的插入顺序。但迭代访问元素时会有好性能，因为它采用链表维护内部顺序。</p>
<p>LinkedHashSet不允许元素的重复</p>
<p>存储的顺序是元素插入的顺序。</p>
<h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>TreeSet : 保存次序的Set, 底层为树结构。使用它可以从Set中提取有序的序列。</p>
<p>TreeSet 继承AbstractSet类，实现NavigableSet、Cloneable、Serializable接口。与HashSet是基于HashMap实现一样，TreeSet 同样是基于TreeMap 实现的。由于得到Tree 的支持，TreeSet 最大特点在于排序，它的作用是提供有序的Set集合。</p>
<p>用于对 Set 集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。</p>
<p>如果元素不具备比较性，在运行时会抛出ClassCastException 异常。 所以元素需要实现Comparable 接口 ，让元素具备可比较性， 重写 compareTo 方法 。依据 compareTo 方法的返回值，确定元素在 TreeSet 数据结构中的位置。 或者用比较器方式，将Comparator对象传递给TreeSet构造器来告诉树集使用不同的比较方法</p>
<p>　</p>
<p>TreeSet底层的数据结构就是二叉树。</p>
<pre><code>　不能写入空数据

写入的数据是有序的。

不写入重复数据
</code></pre><p>TreeSet方法保证元素唯一性的方式：就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。</p>
<p>TreeSet集合排序有两种方式，Comparable和Comparator区别：</p>
<p>1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。</p>
<p>2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。</p>
<p>TreeSet类是SortedSet接口的实现类。因为需要排序，所以性能肯定差于HashSet。与HashSet相比，额外增加的方法有：</p>
<p>first()：返回第一个元素</p>
<p>last()：返回最后一个元素</p>
<p>lower(Object o)：返回指定元素之前的元素</p>
<p>higher(Obect o)：返回指定元素之后的元素</p>
<p>subSet(fromElement, toElement)：返回子集合</p>
<p>可以定义比较器（Comparator）来实现自定义的排序。默认自然升序排序。</p>
<p>TreeSet两种排序方式：自然排序和定制排序，默认情况下，TreeSet采用自然排序</p>
<p>TreeSet会调用集合元素的compareTo(Object object)方法来比较元素之间的大小关系，然后将元素按升序排列</p>
<p>如果试图把一个元素添加到TreeSet中，则该对象必须实现Comparable接口实现Comparable接口必须实现compareTo(Object object)，两个对象即通过这个方法进行比较Comparable的典型实现</p>
<p>BigDecimal、BigInteger以及所有的数值类型对应的包装类型，按对应的数值大小进行比较</p>
<p>Character：按字符的Unicode值进行比较</p>
<p>Boolean：true对应的包装类实例大于false包装类对应的实例</p>
<p>String：按字符对应的Unicode值进行比较</p>
<p>Date、Time：后面的时间、日期比前面的时间、日期大</p>
<p>向TreeSet中添加一个元素，只有第一个不需要使用compareTo()方法，后面的都要调用该方法</p>
<p>因为只有相同类的两个实例才会比较大小，所以向TreeSet中添加的应该是同一个类的对象</p>
<p>TreeSet采用红黑树的数据结构来存储集合元素</p>
<p>对于TreeSet集合而言，它判断两个对象的是否相等的唯一标准是:两个对象的通过compareTo(Object obj)方法比较是否返回0–如果通过compareTo(Object obj)方法比较返回0，TreeSet则会认为它们相等，否则认为它们不相等。对于语句，obj1.compareTo(obj2),如果该方法返回一个正整数，则表明obj1大于obj2;如果该方法返回一个负整数，则表明obj1小于obj2.</p>
<p>在默认的compareTo方法中，需要将的两个的类型的对象的转换同一个类型，因此需要将的保证的加入到TreeSet中的数据类型是同一个类型，但是如果自己覆盖compareTo方法时，没有要求两个对象强制转换成同一个对象，是可以成功的添加treeSet中</p>
<p>如果两个对象通过CompareTo(Object obj)方法比较返回0时，但它们通过equals()方法比较返回false时，TreeSet不会让第二个元素添加进去</p>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>Map主要用于存储健值对，根据键得到值，因此不允许键重复，但允许值重复。</p>
<p>Map接口概述：Java.util.Map&lt;k,v&gt;接口：是一个双列集合</p>
<p>Map集合的特点： 是一个双列集合，有两个泛型key和value，使用的时候key和value的数据类型可以相同。也可以不同.</p>
<p> Key不允许重复的，value可以重复的；</p>
<p> 一个key只能对应一个value</p>
<p>底层是一个哈希表（数组+单向链表）：查询快，增删快, 是一个无序集合</p>
<p>Map接口中的常用方法：</p>
<p> 1.get(key)  根据key值返回对应的value值，key值不存在则返回null</p>
<p> 2.put(key , value); 往集合中添加元素（key和value）</p>
<p> 　　注意：添加的时候，如果key不存在，返回值null</p>
<p> 　　如果Key已经存在的话，就会新值替换旧值，返回旧值</p>
<ol start="3">
<li>remove(key); 删除key值对应的键值对；如果key不存在 ，删除失败。返回值为     null，如果key存在则删除成功，返回值为删除的value</li>
</ol>
<p>Map遍历方式</p>
<p>第一种方式：通过key找value的方式：</p>
<p>　　　Map中有一个方法：</p>
<p>　　　　　　Set <k>  keySet();  返回此映射包含的键的Set 集合</k></p>
<p>　　　操作步骤:</p>
<p>  　　　1.调用Map集合的中方法keySet,把Map集合中所有的健取出来,存储到Set集合中</p>
<p>   　　   2.遍历Set集合,获取Map集合中的每一个健</p>
<p>  　　　3.通过Map集合中的方法get(key),获取value值</p>
<p>　　　  可以使用迭代器跟增强for循环遍历</p>
<p> 第二种方式：Map集合遍历键值方式</p>
<p>　　　　Map集合中的一个方法：</p>
<p>　　　　Set&lt;Map.Entry&lt;k,v&gt;&gt; entrySet(); 返回此映射中包含的映射关系的Set视图</p>
<p>　使用步骤</p>
<p> 　　　　*  1.使用Map集合中的方法entrySet,把键值对(键与值的映射关系),取出来存储到Set  集合中</p>
<p> 　　　　*  2.遍历Set集合,获取每一个Entry对象</p>
<p> 　　　　*  3.使用Entry对象中的方法getKey和getValue获取健和值</p>
<p>　　可以使用迭代器跟增强for循环遍历</p>
<p>Collection中的集合元素是孤立的，可理解为单身，是一个一个存进去的，称为单列集合</p>
<p>Map中的集合元素是成对存在的，可理解为夫妻，是一对一对存进去的，称为双列集合</p>
<p>Map中存入的是：键值对，键不可以重复，值可以重复</p>
<p>Map主要用于存储带有映射关系的数据（比如学号与学生信息的映射关系）</p>
<p>Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个 value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。</p>
<p>Map具有将对象映射到其他对象的功能，是一个K-V形式存储容器，你可以通过containsKey()和containsValue()来判断集合是否包含某个减或某个值。Map可以很容以拓展到多维（值可以是其他容器甚至是其他Map）：</p>
<p>Map&lt;Object,List<object>&gt;</object></p>
<p>Map集合的数据结构仅仅针对键有效，与值无关。</p>
<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p>HashMap非线程安全，高效，支持null；</p>
<p>根据键的HashCode 来存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。</p>
<p>HashMap最多只允许一条记录的键为Null；允许多条记录的值为 Null。（不允许键重复，但允许值重复）</p>
<p>HashMap不支持线程的同步（任一时刻可以有多个线程同时写HashMap，即线程非安全），可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap() 方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。</p>
<p>Hashtable与 HashMap类似。不同的是：它不允许记录的键或者值为空；它支持线程的同步（任一时刻只有一个线程能写Hashtable，即线程安全），因此也导致了 Hashtable 在写入时会比较慢。</p>
<p>HashMap里面存入的值在取出的时候是随机的，它根据键的HashCode来存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。</p>
<p>HashMap基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>值得注意的是HashMap不是线程安全的，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap。</p>
<p>Map map = Collections.synchronizedMap(new HashMap());</p>
<p>HashMap的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。学过数据结构的同学都知道，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。</p>
<p>HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。</p>
<p>HashMap是常用的Java集合之一，是基于哈希表的Map接口的实现。与HashTable主要区别为不支持同步和允许null作为key和value。由于HashMap不是线程安全的，如果想要线程安全，可以使用ConcurrentHashMap代替。</p>
<p>HashMap的底层是哈希数组，数组元素为Entry。HashMap通过key的hashCode来计算hash值，当hashCode相同时，通过“拉链法”解决冲突</p>
<p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。原本Map.Entry接口的实现类Entry改名为了Node。转化为红黑树时改用另一种实现TreeNode。 </p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626171656243-895639630.jpg" alt="image"></p>
<p>1.8中最大的变化就是在一个Bucket中，如果存储节点的数量超过了8个，就会将该Bucket中原来以链表形式存储节点转换为以树的形式存储节点;而如果少于6个，就会还原成链表形式存储。</p>
<p>为什么要这样做？前面已经说过LinkedList的遍历操作不太友好，如果在节点个数比较多的情况下性能会比较差，而树的遍历效率是比较好的，主要是优化遍历，提升性能。</p>
<p>HashMap:去掉了contains(),保留了containsKey(),containsValue()</p>
<p>HashMap:key,value可以为空.null作为key只能有一个,null作为value可以存在多个</p>
<p>HashMap:使用Iterator</p>
<p>HashMap:数组初始大小为16,扩容方式为2的指数幂形式</p>
<p>HashMap:重新计算hash值</p>
<p>HashMap是基于哈希表的Map接口的实现，HashMap是一个散列表，存储的内容是键值对（key-value）映射，键值对都可为null；</p>
<p>HashMap继承自 <code>AbstractMap&lt;K, V&gt;</code> 并实现<code>Map&lt;K, V&gt;</code>, Cloneable, Serializable接口；</p>
<p>HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。底层是个数组，数组上存储的数据是<code>Entry&lt;K,V&gt;</code>类型的链表结构对象。</p>
<p>HashMap是无序的，LinkedHashMap和treeMap是有序的；</p>
<p>HashMap基于哈希原理，可以通过put和get方法存储和获取对象。当我们将键值对传递给put方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到对应的bucket位置存储键对象和值对象作为Map.Entry；如果两个对象的hashcode相同，所以对应的bucket位置是相同的，HashMap采用链表解决冲突碰撞，这个Entry（包含有键值对的Map.Entry对象）会存储到链表的下一个节点中；如果对应的hashcode和key值都相同，则修改对应的value的值。HashMap在每个链表节点中存储键值对对象。当使用get()方法获取对象时，HashMap会根据键对象的hashcode去找到对应的bucket位置，找到对应的bucket位置后会调用keys.equals()方法去找到连表中对应的正确的节点找到对象。</p>
<p> HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。</p>
<p> HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口,能被克隆。</p>
<p>HashMap存数据的过程是：</p>
<pre><code>HashMap内部维护了一个存储数据的Entry数组，HashMap采用链表解决冲突，每一个Entry本质上是一个单向链表。当准备添加一个key-value对时，首先通过hash(key)方法计算hash值，然后通过indexFor(hash,length)求该key-value对的存储位置，计算方法是先用hash&amp;0x7FFFFFFF后，再对length取模，这就保证每一个key-value对都能存入HashMap中，当计算出的位置相同时，由于存入位置是一个链表，则把这个key-value对插入链表头。
</code></pre><p>HashMap中key和value都允许为null。key为null的键值对永远都放在以table[0]为头结点的链表中。</p>
<p>HashMap内存储数据的Entry数组默认是16，如果没有对Entry扩容机制的话，当存储的数据一多，Entry内部的链表会很长，这就失去了HashMap的存储意义了。所以HasnMap内部有自己的扩容机制。HashMap内部有：</p>
<pre><code>变量size，它记录HashMap的底层数组中已用槽的数量；

变量threshold，它是HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）    

变量DEFAULT_LOAD_FACTOR = 0.75f，默认加载因子为0.75

HashMap扩容的条件是：当size大于threshold时，对HashMap进行扩容  

扩容是是新建了一个HashMap的底层数组，而后调用transfer方法，将就HashMap的全部元素添加到新的HashMap中（要重新计算元素在新的数组中的索引位置）。 很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用HashMap的时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。
</code></pre><p> 加载因子，如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），对空间造成严重浪费。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下我们是无需修改的。另外，无论我们指定的容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，且最大值不能超过2的30次方。</p>
<p>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。</p>
<p>HashMap扩容时是当前容量翻倍即:capacity<em>2，Hashtable扩容时是容量翻倍+1即:capacity</em>2+1。</p>
<p>HashMap和Hashtable的底层实现都是数组+链表结构实现。</p>
<p>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;     </span><br><span class="line"></span><br><span class="line">h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);     </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h &amp; (length<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h5><p>HashTable线程安全，低效，不支持null ,Hashtable是同步的</p>
<p>HashTable这个类实现了哈希表从key映射到value的数据结构形式。任何非null的对象都可以作为key或者value。</p>
<p>要在hashtable中存储和检索对象，作为key的对象必须实现hashCode、equals方法。</p>
<p>一般来说，默认的加载因子（0.75）提供了一种对于空间、时间消耗比较好的权衡策略。太高的值（指加载因子loadFactor）虽然减少了空间开销但是增加了检索时间，这反应在对hashtable的很多操作中，比如get、put方法。</p>
<p>初始容量的控制也是在空间消耗和rehash操作耗时(该操作耗时较大)二者之间的权衡。 如果初始容量大于哈希表的当前最大的条目数除以加载因子，则不会发生rehash。但是，将初始容量设置过高会浪费空间。</p>
<p>如果有大量的数据需要放进hashtable，则选择设置较大的初始容量比它自动rehash更优。</p>
<p>如果不需要线程安全的实现，建议使用HashMap代替Hashtable</p>
<p>如果想要一个线程安全的高并发实现，那么建议使用java.util.concurrent.ConcurrentHashMap取代了Hashtable。</p>
<p>HashTable的父类是Dictionary</p>
<p>HashTable:线程安全,HashTable方法有synchronized修饰</p>
<p>HashTable:保留了contains(),containsKey(),containsValue()</p>
<p>HashTable:key,value都不能为空.原因是源码中方法里会遍历entry,然后用entry的key或者value调用equals(),所以要先判断key/value是否为空,如果为空就会抛出异常</p>
<p>HashTable:使用Enumeration,Iterator</p>
<p>HashTable:数组初始大小为11,扩容方式为2*old+1</p>
<p>HashTable: 直接使用hashcode()</p>
<p>Hashtable同样是基于哈希表实现的，同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。</p>
<p>Hashtable也是JDK1.0引入的类，是线程安全的，能用于多线程环境中。</p>
<p>Hashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。</p>
<p>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模：</p>
<p>int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length;</p>
<p>底层数据结构是哈希表,特点和 hashMap 是一样的</p>
<p> 　　　　Hashtable 是线程安全的集合,是单线程的,运行速度慢</p>
<p> 　　　　HashMap 是线程不安全的集合,是多线程的,运行速度快</p>
<p> 　　　　Hashtable 命运和 Vector 是一样的,从 JDK1.2 开始,被更先进的 HashMap 取代</p>
<p>　　　　 HashMap 允许存储 null 值,null 健</p>
<p> 　　　　Hashtable 不允许存储 null 值,null 健</p>
<p>　　　　 Hashtable 他的孩子,子类 Properties 依然活跃在开发舞台</p>
<p>Properties</p>
<p>Java.util.Properties 集合<code>extends Hashtable&lt;k,v&gt;</code> 集合</p>
<p>Properties 集合特点：</p>
<p>Properties集合也是一个双列集合，key跟value都已经被内置为String类型</p>
<p>Properties集合是一个唯一和IO流相结合的集合</p>
<p>可以将集合中存储的临时数据，持久化到硬盘的文件中储存</p>
<p>可以把文件中储存对的键值对，读取到集合中使用</p>
<p>Properties集合的基本操作：添加数据，遍历集合,Key和value都已经被内置为String类型。里面包含了一些和String类的相关方法</p>
<p> Object setProperty(String key ,String value) 往集合中添加键值对，调用Hashtable的方法put添加</p>
<p> String getProperty(String key ) 通过key获取value的值，相当于Map集合中的get(key) 方法</p>
<p> <code>Set&lt;String &gt;   stringPropertyNames()</code>返回此属性列表的键集。相当于Map集合中的keySet()方法；</p>
<p>Properties类的load方法：</p>
<pre><code>可以把文件中存储的键值对,读取到集合中使用
</code></pre><p>  void load(Reader reader)  </p>
<p>  void load(InputStream inStream)  </p>
<p>  参数:</p>
<p> Reader reader:字符输入流,可以使用FileReader</p>
<p> InputStream inStream:字节输入流,可以使用FileInputStream</p>
<p> 操作步骤:</p>
<p> 1.创建Properties集合对象</p>
<p> 2.创建字符输入流FileReader对象,构造方法中绑定要读取的数据源</p>
<p> 3.使用Properties集合中的方法load,把文件中存储的键值对,读取到集合中使   用</p>
<p> 4.释放资源</p>
<p> 5.遍历Properties集合</p>
<p>注意:</p>
<p> 1.流使用Reader字符流,可以读取中文数据</p>
<p> 2.流使用InputStream字节流,不能操作中文,会有乱码</p>
<p> 3.Properties集合的配置文件中,可以使用注释单行数据,使用#</p>
<p> 4.Properties集合的配置文件中,key和value默认都是字符串,不用添加””(画蛇   添足)</p>
<p> 5.Properties集合的配置文件中,key和value的连接符号可以使用=,也可以使用   空格</p>
<p>Properties类的store方法使用：</p>
<p>可以把集合中存储的临时数据,持久化都硬盘的文件中存储</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> store(Writer writer, <span class="keyword">String</span> comments)  </span><br><span class="line"></span><br><span class="line">                     <span class="keyword">void</span> store(OutputStream out, <span class="keyword">String</span> comments)</span><br></pre></td></tr></table></figure>
<p> 参数:</p>
<p> Writer writer:字符输出流,可以使用FileWriter</p>
<p> OutputStream out:字节输出流,可以使用FileOutputStream</p>
<p> String comments:注释,解释说明存储的文件,不能使用中文(乱码),默认编码格式为   Unicode编码</p>
<p>可以使用””空字符串</p>
<p> 操作步骤:</p>
<p>  1.创建Properties集合,往集合中添加数据</p>
<p>  2.创建字符输出流FileWriter对象,构造方法中绑定要写入的目的地</p>
<p>  3.调用Properties集合中的方法store,把集合中存储的临时数据,持久化都硬盘的文  件中存储</p>
<p>  4.释放资源</p>
<p>注意:</p>
<p>  1.流使用Writer字符流,可以写入中文数据的</p>
<p>  2.流使用OutputStream字节流,不能操作中文,会有乱码</p>
<p>  3.Propertie集合存储的文件,一般都以.properties结尾(程序员默认)</p>
<p>HashMap多线程put操作后，get操作导致死循环。为何出现死循环？</p>
<p>大家都知道，HashMap采用链表解决Hash冲突，具体的HashMap的分析因为是链表结构，那么就很容易形成闭合的链路，这样在循环的时候只要有线程对这个HashMap进行get操作就会产生死循环。但是，我好奇的是，这种闭合的链路是如何形成的呢。在单线程情况下，只有一个线程对HashMap的数据结构进行操作，是不可能产生闭合的回路的。那就只有在多线程并发的情况下才会出现这种情况，那就是在put操作的时候，如果size&gt;initialCapacity*loadFactor，那么这时候HashMap就会进行rehash操作，随之HashMap的结构就会发生翻天覆地的变化。很有可能就是在两个线程在这个时候同时触发了rehash操作，产生了闭合的回路。</p>
<p>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，急需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</p>
<p>HashMap存储自定义类型:使用HashMap储存自定义类形式，因为要保证key的唯一性。需要 自定义类重写  hashCode()跟equals()方法；</p>
<p>HashMap的方法基本都是Map中声明的方法</p>
<p>实现原理：实现一个哈希表，存储元素(key/value)时，用key计算hash值，如果hash值没有碰撞，则只用数组存储元素；如果hash值碰撞了，则相同的hash值的元素用链表存储；如果相同hash值超过8个，则相同的hash值的元素用红黑树存储。获取元素时，用key计算hash值，用hash值计算元素在数组中的下标，取得元素如果命中，则返回；如果不是就在红黑树或链表中找。</p>
<p>PS：存储元素的数组是有冗余的。</p>
<p>采用了Fail-Fast机制，通过一个modCount值记录修改次数，在迭代过程中，判断modCount跟初始过程记录的expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常；另外扩容过程中还有可能产生环形链表。</p>
<p>synchronized是针对整张Hash表的，即每次锁住整张表让线程独占</p>
<h5 id="LinkeHashMap"><a href="#LinkeHashMap" class="headerlink" title="LinkeHashMap"></a>LinkeHashMap</h5><p>LinkedHashMap继承自HashMap，实现了<code>Map&lt;K,V&gt;</code>接口。其内部还维护了一个双向链表，在每次插入数据，或者访问、修改数据时，会增加节点、或调整链表的节点顺序。以决定迭代时输出的顺序。</p>
<p>默认情况，遍历时的顺序是按照插入节点的顺序。这也是其与HashMap最大的区别。 </p>
<p>也可以在构造时传入accessOrder参数，使得其遍历顺序按照访问的顺序输出。</p>
<p>LinkedHashMap在实现时，就是重写override了几个方法。以满足其输出序列有序的需求。</p>
<p>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。</p>
<p>在遍历的时候会比HashMap慢，不过有种情况例外：当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢。因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和它的容量有关。</p>
<p>LinkedHashMap是HashMap的子类，保存了插入的顺序，需要输出的顺序和输入的顺序相同时可用LinkedHashMap；</p>
<p>LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现.</p>
<p>LinkedHashMap取键值对时，是按照你放入的顺序来取的。</p>
<p>LinkedHashMap由于它的插入有序特性，也是一种比较常用的Map集合。它继承了HashMap，很多方法都直接复用了父类HashMap的方法。本文将探讨LinkedHashMap的内部实现，以及它是如何保证插入元素是按插入顺序排序的。</p>
<p>在分析前可以先思考下，既然是按照插入顺序，并且以Linked-开头，就很有可能是链表实现。如果纯粹以链表实现，也不是不可以，LinkedHashMap内部维护一个链表，插入一个元素则把它封装成Entry节点，并把它插入到链表尾部。功能可以实现，但这带来的查找效率达到了O(n)，显然远远大于HashMap在没有冲突的情况下O(1)的时间复杂度。这就丝毫不能体现出Map这种数据结构随机存取快的优点。</p>
<p>所以显然，LinkedHashMap不可能只有一个链表来维护Entry节点，它极有可能维护了两种数据结构：散列表+链表。</p>
<p>　</p>
<p>LinkedHashMap的LRU特性</p>
<p>先讲一下LRU的定义：LRU(Least Recently Used),即最近最少使用算法，最初是用于内存管理中将无效的内存块腾出而用于加载数据以提高内存使用效率而发明的算法。</p>
<p>目前已经普遍用于提高缓存的命中率，如Redis、Memcached中都有使用。</p>
<p>为啥说LinkedHashMap本身就实现了LRU算法？原因就在于它额外维护的双向链表中。</p>
<p>在上面已经提到过，在做get/put操作时，LinkedHashMap会将当前访问/插入的节点移动到链表尾部，所以此时链表头部的那个节点就是 “最近最少未被访问”的节点。</p>
<p>举个例子：</p>
<p>往一个空的LinkedHashMap中插入A、B、C三个结点，那么链表会经历以下三个状态：</p>
<ol>
<li><p>A   插入A节点，此时整个链表只有这一个节点，既是头节点也是尾节点</p>
</li>
<li><p>A  -&gt;  B   插入B节点后，此时A为头节点，B为尾节点，而最近最常访问的节点就是B节点（刚被插入），而最近最少使用的节点就是A节点（相对B节点来讲，A节点已经有一段时间没有被访问过）</p>
</li>
<li><p>A  -&gt;  B  -&gt;  C  插入C节点后，此时A为头节点，C为尾节点，而最近最常访问的节点就是C节点（刚被插入），最近最少使用的节点就是A节点 （应该很好理解了吧  : )）</p>
</li>
</ol>
<p>那么对于缓存来讲，A就是我最长时间没访问过的缓存，C就是最近才访问过的缓存，所以当缓存队列满时就会从头开始替换新的缓存值进去，从而保证缓存队列中的缓存尽可能是最近一段时间访问过的缓存，提高缓存命中率。</p>
<p> LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p>
<h5 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h5><p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序。</p>
<p>默认是按键的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</p>
<p>TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。</p>
<p>TreeMap是基于红黑树结构实现的一种Map，要分析TreeMap的实现首先就要对红黑树有所了解。</p>
<p>要了解什么是红黑树，就要了解它的存在主要是为了解决什么问题，对比其他数据结构比如数组，链表，Hash表等树这种结构又有什么优点。</p>
<p>treeMap实现了sortMap接口，能够把保存的数据按照键的值排序，默认是按照自然数排序也可自定义排序方式。</p>
<p>TreeMap对键进行排序了。</p>
<p>当用Iterator遍历TreeMap时，得到的记录是排过序的。</p>
<p>如果使用排序的映射，建议使用TreeMap。</p>
<p>在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
<p>  二叉树插入元素是有顺序的，TreeSet的元素是有序的。</p>
<p> 由于二叉树需要对结点排序（插入的结点位置），默认情况下没有排序方法，所以元素需要继承Comparator并重写compareTo方法来实现元素之间比较大小的功能。</p>
<p>  对于TreeSet，compareTo方法来保证元素的唯一性。【这时候可以不重写equals】</p>
<p>二叉树需要结点排序，所以元素之间比较能够比较，所以对于自定义元素对象，需要继承Comparator并重写的compareTo方法。 两个元素相等时，compareTo返回0；左大于右时，返回正整数（一般返回1）;小于时返回负整数（一般返回-1）</p>
<p>TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n)</p>
<p>TreeMap中默认的排序为升序</p>
<p>使用entrySet遍历方式要比keySet遍历方式快</p>
<p>entrySet遍历方式获取Value对象是直接从Entry对象中直接获得，时间复杂度T(n)=o(1);</p>
<p>keySet遍历获取Value对象则要从Map中重新获取，时间复杂度T(n)=o(n);keySet遍历Map方式比entrySet遍历Map方式多了一次循环，多遍历了一次table，当Map的size越大时，遍历的效率差别就越大。</p>
<p> HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。</p>
<p>在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。</p>
<p>TreeMap 底层数据结构是红黑树(一种自平衡的二叉树) ，其根据比较的返回值是否是0来保证元素唯一性， 元素的排序通过两种方式：第一种是自然排序(元素具备比较性) 即让元素所属的类实现Comparable接口，第二种是比较器排序(集合具备比较性) ，即让集合接收一个Comparator的实现类对象。</p>
<p>Comparable 和 Comparator 的区别：</p>
<p>　　Comparable 是一个比较的标准，里面有比较的方法，对象要具有比较的标准，就必须实现 Comparable 接口；类实现这个接口，就有比较的方法；把元素放到 TreeSet 里面去，就会自动的调用 CompareTo 方法；但是这个 Comparable  并不是专为 TreeSet 设计的；只是说，TreeSet 顺便利用而已；就像 HashCode 和 equals  也一样，不是专门为 HashSet 设计一样；只是你顺便利用而已。</p>
<p>　　Compartor 是个比较器，也不是专门为TreeSet设计. 就是一个第三方的比较器接口；如果对象没有比较性，自己就可以按照比较器的标准，设计一个比较器，创建一个类，实现这个接口，覆写方法。</p>
<h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><p> Queue用于模拟队列这种数据结构，实现“FIFO”等数据结构。即第一个放进去就是第一个拿出来的元素（从一端进去，从另一端出来）。队列常作被当作一个可靠的将对象从程序的某个区域传输到另一个区域的途径。通常，队列不允许随机访问队列中的元素。</p>
<p>Queue 接口并未定义阻塞队列的方法，而这在并发编程中是很常见的。BlockingQueue 接口定义了那些等待元素出现或等待队列中有可用空间的方法，这些方法扩展了此接口。</p>
<p> Queue 实现通常不允许插入 null 元素，尽管某些实现（如 LinkedList）并不禁止插入 null。即使在允许 null 的实现中，也不应该将 null 插入到 Queue 中，因为 null 也用作 poll 方法的一个特殊返回值，表明队列不包含元素。 </p>
<p>LinkedList提供了方法以支持队列的行为，并且实现了Queue接口。通过LinkedList向上转型（up cast）为Queue，看Queue的实现就知道相对于LinkedList，Queue添加了element、offer、peek、poll、remove方法</p>
<p>offer：在允许的情况下，将一个元素插入到队尾，或者返回false</p>
<p>peek，element：在不移除的情况下返回队头，peek在队列为空返回null，element抛异常NoSuchElementException</p>
<p>poll,remove：移除并返回队头，poll当队列为空是返回null，remove抛出NoSuchElementException异常</p>
<p>注意：queue.offer在自动包装机制会自动的把random.nextInt转化程Integer，把char转化成Character</p>
<h5 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h5><p>Deque是Queue的子接口,我们知道Queue是一种队列形式,而Deque则是双向队列,它支持从两个端点方向检索和插入元素,因此Deque既可以支持LIFO形式也可以支持LIFO形式.Deque接口是一种比Stack和Vector更为丰富的抽象数据形式,因为它同时实现了以上两者.</p>
<p>添加功能</p>
<p>void push(E) 向队列头部插入一个元素,失败时抛出异常</p>
<p>void addFirst(E) 向队列头部插入一个元素,失败时抛出异常</p>
<p>void addLast(E) 向队列尾部插入一个元素,失败时抛出异常</p>
<p>boolean offerFirst(E) 向队列头部加入一个元素,失败时返回false</p>
<p>boolean offerLast(E) 向队列尾部加入一个元素,失败时返回false</p>
<p>获取功能</p>
<p>E getFirst() 获取队列头部元素,队列为空时抛出异常</p>
<p>E getLast() 获取队列尾部元素,队列为空时抛出异常</p>
<p>E peekFirst() 获取队列头部元素,队列为空时返回null</p>
<p>E peekLast() 获取队列尾部元素,队列为空时返回null</p>
<p>删除功能</p>
<p>boolean removeFirstOccurrence(Object) 删除第一次出现的指定元素,不存在时返回false</p>
<p>boolean removeLastOccurrence(Object) 删除最后一次出现的指定元素,不存在时返回false</p>
<p>弹出功能</p>
<p>E pop() 弹出队列头部元素,队列为空时抛出异常</p>
<p>E removeFirst() 弹出队列头部元素,队列为空时抛出异常</p>
<p>E removeLast() 弹出队列尾部元素,队列为空时抛出异常</p>
<p>E pollFirst() 弹出队列头部元素,队列为空时返回null</p>
<p>E pollLast() 弹出队列尾部元素,队列为空时返回null</p>
<p>迭代器</p>
<p><code>Iterator&lt;E&gt; descendingIterator()</code> 返回队列反向迭代器</p>
<p>同Queue一样,Deque的实现也可以划分成通用实现和并发实现.</p>
<p>　　通用实现主要有两个实现类ArrayDeque和LinkedList.</p>
<p>　　ArrayDeque是个可变数组,它是在Java 6之后新添加的,而LinkedList是一种链表结构的list,LinkedList要比ArrayDeque更加灵活,因为它也实现了List接口的所有操作,并且可以插入null元素,这在ArrayDeque中是不允许的.</p>
<p>　　从效率来看,ArrayDeque要比LinkedList在两端增删元素上更为高效,因为没有在节点创建删除上的开销.最适合使用LinkedList的情况是迭代队列时删除当前迭代的元素.此外LinkedList可能是在遍历元素时最差的数据结构,并且也LinkedList占用更多的内存,因为LinkedList是通过链表连接其整个队列,它的元素在内存中是随机分布的,需要通过每个节点包含的前后节点的内存地址去访问前后元素.</p>
<p>　　总体ArrayDeque要比LinkedList更优越,在大队列的测试上有3倍与LinkedList的性能,最好的是给ArrayDeque一个较大的初始化大小,以避免底层数组扩容时数据拷贝的开销.</p>
<p>　　LinkedBlockingDeque是Deque的并发实现,在队列为空的时候,它的takeFirst,takeLast会阻塞等待队列处于可用状态</p>
<h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得 Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p>
<p>栈，是指“LIFO”先进后出的集合容器，最后一个压入的元素是第一个出来的，就好比我们洗碗一样（或者叠罗汉）第一个摆放的碗放在最下面，自然是最后一个拿出来的。Stack是由LinkedList实现的，作为Stack的实现，下面是《java编程思想》给出基本的Stack实现：</p>
<p>peek和pop是返回T类型的对象。peek方法提供栈顶元素，但不删除栈顶，而pop是返回并删除栈顶元素;</p>
<h5 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h5><p>ArrayDeque类是双端队列的实现类，类的继承结构如下面，继承自AbastractCollection（该类实习了部分集合通用的方法，其实现了Collection接口），其实现的接口Deque接口中定义了双端队列的主要的方法，比如从头删除，从尾部删除，获取头数据，获取尾部数据等等。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ArrayDeque&lt;E&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractCollection&lt;E&gt;</span>                           <span class="title">implements</span> <span class="title">Deque&lt;E&gt;</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>ArrayDeque基本特征</p>
<p>就其实现而言，ArrayDeque采用了循环数组的方式来完成双端队列的功能。 </p>
<ol>
<li><p>无限的扩展，自动扩展队列大小的。（当然在不会内存溢出的情况下。） </p>
</li>
<li><p>非线程安全的，不支持并发访问和修改。 </p>
</li>
<li><p>支持fast-fail. </p>
</li>
<li><p>作为栈使用的话比比栈要快. </p>
</li>
<li><p>当队列使用比linklist要快。 </p>
</li>
<li><p>null元素被禁止使用。</p>
</li>
</ol>
<p>最小初始化容量限制8(必须是2的幂次)</p>
<p>扩容:之所以说该ArrayDeque容量无限制，是因为只要检测到head==tail的时候，就直接调用doubleCapacity方法进行扩容。</p>
<p>删除元素:删除元素的基本思路为确定那一侧的数据少，少的一侧移动元素位置，这样效率相对于不比较更高些，然后，判断head是跨越最大值还是为跨越最大值，继而可以分两种不同的情况进行拷贝。但是该方法比较慢，因为存在数组的拷贝。</p>
<p>获取并删除元素:这里在举个简单点的例子，中间判断是不是null，可以看出该队列不支持null,通过把其值设为null就算是将其删除了。然后head向递增的方向退一位即可。 </p>
<p>ArrayDeque和LinkedList是Deque的两个通用实现</p>
<p>ArrayDeque不是线程安全的。 </p>
<p>ArrayDeque不可以存取null元素，因为系统根据某个位置是否为null来判断元素的存在。 </p>
<p>当作为栈使用时，性能比Stack好；当作为队列使用时，性能比LinkedList好。 </p>
<p> 1.添加元素        addFirst(E e)在数组前面添加元素        addLast(E e)在数组后面添加元素        offerFirst(E e) 在数组前面添加元素，并返回是否添加成功        offerLast(E e) 在数组后天添加元素，并返回是否添加成功  </p>
<p> 2.删除元素        removeFirst()删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常        pollFirst()删除第一个元素，并返回删除元素的值，如果元素为null，将返回null           removeLast()删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常        pollLast()删除最后一个元素，并返回删除元素的值，如果为null，将返回null           removeFirstOccurrence(Object o) 删除第一次出现的指定元素        removeLastOccurrence(Object o) 删除最后一次出现的指定元素     </p>
<p> 3.获取元素        getFirst() 获取第一个元素,如果没有将抛出异常        getLast() 获取最后一个元素，如果没有将抛出异常       </p>
<p> 4.队列操作        add(E e) 在队列尾部添加一个元素        offer(E e) 在队列尾部添加一个元素，并返回是否成功        remove() 删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())           poll()  删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())           element() 获取第一个元素，如果没有将抛出异常        peek() 获取第一个元素，如果返回null          </p>
<p> 5.栈操作        push(E e) 栈顶添加一个元素        pop(E e) 移除栈顶元素,如果栈顶没有元素将抛出异常            </p>
<p> 6.其他        size() 获取队列中元素个数        isEmpty() 判断队列是否为空        iterator() 迭代器，从前向后迭代        descendingIterator() 迭代器，从后向前迭代        contain(Object o) 判断队列中是否存在该元素        toArray() 转成数组        clear() 清空队列        clone() 克隆(复制)一个新的队列</p>
<h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p>我们知道队列是遵循先进先出（First-In-First-Out）模式的，但有些时候需要在队列中基于优先级处理对象。举个例子，比方说我们有一个每日交易时段生成股票报告的应用程序，需要处理大量数据并且花费很多处理时间。客户向这个应用程序发送请求时，实际上就进入了队列。我们需要首先处理优先客户再处理普通用户。在这种情况下，Java的PriorityQueue(优先队列)会很有帮助。</p>
<p>PriorityQueue类在Java1.5中引入并作为 Java Collections Framework 的一部分。PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。</p>
<p>优先队列不允许空值，而且不支持non-comparable（不可比较）的对象，比如用户自定义的类。优先队列要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。</p>
<p>优先队列的头是基于自然排序或者Comparator排序的最小元素。如果有多个对象拥有同样的排序，那么就可能随机地取其中任意一个。当我们获取队列时，返回队列的头对象。</p>
<p>优先队列的大小是不受限制的，但在创建时可以指定初始大小。当我们向优先队列增加元素的时候，队列大小会自动增加。</p>
<p>PriorityQueue是非线程安全的，所以Java提供了PriorityBlockingQueue（实现BlockingQueue接口）用于Java多线程环境。</p>
<p>由于知道PriorityQueue是基于Heap的，当新的元素存储时，会调用siftUpUsingComparator方法</p>
<p>PriorityQueue的逻辑结构是一棵完全二叉树，存储结构其实是一个数组。逻辑结构层次遍历的结果刚好是一个数组。</p>
<p>PriorityQueue优先队列,它逻辑上使用堆结构（完全二叉树）实现，物理上使用动态数组实现，并非像TreeMap一样完全有序，但是如果按照指定方式出队，结果可以是有序的。</p>
<p>这里的堆是一种数据结构而非计算机内存中的堆栈。堆结构在逻辑上是完全二叉树，物理存储上是数组。</p>
<p>完全二叉树并不是堆结构，堆结构是不完全有序的完全二叉树。</p>
<h5 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h5><p>Java中Queue的最重要的应用大概就是其子类BlockingQueue了。</p>
<p>考虑到生产者消费者模型，我们有多个生产者和多个消费者，生产者不断提供资源给消费者，但如果它们的生产/消费速度不匹配或者不稳定，则会造成大量的生产者闲置/消费者闲置。此时，我们需要使用一个缓冲区来存储资源，即生产者将资源置于缓冲区，而消费者不断地从缓冲区中取用资源，从而减少了闲置和阻塞。</p>
<p>BlockingQueue，阻塞队列，即可视之为一个缓冲区应用于多线程编程之中。当队列为空时，它会阻塞所有消费者线程，而当队列为满时，它会阻塞所有生产者线程。</p>
<p>在queue的基础上，BlockingQueue又添加了以下方法：</p>
<p> put：队列末尾添加一个元素，若队列已满阻塞。</p>
<p> take：移除并返回队列头部元素，若队列已空阻塞。</p>
<p> drainTo:一次性获取所有可用对象，可以用参数指定获取的个数，该操作是原子操作，不需要针对每个元素的获取加锁。</p>
<h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>由一个定长数组和两个标识首尾的整型index标识组成，生产者放入数据和消费者取出数据对于ArrayBlockingQueue而言使用了同一个锁（一个私有的ReentrantLock），因而无法实现真正的并行。可以在初始化时除长度参数以外，附加一个boolean类型的变量，用于给其私有的ReentrantLock进行初始化（初始化是否为公平锁，默认为false）。</p>
<h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><p>LinkedBlockingQueue的最大特点是，若没有指定最大容量，其可以视为无界队列（有默认最大容量限制,往往系统资源耗尽也无法达到）。即，不对生产者的行为加以限制，只在队列为空的时候限制消费者的行为。LinkedBlockingQueue采用了读写分离的两个ReentrantLock去控制put和take，因而有了更好的性能（类似读写锁提供读写场景下更好的性能），如下：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span>    </span><br><span class="line"><span class="keyword">private</span> final ReentrantLock takeLock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>();    </span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span>   </span><br><span class="line"><span class="keyword">private</span> final Condition notEmpty = takeLock.<span class="keyword">new</span><span class="type">Condition</span>();    </span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span>   </span><br><span class="line"><span class="keyword">private</span> final ReentrantLock putLock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>();   </span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span>   </span><br><span class="line"><span class="keyword">private</span> final Condition notFull = putLock.<span class="keyword">new</span><span class="type">Condition</span>();</span><br></pre></td></tr></table></figure>
<p>ArrayBlockingQueue和LinkedBlockingQueue是最常用的两种阻塞队列。</p>
<h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h5><p>PriorityBlockingQueue是对PriorityQueue的包装，因而也是一个优先队列。其优先级默认是直接比较，大者先出队，也可以从构造器传入自定义的Comparator。由于PriorityQueue从实现上是一个无界队列，PriorityBlockingQueue同样是一个无界队列，对生产者不做限制。</p>
<h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><p>DelayQueue是在PriorityBlockingQueue的基础上包装产生的，它用于存放Delayed对象，该队列的头部是延迟期满后保存时间最长的Delayed元素（即，以时间为优先级利用PriorityBlockingQueue），当没有元素延迟期满时，对其进行poll操作将会返回Null。take操作会阻塞。</p>
<h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p>SynchronousQueue十分特殊，它没有容量——换言之，它是一个长度为0的BlockingQueue，生产者和消费者进行的是无中介的直接交易，当生产者/消费者没有找到合适的目标时，即会发生阻塞。但由于减少了环节，其整体性能在一些系统中可能更加适合。该方法同样支持在构造时确定为公平/默认的非公平模式，如果是非公平模式，有可能会导致某些生产者/消费者饥饿。</p>
<h5 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h5><p>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</p>
<h5 id="EnumSet类"><a href="#EnumSet类" class="headerlink" title="EnumSet类"></a>EnumSet类</h5><p>EnumSet是一个专门为枚举设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值，该枚举类型的创建Enumset时显示会隐式的指定。Enumset的集合元素也是有序的，EnumSet以枚举值在Enum类内定义的顺序来决定集合元素的顺序。</p>
<h5 id="使用Java8新增的Predicate操作集合"><a href="#使用Java8新增的Predicate操作集合" class="headerlink" title="使用Java8新增的Predicate操作集合"></a>使用Java8新增的Predicate操作集合</h5><p>Java 8为Collection集合新增了removeIf(Predicate filter)方法，该方法将会批量删除符合条件的filter条件的所有元素</p>
<h5 id="使用java-8-新增的Stream操作集合"><a href="#使用java-8-新增的Stream操作集合" class="headerlink" title="使用java 8 新增的Stream操作集合"></a>使用java 8 新增的Stream操作集合</h5><p>Java8新增了Stream、IntStream、LongStream、DoubleStream等流式API，这些API代表了多个支持串行和并行聚集操作的元素，其中Stream是一个通用的流接口，而IntStream、LongStream、DoubleStream则代表了类型为int，long，double的流。</p>
<p>独立使用Stream的步骤如下:</p>
<p>1、使用Stream或XxxStream的builder()类方法创建该Stream对应的Builder。</p>
<p> 2、重复调用Builder的add()方法向该流中的添加多个元素</p>
<p> 3、调用Builder的build()方法获取对应的Stream</p>
<p> 4、调用Stream的聚集方法。</p>
<p>在Stream中方法分为两类中间方法和末端方法</p>
<p>中间方法：中间操作允许流保持打开状态,并允许直接调用后续方法。上面程序中的map()方法就是中间方法。</p>
<p>末端方法：末端方法是对流的最终操作。当对某个Stream执行末端方法后，该流将会被”消耗”且不再可用。上面程序中的sum()、count()、average()等方法都是末端方法。</p>
<p>除此之外，关于流的方法还有如下特征：</p>
<p>有状态的方法：这种方法会给你流增加一些新的属性，比如元素的唯一性、元素的最大数量、保证元素的排序的方式被处理等。有状态的方法往往需要更大的性能开销</p>
<p>短路方法:短路方法可以尽早结束对流的操作，不必检查所有的元素。</p>
<h3 id="对CAS的理解，CAS带来的问题，如何解决这些问题？"><a href="#对CAS的理解，CAS带来的问题，如何解决这些问题？" class="headerlink" title="对CAS的理解，CAS带来的问题，如何解决这些问题？"></a>对CAS的理解，CAS带来的问题，如何解决这些问题？</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>回答这个问题，可以先介绍一下锁要解决的问题，以及锁机制的缺点。</p>
<p>引入锁就是为了解决多线程竞争同一个资源时，出现脏读、数据不一致问题。一般我们常用的是synchronized等排他锁，</p>
<p>这种锁存在的问题：</p>
<p>1、多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调 度延时，引起性能问题</p>
<p>2、一个线程持有锁会导致其它所有需要此锁的线程挂起直至该锁释放</p>
<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>cas是另一个无锁解决方案，更准确的是采用乐观锁技术，实现线程安全的问题。cas有三个操作数—-内存对象（V）、预期原值（A）、新值（B）。</p>
<p>CAS原理就是对v对象进行赋值时，先判断原来的值是否为A，如果为A，就把新值B赋值到V对象上面，如果原来的值不是A（代表V的值放生了变化），就不赋新值。</p>
<p>我们看一下AtomicInteger类，AtomicInteger是线程安全的，我们看一下源码</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically adds the given value to the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">getAndAddInt</span><span class="params">(<span class="keyword">this</span>, valueOffset, delta)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一下unsafe源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> var6;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var6 = <span class="keyword">this</span>.getLongVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapLong(var1, var2, var6, var6 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到do while自循环，这里为什么会有自循环，就是在 判断预期原值 如果与原来的值不符合，会再循环取原值，再走CAS流程，直到能够把新值B赋值成功。</p>
<h4 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h4><p>cas这个方式也存在一定的问题：</p>
<p>1、自循环时间长，开销大</p>
<p>2、只能保证一个共享变量的原子操作</p>
<p>3、ABA问题</p>
<h5 id="什么是ABA问题？"><a href="#什么是ABA问题？" class="headerlink" title="什么是ABA问题？"></a>什么是ABA问题？</h5><p>考虑如下操作：</p>
<p>并发1（上）：获取出数据的初始值是A，后续计划实施CAS乐观锁，期望数据仍是A的时候，修改才能成功</p>
<p>并发2：将数据修改成B</p>
<p>并发3：将数据修改回A</p>
<p>并发1（下）：CAS乐观锁，检测发现初始值还是A，进行数据修改</p>
<p>上述并发环境下，并发1在修改数据时，虽然还是A，但已经不是初始条件的A了，中间发生了A变B，B又变A的变化，此A已经非彼A，数据却成功修改，可能导致错误，这就是CAS引发的所谓的ABA问题。</p>
<p>库存操作，出现ABA问题并不会对业务产生影响。<br>堆栈操作，会出现ABA的问题。</p>
<h5 id="ABA问题的优化"><a href="#ABA问题的优化" class="headerlink" title="ABA问题的优化"></a>ABA问题的优化</h5><p>ABA问题导致的原因，是CAS过程中只简单进行了“值”的校验，再有些情况下，“值”相同不会引入错误的业务逻辑（例如库存），有些情况下，“值”虽然相同，却已经不是原来的数据了。</p>
<p>优化方向：CAS不能只比对“值”，还必须确保的是原来的数据，才能修改成功。</p>
<p>常见实践：“版本号”的比对，一个数据一个版本，版本变化，即使值相同，也不应该修改成功。</p>
<h5 id="一个共享变量的原子操作问题优化"><a href="#一个共享变量的原子操作问题优化" class="headerlink" title="一个共享变量的原子操作问题优化"></a>一个共享变量的原子操作问题优化</h5><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p>
<h3 id="volatile底层、synchronized底层、锁升级的过程、MESI"><a href="#volatile底层、synchronized底层、锁升级的过程、MESI" class="headerlink" title="volatile底层、synchronized底层、锁升级的过程、MESI"></a>volatile底层、synchronized底层、锁升级的过程、MESI</h3><h4 id="volatile底层"><a href="#volatile底层" class="headerlink" title="volatile底层"></a>volatile底层</h4><p>Java语言规范对于volatile定义如下：</p>
<p>Java编程语言允许线程访问共享变量，为了确保共享变量能够被准确和一致性地更新，线程应该确保通过排它锁单独获得这个变量。</p>
<p>首先我们从定义开始入手，官方定义比较拗口。通俗来说就是一个字段被volatile修饰，Java的内存模型确保所有的线程看到的这个变量值是一致的，但是它并不能保证多线程的原子操作。这就是所谓的线程可见性。我们要知道他是不能保证原子性的。</p>
<h5 id="内存模型相关概念"><a href="#内存模型相关概念" class="headerlink" title="内存模型相关概念"></a>内存模型相关概念</h5><p>Java线程之间的通信由Java内存模型(JMM)控制，JMM决定一个线程对共享变量的修改何时对另外一个线程可见。JMM定义了线程与主内存的抽象关系：线程之间的变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存(Local Memory)保存着共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/17987782-450f4a923f40b9f4.png" alt="image"></p>
<p>如果线程A与线程B通信：</p>
<ul>
<li>线程A要先把本地内存A中更新过的共享变量刷写到主内存中。</li>
<li>线程B到主内存中读取线程A更新后的共享变量</li>
</ul>
<p>计算机在运行程序时，每条指令都是在CPU中执行的，在执行过程中势必会涉及到数据的读写。我们知道程序运行的数据是存储在主存中，这时就会有一个问题，读写主存中的数据没有CPU中执行指令的速度快，如果任何的交互都需要与主存打交道则会大大影响效率，所以就有了CPU高速缓存。CPU高速缓存为某个CPU独有，只与在该CPU运行的线程有关。</p>
<p>有了CPU高速缓存虽然解决了效率问题，但是它会带来一个新的问题：数据一致性。在程序运行中，会将运行所需要的数据复制一份到CPU高速缓存中，在进行运算时CPU不再也主存打交道，而是直接从高速缓存中读写数据，只有当运行结束后才会将数据刷新到主存中。</p>
<p>举个例子：</p>
<p><code>i++;</code></p>
<p>当线程运行这行代码时，首先会从主内存中读取i，然后复制一份到CPU高速缓存中,接着CPU执行+1的操作，再将+1后的数据写在缓存中，最后一步才是刷新到主内存中。在单线程时没有问题，多线程就有问题了。</p>
<p>如下：假如有两个线程A、B都执行这个操作（i++），按照我们正常的逻辑思维主存中的i值应该=3，但事实是这样么？</p>
<blockquote>
<p>分析如下：两个线程从主存中读取i的值（1）到各自的高速缓存中，然后线程A执行+1操作并将结果写入高速缓存中，最后写入主存中，此时主存i==2,线程B做同样的操作，主存中的i仍然=2。所以最终结果为2并不是3。这种现象就是缓存一致性问题。</p>
</blockquote>
<p>解决缓存一致性方案有两种：</p>
<p>通过在总线加LOCK#锁的方式；</p>
<p>通过缓存一致性协议。</p>
<p>但是方案1存在一个问题，它是采用一种独占的方式来实现的，即总线加LOCK#锁的话，只能有一个CPU能够运行，其他CPU都得阻塞，效率较为低下。</p>
<p>第二种方案，缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。所以JMM就解决这个问题。</p>
<h5 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h5><p>有volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令，该指令在多核处理器下会引发两件事情。</p>
<ul>
<li>将当前处理器缓存行数据刷写到系统主内存。</li>
<li>这个刷写回主内存的操作会使其他CPU缓存的该共享变量内存地址的数据无效。</li>
</ul>
<p>这样就保证了多个处理器的缓存是一致的，对应的处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器缓存行设置无效状态，当处理器对这个数据进行修改操作的时候会重新从主内存中把数据读取到缓存里。</p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>volatile经常用于两个场景：状态标记、double check</p>
<p>1、状态标记<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line">boolean <span class="built_in">stop</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">stop</span>)&#123;</span><br><span class="line">   doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="built_in">stop</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>但是加上volatile就没问题了。如下所示：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">   doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  </span><br><span class="line">inited = <span class="keyword">true</span>;            </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></p>
<p>2、double check<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">   private volatile static Singleton<span class="built_in"> instance </span>= <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   private Singleton() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public static Singleton getInstance() &#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="attribute">instance</span>==null) &#123;</span><br><span class="line">           synchronized (Singleton.class) &#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="attribute">instance</span>==null)</span><br><span class="line">                  <span class="built_in"> instance </span>= new Singleton();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="synchronized底层"><a href="#synchronized底层" class="headerlink" title="synchronized底层"></a>synchronized底层</h4><p>上面有写</p>
<h4 id="锁升级的过程"><a href="#锁升级的过程" class="headerlink" title="锁升级的过程"></a>锁升级的过程</h4><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率，下文会详细分析。</p>
<h5 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h5><p>因为偏向锁，锁住对象时，会写入对象头相应的标识，我们先把对象头(官方叫法为:Mark Word)的图示如下(借用了网友的图片):</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180619193100237.jpeg" alt="image"></p>
<h5 id="偏向锁-1"><a href="#偏向锁-1" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>HotSpot [1] 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p>上文中黑体字部分，写得太简略，以致于很多初学者，对这个过程有点不明白，这个过程是怎么实现锁的升级、释放的？下面一一分析</p>
<ol>
<li>线程2来竞争锁对象;</li>
<li>判断当前对象头是否是偏向锁;</li>
<li>判断拥有偏向锁的线程1是否还存在;</li>
<li>线程1不存在,直接设置偏向锁标识为0(线程1执行完毕后,不会主动去释放偏向锁);</li>
<li>使用cas替换偏向锁线程ID为线程2,锁不升级，仍为偏向锁;</li>
<li>线程1仍然存在,暂停线程1；</li>
<li>设置锁标志位为00(变为轻量级锁),偏向锁为0;</li>
<li>从线程1的空闲monitor record中读取一条,放至线程1的当前monitor record中;</li>
<li>更新mark word，将mark word指向线程1中monitor record的指针;</li>
<li>继续执行线程1的代码;</li>
<li>锁升级为轻量级锁;</li>
<li>线程2自旋来获取锁对象;</li>
</ol>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180619200443603.png" alt="image"></p>
<h5 id="轻量级锁-1"><a href="#轻量级锁-1" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>（1）轻量级锁加锁<br>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。<br>（2）轻量级锁解锁<br>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180619194820999.png" alt="image"><br>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h4 id="缓存一致性和MESI"><a href="#缓存一致性和MESI" class="headerlink" title="缓存一致性和MESI"></a>缓存一致性和MESI</h4><p>缓存一致性协议给缓存行（通常为64字节）定义了个状态：独占（exclusive）、共享（share）、修改（modified）、失效（invalid），用来描述该缓存行是否被多处理器共享、是否修改。所以缓存一致性协议也称MESI协议。</p>
<ul>
<li>独占（exclusive）：仅当前处理器拥有该缓存行，并且没有修改过，是最新的值。</li>
<li>共享（share）：有多个处理器拥有该缓存行，每个处理器都没有修改过缓存，是最新的值。</li>
<li>修改（modified）：仅当前处理器拥有该缓存行，并且缓存行被修改过了，一定时间内会写回主存，会写成功状态会变为S。</li>
<li><p>失效（invalid）：缓存行被其他处理器修改过，该值不是最新的值，需要读取主存上最新的值。<br>协议协作如下：</p>
</li>
<li><p>一个处于M状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回CPU。</p>
</li>
<li>一个处于S状态的缓存行，必须时刻监听使该缓存行无效或者独享该缓存行的请求，如果监听到，则必须把其缓存行状态设置为I。</li>
<li>一个处于E状态的缓存行，必须时刻监听其他试图读取该缓存行对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S。</li>
<li>当CPU需要读取数据时，如果其缓存行的状态是I的，则需要从内存中读取，并把自己状态变成S，如果不是I，则可以直接读取缓存中的值，但在此之前，必须要等待其他CPU的监听结果，如其他CPU也有该数据的缓存且状态是M，则需要等待其把缓存更新到内存之后，再读取。</li>
<li>当CPU需要写数据时，只有在其缓存行是M或者E的时候才能执行，否则需要发出特殊的RFO指令(Read Or Ownership，这是一种总线事务)，通知其他CPU置缓存无效(I)，这种情况下会性能开销是相对较大的。在写入完成后，修改其缓存状态为M。</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG256.png" alt="image"></p>
<p>这个图的含义就是当一个core持有一个cacheline的状态为Y时,其它core对应的cacheline应该处于状态X, 比如地址 0x00010000 对应的cacheline在core0上为状态M, 则其它所有的core对应于0x00010000的cacheline都必须为I , 0x00010000 对应的cacheline在core0上为状态S, 则其它所有的core对应于0x00010000的cacheline 可以是S或者I ,</p>
<p>另外MESI协议为了提高性能，引入了Store Buffe和Invalidate Queues，还是有可能会引起缓存不一致，还会再引入内存屏障来确保一致性，可以参考[7]和[12]</p>
<h6 id="存储缓存-Store-Buffe）"><a href="#存储缓存-Store-Buffe）" class="headerlink" title="存储缓存(Store Buffe）"></a>存储缓存(Store Buffe）</h6><p>也就是常说的写缓存，当处理器修改缓存时，把新值放到存储缓存中，处理器就可以去干别的事了，把剩下的事交给存储缓存。</p>
<h6 id="失效队列（Invalidate-Queues）"><a href="#失效队列（Invalidate-Queues）" class="headerlink" title="失效队列（Invalidate Queues）"></a>失效队列（Invalidate Queues）</h6><p>处理失效的缓存也不是简单的，需要读取主存。并且存储缓存也不是无限大的，那么当存储缓存满的时候，处理器还是要等待失效响应的。为了解决上面两个问题，引进了失效队列（invalidate queue）。处理失效的工作如下：</p>
<p>收到失效消息时，放到失效队列中去。<br>为了不让处理器久等失效响应，收到失效消息需要马上回复失效响应。<br>为了不频繁阻塞处理器，不会马上读主存以及设置缓存为invlid，合适的时候再一块处理失效队列。</p>
<h5 id="MESI和CAS关系"><a href="#MESI和CAS关系" class="headerlink" title="MESI和CAS关系"></a>MESI和CAS关系</h5><p>在x86架构上，CAS被翻译为”lock cmpxchg…“，当两个core同时执行针对同一地址的CAS指令时,其实他们是在试图修改每个core自己持有的Cache line</p>
<blockquote>
<p>假设两个core都持有相同地址对应cacheline,且各自cacheline 状态为S, 这时如果要想成功修改,就首先需要把S转为E或者M, 则需要向其它core invalidate 这个地址的cacheline,则两个core都会向ring bus发出 invalidate这个操作, 那么在ringbus上就会根据特定的设计协议仲裁是core0,还是core1能赢得这个invalidate, 胜者完成操作, 失败者需要接受结果, invalidate自己对应的cacheline,再读取胜者修改后的值, 回到起点.</p>
</blockquote>
<p>对于我们的CAS操作来说, 其实锁并没有消失,只是转嫁到了ring bus的总线仲裁协议中. 而且大量的多核同时针对一个地址的CAS操作会引起反复的互相invalidate 同一cacheline, 造成pingpong效应, 同样会降低性能（参考[9]）。当然如果真的有性能问题，我觉得这可能会在ns级别体现了,一般的应用程序中使用CAS应该不会引起性能问题</p>
<h4 id="指令重排和内存屏障"><a href="#指令重排和内存屏障" class="headerlink" title="指令重排和内存屏障"></a>指令重排和内存屏障</h4><h5 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h5><p>现代CPU的速度越来越快，为了充分的利用CPU，在编译器和CPU执行期，都可能对指令重排。举个例子：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR </span><span class="built_in">R1</span>, [<span class="built_in">R0</span>]<span class="comment">;//操作1</span></span><br><span class="line"><span class="keyword">ADD </span><span class="built_in">R2</span>, <span class="built_in">R1</span>, <span class="built_in">R1</span><span class="comment">;//操作2</span></span><br><span class="line"><span class="keyword">ADD </span><span class="built_in">R3</span>, <span class="built_in">R4</span>, <span class="built_in">R4</span><span class="comment">;//操作3</span></span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，如果操作1如果发生cache miss，则需要等待读取内存外存。看看有没有能优先执行的指令，操作2依赖于操作1，不能被优先执行，操作3不依赖1和2，所以能优先执行操作3。<br>JVM的JSR-133规范中定义了as-if-serial语义，即compiler, runtime, and hardware三者需要保证在单线程模型下程序不会感知到指令重排的影响。</p>
<p>在并发模型下，重排序还是可能会引发问题，比较经典的就是“单例模式失效”问题（DoubleCheckedLocking）：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private static Singleton<span class="built_in"> instance </span>= <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  private Singleton() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  public static Singleton getInstance() &#123;</span><br><span class="line">     <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        synchronzied(Singleton.class) &#123;</span><br><span class="line">           <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="built_in"> instance </span>= new Singleton();  //</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，初看没问题，但是在并发模型下，可能会出错,那是因为instance= new Singleton()并非一个原子操作，它实际上下面这三个操作：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    //1：分配对象的内存空间</span><br><span class="line">ctorInstance(memory);  //2：初始化对象</span><br><span class="line">instance =memory;     //3：设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure></p>
<p>上面操作2依赖于操作1，但是操作3并不依赖于操作2，所以JVM是可以针对它们进行指令的优化重排序的，经过重排序后如下：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    //1：分配对象的内存空间</span><br><span class="line">instance =memory;     //3：instance指向刚分配的内存地址，此时对象还未初始化</span><br><span class="line">ctorInstance(memory);  //2：初始化对象</span><br></pre></td></tr></table></figure></p>
<p>可以看到指令重排之后，instance指向分配好的内存放在了前面，而这段内存的初始化被排在了后面。在多线程场景下，可能A线程执行到了3，B线程发现已经不为空就返回继续执行，就会出错。</p>
<p>在java里面volatile可以防止重排，当然还有另外一个作用即内存可见性，这个知道的人还应该比较普遍，就不说了</p>
<h5 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h5><p>硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。内存屏障有两个作用：</p>
<p>1.阻止屏障两侧的指令重排序；<br>2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</p>
<p>在JSR规范中定义了4种内存屏障：</p>
<ul>
<li>LoadLoad屏障：（指令Load1; LoadLoad; Load2），在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li>LoadStore屏障：（指令Load1; LoadStore; Store2），在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreStore屏障：（指令Store1; StoreStore; Store2），在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li><p>StoreLoad屏障：（指令Store1; StoreLoad; Load2），在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能<br>对于volatile关键字，按照规范会有下面的操作：</p>
</li>
<li><p>在每个volatile写入之前，插入一个StoreStore，写入之后，插入一个StoreLoad</p>
</li>
<li>在每个volatile读取之前，插入LoadLoad，之后插入LoadStore</li>
<li>具体到X86来看，其实没那么多指令，只有StoreLoad:</li>
</ul>
<p>结合上面的【一】和【二】的内容，内存屏障首先阻止了指令的重排，另外也和MESI协议结合，确保了内存的可见性</p>
<h3 id="怎么理解Java-中和-MySQL中的乐观锁、悲观锁？"><a href="#怎么理解Java-中和-MySQL中的乐观锁、悲观锁？" class="headerlink" title="怎么理解Java 中和 MySQL中的乐观锁、悲观锁？"></a>怎么理解Java 中和 MySQL中的乐观锁、悲观锁？</h3><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p>
<h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<h5 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h5><p>乐观锁一般会使用版本号机制或CAS（Compare-and-Swap，即比较并替换）算法实现。</p>
<h6 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h6><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p>
<ol>
<li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li>
<li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li>
<li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li>
<li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。<br>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</li>
</ol>
<h6 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h6><p>即 compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数</p>
<p>需要读写的内存值 V<br>进行比较的值 A<br>拟写入的新值 B<br>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
<h6 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h6><p>ABA 问题是乐观锁一个常见的问题。</p>
<ol>
<li>ABA 问题</li>
</ol>
<p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</p>
<p>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<ol start="2">
<li>循环时间长开销大</li>
</ol>
<p>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<ol start="3">
<li>只能保证一个共享变量的原子操作</li>
</ol>
<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p>
<h6 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h6><p>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</p>
<ul>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。<br>补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</li>
</ul>
<h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><h5 id="悲观锁（Pessimistic-Lock）"><a href="#悲观锁（Pessimistic-Lock）" class="headerlink" title="悲观锁（Pessimistic Lock）"></a>悲观锁（Pessimistic Lock）</h5><p>悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p>
<p>这里需要注意的一点是不同的数据库对select for update的实现和支持都是有所区别的，例如oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，mysql就没有no wait这个选项。另外mysql还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在mysql中用悲观锁务必要确定走了索引，而不是全表扫描。</p>
<h5 id="乐观锁（Optimistic-Lock）"><a href="#乐观锁（Optimistic-Lock）" class="headerlink" title="乐观锁（Optimistic Lock）"></a>乐观锁（Optimistic Lock）</h5><p>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。</p>
<p>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，然后按照如下方式实现：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="keyword">SELECT</span> <span class="keyword">data</span> <span class="keyword">AS</span> old_data, <span class="keyword">version</span> <span class="keyword">AS</span> old_version <span class="keyword">FROM</span> …;</span><br><span class="line">2. 根据获取的数据进行业务操作，得到new_data和new_version</span><br><span class="line">3. <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">data</span> = new_data, <span class="keyword">version</span> = new_version <span class="keyword">WHERE</span> <span class="keyword">version</span> = old_version</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">updated</span> <span class="keyword">row</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    // 乐观锁获取成功，操作完成</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // 乐观锁获取失败，回滚并重试</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>乐观锁是否在事务中其实都是无所谓的，其底层机制是这样：在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放。因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这之间没有发生并发的修改。如果更新失败即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。</p>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><ul>
<li>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</li>
<li>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方</li>
</ul>
<h3 id="对线程池的理解，项目中哪个地方使用了，如何使用的，用的Excutor框架中的哪个实现类，为什么用这个"><a href="#对线程池的理解，项目中哪个地方使用了，如何使用的，用的Excutor框架中的哪个实现类，为什么用这个" class="headerlink" title="对线程池的理解，项目中哪个地方使用了，如何使用的，用的Excutor框架中的哪个实现类，为什么用这个"></a>对线程池的理解，项目中哪个地方使用了，如何使用的，用的Excutor框架中的哪个实现类，为什么用这个</h3><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h6 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h6><p>线程池作用就是限制系统中执行线程的数量。</p>
<p>根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。</p>
<h5 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h5><p>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p>
<p>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</p>
<p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。</p>
<p>比较重要的几个类：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ExecutorService</td>
<td>真正的线程池接口。</td>
</tr>
<tr>
<td>ScheduledExecutorService</td>
<td>能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</td>
</tr>
<tr>
<td>ThreadPoolExecutor</td>
<td>ExecutorService的默认实现。</td>
</tr>
<tr>
<td>ScheduledThreadPoolExecutor</td>
<td>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</td>
</tr>
</tbody>
</table>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。</p>
<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
<h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，</p>
<p>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
<h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<h4 id="ThreadPoolExecutor详解"><a href="#ThreadPoolExecutor详解" class="headerlink" title="ThreadPoolExecutor详解"></a>ThreadPoolExecutor详解</h4><p>ThreadPoolExecutor的完整构造方法的签名是：ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) .</runnable></p>
<ul>
<li>corePoolSize - 池中所保存的线程数，包括空闲线程。</li>
<li>maximumPoolSize-池中允许的最大线程数。</li>
<li>keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</li>
<li>unit - keepAliveTime 参数的时间单位。</li>
<li>workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute方法提交的 Runnable任务。</li>
<li>threadFactory - 执行程序创建新线程时使用的工厂。</li>
<li>handler - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。</li>
<li>ThreadPoolExecutor是Executors类的底层实现。</li>
</ul>
<p>下面介绍一下几个类的源码：</p>
<p>ExecutorService  newFixedThreadPool (int nThreads):固定大小线程池。</p>
<p>可以看到，corePoolSize和maximumPoolSize的大小是一样的（实际上，后面会介绍，如果使用无界queue的话maximumPoolSize参数是没有意义的），keepAliveTime和unit的设值表名什么？-就是该实现不想keep alive！最后的BlockingQueue选择了LinkedBlockingQueue，该queue有一个特点，他是无界的。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,<span class="number">0</span>L, TimeUnit.MILLISECONDS,   </span><br><span class="line">    <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ExecutorService  newSingleThreadExecutor()：单线程<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span> (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,   </span><br><span class="line">        <span class="number">0</span>L, TimeUnit.MILLISECONDS,   </span><br><span class="line">        <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ExecutorService newCachedThreadPool()：无界线程池，可以进行自动线程回收</p>
<p>这个实现就有意思了。首先是无界的线程池，所以我们可以发现maximumPoolSize为big big。其次BlockingQueue的选择上使用SynchronousQueue。可能对于该BlockingQueue有些陌生，简单说：该QUEUE中，每个插入操作必须等待另一个线程的对应移除操作。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;   </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,   </span><br><span class="line">       <span class="number">60</span>L, TimeUnit.SECONDS,   </span><br><span class="line">       <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先从<code>BlockingQueue&lt;Runnable&gt; workQueue</code>这个入参开始说起。在JDK中，其实已经说得很清楚了，一共有三种类型的queue。</p>
<p>所有BlockingQueue 都可用于传输和保持提交的任务。可以使用此队列与池大小进行交互：</p>
<p>如果运行的线程少于 corePoolSize，则 Executor始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于corePoolSize，则任务根本不会存放，添加到queue中，而是直接抄家伙（thread）开始运行）</p>
<p>如果运行的线程等于或多于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。</p>
<p>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。</p>
<p>queue上的三种类型。</p>
<p>排队有三种通用策略：</p>
<p><strong>直接提交</strong>。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p>
<p><strong>无界队列</strong>。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p>
<p><strong>有界队列</strong>。当使用有限的 maximumPoolSizes时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 </p>
<p><strong>BlockingQueue的选择</strong></p>
<h6 id="例子一：使用直接提交策略，也即SynchronousQueue。"><a href="#例子一：使用直接提交策略，也即SynchronousQueue。" class="headerlink" title="例子一：使用直接提交策略，也即SynchronousQueue。"></a>例子一：使用直接提交策略，也即SynchronousQueue。</h6><p>首先SynchronousQueue是无界的，也就是说他存数任务的能力是没有限制的，但是由于该Queue本身的特性，在某次添加元素后必须等待其他线程取走后才能继续添加。在这里不是核心线程便是新创建的线程，但是我们试想一样下，下面的场景。</p>
<p>我们使用一下参数构造ThreadPoolExecutor：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>( <span class="number">2</span>, <span class="number">3</span>, <span class="number">30</span>, TimeUnit.SECONDS,<span class="keyword">new</span>  <span class="type">SynchronousQueue</span>&lt;Runnable&gt;(),<span class="keyword">new</span> <span class="type">RecorderThreadFactory</span>(<span class="string">"CookieRecorderPool"</span>),<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">30</span>, TimeUnit.SECONDS,<span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;(),<span class="keyword">new</span> <span class="type">RecorderThreadFactory</span>(<span class="string">"CookieRecorderPool"</span>),<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>
<p>当核心线程已经有2个正在运行.</p>
<ol>
<li>此时继续来了一个任务（A），根据前面介绍的“如果运行的线程等于或多于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。”,所以A被添加到queue中。</li>
<li>又来了一个任务（B），且核心2个线程还没有忙完，OK，接下来首先尝试1中描述，但是由于使用的SynchronousQueue，所以一定无法加入进去。</li>
<li>此时便满足了上面提到的“如果无法将请求加入队列，则创建新的线程，除非创建此线程超出maximumPoolSize，在这种情况下，任务将被拒绝。”，所以必然会新建一个线程来运行这个任务。</li>
<li>暂时还可以，但是如果这三个任务都还没完成，连续来了两个任务，第一个添加入queue中，后一个呢？queue中无法插入，而线程数达到了maximumPoolSize，所以只好执行异常策略了。</li>
</ol>
<p>所以在使用SynchronousQueue通常要求maximumPoolSize是无界的，这样就可以避免上述情况发生（如果希望限制就直接使用有界队列）。对于使用SynchronousQueue的作用jdk中写的很清楚：此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。</p>
<p>什么意思？如果你的任务A1，A2有内部关联，A1需要先运行，那么先提交A1，再提交A2，当使用SynchronousQueue我们可以保证，A1必定先被执行，在A1么有被执行前，A2不可能添加入queue中。</p>
<h6 id="例子二：使用无界队列策略，即LinkedBlockingQueue"><a href="#例子二：使用无界队列策略，即LinkedBlockingQueue" class="headerlink" title="例子二：使用无界队列策略，即LinkedBlockingQueue"></a>例子二：使用无界队列策略，即LinkedBlockingQueue</h6><p>这个就拿newFixedThreadPool来说，根据前文提到的规则：</p>
<p>如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。那么当任务继续增加，会发生什么呢？</p>
<p>如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。OK，此时任务变加入队列之中了，那什么时候才会添加新线程呢？</p>
<p>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。这里就很有意思了，可能会出现无法加入队列吗？不像SynchronousQueue那样有其自身的特点，对于无界队列来说，总是可以加入的（资源耗尽，当然另当别论）。换句说，永远也不会触发产生新的线程！corePoolSize大小的线程数会一直运行，忙完当前的，就从队列中拿任务开始运行。所以要防止任务疯长，比如任务运行的实行比较长，而添加任务的速度远远超过处理任务的时间，而且还不断增加，不一会儿就爆了。</p>
<h6 id="例子三：有界队列，使用ArrayBlockingQueue。"><a href="#例子三：有界队列，使用ArrayBlockingQueue。" class="headerlink" title="例子三：有界队列，使用ArrayBlockingQueue。"></a>例子三：有界队列，使用ArrayBlockingQueue。</h6><p>这个是最为复杂的使用，所以JDK不推荐使用也有些道理。与上面的相比，最大的特点便是可以防止资源耗尽的情况发生。</p>
<p>举例来说，请看如下构造方法：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">30</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2</span>),<span class="keyword">new</span> <span class="type">RecorderThreadFactory</span>(<span class="string">"CookieRecorderPool"</span>), <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">30</span>, TimeUnit.SECONDS,<span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2</span>),<span class="keyword">new</span> <span class="type">RecorderThreadFactory</span>(<span class="string">"CookieRecorderPool"</span>),<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>
<p>假设，所有的任务都永远无法执行完。</p>
<p>对于首先来的A,B来说直接运行，接下来，如果来了C,D，他们会被放到queue中，如果接下来再来E,F，则增加线程运行E，F。但是如果再来任务，队列无法再接受了，线程数也到达最大的限制了，所以就会使用拒绝策略来处理。</p>
<h5 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h5><p>jdk中的解释是：当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</p>
<p>有点拗口，其实这个不难理解，在使用了“池”的应用中，大多都有类似的参数需要配置。比如数据库连接池，DBCP中的maxIdle，minIdle参数。</p>
<p>什么意思？接着上面的解释，后来向老板派来的工人始终是“借来的”，俗话说“有借就有还”，但这里的问题就是什么时候还了，如果借来的工人刚完成一个任务就还回去，后来发现任务还有，那岂不是又要去借？这一来一往，老板肯定头也大死了。</p>
<p>合理的策略：既然借了，那就多借一会儿。直到“某一段”时间后，发现再也用不到这些工人时，便可以还回去了。这里的某一段时间便是keepAliveTime的含义，TimeUnit为keepAliveTime值的度量。</p>
<p>RejectedExecutionHandler</p>
<p>另一种情况便是，即使向老板借了工人，但是任务还是继续过来，还是忙不过来，这时整个队伍只好拒绝接受了。</p>
<p>RejectedExecutionHandler接口提供了对于拒绝任务的处理的自定方法的机会。在ThreadPoolExecutor中已经默认包含了4中策略，因为源码非常简单，这里直接贴出来。</p>
<p>CallerRunsPolicy：线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">if</span> (!e.isShutdown()) &#123;   </span><br><span class="line">          r.run();   </span><br><span class="line">      &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个策略显然不想放弃执行任务。但是由于池中已经没有任何资源了，那么就直接使用调用该execute的线程本身来执行。</p>
<p>AbortPolicy：处理程序遭到拒绝将抛出运行时RejectedExecutionException<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 这种策略直接抛出异常，丢弃任务。</p>
<p>DiscardPolicy：不能执行的任务将被删除<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种策略和AbortPolicy几乎一样，也是丢弃任务，只不过他不抛出异常。</p>
<p>DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">rejectedExecution</span>(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">     <span class="selector-tag">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">         <span class="selector-tag">e</span><span class="selector-class">.getQueue</span>()<span class="selector-class">.poll</span>();</span><br><span class="line">         <span class="selector-tag">e</span><span class="selector-class">.execute</span>(r);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该策略就稍微复杂一些，在pool没有关闭的前提下首先丢掉缓存在队列中的最早的任务，然后重新尝试运行该任务。这个策略需要适当小心。</p>
<p>设想:如果其他线程都还在运行，那么新来任务踢掉旧任务，缓存在queue中，再来一个任务又会踢掉queue中最老任务。</p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>keepAliveTime和maximumPoolSize及BlockingQueue的类型均有关系。如果BlockingQueue是无界的，那么永远不会触发maximumPoolSize，自然keepAliveTime也就没有了意义。</p>
<p>反之，如果核心数较小，有界BlockingQueue数值又较小，同时keepAliveTime又设的很小，如果任务频繁，那么系统就会频繁的申请回收线程。</p>
<h3 id="怎么理解线程安全？"><a href="#怎么理解线程安全？" class="headerlink" title="怎么理解线程安全？"></a>怎么理解线程安全？</h3><p>线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。</p>
<p>线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p>
<p>安全性：<br>比如一个 ArrayList 类，在添加一个元素的时候，它可能会有两步来完成：1. 在 Items[Size] 的位置存放此元素；2. 增大 Size 的值。<br>在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；<br>而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。<br>那好，我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。</p>
<h3 id="一个final修饰的属性，定义的时候没有初始化，在无参构造函数中初始化，可以吗，为什么"><a href="#一个final修饰的属性，定义的时候没有初始化，在无参构造函数中初始化，可以吗，为什么" class="headerlink" title="一个final修饰的属性，定义的时候没有初始化，在无参构造函数中初始化，可以吗，为什么"></a>一个final修饰的属性，定义的时候没有初始化，在无参构造函数中初始化，可以吗，为什么</h3><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ol>
<li><p>static修饰一个属性字段，那么这个属性字段将成为类本身的资源，public修饰为共有的，可以在类的外部通过test.a来访问此属性；在类内部任何地方可以使用。如果被修饰为private私有，那么只能在类内部使用。</p>
</li>
<li><p>如果属性被修饰为static静态类资源，那么这个字段永远只有一个，也就是说不管你new test()多少个类的对象，操作的永远都只是属于类的那一块内存资源。</p>
</li>
</ol>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p> final 用于声明属性、方法和类，分别表示属性一旦被分配内存空间就必须初始化并且以后不可变；方法一旦定义必须有实现代码并且子类里不可被覆盖；类一旦定义不能被定义为抽象类或是接口，因为不可被继承。</p>
<p> 被final修饰而没有被static修饰的类的属性变量只能在两种情况下初始化：</p>
<ul>
<li><p>在它被定义的时候</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在构造函数里初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">　　	<span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　		a=<span class="number">0</span>;</span><br><span class="line">　　	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>同时被final和static修饰的类的属性变量只能在两种情况下初始化</p>
<ul>
<li><p>在它被定义的时候</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">　　	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">　　	<span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　		</span><br><span class="line">　　	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类的静态块里初始化</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">　　	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">　　	<span class="keyword">static</span>&#123;</span><br><span class="line">　　		a=<span class="number">0</span>;</span><br><span class="line">　　	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当类的属性被同时被修饰为static和final的时候，他属于类的资源，那么就是类在被加载进内存的时候（也就是应用程序启动的时候）就要为属性分配内存，所以此时属性已经存在，它又被final修饰，所以必须在属性定义了以后就给其初始化值。而构造函数是在当类被实例化的时候才会执行，所以不能用构造函数。而static块是类被加载的时候执行，且只执行这一次，所以在static块中可以执行初始化。</p>
<h3 id="HashMap，concurrentHashMap底实现序列化层实现"><a href="#HashMap，concurrentHashMap底实现序列化层实现" class="headerlink" title="HashMap，concurrentHashMap底实现序列化层实现"></a>HashMap，concurrentHashMap底实现序列化层实现</h3><p>实现了Serializable接口</p>
<p>Java中 Serializable 是 标示一个类是可以被 JDK 序列化和反序列化的，他只是一个接口并没有任何操作。</p>
<p>序列化，本质就是将内存里面的 Java 对象写入到流里面，还可以将流里面的Java序列化数据反序列化还原到实例对象。</p>
<p>当然，序列化的方法很多，常见的就是 JDK 序列化、JSON 序列化、还有 protobuffer 等等。</p>
<p>每一种框架，序列化和反序列化都是有一个统一的数据格式规范和算法。</p>
<h3 id="什么是红黑树，什么是B-Tree，为什么HashMap中用红黑树不用其他树？"><a href="#什么是红黑树，什么是B-Tree，为什么HashMap中用红黑树不用其他树？" class="headerlink" title="什么是红黑树，什么是B-Tree，为什么HashMap中用红黑树不用其他树？"></a>什么是红黑树，什么是B-Tree，为什么HashMap中用红黑树不用其他树？</h3><p>树的概念前面有。</p>
<p>那么很多人就有疑问为什么是使用红黑树而不是AVL树，AVL树是完全平衡二叉树阿？</p>
<p>最主要的一点是：</p>
<p>在CurrentHashMap中是加锁了的，实际上是读写锁，如果写冲突就会等待，<br>如果插入时间过长必然等待时间更长，而红黑树相对AVL树他的插入更快！</p>
<p>问题：为什么不使用AVL树而使用红黑树？<br>红黑树和AVL树都是最常用的平衡二叉搜索树，它们的查找、删除、修改都是O(lgn) time</p>
<p>AVL树和红黑树有几点比较和区别：<br>（1）AVL树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用AVL树。<br>（2）红黑树更适合于插入修改密集型任务。<br>（3）通常，AVL树的旋转比红黑树的旋转更加难以平衡和调试。</p>
<p>总结：</p>
<p>（1）AVL以及红黑树是高度平衡的树数据结构。它们非常相似，真正的区别在于在任何添加/删除操作时完成的旋转操作次数。</p>
<p>（2）两种实现都缩放为a O(lg N)，其中N是叶子的数量，但实际上AVL树在查找密集型任务上更快：利用更好的平衡，树遍历平均更短。另一方面，插入和删除方面，AVL树速度较慢：需要更高的旋转次数才能在修改时正确地重新平衡数据结构。</p>
<p>（3）在AVL树中，从根到任何叶子的最短路径和最长路径之间的差异最多为1。在红黑树中，差异可以是2倍。</p>
<p>（4）两个都给O（log n）查找，但平衡AVL树可能需要O（log n）旋转，而红黑树将需要最多两次旋转使其达到平衡（尽管可能需要检查O（log n）节点以确定旋转的位置）。旋转本身是O（1）操作，因为你只是移动指针。</p>
<h3 id="计算密集型-IO密集型任务分别如何设置线程池的核心线程数和最大线程数，为什么这么设置？"><a href="#计算密集型-IO密集型任务分别如何设置线程池的核心线程数和最大线程数，为什么这么设置？" class="headerlink" title="计算密集型/IO密集型任务分别如何设置线程池的核心线程数和最大线程数，为什么这么设置？"></a>计算密集型/IO密集型任务分别如何设置线程池的核心线程数和最大线程数，为什么这么设置？</h3><h4 id="任务类型举例"><a href="#任务类型举例" class="headerlink" title="任务类型举例:"></a>任务类型举例:</h4><h5 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型:"></a>CPU密集型:</h5><p> 例如,一般我们系统的静态资源,比如js,css等,会存在一个版本号,如 main.js?v0,每当用户访问这个资源的时候,会发送一个比对请求到服务端,比对本地静态文件版本和服务端的文件版本是否一致,不一致则更新.这种任务一般不占用大量IO,所以后台服务器可以快速处理,压力落在CPU上.</p>
<h5 id="I-O密集型"><a href="#I-O密集型" class="headerlink" title="I/O密集型:"></a>I/O密集型:</h5><p>比方说近期我们做的万科CRM系统,常有大数据量的查询和批量插入操作,此时的压力主要在I/O上.</p>
<h4 id="线程数与任务类型的关系"><a href="#线程数与任务类型的关系" class="headerlink" title="线程数与任务类型的关系:"></a>线程数与任务类型的关系:</h4><h5 id="与CPU密集型的关系"><a href="#与CPU密集型的关系" class="headerlink" title="与CPU密集型的关系:"></a>与CPU密集型的关系:</h5><p>一般情况下,CPU核心数 == 最大同时执行线程数.在这种情况下(设CPU核心数为n),大量客户端会发送请求到服务器,但是服务器最多只能同时执行n个线程.</p>
<p>设线程池工作队列长度为m,且m&gt;&gt;n,则此时会导致CPU频繁切换线程来执行(如果CPU使用的是FCFS,则不会频繁切换,如使用的是其他CPU调度算法,如时间片轮转法,最短时间优先,则可能会导致频繁的线程切换).</p>
<p>所以这种情况下,无需设置过大的线程池工作队列,(工作队列长度 = CPU核心数 || CPU核心数+1) 即可.</p>
<h5 id="与I-O密集型的关系"><a href="#与I-O密集型的关系" class="headerlink" title="与I/O密集型的关系:"></a>与I/O密集型的关系:</h5><p>1个线程对应1个方法栈,线程的生命周期与方法栈相同.</p>
<p>比如某个线程的方法栈对应的入站顺序为:controller()-&gt;service()-&gt;DAO(),由于DAO长时间的I/O操作,导致该线程一直处于工作队列,但它又不占用CPU,则此时有1个CPU是处于空闲状态的.</p>
<p>所以,这种情况下,应该加大线程池工作队列的长度(如果CPU调度算法使用的是FCFS,则无法切换),尽量不让CPU空闲下来,提高CPU利用率.</p>
<h3 id="画一下Java-线程几个状态及状态之间互相转换的图？"><a href="#画一下Java-线程几个状态及状态之间互相转换的图？" class="headerlink" title="画一下Java 线程几个状态及状态之间互相转换的图？"></a>画一下Java 线程几个状态及状态之间互相转换的图？</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/v2-6fdc939e35ec801c31ea515e80a88367_hd.jpg" alt="image"></p>
<p>在Java中线程的状态一共被分成6种：</p>
<h4 id="初始态：NEW"><a href="#初始态：NEW" class="headerlink" title="初始态：NEW"></a>初始态：NEW</h4><p>创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。</p>
<h4 id="运行态：RUNNABLE"><a href="#运行态：RUNNABLE" class="headerlink" title="运行态：RUNNABLE"></a>运行态：RUNNABLE</h4><p>在Java中，运行态包括就绪态 和 运行态。</p>
<ul>
<li>就绪态  <ul>
<li>该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。</li>
<li>所有就绪态的线程存放在就绪队列中。</li>
</ul>
</li>
<li>运行态  <ul>
<li>获得CPU执行权，正在执行的线程。</li>
<li>由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。</li>
</ul>
</li>
</ul>
<h4 id="阻塞态"><a href="#阻塞态" class="headerlink" title="阻塞态"></a>阻塞态</h4><ul>
<li>当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。</li>
<li>而在Java中，阻塞态专指请求锁失败时进入的状态。</li>
<li>由一个阻塞队列存放所有阻塞态的线程。</li>
<li>处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。</li>
</ul>
<p>PS：锁、IO、Socket等都资源。</p>
<h4 id="等待态"><a href="#等待态" class="headerlink" title="等待态"></a>等待态</h4><ul>
<li>当前线程中调用wait、join、park函数时，当前线程就会进入等待态。</li>
<li>也有一个等待队列存放所有等待态的线程。</li>
<li>线程处于等待态表示它需要等待其他线程的指示才能继续运行。</li>
<li>进入等待态的线程会释放CPU执行权，并释放资源（如：锁）</li>
</ul>
<h4 id="终止态"><a href="#终止态" class="headerlink" title="终止态"></a>终止态</h4><p>线程执行结束后的状态。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>wait()方法会释放CPU执行权 和 占有的锁。</li>
<li>sleep(long)方法仅释放CPU使用权，锁仍然占用；线程被放入超时等待队列，与yield相比，它会使线程较长时间得不到运行。</li>
<li>yield()方法仅释放CPU执行权，锁仍然占用，线程会被放入就绪队列，会在短时间内再次执行。</li>
<li>wait和notify必须配套使用，即必须使用同一把锁调用；</li>
<li>wait和notify必须放在一个同步块中</li>
<li>调用wait和notify的对象必须是他们所处同步块的锁对象。</li>
</ul>
<h3 id="对线程池的理解，在项目中如何使用的，多个线程之间如何共享数据，多个进程之间如何共享数据？"><a href="#对线程池的理解，在项目中如何使用的，多个线程之间如何共享数据，多个进程之间如何共享数据？" class="headerlink" title="对线程池的理解，在项目中如何使用的，多个线程之间如何共享数据，多个进程之间如何共享数据？"></a>对线程池的理解，在项目中如何使用的，多个线程之间如何共享数据，多个进程之间如何共享数据？</h3><p>首先想到的是将共享数据设置为全局变量，并且用static修饰，但是static修饰的变量是类变量，生命周期太长了，占用内存。</p>
<p>方法一：多个线程对共享数据的操作是相同的，那么创建<br>一个Runnable的子类对象，将这个对象作为参数传递给Thread的构造方法，此时因为多个线程操作的是同一个Runnable的子类对象，所以他们操作的是同一个共享数据。比如：买票系统，所以的线程的操作都是对票数减一的操作。 </p>
<p>方法二：多个线程对共享数据的操作是不同的，将共享数据和操作共享数据的方法放在同一对象中，将这个对象作为参数传递给Runnable的子类，在子类中用该对象的方法对共享数据进行操作。如：生产者消费者。</p>
<p>方法三：多个线程对共享数据的操作是不同的， 用内部类的方式去实现，创建Runnable的子类作为内部类，将共享对象作为全局变量，在Runnable的子类中对共享数据进行操作。 </p>
<p>方法四:ThreadLocal实现线程范围内数据的共享</p>
<h2 id="框架相关（Spring）"><a href="#框架相关（Spring）" class="headerlink" title="框架相关（Spring）"></a>框架相关（Spring）</h2><h3 id="Spring源码看过没有，会多少讲多少？"><a href="#Spring源码看过没有，会多少讲多少？" class="headerlink" title="Spring源码看过没有，会多少讲多少？"></a>Spring源码看过没有，会多少讲多少？</h3><p>灵魂问题，，，自己发挥</p>
<h4 id="各个组件"><a href="#各个组件" class="headerlink" title="各个组件"></a>各个组件</h4><h5 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h5><p>是对资源的抽象，每一个接口实现类都代表了一种资源类型，如 ClasspathResource 、 URLResource ， FileSystemResource 等。每一个资源类型都封装了对某一种特定资源的访问策略。它是 spring 资源访问策略的一个基础实现，应用在很多场景。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/ead09fcb-3c6c-3740-9e36-6de33fd65cca.jpg" alt="image"></p>
<h5 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h5><p>用来抽象和描述一个具体 bean 对象。是描述一个 bean 对象的基本数据结构。</p>
<h5 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h5><p>BeanDefinitionReader 将外部资源对象描述的 bean 定义统一转化为统一的内部数据结构 BeanDefinition 。对应不同的描述需要有不同的 Reader 。如 XmlBeanDefinitionReader 用来读取 xml 描述配置的 bean 对象。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/c4143d16-02e2-3d7b-9734-4d19a9a984dd.jpg" alt="image"></p>
<h5 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h5><p>用来定义一个很纯粹的 bean 容器。它是一个 bean 容器的必备结构。同时和外部应用环境等隔离。 BeanDefinition 是它的基本数据结构。它维护一个 BeanDefinitions Map, 并可根据 BeanDefinition 的描述进行 bean 的创建和管理。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/24095923-75cd-363b-bc2f-9fbc603c341f.jpg" alt="image"></p>
<h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h5><p>从名字来看叫应用上下文，是和应用环境息息相关的。没错这个就是我们平时开发中经常直接使用打交道的一个类，应用上下文，或者也叫做 spring 容器。其实它的基本实现是会持有一个 BeanFactory 对象，并基于此提供一些包装和功能扩展。为什么要这么做呢？因为 BeanFactory 实现了一个容器基本结构和功能，但是与外部环境隔离。那么读取配置文件，并将配置文件解析成 BeanDefinition ，然后注册到 BeanFactory 的这一个过程的封装自然就需要 ApplicationContext 。 ApplicationContext 和应用环境细细相关，常见实现有 ClasspathXmlApplicationContext,FileSystemXmlApplicationContext,WebApplicationContext 等。 Classpath 、 xml 、 FileSystem 、 Web 等词都代表了应用和环境相关的一些意思，从字面上不难理解各自代表的含义。</p>
<p>当然 ApplicationContext 和 BeanFactory 的区别远不止于此，有：</p>
<ol>
<li><p>资源访问功能：在 Resource 和 ResourceLoader 的基础上可以灵活的访问不同的资源。</p>
</li>
<li><p>支持不同的信息源。</p>
</li>
<li><p>支持应用事件：继承了接口 ApplicationEventPublisher ，这样在上下文中为 bean 之间提供了事件机制。</p>
</li>
</ol>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/c456f949-7b9c-34db-ad1a-ca3141219b6d.jpg" alt="image"></p>
<p>以上 5 个组件基本代表了 ioc 容器的一个最基本组成，而组件的组合是放在 ApplicationContext 的实现这一层来完成。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/d9a0e8c8-29d6-36a3-888e-e22c2d1bb44f.jpg" alt="image"><br>左边黄色部分是 ApplicationContext 体系继承结构，右边是 BeanFactory 的结构体系,两个结构是典型模板方法设计模式的使用。</p>
<p>从该继承体系可以看出：</p>
<ol>
<li><p>BeanFactory 是一个 bean 工厂的最基本定义，里面包含了一个 bean 工厂的几个最基本的方法， getBean(…) 、 containsBean(…) 等 ,是一个很纯粹的bean工厂，不关注资源、资源位置、事件等。 ApplicationContext 是一个容器的最基本接口定义，它继承了 BeanFactory, 拥有工厂的基本方法。同时继承了 ApplicationEventPublisher 、 MessageSource 、 ResourcePatternResolver 等接口，使其 定义了一些额外的功能，如资源、事件等这些额外的功能。</p>
</li>
<li><p>AbstractBeanFactory 和 AbstractAutowireCapableBeanFactory 是两个模板抽象工厂类。 AbstractBeanFactory 提供了 bean 工厂的抽象基类，同时提供了 ConfigurableBeanFactory 的完整实现。 AbstractAutowireCapableBeanFactory 是继承了 AbstractBeanFactory 的抽象工厂，里面提供了 bean 创建的支持，包括 bean 的创建、依赖注入、检查等等功能，是一个核心的 bean 工厂基类。</p>
</li>
<li><p>ClassPathXmlApplicationContext之 所以拥有 bean 工厂的功能是通过持有一个真正的 bean 工厂 DefaultListableBeanFactory 的实例，并通过 代理 该工厂完成。</p>
</li>
<li><p>ClassPathXmlApplicationContext 的初始化过程是对本身容器的初始化同时也是对其持有的 DefaultListableBeanFactory 的初始化。</p>
</li>
</ol>
<h4 id="容器初始化过程"><a href="#容器初始化过程" class="headerlink" title="容器初始化过程"></a>容器初始化过程</h4><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/370101b5-b3d1-3b79-b9b2-3bba91d092d7.jpg" alt="image"><br>整个过程可以理解为是容器的初始化过程。第一个过程是 ApplicationContext 的职责范围，第二步是 BeanFactory 的职责范围。可以看出 ApplicationContext 是一个运行时的容器需要提供不容资源环境的支持，屏蔽不同环境的差异化。而 BeanDifinition 是内部关于 bean 定义的基本结构。 Bean 的创建就是基于它，回头会介绍一下改结构的定义。下面看一下整个容器的初始化过程。</p>
<p>容器的初始化是通过调用 refresh() 来实现。该方法是非常重要的一个方法，定义在 AbstractApplicationContext 接口里。 AbstractApplicationContext 是容器的最基础的一个抽象父类。也就是说在该里面定义了一个容器初始化的基本流程，流程里的各个方法有些有提供了具体实现，有些是抽象的 ( 因为不同的容器实例不一样 ) ，由继承它的每一个具体容器完成定制。看看 refresh 的基本流程：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;  </span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.  </span></span><br><span class="line">        prepareRefresh();  </span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.  </span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();  </span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.  </span></span><br><span class="line">        prepareBeanFactory(beanFactory);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.  </span></span><br><span class="line">            postProcessBeanFactory(beanFactory);  </span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.  </span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);  </span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.  </span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);  </span><br><span class="line">            <span class="comment">// Initialize message source for this context.  </span></span><br><span class="line">            initMessageSource();  </span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.  </span></span><br><span class="line">            initApplicationEventMulticaster();  </span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.  </span></span><br><span class="line">            onRefresh();  </span><br><span class="line">            <span class="comment">// Check for listener beans and register them.  </span></span><br><span class="line">            registerListeners();  </span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.  </span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);  </span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.  </span></span><br><span class="line">            finishRefresh();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.  </span></span><br><span class="line">            beanFactory.destroySingletons();  </span><br><span class="line">            <span class="comment">// Reset 'active' flag.  </span></span><br><span class="line">            cancelRefresh(ex);  </span><br><span class="line">            <span class="comment">// Propagate exception to caller.  </span></span><br><span class="line">            <span class="keyword">throw</span> ex;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2187e288-5c0b-313b-8053-82992267fab6.jpg" alt="image"></p>
<h4 id="Bean-的创建过程"><a href="#Bean-的创建过程" class="headerlink" title="Bean 的创建过程"></a>Bean 的创建过程</h4><p>Bean的创建过程基本是BeanFactory所要完成的事情.</p>
<p>根据以上过程，将会重点带着以下两个个问题来理解核心代码：</p>
<p>1.Bean 的创建时机</p>
<p>bean 是在什么时候被创建的，有哪些规则。</p>
<p>2.Bean 的创建过程</p>
<p>bean 是怎么创建的，会选择哪个构造函数？依赖如何注入？ InitializingBean 的 set 方法什么时候被调用？实现 ApplicationContextAware, BeanFactoryAware,BeanNameAware, ResourceLoaderAware 这些接口的 bean 的 set 方法何时被调用？</p>
<p>在解释这两个问题前，先看一下 BeanDefinition 接口的定义。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2beb44aa-4b38-3d87-a444-308d8f380e87.jpg" alt="image"></p>
<p>从该接口定义可以看出，通过 bean 定义能够得到 bean 的详细信息，如类名子、工厂类名称、 scope 、是否单例、是否抽象、是否延迟加载等等。基于此，来看一下以下两个问题：</p>
<h5 id="问题-1-：-Bean-的创建时机"><a href="#问题-1-：-Bean-的创建时机" class="headerlink" title="问题 1 ： Bean 的创建时机"></a>问题 1 ： Bean 的创建时机</h5><p>bean 是在什么时候被创建的，有哪些规则？</p>
<p>容器初始化的时候会预先对单例和非延迟加载的对象进行预先初始化。其他的都是延迟加载是在第一次调用 getBean 的时候被创建。从 DefaultListableBeanFactory 的 preInstantiateSingletons 里可以看到这个规则的实现。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> void preInstantiateSingletons() throws <span class="keyword">BeansException </span>&#123;  </span><br><span class="line">    <span class="meta">if</span> (this.logger.isInfoEnabled()) &#123;  </span><br><span class="line">        this.logger.info(<span class="string">"Pre-instantiating singletons in "</span> + this)<span class="comment">;  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    synchronized (this.<span class="keyword">beanDefinitionMap) </span>&#123;  </span><br><span class="line">        for (<span class="keyword">Iterator </span><span class="keyword">it </span>= this.<span class="keyword">beanDefinitionNames.iterator(); </span><span class="keyword">it.hasNext();) </span>&#123;  </span><br><span class="line">            <span class="keyword">String </span><span class="keyword">beanName </span>= (<span class="keyword">String) </span><span class="keyword">it.next(); </span> </span><br><span class="line">            RootBeanDefinition <span class="keyword">bd </span>= getMergedLocalBeanDefinition(<span class="keyword">beanName); </span> </span><br><span class="line">            &lt;span style=<span class="string">"color: #ff0000;"</span>&gt;<span class="meta">if</span> (!<span class="keyword">bd.isAbstract() </span>&amp;&amp; <span class="keyword">bd.isSingleton() </span>&amp;&amp; !<span class="keyword">bd.isLazyInit()) </span>&#123;&lt;/span&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//对非抽象、单例的和非延迟加载的对象进行实例化。  </span><br><span class="line">                <span class="meta">if</span> (isFactoryBean(<span class="keyword">beanName)) </span>&#123;  </span><br><span class="line">                    FactoryBean factory = (FactoryBean) getBean(FACTORY_BEAN_PREFIX + <span class="keyword">beanName); </span> </span><br><span class="line">                    <span class="meta">if</span> (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean) factory).isEagerInit()) &#123;  </span><br><span class="line">                        getBean(<span class="keyword">beanName); </span> </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="meta">else</span> &#123;  </span><br><span class="line">                    getBean(<span class="keyword">beanName); </span> </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面来看对于以下配置，只有 singletonBean 会被预先创建。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"GB2312"</span><span class="meta">?&gt;</span></span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"otherBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.OtherBean"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.MyBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"singletonBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.SingletonBean"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="问题二：Bean-的创建过程"><a href="#问题二：Bean-的创建过程" class="headerlink" title="问题二：Bean 的创建过程"></a>问题二：Bean 的创建过程</h5><p>对于 bean 的创建过程其实都是通过调用工厂的 getBean 方法来完成的。这里面将会完成对构造函数的选择、依赖注入等。</p>
<p>无论预先创建还是延迟加载都是调用getBean实现，AbstractBeanFactory 定义了 getBean 的过程：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> doGetBean(  </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> name, <span class="keyword">final</span> Class requiredType, <span class="keyword">final</span> <span class="keyword">Object</span>[] args, <span class="built_in">boolean</span> typeCheckOnly) <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span> beanName = transformedBeanName(name);  </span><br><span class="line">    <span class="keyword">Object</span> bean = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.  </span></span><br><span class="line">    <span class="keyword">Object</span> sharedInstance = getSingleton(beanName);  </span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;  </span><br><span class="line">                logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +  </span><br><span class="line">                        <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// Fail if we're already creating this bean instance:  </span></span><br><span class="line">        <span class="comment">// We're assumably within a circular reference.  </span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if bean definition exists in this factory.  </span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();  </span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;  </span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.  </span></span><br><span class="line">            <span class="keyword">String</span> nameToLookup = originalBeanName(name);  </span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.  </span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, args);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.  </span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;  </span><br><span class="line">            markBeanAsCreated(beanName);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);  </span><br><span class="line">        checkMergedBeanDefinition(mbd, beanName, args);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Guarantee initialization of beans that the current bean depends on.  </span></span><br><span class="line">        <span class="keyword">String</span>[] dependsOn = mbd.getDependsOn();  </span><br><span class="line">        <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dependsOn.length; i++) &#123;  </span><br><span class="line">                <span class="keyword">String</span> dependsOnBean = dependsOn[i];  </span><br><span class="line">                getBean(dependsOnBean);  </span><br><span class="line">                registerDependentBean(dependsOnBean, beanName);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// Create bean instance.  </span></span><br><span class="line">        &lt;span style=<span class="string">"color: #ff0000;"</span>&gt;<span class="keyword">if</span> (mbd.isSingleton()) &#123;<span class="comment">//单例对象创建过程,间接通过getSingleton方法来创建，里面会实现将单例对象缓存&lt;/span&gt;  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">Object</span> getObject() <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">                        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there  </span></span><br><span class="line">                        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.  </span></span><br><span class="line">                        <span class="comment">// Also remove any beans that received a temporary reference to the bean.  </span></span><br><span class="line">                        destroySingleton(beanName);  </span><br><span class="line">                        <span class="keyword">throw</span> ex;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        &lt;span style=<span class="string">"color: #ff0000;"</span>&gt;<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;<span class="comment">//非单例对象创建&lt;/span&gt;  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// It's a prototype -&gt; create a new instance.  </span></span><br><span class="line">            <span class="keyword">Object</span> prototypeInstance = <span class="keyword">null</span>;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                beforePrototypeCreation(beanName);  </span><br><span class="line">                prototypeInstance = createBean(beanName, mbd, args);&lt;span style=<span class="string">"color: #ff0000;"</span>&gt;<span class="comment">//直接调用createBean&lt;/span&gt;  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">finally</span> &#123;  </span><br><span class="line">                afterPrototypeCreation(beanName);  </span><br><span class="line">            &#125;  </span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">String</span> scopeName = mbd.getScope();  </span><br><span class="line">            <span class="keyword">final</span> Scope scope = (Scope) <span class="keyword">this</span>.scopes.<span class="built_in">get</span>(scopeName);  </span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope '"</span> + scopeName + <span class="string">"'"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">Object</span> scopedInstance = scope.<span class="built_in">get</span>(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">Object</span> getObject() <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">                        beforePrototypeCreation(beanName);  </span><br><span class="line">                        <span class="keyword">try</span> &#123;  </span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">finally</span> &#123;  </span><br><span class="line">                            afterPrototypeCreation(beanName);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;);  </span><br><span class="line">                bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,  </span><br><span class="line">                        <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; "</span> +  </span><br><span class="line">                        <span class="string">"consider defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,  </span><br><span class="line">                        ex);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Check if required type matches the type of the actual bean instance.  </span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> bean;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GetBean 的大概过程：</p>
<p>1.先试着从单例缓存对象里获取。</p>
<p>2.从父容器里取定义，有则由父容器创建。</p>
<p>3.如果是单例，则走单例对象的创建过程：在 spring 容器里单例对象和非单例对象的创建过程是一样的。都会调用父类 AbstractAutowireCapableBeanFactory 的 createBean 方法。 不同的是单例对象只创建一次并且需要缓存起来。 DefaultListableBeanFactory 的父类 DefaultSingletonBeanRegistry 提供了对单例对象缓存等支持工作。所以是单例对象的话会调用 DefaultSingletonBeanRegistry 的 getSingleton 方法，它会间接调用 AbstractAutowireCapableBeanFactory 的 createBean 方法。</p>
<p>如果是 Prototype 多例则直接调用父类 AbstractAutowireCapableBeanFactory 的 createBean 方法。</p>
<p>bean的创建是由AbstractAutowireCapableBeanFactory来定义：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> createBean(<span class="keyword">final</span> <span class="keyword">String</span> beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="keyword">Object</span>[] args)  </span><br><span class="line">            <span class="keyword">throws</span> BeanCreationException &#123;  </span><br><span class="line">    AccessControlContext acc = AccessController.getContext();  </span><br><span class="line">    <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">Object</span> run() &#123;  </span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// Make sure bean class is actually resolved at this point.  </span></span><br><span class="line">            resolveBeanClass(mbd, beanName);  </span><br><span class="line">            <span class="comment">// Prepare method overrides.  </span></span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                mbd.prepareMethodOverrides();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(),  </span><br><span class="line">                        beanName, <span class="string">"Validation of method overrides failed"</span>, ex);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.  </span></span><br><span class="line">                <span class="keyword">Object</span> bean = resolveBeforeInstantiation(beanName, mbd);  </span><br><span class="line">                <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    <span class="keyword">return</span> bean;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,  </span><br><span class="line">                        <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">Object</span> beanInstance = doCreateBean(beanName, mbd, args);  </span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> beanInstance;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;, acc);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>createBean 会调用 doCreateBean 方法：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> doCreateBean(<span class="keyword">final</span> <span class="keyword">String</span> beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="keyword">Object</span>[] args) &#123;  </span><br><span class="line">    <span class="comment">// Instantiate the bean.  </span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;  </span><br><span class="line">        instanceWrapper = (BeanWrapper) <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">Object</span> bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);  </span><br><span class="line">    Class beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.  </span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;  </span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);  </span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references  </span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.  </span></span><br><span class="line">    <span class="built_in">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;  </span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));  </span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +  </span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">Object</span> getObject() <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">                <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Initialize the bean instance.  </span></span><br><span class="line">    <span class="keyword">Object</span> exposedObject = bean;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);  </span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;  </span><br><span class="line">        <span class="keyword">Object</span> earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);  </span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;  </span><br><span class="line">                exposedObject = earlySingletonReference;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;  </span><br><span class="line">                <span class="keyword">String</span>[] dependentBeans = getDependentBeans(beanName);  </span><br><span class="line">                Set actualDependentBeans = <span class="keyword">new</span> LinkedHashSet(dependentBeans.length);  </span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dependentBeans.length; i++) &#123;  </span><br><span class="line">                    <span class="keyword">String</span> dependentBean = dependentBeans[i];  </span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;                         actualDependentBeans.<span class="built_in">add</span>(dependentBean);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;  </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,  </span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +  </span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +  </span><br><span class="line">                            <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +  </span><br><span class="line">                            <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +  </span><br><span class="line">                            <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +  </span><br><span class="line">                            <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Register bean as disposable.  </span></span><br><span class="line">    registerDisposableBeanIfNecessary(beanName, bean, mbd);  </span><br><span class="line">    <span class="keyword">return</span> exposedObject;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>doCreateBean 的流程：</p>
<p>1.会创建一个 BeanWrapper 对象 用于存放实例化对象。</p>
<p>2.如果没有指定构造函数，会通过反射拿到一个默认的构造函数对象，并赋予 beanDefinition.resolvedConstructorOrFactoryMethod 。</p>
<p>3.调用 spring 的 BeanUtils 的 instantiateClass 方法，通过反射创建对象。</p>
<p>4.applyMergedBeanDefinitionPostProcessors</p>
<p>5.populateBean(beanName, mbd, instanceWrapper); 根据注入方式进行注入。根据是否有依赖检查进行依赖检查。</p>
<p>执行 bean 的注入里面会选择注入类型：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||  </span><br><span class="line">                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </span><br><span class="line">    MutablePropertyValues <span class="keyword">new</span><span class="type">Pvs</span> = <span class="keyword">new</span> <span class="type">MutablePropertyValues</span>(pvs);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add property values based on autowire by name if applicable.  </span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;  </span><br><span class="line">        autowireByName(beanName, mbd, bw, <span class="keyword">new</span><span class="type">Pvs</span>);  </span><br><span class="line">    &#125;&lt;span style=<span class="string">"color: #ff0000;"</span>&gt;<span class="comment">//根据名字注入&lt;/span&gt;  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add property values based on autowire by type if applicable.  </span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </span><br><span class="line">        autowireByType(beanName, mbd, bw, <span class="keyword">new</span><span class="type">Pvs</span>);  </span><br><span class="line">    &#125;&lt;span style=<span class="string">"color: #ff0000;"</span>&gt;<span class="comment">//根据类型注入&lt;/span&gt;  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pvs = <span class="keyword">new</span><span class="type">Pvs</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.initializeBean(beanName, exposedObject, mbd);</p>
<p>判断是否实现了 BeanNameAware 、 BeanClassLoaderAware 等 spring 提供的接口，如果实现了，进行默认的注入。同时判断是否实现了 InitializingBean 接口，如果是的话，调用 afterPropertySet 方法。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">protected</span> Object initializeBean(<span class="keyword">String </span><span class="keyword">beanName, </span>Object <span class="keyword">bean, </span>RootBeanDefinition mbd) &#123;  </span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">bean </span>instanceof <span class="keyword">BeanNameAware) </span>&#123;  </span><br><span class="line">        ((<span class="keyword">BeanNameAware) </span><span class="keyword">bean).setBeanName(beanName); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">bean </span>instanceof <span class="keyword">BeanClassLoaderAware) </span>&#123;  </span><br><span class="line">        ((<span class="keyword">BeanClassLoaderAware) </span><span class="keyword">bean).setBeanClassLoader(getBeanClassLoader()); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">bean </span>instanceof <span class="keyword">BeanFactoryAware) </span>&#123;  </span><br><span class="line">        ((<span class="keyword">BeanFactoryAware) </span><span class="keyword">bean).setBeanFactory(this); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">    Object wrappedBean = <span class="keyword">bean; </span> </span><br><span class="line">    <span class="meta">if</span> (mbd == null <span class="title">||</span> !mbd.isSynthetic()) &#123;  </span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, <span class="keyword">beanName); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">&lt;span style=<span class="string">"color: #ff0000;"</span>&gt;      try &#123;  </span><br><span class="line">        invokeInitMethods(<span class="keyword">beanName, </span>wrappedBean, mbd)<span class="comment">;  </span></span><br><span class="line">    &#125;&lt;/span&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    catch (Throwable ex) &#123;  </span><br><span class="line">        throw new <span class="keyword">BeanCreationException( </span> </span><br><span class="line">                (mbd != null ? mbd.getResourceDescription() : null),  </span><br><span class="line">                <span class="keyword">beanName, </span><span class="string">"Invocation of init method failed"</span>, ex)<span class="comment">;  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">if</span> (mbd == null <span class="title">||</span> !mbd.isSynthetic()) &#123;  </span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, <span class="keyword">beanName); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">    return wrappedBean<span class="comment">;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中invokeInitMethods实现如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> invokeInitMethods(<span class="keyword">String</span> beanName, <span class="keyword">Object</span> bean, RootBeanDefinition mbd)  </span><br><span class="line">        <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);  </span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            logger.debug(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        ((InitializingBean) bean).afterPropertiesSet();&lt;span style=<span class="string">"color: #ff0000;"</span>&gt;<span class="comment">//调用afterPropertiesSet方法&lt;/span&gt;  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">String</span> initMethodName = (mbd != <span class="keyword">null</span> ? mbd.getInitMethodName() : <span class="keyword">null</span>);  </span><br><span class="line">    <span class="keyword">if</span> (initMethodName != <span class="keyword">null</span> &amp;&amp; !(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;  </span><br><span class="line">            !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;  </span><br><span class="line">        invokeCustomInitMethod(beanName, bean, initMethodName, mbd.isEnforceInitMethod());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Spring-xml-ioc-容器常用标签和自定义标签"><a href="#Spring-xml-ioc-容器常用标签和自定义标签" class="headerlink" title="Spring  xml ioc 容器常用标签和自定义标签"></a>Spring  xml ioc 容器常用标签和自定义标签</h4><p>以 Xml 资源定义的容器配置是我们最常见的一种方式。</p>
<p>Spring 容器需要解析 xml 的标签，并把 xml 里 bean 的定义转化为内部的结构 BeanDifinition 。</p>
<p>Spring 的标签有很多种，其支持的常见的标签有：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;bean&gt;</code></td>
<td>最常用的，定义一个普通 bean。</td>
<td><figure class="highlight plain"><figcaption><span>id</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``&lt;tx&gt;`` | 如``&lt;tx: advice&gt;`` 等,提供事务配置通用支持。 | ```&lt;tx:advice id=&quot;txAdvice&quot;transaction-manager=&quot;transactionManager&quot;&gt;  &lt;tx:attributes&gt; &lt;tx:method name=&quot;save*&quot;/&gt;  &lt;tx:method name=&quot;remove*&quot;/&gt;   &lt;tx:method name=&quot;*&quot; read-only=&quot;true&quot;/&gt;  &lt;/tx:attributes&gt;  &lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure></td>
</tr>
</tbody>
</table>
<p><code>&lt;aop&gt;</code> | <code>&lt;aop:config&gt;</code>,<code>&lt;aop: aspectj-autoproxy&gt;</code> 等提供代理 bean 通用配置支持。 | <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``&lt;util&gt;`` | 提供在容器内配置一些JDK自带的工具类、集合类和常量的支持。 | ```&lt;util:list id=&quot;list&quot;list-class=&quot;java.util.ArrayList&quot;&gt;&lt;value&gt;listValue1&lt;/value&gt;   &lt;value&gt;listValue2&lt;/value&gt;  &lt;/util:list&gt;  &lt;util:map id=&quot;map&quot;&gt;  &lt;entry key=&quot;key1&quot;  value=&quot;mapValue1&quot;&gt;&lt;/entry&gt;&lt;entry key=&quot;key12&quot; value=&quot;mapValue2&quot;&gt;&lt;/entry&gt;  &lt;/util:map&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;p&gt;</code> | 属性的简单访问。 | <figure class="highlight plain"><figcaption><span>id</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``&lt;lang&gt;`` | ``&lt;lang:groovy&gt;````&lt;lang:jruby&gt;``等，提供对动态脚本的支持。 | ```&lt;lang:groovy id=&quot;test&quot;  refresh-check-delay=&quot;5000&quot; script-source=&quot;classpath:com/test/groovy/test.groovy&quot;&gt;  &lt;/lang:groovy&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;jee&gt;</code> | <code>&lt;jee:jndi-lookup/&gt;</code>等，对一些javaEE规范的bean配置的简化，如jndi等。 | <figure class="highlight plain"><figcaption><span>id</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">基本上每一种标签都是用来定义一类 bean 的（P标签除外）。以上都是 spring 自带的一些标签，当然 spring 也支持自定义标签。其实 ``&lt;tx&gt;&lt;aop&gt;`` 这些也可以认为是自定义标签，不过是由 spring 扩展的而已。</span><br><span class="line"></span><br><span class="line">其实所有的bean定义都可以用bean标签来实现定义的。而衍生这种自定义标签来定义 bean 有几个好处：</span><br><span class="line"></span><br><span class="line">1.见名知意。</span><br><span class="line"></span><br><span class="line">2. 对于同一类的通用 bean。封装不必要的配置，只给外部暴露一个简单易用的标签和一些需要配置的属性。很多时候对于一个框架通用的 bean ，我们不需要把 bean 的所有配置都暴露出来，甚至像类名、默认值等我们都想直接封装，这个时候就可以使用自定义标签了，如： &lt;services:property-placeholder /&gt; 可能这个标签就默认代表配置了一个支持 property placeholder 的通用 bean ，我们都不需要去知道配这样一个 bean 的类路径是什么。</span><br><span class="line"></span><br><span class="line">可以说自定义标签是 spring 的 xml 容器的一个扩展点，本身 spring 自己的很多标签也是基于这个设计上面来构造出来的。</span><br><span class="line"></span><br><span class="line">#### Spring 对于自定义（声明式）bean标签解析如何设计</span><br><span class="line">Bean 的定义方式有千千万万种，无论是何种标签，无论是何种资源定义，无论是何种容器，最终的 bean 定义内部表示都将转换为内部的唯一结构： BeanDefinition 。外部的各种定义说白了就是为了方便配置。</span><br><span class="line"></span><br><span class="line">Spring 提供对其支持的标签解析的天然支持。所以只要按照 spring 的规范编写 xml 配置文件。所有的配置，在启动时都会正常的被解析成 BeanDefinition 。但是如果我们要实现一个自定义标签，则需要提供对自定义标签的全套支持。</span><br><span class="line"></span><br><span class="line">我们知道要去完成一个自定义标签，需要完成的事情有：</span><br><span class="line"></span><br><span class="line">1. 编写自定义标签 schema 定义文件，放在某个 classpath 下。</span><br><span class="line"></span><br><span class="line">2.  在 classpath 的在 META-INF 下面增加 spring.schemas 配置文件，指定 schema 虚拟路径和实际 xsd 的映射。我们在 xml 里的都是虚拟路径，如：</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;  </p>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xsi:schemalocation="  
            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  
            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd  
            ">  

<pre><code>    &lt;bean id=&quot;otherBean&quot;          class=&quot;com.test.OtherBean&quot; scope=&quot;prototype&quot;/&gt;  
&lt;bean id=&quot;myBean&quot;          class=&quot;com.test.MyBean&quot; lazy-init=&quot;true&quot;/&gt;  
&lt;bean id=&quot;singletonBean&quot;          class=&quot;com.test.SingletonBean&quot;/&gt;  
</code></pre><p></p></beans><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">头部的</span><br></pre></td></tr></table></figure><p></p>
<p><a href="http://www.springframework.org/schema/beans" target="_blank" rel="noopener">http://www.springframework.org/schema/beans</a> <a href="http://www.springframework.org/schema/beans/spring-beans-2.5.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</a><br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是一个虚拟路径，其对应的真实路径在<span class="keyword">spring</span> jar包里的META-INF/<span class="keyword">spring</span>.schemas里面有映射到classpath定义：</span><br></pre></td></tr></table></figure></p>
<p> http\://<a href="http://www.springframework.org/schema/beans/spring-beans-2.5.xsd=org/springframework/beans/factory/xml/spring-beans-2.5.xsd" target="_blank" rel="noopener">www.springframework.org/schema/beans/spring-beans-2.5.xsd=org/springframework/beans/factory/xml/spring-beans-2.5.xsd</a><br> <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">3</span>.       增加一个 NamespaceHandler 和 BeanDefinitionParser ，用于解析自定义的标签，将自定义标签的 bean 解析成一个 BeanDefinition 返回。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.       在 classpath 的在 <span class="keyword">META</span><span class="literal">-INF</span> 下面增加 spring.handlers 配置文件，指定标签命名空间和 handlers 的映射。</span><br><span class="line"></span><br><span class="line"> 为什么要做以上几个事情？我们来看看设计：</span><br><span class="line"></span><br><span class="line">Spring 对标签解析的设计的过程如下：</span><br><span class="line"></span><br><span class="line">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/a2d7e37b-e394-<span class="number">3</span>f90-bf20-<span class="number">7</span>f480db1dc5d.jpg)</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Step <span class="number">1</span>： 将 <span class="keyword">xml</span> <span class="title">文件解析成 Dom</span> 树。将 <span class="keyword">xml</span> <span class="title">文件解析成 dom</span> 树的时候，需要 <span class="keyword">xml</span> <span class="title">标签定义 schema</span> 来验证文件的语法结构。 Spring 约定将所有的 shema 的虚拟路径和真是文件路径映射定义在 classpath 的在 <span class="keyword">META</span><span class="literal">-INF</span>/spring.schemas 下面。在容器启动时 Spring 会扫描所有的 <span class="keyword">META</span><span class="literal">-INF</span>/spring.schemas 并将映射维护到一个 map 里。</span><br><span class="line"></span><br><span class="line">如 spring jar 包里会有自带的标签的 schemas 映射，可以看一下部分配置：</span><br></pre></td></tr></table></figure></p>
<p>http\://<a href="http://www.springframework.org/schema/aop/spring-aop-2.0.xsd" target="_blank" rel="noopener">www.springframework.org/schema/aop/spring-aop-2.0.xsd</a>  =  org/springframework/aop/config/spring-aop-2.0.xsd<br>http\://<a href="http://www.springframework.org/schema/aop/spring-aop-2.5.xsd" target="_blank" rel="noopener">www.springframework.org/schema/aop/spring-aop-2.5.xsd</a>  =  org/springframework/aop/config/spring-aop-2.5.xsd<br>http\://<a href="http://www.springframework.org/schema/aop/spring-aop.xsd" target="_blank" rel="noopener">www.springframework.org/schema/aop/spring-aop.xsd</a>  =  org/springframework/aop/config/spring-aop-2.5.xsd<br>http\://<a href="http://www.springframework.org/schema/beans/spring-beans-2.0.xsd" target="_blank" rel="noopener">www.springframework.org/schema/beans/spring-beans-2.0.xsd</a>  =  org/springframework/beans/factory/xml/spring-beans-2.0.xsd<br>http\://<a href="http://www.springframework.org/schema/beans/spring-beans-2.5.xsd" target="_blank" rel="noopener">www.springframework.org/schema/beans/spring-beans-2.5.xsd</a>  =  org/springframework/beans/factory/xml/spring-beans-2.5.xsd<br>http\://<a href="http://www.springframework.org/schema/beans/spring-beans.xsd" target="_blank" rel="noopener">www.springframework.org/schema/beans/spring-beans.xsd</a>  =  org/springframework/beans/factory/xml/spring-beans-2.5.xsd<br>http\://<a href="http://www.springframework.org/schema/context/spring-context-2.5.xsd" target="_blank" rel="noopener">www.springframework.org/schema/context/spring-context-2.5.xsd</a>  =  org/springframework/context/config/spring-context-2.5.xsd<br>http\://<a href="http://www.springframework.org/schema/context/spring-context.xsd" target="_blank" rel="noopener">www.springframework.org/schema/context/spring-context.xsd</a>  =  org/springframework/context/config/spring-context-2.5.xsd<br>http\://<a href="http://www.springframework.org/schema/jee/spring-jee-2.0.xsd" target="_blank" rel="noopener">www.springframework.org/schema/jee/spring-jee-2.0.xsd</a>  =  org/springframework/ejb/config/spring-jee-2.0.xsd<br>http\://<a href="http://www.springframework.org/schema/jee/spring-jee-2.5.xsd" target="_blank" rel="noopener">www.springframework.org/schema/jee/spring-jee-2.5.xsd</a>  =  org/springframework/ejb/config/spring-jee-2.5.xsd<br>……<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">等号左边是虚拟路径，右边是真是路径(<span class="keyword">classpath</span>下的)。</span><br><span class="line">虚拟路径用在我们的bean定义配置文件里，如：</span><br></pre></td></tr></table></figure></p>
<p>&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/beans&quot;</a><br>    xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance&quot;</a> xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/context&quot;</a><br>    xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/p&quot;</a><br>    xsi:schemaLocation=”<br>            <a href="http://www.springframework.org/schema/beans" target="_blank" rel="noopener">http://www.springframework.org/schema/beans</a> <a href="http://www.springframework.org/schema/beans/spring-beans-2.5.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</a><br>            <a href="http://www.springframework.org/schema/context" target="_blank" rel="noopener">http://www.springframework.org/schema/context</a> <a href="http://www.springframework.org/schema/context/spring-context-2.5.xsd&gt;" target="_blank" rel="noopener">http://www.springframework.org/schema/context/spring-context-2.5.xsd&gt;</a>  </p>
<p><bean><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beans里面的</span><br></pre></td></tr></table></figure></bean></p>
<p><a href="http://www.springframework.org/schema/beans" target="_blank" rel="noopener">http://www.springframework.org/schema/beans</a> <a href="http://www.springframework.org/schema/beans/spring-beans-2.5.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</a><br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">就是个虚拟路径。</span><br><span class="line"></span><br><span class="line">Step <span class="number">2</span>： 将 dom 树解析成 BeanDifinition 。将定义 bean 的标签和 xml 定义解析成 BeanDefinition 的过程。如果是默认的 bean 标签， spring 会直接进行解析。而如果不是默认的 bean 标签，包括自定义和 spring 扩展的 ``&lt;aop&gt; ``、 ``&lt;p&gt; ``、 ``&lt;util&gt;`` 等标签，则需要提供专门的 xmlparser 来处理。 paorser由自己定义和编写，并通过handler注册到容器。Spring 约定了 META-INF/spring.handlers 文件，在这里面定义了标签命名空间和 handler 的映射。容器起来的时候会加载 handler ， handler 会向容器注册该命名空间下的标签和解析器。在解析的自定义标签的时候， spring 会根据标签的命名空间和标签名找到一个解析器。由该解析器来完成对该标签内容的解析，并返回一个 BeanDefinition 。</span><br><span class="line"></span><br><span class="line">以下是 spring jar 包自带的一些自定义标签扩展的 spring.handlers 文件，可以看到定义了 aop\p 等其扩展标签的 handlers 。</span><br></pre></td></tr></table></figure></p>
<p>http\://<a href="http://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler" target="_blank" rel="noopener">www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler</a><br>http\://<a href="http://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler" target="_blank" rel="noopener">www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</a><br>http\://<a href="http://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler" target="_blank" rel="noopener">www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler</a><br>http\://<a href="http://www.springframework.org/schema/jms=org.springframework.jms.config.JmsNamespaceHandler" target="_blank" rel="noopener">www.springframework.org/schema/jms=org.springframework.jms.config.JmsNamespaceHandler</a><br>http\://<a href="http://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler" target="_blank" rel="noopener">www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler</a><br>http\://<a href="http://www.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandler" target="_blank" rel="noopener">www.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandler</a><br>http\://<a href="http://www.springframework.org/schema/tx=org.springframework.transaction.config.TxNamespaceHandler" target="_blank" rel="noopener">www.springframework.org/schema/tx=org.springframework.transaction.config.TxNamespaceHandler</a><br>http\://<a href="http://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler" target="_blank" rel="noopener">www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看看UtilNamespaceHandler的代码实现</span><br></pre></td></tr></table></figure></p>
<p>public void init() {<br>    registerBeanDefinitionParser(“constant”, new ConstantBeanDefinitionParser());<br>    registerBeanDefinitionParser(“property-path”, new PropertyPathBeanDefinitionParser());<br>    registerBeanDefinitionParser(“list”, new ListBeanDefinitionParser());<br>    registerBeanDefinitionParser(“set”, new SetBeanDefinitionParser());<br>    registerBeanDefinitionParser(“map”, new MapBeanDefinitionParser());<br>    registerBeanDefinitionParser(“properties”, new PropertiesBeanDefinitionParser());<br>}<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实现了标签和对应<span class="keyword">parser</span>的映射注册。</span><br><span class="line"></span><br><span class="line"><span class="type">ListBeanDefinitionParser</span>的实现如下：</span><br></pre></td></tr></table></figure></p>
<p>private static class ListBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {  </p>
<pre><code>protected Class getBeanClass(Element element) {  
    return ListFactoryBean.class;  
}  

protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {  
    String listClass = element.getAttribute(&quot;list-class&quot;);  
    List parsedList = parserContext.getDelegate().parseListElement(element, builder.getRawBeanDefinition());  
    builder.addPropertyValue(&quot;sourceList&quot;, parsedList);  
    if (StringUtils.hasText(listClass)) {  
        builder.addPropertyValue(&quot;targetListClass&quot;, listClass);  
    }  
    String scope = element.getAttribute(SCOPE_ATTRIBUTE);  
    if (StringUtils.hasLength(scope)) {  
        builder.setScope(scope);  
    }  
}  
</code></pre><p>}<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">这里父类代码不贴了，主要完成的是beanDifinition的生成。</span><br><span class="line"><span class="section">##### 源码实现</span></span><br><span class="line">Spring 对于自定义（声明式）bean标签源码实现大概的源码结构如下：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1486692b-7ba3-3d1d-a6f6-1c70aa45a21e.jpg</span>)</span><br><span class="line">XmlBeanDefinitionReader 是核心类，它接收 spring 容器传给它的资源 resource 文件，由它负责完成整个转换。它调用 DefaultDocumentLoader 来完成将 Resource 到 Dom 树的转换。调用 DefaultBeanDefinitionDocumentReader 完成将 Dom 树到 BeanDefinition 的转换。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">具体的代码流程细节完全可以基于这个结构去阅读，下面就贴几个核心源码段：</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">源码段 1 ： 加载 spring.shemas，在PluggableSchemaResolver.java里实现：</span><br></pre></td></tr></table></figure></p>
<p>public class PluggableSchemaResolver implements EntityResolver {<br>/<strong><em>定义schema location的映射文件路径</em></strong>/<br>    public static final String DEFAULT_SCHEMA_MAPPINGS_LOCATION = “META-INF/spring.schemas”;<br>    private static final Log logger = LogFactory.getLog(PluggableSchemaResolver.class);<br>    private final ClassLoader classLoader;<br>    private final String schemaMappingsLocation;<br>    /*<em> Stores the mapping of schema URL -&gt; local schema path </em>/<br>    private Properties schemaMappings;<br>    public PluggableSchemaResolver(ClassLoader classLoader) {<br>        this.classLoader = classLoader;<br>        this.schemaMappingsLocation = DEFAULT_SCHEMA_MAPPINGS_LOCATION;<br>    }  </p>
<pre><code>public PluggableSchemaResolver(ClassLoader classLoader, String schemaMappingsLocation) {  
    Assert.hasText(schemaMappingsLocation, &quot;&apos;schemaMappingsLocation&apos; must not be empty&quot;);  
    this.classLoader = classLoader;  
    this.schemaMappingsLocation = schemaMappingsLocation;  
}  
</code></pre><p>/<strong>==========中间省略部分代码=========</strong>/  </p>
<p>/<strong><em>此处完成schema的加载</em></strong>/<br>    protected String getSchemaMapping(String systemId) {<br>        if (this.schemaMappings == null) {<br>            if (logger.isDebugEnabled()) {<br>                logger.debug(“Loading schema mappings from [“ + this.schemaMappingsLocation + “]”);<br>            }<br>            try {<br>                this.schemaMappings =<br>                        PropertiesLoaderUtils.loadAllProperties(this.schemaMappingsLocation, this.classLoader);<br>                if (logger.isDebugEnabled()) {<br>                    logger.debug(“Loaded schema mappings: “ + this.schemaMappings);<br>                }<br>            }<br>            catch (IOException ex) {<br>                throw new FatalBeanException(<br>                        “Unable to load schema mappings from location [“ + this.schemaMappingsLocation + “]”, ex);<br>            }<br>        }<br>        return this.schemaMappings.getProperty(systemId);<br>    }  </p>
<p>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源码段 <span class="number">2</span> ： 加载 spring<span class="selector-class">.handlers</span>,在 DefaultNamespaceHandlerResolver里实现：</span><br></pre></td></tr></table></figure></p>
<p>public class DefaultNamespaceHandlerResolver implements NamespaceHandlerResolver {<br>    /** </p>
<pre><code> * The location to look for the mapping files. Can be present in multiple JAR files. 
 */  
public static final String DEFAULT_HANDLER_MAPPINGS_LOCATION = &quot;META-INF/spring.handlers&quot;;  

/** Logger available to subclasses */  
protected final Log logger = LogFactory.getLog(getClass());  
/** ClassLoader to use for NamespaceHandler classes */  
private final ClassLoader classLoader;  
/** Resource location to search for */  
private final String handlerMappingsLocation;  
/** Stores the mappings from namespace URI to NamespaceHandler class name / instance */  
private Map handlerMappings;  

public DefaultNamespaceHandlerResolver() {  
    this(null, DEFAULT_HANDLER_MAPPINGS_LOCATION);  
}  

public DefaultNamespaceHandlerResolver(ClassLoader classLoader) {  
    this(classLoader, DEFAULT_HANDLER_MAPPINGS_LOCATION);  
}  

public DefaultNamespaceHandlerResolver(ClassLoader classLoader, String handlerMappingsLocation) {  
    Assert.notNull(handlerMappingsLocation, &quot;Handler mappings location must not be null&quot;);  
    this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());  
    this.handlerMappingsLocation = handlerMappingsLocation;  
}  
</code></pre><p>/<strong>==========中间省略部分代码=========</strong>/  </p>
<pre><code>   /************************ 
 * Load the specified NamespaceHandler mappings lazily. 
    *  此处加载延迟加载spring.handlers，只有第一次自定义标签被解析到，才会被加载。 
    ****************************/  
private Map getHandlerMappings() {  
    if (this.handlerMappings == null) {  
        try {  
            Properties mappings =  
                    PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader);  
            if (logger.isDebugEnabled()) {  
                logger.debug(&quot;Loaded mappings [&quot; + mappings + &quot;]&quot;);  
            }  
            this.handlerMappings = new HashMap(mappings);  
        }  
        catch (IOException ex) {  
            IllegalStateException ise = new IllegalStateException(  
                    &quot;Unable to load NamespaceHandler mappings from location [&quot; + this.handlerMappingsLocation + &quot;]&quot;);  
            ise.initCause(ex);  
            throw ise;  
        }  
    }  
    return this.handlerMappings;  
}  
</code></pre><p>}<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">源码段<span class="number">3</span> ： <span class="keyword">xml</span> <span class="title">到 dom</span> 树的解析。</span><br><span class="line"></span><br><span class="line">在 XmlBeanDefinitionReader .java 的 doLoadBeanDefinitions 方法里，调用 DefaultDocumentLoader 完成。</span><br></pre></td></tr></table></figure></p>
<p>protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)<br>            throws BeanDefinitionStoreException {<br>    try {<br>        int validationMode = getValidationModeForResource(resource);<br>        Document doc = this.documentLoader.loadDocument(<br>                inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware());<br>        return registerBeanDefinitions(doc, resource);<br>    }<br>    catch (BeanDefinitionStoreException ex) {<br>        throw ex;<br>    }<br>    catch (SAXParseException ex) {<br>        throw new XmlBeanDefinitionStoreException(resource.getDescription(),<br>                “Line “ + ex.getLineNumber() + “ in XML document from “ + resource + “ is invalid”, ex);<br>    }<br>    catch (SAXException ex) {<br>        throw new XmlBeanDefinitionStoreException(resource.getDescription(),<br>                “XML document from “ + resource + “ is invalid”, ex);<br>    }<br>    catch (ParserConfigurationException ex) {<br>        throw new BeanDefinitionStoreException(resource.getDescription(),<br>                “Parser configuration exception parsing XML from “ + resource, ex);<br>    }<br>    catch (IOException ex) {<br>        throw new BeanDefinitionStoreException(resource.getDescription(),<br>                “IOException parsing XML document from “ + resource, ex);<br>    }<br>    catch (Throwable ex) {<br>        throw new BeanDefinitionStoreException(resource.getDescription(),<br>                “Unexpected exception parsing XML document from “ + resource, ex);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其中的</span><br></pre></td></tr></table></figure></p>
<p>getEntityResolver()<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">会完成spring.<span class="keyword">schemas的装载,里面会间接调用源码段1。穿进去的entityResolver作为标签解析使用。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span></span><br><span class="line"></span><br><span class="line">源码段<span class="number">4</span> ： dom 树到 <span class="keyword">Beandifinition：</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span></span><br><span class="line"></span><br><span class="line">在 XmlBeanDefinitionReader .<span class="keyword">java </span>的 doLoadBeanDefinitions 方法里，调用 <span class="keyword">BeanDefinitionDocumentReader </span>完成。</span><br></pre></td></tr></table></figure></p>
<p> public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {<br>    // Support old XmlBeanDefinitionParser SPI for backwards-compatibility.<br>    if (this.parserClass != null) {<br>        XmlBeanDefinitionParser parser =<br>                (XmlBeanDefinitionParser) BeanUtils.instantiateClass(this.parserClass);<br>        return parser.registerBeanDefinitions(this, doc, resource);<br>    }<br>    // Read document based on new BeanDefinitionDocumentReader SPI.<br>    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();<br>    int countBefore = getRegistry().getBeanDefinitionCount();<br>    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<br>    return getRegistry().getBeanDefinitionCount() - countBefore;<br>}<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### AOP底层实现原理</span><br><span class="line">代理设计模式</span><br><span class="line"></span><br><span class="line">什么是代理模式</span><br><span class="line"></span><br><span class="line">通过代理控制对象的访问,可以详细访问某个对象的方法，在这个方法调用处理，或调用后处理。既(AOP微实现) ,AOP核心技术面向切面编程。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">代理模式应用场景</span><br><span class="line"></span><br><span class="line">SpringAOP、事物原理、日志打印、权限控制、远程调用、安全代理 可以隐蔽真实角色</span><br><span class="line"></span><br><span class="line">代理的分类</span><br><span class="line"></span><br><span class="line">静态代理(静态定义代理类)</span><br><span class="line"></span><br><span class="line">动态代理(动态生成代理类)</span><br><span class="line"></span><br><span class="line">Jdk自带动态代理</span><br><span class="line"></span><br><span class="line">Cglib 、javaassist（字节码操作库）</span><br><span class="line"></span><br><span class="line">##### 静态代理</span><br><span class="line"></span><br><span class="line">什么是静态代理</span><br><span class="line"></span><br><span class="line">由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</span><br></pre></td></tr></table></figure></p>
<p>public interface IUserDao {<br>    void save();<br>}<br>public class UserDao implements IUserDao {<br>    public void save() {<br>        System.out.println(“已经保存数据…”);<br>    }<br>}<br>代理类<br>public class UserDaoProxy implements IUserDao {<br>    private IUserDao target;</p>
<pre><code>public UserDaoProxy(IUserDao iuserDao) {
    this.target = iuserDao;
}

public void save() {
    System.out.println(&quot;开启事物...&quot;);
    target.save();
    System.out.println(&quot;关闭事物...&quot;);
}
</code></pre><p>}<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">##### 什么是动态代理</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.代理对象,不需要实现接口</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.动态代理也叫做:JDK代理,接口代理</span><br><span class="line"></span><br><span class="line">###### JDK动态代理</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>)原理：是根据类加载器和接口创建代理类（此代理类是接口的实现类，所以必须使用接口 面向接口生成代理，位于java.lang.reflect包下）</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)实现方式：</span><br><span class="line"></span><br><span class="line">通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(…);</span><br><span class="line"></span><br><span class="line">通过为Proxy类指定ClassLoader对象和一组<span class="keyword">interface</span>创建动态代理类<span class="keyword">Class</span> clazz = Proxy.getProxyClass(classLoader,<span class="keyword">new</span> <span class="keyword">Class</span>[]<span class="comment">&#123;…&#125;</span>);</span><br><span class="line"></span><br><span class="line">通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型<span class="function"><span class="keyword">Constructor</span> <span class="title">constructor</span> = <span class="title">clazz</span>.<span class="title">getConstructor</span><span class="params">(<span class="keyword">new</span> <span class="keyword">Class</span>[]&#123;InvocationHandler.<span class="keyword">class</span>&#125;)</span>;</span></span><br><span class="line"></span><br><span class="line">通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入<span class="keyword">Interface</span> Proxy = (<span class="keyword">Interface</span>)<span class="function"><span class="keyword">constructor</span>.<span class="title">newInstance</span><span class="params">(<span class="keyword">new</span> Object[] (handler)</span>);</span></span><br><span class="line"></span><br><span class="line">缺点：jdk动态代理，必须是面向接口，目标业务类必须实现接口</span><br></pre></td></tr></table></figure></p>
<p>// 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象<br>public class InvocationHandlerImpl implements InvocationHandler {<br>    private Object target;// 这其实业务实现类对象，用来调用具体的业务方法<br>    // 通过构造函数传入目标对象<br>    public InvocationHandlerImpl(Object target) {<br>        this.target = target;<br>    }</p>
<pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    Object result = null;
    System.out.println(&quot;调用开始处理&quot;);
    result = method.invoke(target, args);
    System.out.println(&quot;调用结束处理&quot;);
    return result;
}


public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException,
        IllegalAccessException, IllegalArgumentException, InvocationTargetException {
    // 被代理对象
    IUserDao userDao = new UserDao();
    InvocationHandlerImpl invocationHandlerImpl = new InvocationHandlerImpl(userDao);
    ClassLoader loader = userDao.getClass().getClassLoader();
    Class&lt;?&gt;[] interfaces = userDao.getClass().getInterfaces();
    // 主要装载器、一组接口及调用处理动态代理实例
    IUserDao newProxyInstance = (IUserDao) Proxy.newProxyInstance(loader, interfaces, invocationHandlerImpl);
    newProxyInstance.save();
}
</code></pre><p>}<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">###### CGLIB动态代理</span><br><span class="line"></span><br><span class="line">原理：利用asm开源包，对代理对象类的<span class="keyword">class</span>文件加载进来，通过修改其字节码生成子类来处理。</span><br><span class="line"></span><br><span class="line">什么是CGLIB动态代理</span><br><span class="line"></span><br><span class="line">使用cglib[Code Generation Library]实现动态代理，并不要求委托类必须实现接口，底层采用asm字节码生成框架生成代理类的字节码</span><br><span class="line"></span><br><span class="line">CGLIB动态代理相关代码</span><br></pre></td></tr></table></figure></p>
<p>public class CglibProxy implements MethodInterceptor {<br>    private Object targetObject;<br>    // 这里的目标类型为Object，则可以接受任意一种参数作为被代理类，实现了动态代理<br>    public Object getInstance(Object target) {<br>        // 设置需要创建子类的类<br>        this.targetObject = target;<br>        Enhancer enhancer = new Enhancer();<br>        enhancer.setSuperclass(target.getClass());<br>        enhancer.setCallback(this);<br>        return enhancer.create();<br>    }</p>
<pre><code>public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
    System.out.println(&quot;开启事物&quot;);
    Object result = proxy.invoke(targetObject, args);
    System.out.println(&quot;关闭事物&quot;);
    // 返回代理对象
    return result;
}
public static void main(String[] args) {
    CglibProxy cglibProxy = new CglibProxy();
    UserDao userDao = (UserDao) cglibProxy.getInstance(new UserDao());
    userDao.save();
}
</code></pre><p>}<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">###### CGLIB动态代理与JDK动态区别</span><br><span class="line"></span><br><span class="line">java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</span><br><span class="line"></span><br><span class="line">而cglib动态代理是利用asm开源包，对代理对象类的<span class="keyword">class</span>文件加载进来，通过修改其字节码生成子类来处理。</span><br><span class="line"></span><br><span class="line">Spring中。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、如果目标对象实现了接口，可以强制使用CGLIB实现AOP</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</span><br><span class="line"></span><br><span class="line">JDK动态代理只能对实现了接口的类生成代理，而不能针对类 。 CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 。 因为是继承，所以该类或方法最好不要声明成final ，final可以阻止继承和多态。</span><br><span class="line"></span><br><span class="line">### springcloud的整体架构</span><br><span class="line">#### Eureka</span><br><span class="line">心跳检测机制，如果某个实例在规定的时间内没有进行通讯则会自动被剔除掉，避免了某个实例挂掉而影响服务，Eureka就自动具有了注册中心、负载均衡、故障转移的功能。</span><br><span class="line">#### Hystrix</span><br><span class="line">Hystrix会在某个服务连续调用N次不响应的情况下，立即通知调用端调用失败，避免调用端持续等待而影响了整体服务。Hystrix间隔时间会再次检查此服务，如果服务恢复将继续提供服务。 </span><br><span class="line">#### Spring Cloud Config</span><br><span class="line">解决分布式系统的配置管理方案。它包含了Client和Server两个部分，Server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，Client通过接口获取数据、并依据此数据初始化自己的应用。 </span><br><span class="line">#### Spring Cloud Bus</span><br><span class="line">通过轻量消息代理连接各个分布的节点。这会用在广播状态的变化（例如配置变化）或者其它的消息指令中。Spring Cloud Bus的一个核心思想是通过分布式的启动器对Spring Boot应用进行扩展，也可以用来建立一个或多个应用之间的通信频道。目前唯一实现的方式是用AMQP消息代理作为通道。 有了Spring Cloud Bus之后，当我们改变配置文件提交到版本库中时，会自动的触发对应实例的Refresh。</span><br><span class="line"></span><br><span class="line">#### 服务网关</span><br><span class="line">Spring Cloud体系中支持API Gateway落地的技术就是Zuul。Spring Cloud Zuul路由是微服务架构中不可或缺的一部分，提供动态路由，监控，弹性，安全等的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。 它的具体作用就是服务转发，接收并转发所有内外部的客户端调用。使用Zuul可以作为资源的统一访问入口，同时也可以在网关做一些权限校验等类似的功能。 </span><br><span class="line">#### 链路跟踪</span><br><span class="line">Spring Cloud Sleuth和Zipkin，Spring Cloud Sleuth为服务之间调用提供链路追踪。通过Sleuth可以很清楚的了解到一个服务请求经过了哪些服务，每个服务处理花费了多长时间。从而让我们可以很方便的理清各微服务间的调用关系。Zipkin是Twitter的一个开源项目，允许开发者收集 Twitter 各个服务上的监控数据，并提供查询接口 。</span><br><span class="line">#### Feign技术</span><br><span class="line">利用此技术可以伪造接口实现。</span><br><span class="line"></span><br><span class="line">### 负载均衡的算法有哪些</span><br><span class="line">#### 轮询（Round Robin）法</span><br><span class="line"></span><br><span class="line">将所有请求，依次分发到每台服务器上，适合服务器硬件相同的场景。</span><br><span class="line">- 优点：服务器请求数目相同；</span><br><span class="line">- 缺点：服务器压力不一样，不适合服务器配置不同的情况，为了做到请求转移的绝对均衡，必须付出相当大的代价，因为为了保证pos变量修改的互斥性，需要引入重量级的悲观锁synchronized，这将会导致该段轮询代码的并发吞吐量发生明显的下降；</span><br><span class="line"></span><br><span class="line">#### 随机（Random）法</span><br><span class="line"></span><br><span class="line">基于概率统计的理论，吞吐量越大，随机算法的效果越接近于轮询算法的效果。</span><br><span class="line">- 优点：使用简单；</span><br><span class="line">- 缺点：不适合机器配置不同的场景；</span><br><span class="line"></span><br><span class="line">#### 源地址哈希（Hash）法</span><br><span class="line">源地址哈希的思想是获取客户端访问的IP地址值，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是要访问的服务器的序号。</span><br><span class="line">- 优点：保证了相同客户端IP地址将会被哈希到同一台后端服务器，直到后端服务器列表变更。根据此特性可以在服务消费者与服务提供者之间建立有状态的session会话。</span><br><span class="line">- 缺点：除非集群中服务器的非常稳定，基本不会上下线，否则一旦有服务器上线、下线，那么通过源地址哈希算法路由到的服务器是服务器上线、下线前路由到的服务器的概率非常低，如果是session则取不到session，如果是缓存则可能引发<span class="string">"雪崩"</span>；</span><br><span class="line"></span><br><span class="line">#### 加权法</span><br><span class="line">在轮询，随机，最少链接，Hash等算法的基础上，通过加权的方式，进行负载服务器分配。</span><br><span class="line">- 优点：根据权重，调节转发服务器的请求数目；</span><br><span class="line">- 缺点：使用相对复杂；</span><br><span class="line"></span><br><span class="line">#### 最小连接数（Least Connections）法</span><br><span class="line">将请求分配到连接数最少的服务器上（目前处理请求最少的服务器）。</span><br><span class="line">- 优点：根据服务器当前的请求处理情况，动态分配；</span><br><span class="line">- 缺点：算法实现相对复杂，需要监控服务器请求连接数；</span><br><span class="line"></span><br><span class="line">### SpringBoot如何启动</span><br><span class="line">-  如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：</span><br><span class="line">    - 根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</span><br><span class="line">    - 使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</span><br><span class="line">    - 使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</span><br><span class="line">    - 推断并设置main方法的定义类。</span><br><span class="line">- SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。</span><br><span class="line">- 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</span><br><span class="line">- 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</span><br><span class="line">- 如果SpringApplication的showBanner属性被设置为true，则打印banner。</span><br><span class="line">- 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</span><br><span class="line">- ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</span><br><span class="line">-  遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</span><br><span class="line">-  最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。</span><br><span class="line">-  遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</span><br><span class="line">-  调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</span><br><span class="line">-   查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</span><br><span class="line">-    正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）</span><br><span class="line"></span><br><span class="line">去除事件通知点后，整个流程如下：</span><br></pre></td></tr></table></figure></p>
<p>public ConfigurableApplicationContext run(String… args) {<br>    // 开启定时器,统计启动时间<br>   StopWatch stopWatch = new StopWatch();<br>   stopWatch.start();<br>   ConfigurableApplicationContext context = null;<br>   Collection<springbootexceptionreporter> exceptionReporters = new ArrayList&lt;&gt;();<br>   configureHeadlessProperty();<br>    // 获取并初始化所有RunListener<br>   SpringApplicationRunListeners listeners = getRunListeners(args);<br>    // 发布启动事件<br>   listeners.starting();<br>   try {<br>      ApplicationArguments applicationArguments = new DefaultApplicationArguments(<br>            args);<br>    // 准备好环境environment,即配置文件等<br>      ConfigurableEnvironment environment = prepareEnvironment(listeners,<br>            applicationArguments);<br>      configureIgnoreBeanInfo(environment);<br>    // 打印SpringBoot Logo<br>      Banner printedBanner = printBanner(environment);<br>    // 创建我们最常用的ApplicationContext<br>      context = createApplicationContext();<br>    // 获取异常报告器,在启动发生异常的时候用友好的方式提示用户<br>      exceptionReporters = getSpringFactoriesInstances(<br>            SpringBootExceptionReporter.class,<br>            new Class[] { ConfigurableApplicationContext.class }, context);<br>    // 准备Context,加载启动类作为source<br>      prepareContext(context, environment, listeners, applicationArguments,<br>            printedBanner);<br>    // Spring初始化的核心逻辑,构建整个容器<br>      refreshContext(context);<br>      afterRefresh(context, applicationArguments);<br>    // 停止计时,统计启动耗时<br>      stopWatch.stop();<br>      if (this.logStartupInfo) {<br>         new StartupInfoLogger(this.mainApplicationClass)<br>               .logStarted(getApplicationLog(), stopWatch);<br>      }<br>      listeners.started(context);<br>    // 调用runner接口供应用自定义初始化<br>      callRunners(context, applicationArguments);<br>   }<br>   catch (Throwable ex) {<br>    // 处理启动中抛出的异常,使用异常报告器输出<br>      handleRunFailure(context, ex, exceptionReporters, listeners);<br>      throw new IllegalStateException(ex);<br>   }</springbootexceptionreporter></p>
<p>   try {<br>      listeners.running(context);<br>   }<br>   catch (Throwable ex) {<br>      handleRunFailure(context, ex, exceptionReporters, null);<br>      throw new IllegalStateException(ex);<br>   }<br>   return context;<br>}<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG992.jpeg</span>)</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG993.png</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">http://image.tengj.top/springboot3-3.jpg</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### 什么是脑裂</span></span><br><span class="line"><span class="section">#### 什么是脑裂</span></span><br><span class="line">脑裂(split-brain)就是“大脑分裂”，也就是本来一个“大脑”被拆分了两个或多个“大脑”，我们都知道，如果一个人有多个大脑，并且相互独立的话，那么会导致人体“手舞足蹈”，“不听使唤”。</span><br><span class="line"></span><br><span class="line">脑裂通常会出现在集群环境中，比如ElasticSearch、Zookeeper集群，而这些集群环境有一个统一的特点，就是它们有一个大脑，比如ElasticSearch集群中有Master节点，Zookeeper集群中有Leader节点。</span><br><span class="line"></span><br><span class="line">章着重来给大家讲一下Zookeeper中的脑裂问题，以及是如果解决脑裂问题的。</span><br><span class="line"></span><br><span class="line"><span class="section">#### Zookeeper集群中的脑裂场景</span></span><br><span class="line">对于一个集群，想要提高这个集群的可用性，通常会采用多机房部署，比如现在有一个由6台zkServer所组成的一个集群，部署在了两个机房： image.png</span><br><span class="line"></span><br><span class="line">正常情况下，此集群只会有一个Leader，那么如果机房之间的网络断了之后，两个机房内的zkServer还是可以相互通信的，如果不考虑过半机制，那么就会出现每个机房内部都将选出一个Leader。 image.png</span><br><span class="line"></span><br><span class="line">这就相当于原本一个集群，被分成了两个集群，出现了两个“大脑”，这就是脑裂。</span><br><span class="line"></span><br><span class="line">对于这种情况，我们也可以看出来，原本应该是统一的一个集群对外提供服务的，现在变成了两个集群同时对外提供服务，如果过了一会，断了的网络突然联通了，那么此时就会出现问题了，两个集群刚刚都对外提供服务了，数据该怎么合并，数据冲突怎么解决等等问题。</span><br><span class="line"></span><br><span class="line">刚刚在说明脑裂场景时，有一个前提条件就是没有考虑过半机制，所以实际上Zookeeper集群中是不会出现脑裂问题的，而不会出现的原因就跟过半机制有关。</span><br><span class="line"></span><br><span class="line"><span class="section">#### 过半机制</span></span><br><span class="line">在领导者选举的过程中，如果某台zkServer获得了超过半数的选票，则此zkServer就可以成为Leader了。</span><br><span class="line"></span><br><span class="line">过半机制的源码实现其实非常简单：</span><br></pre></td></tr></table></figure></p>
<p>public class QuorumMaj implements QuorumVerifier {<br>    private static final Logger LOG = LoggerFactory.getLogger(QuorumMaj.class);</p>
<pre><code>int half;

// n表示集群中zkServer的个数（准确的说是参与者的个数，参与者不包括观察者节点）
public QuorumMaj(int n){
    this.half = n/2;
}

// 验证是否符合过半机制
public boolean containsQuorum(Set&lt;Long&gt; set){
    // half是在构造方法里赋值的
    // set.size()表示某台zkServer获得的票数
    return (set.size() &gt; half);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大家仔细看一下上面方法中的注释，核心代码就是下面两行：</span><br></pre></td></tr></table></figure></p>
<p>this.half = n/2;<br>return (set.size() &gt; half);<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line">举个简单的例子： 如果现在集群中有<span class="number">5</span>台zkServer，那么half=<span class="number">5</span>/<span class="number">2</span>=<span class="number">2</span>，那么也就是说，领导者选举的过程中至少要有三台zkServer投了同一个zkServer，才会符合过半机制，才能选出来一个Leader。</span><br><span class="line"></span><br><span class="line">那么有一个问题我们想一下，选举的过程中为什么一定要有一个过半机制验证？ 因为这样不需要等待所有zkServer都投了同一个zkServer就可以选举出来一个Leader了，这样比较快，所以叫快速领导者选举算法呗。</span><br><span class="line"></span><br><span class="line">那么再来想一个问题，过半机制中为什么是大于，而不是大于等于呢？</span><br><span class="line"></span><br><span class="line">这就是更脑裂问题有关系了，比如回到上文出现脑裂问题的场景： image.png</span><br><span class="line"></span><br><span class="line">当机房中间的网络断掉之后，机房<span class="number">1</span>内的三台服务器会进行领导者选举，但是此时过半机制的条件是set.size() &gt; <span class="number">3</span>，也就是说至少要<span class="number">4</span>台zkServer才能选出来一个Leader，所以对于机房<span class="number">1</span>来说它不能选出一个Leader，同样机房<span class="number">2</span>也不能选出一个Leader，这种情况下整个集群当机房间的网络断掉后，整个集群将没有Leader。</span><br><span class="line"></span><br><span class="line">而如果过半机制的条件是set.size() &gt;= <span class="number">3</span>，那么机房<span class="number">1</span>和机房<span class="number">2</span>都会选出一个Leader，这样就出现了脑裂。所以我们就知道了，为什么过半机制中是大于，而不是大于等于。就是为了防止脑裂。</span><br><span class="line"></span><br><span class="line">如果假设我们现在只有<span class="number">5</span>台机器，也部署在两个机房： image.png</span><br><span class="line"></span><br><span class="line">此时过半机制的条件是set.size() &gt; <span class="number">2</span>，也就是至少要<span class="number">3</span>台服务器才能选出一个Leader，此时机房件的网络断开了，对于机房<span class="number">1</span>来说是没有影响的，Leader依然还是Leader，对于机房<span class="number">2</span>来说是选不出来Leader的，此时整个集群中只有一个Leader。</span><br><span class="line"></span><br><span class="line">所以，我们可以总结得出，有了过半机制，对于一个Zookeeper集群，要么没有Leader，要没只有<span class="number">1</span>个Leader，这样就避免了脑裂问题。</span><br><span class="line"></span><br><span class="line">有痛点才有创新，一个技术肯定都是为了解决某个痛点才出现的。</span><br><span class="line"></span><br><span class="line">### Saga模式与TCC的区别</span><br><span class="line">#### 各种形态的分布式事务</span><br><span class="line">分布式事务有多种主流形态，包括：</span><br><span class="line"></span><br><span class="line">- 基于消息实现的分布式事务</span><br><span class="line">- 基于补偿实现的分布式事务</span><br><span class="line">- 基于TCC实现的分布式事务</span><br><span class="line">- 基于SAGA实现的分布式事务</span><br><span class="line">- 基于<span class="number">2</span>PC实现的分布式事务</span><br><span class="line">这些形态的原理已经在很多文章中进行了剖析，用“分布式事务”关键字就能搜到对应的文章，本文不再赘述这些形态的原理，并将重点放在如何根据业务选择对应的分布式事务形态上。</span><br><span class="line"></span><br><span class="line">#### 何时选择单机事务</span><br><span class="line">这个相信大家都很清楚，在条件允许的情况下，我们应该尽可能地使用单机事务，因为单机事务里，无需额外协调其他数据源，减少了网络交互时间消耗以及协调时所需的存储IO消耗，在修改等量业务数据的情况下，单机事务将会有更高的性能。</span><br><span class="line"></span><br><span class="line">但单机数据库由于 业务逻辑解耦等因素进行了数据库垂直拆分、或者由于单机数据库性能压力等因素进行了数据库水平拆分之后，数据分布于多个数据库，这时若需要对多个数据库的数据进行协调变更，则需要引入分布式事务。</span><br><span class="line"></span><br><span class="line">分布式事务的模式有很多种，那究竟要怎么选择适合业务的模式呢？以下我们将从使用场景、性能、开发成本这几个方面进行分析。</span><br><span class="line"></span><br><span class="line">#### 何时选择基于消息实现的事务</span><br><span class="line">基于消息实现的事务适用于分布式事务的提交或回滚只取决于事务发起方的业务需求，其他数据源的数据变更跟随发起方进行的业务场景。</span><br><span class="line"></span><br><span class="line">举个例子，假设存在业务规则：某笔订单成功后，为用户加一定的积分。</span><br><span class="line"></span><br><span class="line">在这条规则里，管理订单数据源的服务为事务发起方，管理积分数据源的服务为事务跟随者。</span><br><span class="line"></span><br><span class="line">从这个过程可以看到，基于消息队列实现的事务存在以下操作：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">订单服务创建订单，提交本地事务</span><br><span class="line">订单服务发布一条消息</span><br><span class="line">积分服务收到消息后加积分</span><br><span class="line">我们可以看到它的整体流程是比较简单的，同时业务开发工作量也不大：</span><br><span class="line"></span><br><span class="line">- 编写订单服务里订单创建的逻辑</span><br><span class="line">- 编写积分服务里增加积分的逻辑</span><br><span class="line">可以看到该事务形态过程简单，性能消耗小，发起方与跟随方之间的流量峰谷可以使用队列填平，同时业务开发工作量也基本与单机事务没有差别，都不需要编写反向的业务逻辑过程。因此基于消息队列实现的事务是我们除了单机事务外最优先考虑使用的形态。</span><br><span class="line"></span><br><span class="line">#### 何时选择利用补偿实现的事务？</span><br><span class="line">但是基于消息实现的事务并不能解决所有的业务场景，例如以下场景：某笔订单完成时，同时扣掉用户的现金。</span><br><span class="line"></span><br><span class="line">这里事务发起方是管理订单库的服务，但对整个事务是否提交并不能只由订单服务决定，因为还要确保用户有足够的钱，才能完成这笔交易，而这个信息在管理现金的服务里。这里我们可以引入基于补偿实现的事务，其流程如下：</span><br><span class="line"></span><br><span class="line">- 创建订单数据，但暂不提交本地事务</span><br><span class="line">- 订单服务发送远程调用到现金服务，以扣除对应的金额</span><br><span class="line">- 上述步骤成功后提交订单库的事务</span><br><span class="line">以上这个是正常成功的流程，异常流程需要回滚的话，将额外发送远程调用到现金服务以加上之前扣掉的金额。</span><br><span class="line"></span><br><span class="line">以上流程比基于消息队列实现的事务的流程要复杂，同时开发的工作量也更多：</span><br><span class="line"></span><br><span class="line">- 编写订单服务里创建订单的逻辑</span><br><span class="line">- 编写现金服务里扣钱的逻辑</span><br><span class="line">- 编写现金服务里补偿返还的逻辑</span><br><span class="line">可以看到，该事务流程相对于基于消息实现的分布式事务更为复杂，需要额外开发相关的业务回滚方法，也失去了服务间流量削峰填谷的功能。但其仅仅只比基于消息的事务复杂多一点，若不能使用基于消息队列的最终一致性事务，那么可以优先考虑使用基于补偿的事务形态。</span><br><span class="line"></span><br><span class="line">（题外话：阿里GTS也是利用补偿实现，只不过补偿代码自动生成，无需业务干预，同时接管应用数据源，禁止业务修改处于全局事务状态中的记录。）</span><br><span class="line"></span><br><span class="line">#### 何时选择利用TCC实现的事务</span><br><span class="line">然而基于补偿的事务形态也并非能实现所有的需求，如以下场景：某笔订单完成时，同时扣掉用户的现金，但交易未完成，也未被取消时，不能让客户看到钱变少了。</span><br><span class="line"></span><br><span class="line">这时我们可以引入TCC，其流程如下：</span><br><span class="line"></span><br><span class="line">- 订单服务创建订单</span><br><span class="line">- 订单服务发送远程调用到现金服务，冻结客户的现金</span><br><span class="line">- 提交订单服务数据</span><br><span class="line">- 订单服务发送远程调用到现金服务，扣除客户冻结的现金</span><br><span class="line">以上是正常完成的流程，若为异常流程，则需要发送远程调用请求到现金服务，撤销冻结的金额。</span><br><span class="line"></span><br><span class="line">以上流程比基于补偿实现的事务的流程要复杂，同时开发的工作量也更多：</span><br><span class="line"></span><br><span class="line">- 订单服务编写创建订单的逻辑</span><br><span class="line">- 现金服务编写冻结现金的逻辑</span><br><span class="line">- 现金服务编写扣除现金的逻辑</span><br><span class="line">- 现金服务编写解冻现金的逻辑</span><br><span class="line">TCC实际上是最为复杂的一种情况，其能处理所有的业务场景，但无论出于性能上的考虑，还是开发复杂度上的考虑，都应该尽量避免该类事务。</span><br><span class="line"></span><br><span class="line">#### 何时选择利用SAGA实现的事务？</span><br><span class="line"></span><br><span class="line">saga是<span class="number">30</span>年前的一篇数据库论文提到的概念。 论文中定义saga事务是一个长事务，整个事务可以由多个本地事务组成，每个本地事务有相应的执行模块和补偿模块，当saga事务中任意一个事务出错了，可以调用相关事务进行对应的补偿恢复，达到事务的最终一致性。</span><br><span class="line"></span><br><span class="line">由于分布式系统中网络带来的不可靠性，saga调用服务提出了服务应该支持幂等，在服务调用超时重试情况下，不至于产生问题。</span><br><span class="line"></span><br><span class="line">saga事务没有准备阶段，不具备隔离性，如果多个saga事务同时操作同一资源会遇到多线程临界资源的情况，产生数据丢失或者脏数据。</span><br><span class="line"></span><br><span class="line">为解决隔离性，可以参考TCC模式，在业务层加入session及锁机制保证操作串型化，通过业务层面达到隔离效果。</span><br><span class="line"></span><br><span class="line">saga在分布式架构下，采用事务驱动方式，让服务进行相关交互，业务方订阅相关领域事件即可。 通过事件方式降低系统复杂度，提升系统扩展性，但要注意事件循环依赖的问题。</span><br><span class="line"></span><br><span class="line">SAGA可以看做一个异步的、利用队列实现的补偿事务。</span><br><span class="line"></span><br><span class="line">其适用于无需马上返回业务发起方最终状态的场景，例如：你的请求已提交，请稍后查询或留意通知 之类。</span><br><span class="line"></span><br><span class="line">将上述补偿事务的场景用SAGA改写，其流程如下：</span><br><span class="line"></span><br><span class="line">- 订单服务创建最终状态未知的订单记录，并提交事务</span><br><span class="line">- 现金服务扣除所需的金额，并提交事务</span><br><span class="line">- 订单服务更新订单状态为成功，并提交事务</span><br><span class="line">以上为成功的流程，若现金服务扣除金额失败，那么，最后一步订单服务将会更新订单状态为失败。</span><br><span class="line"></span><br><span class="line">其业务编码工作量比补偿事务多一点，包括以下内容：</span><br><span class="line"></span><br><span class="line">- 订单服务创建初始订单的逻辑</span><br><span class="line">- 订单服务确认订单成功的逻辑</span><br><span class="line">- 订单服务确认订单失败的逻辑</span><br><span class="line">- 现金服务扣除现金的逻辑</span><br><span class="line">- 现金服务补偿返回现金的逻辑</span><br><span class="line">但其相对于补偿事务形态有性能上的优势，所有的本地子事务执行过程中，都无需等待其调用的子事务执行，减少了加锁的时间，这在事务流程较多较长的业务中性能优势更为明显。同时，其利用队列进行进行通讯，具有削峰填谷的作用。</span><br><span class="line"></span><br><span class="line">因此该形式适用于不需要同步返回发起方执行最终结果、可以进行补偿、对性能要求较高、不介意额外编码的业务场景。</span><br><span class="line"></span><br><span class="line">但当然SAGA也可以进行稍微改造，变成与TCC类似、可以进行资源预留的形态。</span><br><span class="line"></span><br><span class="line">#### <span class="number">2</span>PC事务</span><br><span class="line">其适用于参与者较少，单个本地事务执行时间较少，并且参与者自身可用性很高的场景，否则，其很可能导致性能下降严重。</span><br><span class="line"></span><br><span class="line">#### 并非一种事务形态就能打遍天下</span><br><span class="line">通过分析我们可以发现，并不存在一种事务形态能解决所有的问题，我们需要根据特定的业务场景选择合适的事务形态。甚至于有时需要混合多种事务形态才能更好的完成目标，如 上面提到的 订单、积分、钱包混合的场景：订单的成功与否需要依赖于钱包的余额，但不依赖于积分的多少，因此可以混合基于消息的事务形态以加积分 及 基于补偿的事务形态以确保扣钱成功，从而得到一个性能更好，编码量更少的形态。</span><br><span class="line"></span><br><span class="line">然而目前很多框架都专注于某单一方面的事务形态，如TCC单独一个框架，可靠消息单独一个框架，SAGA单独一个框架，他们各自独立，容易导致以下问题：</span><br><span class="line"></span><br><span class="line">- 由于前期只采用了其中一种类型事务的框架，因为工具目前只有锤子，引入其他工具又涉及测试、阅读代码等过程，因此把所有问题都看做钉子，导致性能偏低或者实现不够优雅</span><br><span class="line">- 由于不同框架管理事务的形态可能不一致，导致不能很好的协调工作，如某一个TCC框架和另一个基于消息的事务框架无法很好融合。</span><br><span class="line"></span><br><span class="line">### 事务隔离级别</span><br><span class="line"></span><br><span class="line">**Spring事务的隔离级别**</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  ``ISOLATION_DEFAULT``： 这是一个 PlatfromTransactionManager  默认的隔离级别，使用数据库默认的事务隔离级别.</span><br><span class="line"></span><br><span class="line">另外四个与 JDBC的隔离级别相对应:</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>   ``ISOLATION_READ_UNCOMMITTED``： 这是事务最低的隔离级别，它允许令外一个事务可以看到这个事务未提交的数据,</span><br><span class="line"></span><br><span class="line">这种隔离级别会产生脏读，不可重复读和幻像读。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> ``ISOLATION_READ_COMMITTED``： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> ``ISOLATION_REPEATABLE_READ``： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> ``ISOLATION_SERIALIZABLE``  这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</span><br><span class="line"></span><br><span class="line">除了防止脏读，不可重复读外，还避免了幻像读。</span><br><span class="line"></span><br><span class="line">**其中的一些概念的说明：**</span><br><span class="line">**脏读**:  指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一 个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</span><br><span class="line"></span><br><span class="line">**不可重复读**:  指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。 那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</span><br><span class="line"></span><br><span class="line">**幻觉读**:指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及 到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，就会发生操作第一个事务的用户发现表中还有 没有修改的数据行,也就是说幻像读是指同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻像读,就好象发生了幻觉一样。</span><br><span class="line"></span><br><span class="line">### 事务的传播行为和隔离级别之间有什么联系</span><br><span class="line">#### 事务传播行为</span><br><span class="line">事务传播行为(为了解决业务层方法之间互相调用的事务问题): 当事务方法被另一个事务方法调用时,必须指定事务应该如何传播。例如:方法可能继续在现有事务中运行,也可能开启一个新事务,并在自己的事务中运行。在TransactionDefinition定义中包括了如下几个表示传播行为的常量:</span><br><span class="line"></span><br><span class="line">##### 支持当前事务的情况</span><br><span class="line">- ``TransactionDefinition.PROPAGATION_REQUIRED``: 如果当前存在事务,则加入该事务;如果当前没有事务,则创建一个新的事务。</span><br><span class="line">- ``TransactionDefinition.PROPAGATION_SUPPORTS``: 如果当前存在事务,则加入该事务;如果当前没有事务,则以非事务的方式继续运行。</span><br><span class="line">- ``TransactionDefinition.PROPAGATION_MANDATORY``: 如果当前存在事务,则加入该事务;如果当前没有事务,则抛出异常。(mandatory:强制性)</span><br><span class="line"></span><br><span class="line">##### 不支持当前事务的情况</span><br><span class="line">- ``TransactionDefinition.PROPAGATION_REQUIRES_NEW``: 创建一个新的事务,如果当前存在事务,则把当前事务挂起。</span><br><span class="line">- ``TransactionDefinition.PROPAGATION_NOT_SUPPORTED``: 以非事务方式运行,如果当前存在事务,则把当前事务挂起。</span><br><span class="line">- ``TransactionDefinition.PROPAGATION_NEVER``: 以非事务方式运行,如果当前存在事务,则抛出异常。</span><br><span class="line"></span><br><span class="line">##### 其他情况</span><br><span class="line">- ``TransactionDefinition.PROPAGATION_NESTED``: 如果当前存在事务,则创建一个事务作为当前事务的嵌套事务来运行;如果当前没有事务,则该取值等价于``TransactionDefinition.PROPAGATION_REQUIRED``。</span><br><span class="line"></span><br><span class="line">#### 隔离级别</span><br><span class="line">TransactionDefinition 接口中定义了五个表示隔离级别的常量:</span><br><span class="line"></span><br><span class="line">- ``TransactionDefinition.ISOLATION_DEFAULT``: 使用后端数据库默认的隔离级别,Mysql 默认采用的``REPEATABLE_READ``隔离级别 Oracle 默认采用的 ``READ_COMMITTED``隔离级别。</span><br><span class="line">- ``TransactionDefinition.ISOLATION_READ_UNCOMMITTED``: 最低的隔离级别,允许读取尚未提交的数据变更,可能会导致脏读、幻读或不可重复读。</span><br><span class="line">- ``TransactionDefinition.ISOLATION_READ_COMMITTED``: 允许读取并发事务已经提交的数据,可以阻止脏读,但是幻读或不可重复读仍有可能发生。</span><br><span class="line">- ``TransactionDefinition.ISOLATION_REPEATABLE_READ``: 对同一字段的多次读取结果都是一致的,除非数据是被本身事务自己所修改,可以阻止脏读和不可重复读,但幻读仍有可能发生。</span><br><span class="line">- ``TransactionDefinition.ISOLATION_SERIALIZABLE``: 最高的隔离级别,完全服从ACID的隔离级别。所有的事务依次逐个执行,这样事务之间就完全不可能产生干扰,也就是说,该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</span><br><span class="line"></span><br><span class="line">![image](https:<span class="comment">//minios.strongsickcat.com/dinghuang-blog-picture/1656058-20190611152652742-1944751292.png)</span></span><br><span class="line"></span><br><span class="line">### 如何理解Spring中的AOP 和 IOC，以及DI，读过Spring源码没有？</span><br><span class="line">#### AOP</span><br><span class="line">![image](https:<span class="comment">//minios.strongsickcat.com/dinghuang-blog-picture/12942196-ccb87f486fddc550.png)</span></span><br><span class="line"></span><br><span class="line">##### 什么是aop</span><br><span class="line">- AOP（Aspect Oriented Programming）称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待，Struts2的拦截器设计就是基于AOP的思想，是个比较经典的例子。</span><br><span class="line">- 在不改变原有的逻辑的基础上，增加一些额外的功能。代理也是这个功能，读写分离也能用aop来做。</span><br><span class="line">- AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</span><br><span class="line">- AOP技术恰恰相反，它利用一种称为<span class="string">"横切"</span>的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为<span class="string">"Aspect"</span>，即切面。所谓<span class="string">"切面"</span>，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</span><br><span class="line">- 使用<span class="string">"横切"</span>技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</span><br><span class="line"></span><br><span class="line">##### AOP的相关概念</span><br><span class="line">(<span class="number">1</span>)横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)Aspect(切面):通常是一个类，里面可以定义切入点和通知</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)JointPoint(连接点):程序执行过程中明确的点，一般是方法的调用。被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)Advice(通知):AOP在特定的切入点上执行的增强处理，有before(前置),after(后置),afterReturning(最终),afterThrowing(异常),around(环绕)</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)Pointcut(切入点):就是带有通知的连接点，在程序中主要体现为书写切入点表达式</span><br><span class="line"></span><br><span class="line">(<span class="number">6</span>)weave(织入)：将切面应用到目标对象并导致代理对象创建的过程</span><br><span class="line"></span><br><span class="line">(<span class="number">7</span>)introduction(引入)：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段</span><br><span class="line"></span><br><span class="line">(<span class="number">8</span>)AOP代理(AOP Proxy)：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类</span><br><span class="line"></span><br><span class="line">(<span class="number">9</span>)目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO</span><br><span class="line"></span><br><span class="line">##### Advice通知类型介绍</span><br><span class="line">(<span class="number">1</span>)Before:在目标方法被调用之前做增强处理,@Before只需要指定切入点表达式即可</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)AfterReturning:在目标方法正常完成后做增强,@AfterReturning除了指定切入点表达式后，还可以指定一个返回值形参名returning,代表目标方法的返回值</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)AfterThrowing:主要用来处理程序中未处理的异常,@AfterThrowing除了指定切入点表达式后，还可以指定一个throwing的返回值形参名,可以通过该形参名</span><br><span class="line"></span><br><span class="line">来访问目标方法中所抛出的异常对象</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)After:在目标方法完成之后做增强，无论目标方法时候成功完成。@After可以指定一个切入点表达式</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>)Around:环绕通知,在目标方法完成前后做增强处理,环绕通知是最重要的通知类型,像事务,日志等都是环绕通知,注意编程中核心是一个ProceedingJoinPoint</span><br><span class="line"></span><br><span class="line">##### AOP使用场景</span><br><span class="line">- Authentication 权限</span><br><span class="line">- Caching 缓存</span><br><span class="line">- Context passing 内容传递</span><br><span class="line">- Error handling 错误处理</span><br><span class="line">- Lazy loading　懒加载</span><br><span class="line">- Debugging　　调试</span><br><span class="line">- logging, tracing, profiling and monitoring　记录跟踪　优化　校准</span><br><span class="line">- Performance optimization　性能优化</span><br><span class="line">- Persistence　　持久化</span><br><span class="line">- Resource pooling　资源池</span><br><span class="line">- Synchronization　同步</span><br><span class="line">- Transactions 事务</span><br><span class="line"></span><br><span class="line">##### 使用AOP的几种方式</span><br><span class="line"><span class="number">1.</span>经典的基于代理的AOP</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>@AspectJ注解驱动的切面</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>纯POJO切面（纯粹通过``&lt;aop:fonfig&gt;``标签配置）</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>注入式AspectJ切面</span><br><span class="line"></span><br><span class="line">#### IOC</span><br><span class="line">IoC 全称为 Inversion <span class="keyword">of</span> Control，翻译为 “控制反转”，它还有一个别名为 DI（Dependency Injection）,即依赖注入。</span><br><span class="line"></span><br><span class="line">如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：</span><br><span class="line"><span class="number">1.</span> 谁控制谁</span><br><span class="line"><span class="number">1.</span> 控制什么</span><br><span class="line"><span class="number">1.</span> 为何是反转</span><br><span class="line"><span class="number">1.</span> 哪些方面反转了</span><br><span class="line"></span><br><span class="line">在回答这四个问题之前，我们先看 IOC 的定义：</span><br><span class="line">&gt; 所谓 IOC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系</span><br><span class="line"></span><br><span class="line">上面这句话是整个 IoC 理论的核心。如何来理解这句话？我们引用一个例子来走阐述（看完该例子上面四个问题也就不是问题了）。</span><br><span class="line"></span><br><span class="line">已找女朋友为例（对于程序猿来说这个值得探究的问题）。一般情况下我们是如何来找女朋友的呢？首先我们需要根据自己的需求（漂亮、身材好、性格好）找一个妹子，然后到处打听她的兴趣爱好、微信、电话号码，然后各种投其所好送其所要，最后追到手。如下：</span><br></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li><p>年轻小伙子<br>*/<br>public class YoungMan {<br> private BeautifulGirl beautifulGirl;</p>
<p> YoungMan(){</p>
<pre><code>// 可能你比较牛逼，指腹为婚
// beautifulGirl = new BeautifulGirl();
</code></pre><p> }</p>
<p> public void setBeautifulGirl(BeautifulGirl beautifulGirl) {</p>
<pre><code>this.beautifulGirl = beautifulGirl;
</code></pre><p> }</p>
<p> public static void main(String[] args){</p>
<pre><code>YoungMan you = new YoungMan();
BeautifulGirl beautifulGirl = new BeautifulGirl(&quot;你的各种条件&quot;);
beautifulGirl.setxxx(&quot;各种投其所好&quot;);

// 然后你有女票了
you.setBeautifulGirl(beautifulGirl);
</code></pre><p> }<br>}</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">这就是我们通常做事的方式，如果我们需要某个对象，一般都是采用这种直接创建的方式(``new BeautifulGirl()``)，这个过程复杂而又繁琐，而且我们必须要面对每个环节，同时使用完成之后我们还要负责销毁它，在这种情况下我们的对象与它所依赖的对象耦合在一起。</span><br><span class="line"></span><br><span class="line">其实我们需要思考一个问题？我们每次用到自己依赖的对象真的需要自己去创建吗？我们知道，我们依赖对象其实并不是依赖该对象本身，而是依赖它所提供的服务，只要在我们需要它的时候，它能够及时提供服务即可，至于它是我们主动去创建的还是别人送给我们的，其实并不是那么重要。再说了，相比于自己千辛万苦去创建它还要管理、善后而言，直接有人送过来是不是显得更加好呢？</span><br><span class="line"></span><br><span class="line">这个给我们送东西的“人” 就是 IoC，在上面的例子中，它就相当于一个婚介公司，作为一个婚介公司它管理着很多男男女女的资料，当我们需要一个女朋友的时候，直接跟婚介公司提出我们的需求，婚介公司则会根据我们的需求提供一个妹子给我们，我们只需要负责谈恋爱，生猴子就行了。你看，这样是不是很简单明了。</span><br><span class="line"></span><br><span class="line">诚然，作为婚介公司的 IoC 帮我们省略了找女朋友的繁杂过程，将原来的主动寻找变成了现在的被动接受（符合我们的要求），更加简洁轻便。你想啊，原来你还得鞍马前后，各种巴结，什么东西都需要自己去亲力亲为，现在好了，直接有人把现成的送过来，多么美妙的事情啊。所以，简单点说，IoC 的理念就是让别人为你服务</span><br><span class="line"></span><br><span class="line">在没有引入 IoC 的时候，被注入的对象直接依赖于被依赖的对象，有了 IoC 后，两者及其他们的关系都是通过 Ioc<span class="built_in"> Service </span>Provider 来统一管理维护的。被注入的对象需要什么，直接跟 IoC<span class="built_in"> Service </span>Provider 打声招呼，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到 IOC<span class="built_in"> Service </span>Provider 为被注入对象服务的目的。所以 IoC 就是这么简单！原来是需要什么东西自己去拿，现在是需要什么东西让别人（IOC<span class="built_in"> Service </span>Provider）送过来</span><br><span class="line"></span><br><span class="line">现在在看上面那四个问题，答案就显得非常明显了:</span><br><span class="line"></span><br><span class="line">- 谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。</span><br><span class="line">- 控制什么：控制对象。</span><br><span class="line">- 为何是反转：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</span><br><span class="line">- 哪些方面反转了：所依赖对象的获取被反转了。</span><br><span class="line">妹子有了，但是如何拥有妹子呢？这也是一门学问。</span><br><span class="line"></span><br><span class="line">- 可能你比较牛逼，刚刚出生的时候就指腹为婚了。</span><br><span class="line">- 大多数情况我们还是会考虑自己想要什么样的妹子，所以还是需要向婚介公司打招呼的。</span><br><span class="line">- 还有一种情况就是，你根本就不知道自己想要什么样的妹子，直接跟婚介公司说，我就要一个这样的妹子。</span><br><span class="line">所以，IOC<span class="built_in"> Service </span>Provider 为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、stter方法注入、接口注入。</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 构造器注入</span></span><br><span class="line">构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>YoungMan(BeautifulGirl beautifulGirl){<br>        this.beautifulGirl = beautifulGirl;<br>}<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造器注入方式比较直观，对象构造完毕后就可以直接使用，这就好比你出生你家里就给你指定了你媳妇。</span><br><span class="line"></span><br><span class="line">##### setter 方法注入</span><br><span class="line">对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下：</span><br></pre></td></tr></table></figure></p>
<p>public class YoungMan {<br>    private BeautifulGirl beautifulGirl;</p>
<pre><code>public void setBeautifulGirl(BeautifulGirl beautifulGirl) {
    this.beautifulGirl = beautifulGirl;
}
</code></pre><p>}<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前），这就好比你可以先把自己想要的妹子想好了，然后再跟婚介公司打招呼，你可以要林志玲款式的，赵丽颖款式的，甚至凤姐哪款的，随意性较强。</span><br><span class="line"></span><br><span class="line">##### 接口方式注入</span><br><span class="line">接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。</span><br><span class="line"></span><br><span class="line">#### DI</span><br><span class="line"></span><br><span class="line">DI（Dependency Injection）依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。</span><br><span class="line"></span><br><span class="line">##### 依赖注入发生的时间</span><br><span class="line">当 Spring IOC 容器完成了 Bean 定义资源的定位、载入和解析注册以后，IOC 容器中已经管理类 Bean定义的相关数据，但是此时 IOC 容器还没有对所管理的 Bean 进行依赖注入，依赖注入在以下两种情况发生：</span><br><span class="line"><span class="number">1</span>)、用户第一次调用 getBean()方法时，IOC 容器触发依赖注入。</span><br><span class="line"><span class="number">2</span>)、当用户在配置文件中将``&lt;bean&gt;``元素配置了 lazy-init=false 属性，即让容器在解析注册 Bean 定义时进行预实例化，触发依赖注入。</span><br><span class="line"></span><br><span class="line">BeanFactory 接口定义了 Spring IOC 容器的基本功能规范，是 Spring IOC 容器所应遵守的最底层和最基本的编程规范。BeanFactory 接口中定义了几个 getBean()方法，就是用户向 IOC 容器索取管理的Bean 的方法，我们通过分析其子类AbstractBeanFactory 的具体实现，理解 Spring IOC 容器在用户索取 Bean 时如何完成依赖注入。</span><br><span class="line"></span><br><span class="line">AbstractBeanFactory 的 getBean()相关方法的源码如下：</span><br></pre></td></tr></table></figure></p>
<p>//获取IOC容器中指定名称的Bean<br>@Override<br>public Object getBean(String name) throws BeansException {<br>    //doGetBean才是真正向IoC容器获取被管理Bean的过程<br>    return doGetBean(name, null, null, false);<br>}</p>
<p>//获取IOC容器中指定名称和类型的Bean<br>@Override<br>public <t> T getBean(String name, @Nullable Class<t> requiredType) throws BeansException {<br>    //doGetBean才是真正向IoC容器获取被管理Bean的过程<br>    return doGetBean(name, requiredType, null, false);<br>}</t></t></p>
<p>//获取IOC容器中指定名称和参数的Bean<br>@Override<br>public Object getBean(String name, Object… args) throws BeansException {<br>    //doGetBean才是真正向IoC容器获取被管理Bean的过程<br>    return doGetBean(name, null, args, false);<br>}</p>
<p>//获取IOC容器中指定名称、类型和参数的Bean<br>public <t> T getBean(String name, @Nullable Class<t> requiredType, @Nullable Object… args)<br>        throws BeansException {<br>    //doGetBean才是真正向IoC容器获取被管理Bean的过程<br>    return doGetBean(name, requiredType, args, false);<br>}</t></t></p>
<p>@SuppressWarnings(“unchecked”)<br>//真正实现向IOC容器获取Bean的功能，也是触发依赖注入功能的地方<br>protected <t> T doGetBean(final String name, @Nullable final Class<t> requiredType,<br>        @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {</t></t></p>
<pre><code>//根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖
//如果指定的是别名，将别名转换为规范的Bean名称
final String beanName = transformedBeanName(name);
Object bean;

// Eagerly check singleton cache for manually registered singletons.
//先从缓存中取是否已经有被创建过的单态类型的Bean
//对于单例模式的Bean整个IOC容器中只创建一次，不需要重复创建
Object sharedInstance = getSingleton(beanName);
//IOC容器创建单例模式Bean实例对象
if (sharedInstance != null &amp;&amp; args == null) {
    if (logger.isDebugEnabled()) {
        //如果指定名称的Bean在容器中已有单例模式的Bean被创建
        //直接返回已经创建的Bean
        if (isSingletonCurrentlyInCreation(beanName)) {
            logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName +
                    &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;);
        }
        else {
            logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);
        }
    }
    //获取给定Bean的实例对象，主要是完成FactoryBean的相关处理
    //注意：BeanFactory是管理容器中Bean的工厂，而FactoryBean是
    //创建创建对象的工厂Bean，两者之间有区别
    bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
}

else {
    // Fail if we&apos;re already creating this bean instance:
    // We&apos;re assumably within a circular reference.
    //缓存没有正在创建的单例模式Bean
    //缓存中已经有已经创建的原型模式Bean
    //但是由于循环引用的问题导致实例化对象失败
    if (isPrototypeCurrentlyInCreation(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }

    // Check if bean definition exists in this factory.
    //对IOC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否
    //能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器
    //的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找
    BeanFactory parentBeanFactory = getParentBeanFactory();
    //当前容器的父级容器存在，且当前容器中不存在指定名称的Bean
    if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
        // Not found -&gt; check parent.
        //解析指定Bean名称的原始名称
        String nameToLookup = originalBeanName(name);
        if (parentBeanFactory instanceof AbstractBeanFactory) {
            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                    nameToLookup, requiredType, args, typeCheckOnly);
        }
        else if (args != null) {
            // Delegation to parent with explicit args.
            //委派父级容器根据指定名称和显式的参数查找
            return (T) parentBeanFactory.getBean(nameToLookup, args);
        }
        else {
            // No args -&gt; delegate to standard getBean method.
            //委派父级容器根据指定名称和类型查找
            return parentBeanFactory.getBean(nameToLookup, requiredType);
        }
    }

    //创建的Bean是否需要进行类型验证，一般不需要
    if (!typeCheckOnly) {
        //向容器标记指定的Bean已经被创建
        markBeanAsCreated(beanName);
    }

    try {
        //根据指定Bean名称获取其父级的Bean定义
        //主要解决Bean继承时子类合并父类公共属性问题
        final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
        checkMergedBeanDefinition(mbd, beanName, args);

        // Guarantee initialization of beans that the current bean depends on.
        //获取当前Bean所有依赖Bean的名称
        String[] dependsOn = mbd.getDependsOn();
        //如果当前Bean有依赖Bean
        if (dependsOn != null) {
            for (String dep : dependsOn) {
                if (isDependent(beanName, dep)) {
                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                            &quot;Circular depends-on relationship between &apos;&quot; + beanName + &quot;&apos; and &apos;&quot; + dep + &quot;&apos;&quot;);
                }
                //递归调用getBean方法，获取当前Bean的依赖Bean
                registerDependentBean(dep, beanName);
                //把被依赖Bean注册给当前依赖的Bean
                getBean(dep);
            }
        }

        // Create bean instance.
        //创建单例模式Bean的实例对象
        if (mbd.isSingleton()) {
            //这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象
            sharedInstance = getSingleton(beanName, () -&gt; {
                try {
                    //创建一个指定Bean实例对象，如果有父级继承，则合并子类和父类的定义
                    return createBean(beanName, mbd, args);
                }
                catch (BeansException ex) {
                    // Explicitly remove instance from singleton cache: It might have been put there
                    // eagerly by the creation process, to allow for circular reference resolution.
                    // Also remove any beans that received a temporary reference to the bean.
                    //显式地从容器单例模式Bean缓存中清除实例对象
                    destroySingleton(beanName);
                    throw ex;
                }
            });
            //获取给定Bean的实例对象
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
        }

        //IOC容器创建原型模式Bean实例对象
        else if (mbd.isPrototype()) {
            // It&apos;s a prototype -&gt; create a new instance.
            //原型模式(Prototype)是每次都会创建一个新的对象
            Object prototypeInstance = null;
            try {
                //回调beforePrototypeCreation方法，默认的功能是注册当前创建的原型对象
                beforePrototypeCreation(beanName);
                //创建指定Bean对象实例
                prototypeInstance = createBean(beanName, mbd, args);
            }
            finally {
                //回调afterPrototypeCreation方法，默认的功能告诉IOC容器指定Bean的原型对象不再创建
                afterPrototypeCreation(beanName);
            }
            //获取给定Bean的实例对象
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
        }

        //要创建的Bean既不是单例模式，也不是原型模式，则根据Bean定义资源中
        //配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中
        //比较常用，如：request、session、application等生命周期
        else {
            String scopeName = mbd.getScope();
            final Scope scope = this.scopes.get(scopeName);
            //Bean定义资源中没有配置生命周期范围，则Bean定义不合法
            if (scope == null) {
                throw new IllegalStateException(&quot;No Scope registered for scope name &apos;&quot; + scopeName + &quot;&apos;&quot;);
            }
            try {
                //这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例
                Object scopedInstance = scope.get(beanName, () -&gt; {
                    beforePrototypeCreation(beanName);
                    try {
                        return createBean(beanName, mbd, args);
                    }
                    finally {
                        afterPrototypeCreation(beanName);
                    }
                });
                //获取给定Bean的实例对象
                bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
            }
            catch (IllegalStateException ex) {
                throw new BeanCreationException(beanName,
                        &quot;Scope &apos;&quot; + scopeName + &quot;&apos; is not active for the current thread; consider &quot; +
                        &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
                        ex);
            }
        }
    }
    catch (BeansException ex) {
        cleanupAfterBeanCreationFailure(beanName);
        throw ex;
    }
}

// Check if required type matches the type of the actual bean instance.
//对创建的Bean实例对象进行类型检查
if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {
    try {
        T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
        if (convertedBean == null) {
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
        }
        return convertedBean;
    }
    catch (TypeMismatchException ex) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type &apos;&quot; +
                    ClassUtils.getQualifiedName(requiredType) + &quot;&apos;&quot;, ex);
        }
        throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
    }
}
return (T) bean;
</code></pre><p>}<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过上面对向 IOC 容器获取 <span class="keyword">Bean </span>方法的分析，我们可以看到在 Spring 中，如果 <span class="keyword">Bean </span>定义的单例模式(Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果 <span class="keyword">Bean定义的是原型模式(Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean </span>定义还可以通过其指定的生命周期范围来创建。</span><br><span class="line"></span><br><span class="line">上面的源码只是定义了根据 <span class="keyword">Bean </span>定义的模式，采取的不同创建 <span class="keyword">Bean </span>实例对象的策略，具体的 <span class="keyword">Bean实例 </span>对象的创 建过程 由实现了AbstractBeanFactory接口 的匿名内 部类的createBean()方法 完成，AbstractBeanFactory使 用 委 派 模 式 ， 具 体 的 <span class="keyword">Bean </span>实 例 创 建 过 程 交 由 其 实 现 类AbstractAutowireCapableBeanFactory 完成，我们继续分析AbstractAutowireCapableBeanFactory的 createBean()方法的源码，理解其创建 <span class="keyword">Bean </span>实例的具体实现过程。</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 开始实例化</span></span><br><span class="line">AbstractAutowireCapableBeanFactory 类实现了 AbstractBeanFactory接口，创建容器指定的 <span class="keyword">Bean </span>实例对象，同时还对创建的 <span class="keyword">Bean </span>实例对象进行初始化处理。其创建 <span class="keyword">Bean </span>实例对象的方法源码如下：</span><br></pre></td></tr></table></figure></p>
<p>//创建Bean实例对象<br>@Override<br>protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)<br>        throws BeanCreationException {</p>
<pre><code>if (logger.isDebugEnabled()) {
    logger.debug(&quot;Creating instance of bean &apos;&quot; + beanName + &quot;&apos;&quot;);
}
RootBeanDefinition mbdToUse = mbd;

// Make sure bean class is actually resolved at this point, and
// clone the bean definition in case of a dynamically resolved Class
// which cannot be stored in the shared merged bean definition.
//判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载
Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {
    mbdToUse = new RootBeanDefinition(mbd);
    mbdToUse.setBeanClass(resolvedClass);
}

// Prepare method overrides.
//校验和准备Bean中的方法覆盖
try {
    mbdToUse.prepareMethodOverrides();
}
catch (BeanDefinitionValidationException ex) {
    throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
            beanName, &quot;Validation of method overrides failed&quot;, ex);
}

try {
    // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
    //如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建Bean的代理对象
    Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
    if (bean != null) {
        return bean;
    }
}
catch (Throwable ex) {
    throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
            &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);
}

try {
    //创建Bean的入口
    Object beanInstance = doCreateBean(beanName, mbdToUse, args);
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Finished creating instance of bean &apos;&quot; + beanName + &quot;&apos;&quot;);
    }
    return beanInstance;
}
catch (BeanCreationException ex) {
    // A previously detected exception with proper bean creation context already...
    throw ex;
}
catch (ImplicitlyAppearedSingletonException ex) {
    // An IllegalStateException to be communicated up to DefaultSingletonBeanRegistry...
    throw ex;
}
catch (Throwable ex) {
    throw new BeanCreationException(
            mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);
}
</code></pre><p>}</p>
<p>//真正创建Bean的方法<br>protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)<br>        throws BeanCreationException {</p>
<pre><code>// Instantiate the bean.
//封装被创建的Bean对象
BeanWrapper instanceWrapper = null;
if (mbd.isSingleton()) {
    instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
}
if (instanceWrapper == null) {
    instanceWrapper = createBeanInstance(beanName, mbd, args);
}
final Object bean = instanceWrapper.getWrappedInstance();
//获取实例化对象的类型
Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
if (beanType != NullBean.class) {
    mbd.resolvedTargetType = beanType;
}

// Allow post-processors to modify the merged bean definition.
//调用PostProcessor后置处理器
synchronized (mbd.postProcessingLock) {
    if (!mbd.postProcessed) {
        try {
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
        }
        catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                    &quot;Post-processing of merged bean definition failed&quot;, ex);
        }
        mbd.postProcessed = true;
    }
}

// Eagerly cache singletons to be able to resolve circular references
// even when triggered by lifecycle interfaces like BeanFactoryAware.
//向容器中缓存单例模式的Bean对象，以防循环引用
boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
        isSingletonCurrentlyInCreation(beanName));
if (earlySingletonExposure) {
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Eagerly caching bean &apos;&quot; + beanName +
                &quot;&apos; to allow for resolving potential circular references&quot;);
    }
    //这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用
    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
}

// Initialize the bean instance.
//Bean对象的初始化，依赖注入在此触发
//这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean
Object exposedObject = bean;
try {
    //将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象
    populateBean(beanName, mbd, instanceWrapper);
    //初始化Bean对象
    exposedObject = initializeBean(beanName, exposedObject, mbd);
}
catch (Throwable ex) {
    if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
        throw (BeanCreationException) ex;
    }
    else {
        throw new BeanCreationException(
                mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
    }
}

if (earlySingletonExposure) {
    //获取指定名称的已注册的单例模式Bean对象
    Object earlySingletonReference = getSingleton(beanName, false);
    if (earlySingletonReference != null) {
        //根据名称获取的已注册的Bean和正在实例化的Bean是同一个
        if (exposedObject == bean) {
            //当前实例化的Bean初始化完成
            exposedObject = earlySingletonReference;
        }
        //当前Bean依赖其他Bean，并且当发生循环引用时不允许新创建实例对象
        else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
            String[] dependentBeans = getDependentBeans(beanName);
            Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
            //获取当前Bean所依赖的其他Bean
            for (String dependentBean : dependentBeans) {
                //对依赖Bean进行类型检查
                if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                    actualDependentBeans.add(dependentBean);
                }
            }
            if (!actualDependentBeans.isEmpty()) {
                throw new BeanCurrentlyInCreationException(beanName,
                        &quot;Bean with name &apos;&quot; + beanName + &quot;&apos; has been injected into other beans [&quot; +
                        StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                        &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
                        &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
                        &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
                        &quot;&apos;getBeanNamesOfType&apos; with the &apos;allowEagerInit&apos; flag turned off, for example.&quot;);
            }
        }
    }
}

// Register bean as disposable.
//注册完成依赖注入的Bean
try {
    registerDisposableBeanIfNecessary(beanName, bean, mbd);
}
catch (BeanDefinitionValidationException ex) {
    throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
}

return exposedObject;
</code></pre><p>}<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通过上面的源码注释，我们看到具体的依赖注入实现其实就在以下两个方法中：</span><br><span class="line"><span class="number">1</span>)、createBeanInstance()方法，生成 Bean 所包含的 java 对象实例。</span><br><span class="line"><span class="number">2</span>)、populateBean()方法，对 Bean 属性的依赖注入进行处理。</span><br><span class="line">下面继续分析这两个方法的代码实现。</span><br><span class="line"></span><br><span class="line">##### 选择 Bean 实例化策略</span><br><span class="line">在 createBeanInstance()方法中，根据指定的初始化策略，使用简单工厂、工厂方法或者容器的自动装配特性生成 Java 实例对象，创建对象的源码如下：</span><br></pre></td></tr></table></figure></p>
<p>//创建Bean的实例对象<br>protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {<br>    // Make sure bean class is actually resolved at this point.<br>    //检查确认Bean是可实例化的<br>    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</p>
<pre><code>//使用工厂方法对Bean进行实例化
if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {
    throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &quot;Bean class isn&apos;t public, and non-public access not allowed: &quot; + beanClass.getName());
}

Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();
if (instanceSupplier != null) {
    return obtainFromSupplier(instanceSupplier, beanName);
}

if (mbd.getFactoryMethodName() != null)  {
    //调用工厂方法实例化
    return instantiateUsingFactoryMethod(beanName, mbd, args);
}

// Shortcut when re-creating the same bean...
//使用容器的自动装配方法进行实例化
boolean resolved = false;
boolean autowireNecessary = false;
if (args == null) {
    synchronized (mbd.constructorArgumentLock) {
        if (mbd.resolvedConstructorOrFactoryMethod != null) {
            resolved = true;
            autowireNecessary = mbd.constructorArgumentsResolved;
        }
    }
}
if (resolved) {
    if (autowireNecessary) {
        //配置了自动装配属性，使用容器的自动装配实例化
        //容器的自动装配是根据参数类型匹配Bean的构造方法
        return autowireConstructor(beanName, mbd, null, null);
    }
    else {
        //使用默认的无参构造方法实例化
        return instantiateBean(beanName, mbd);
    }
}

// Need to determine the constructor...
//使用Bean的构造方法进行实例化
Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
if (ctors != null ||
        mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
    //使用容器的自动装配特性，调用匹配的构造方法实例化
    return autowireConstructor(beanName, mbd, ctors, args);
}

// No special handling: simply use no-arg constructor.
//使用默认的无参构造方法实例化
return instantiateBean(beanName, mbd);
</code></pre><p>}</p>
<p>//使用默认的无参构造方法实例化Bean对象<br>protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {<br>    try {<br>        Object beanInstance;<br>        final BeanFactory parent = this;<br>        //获取系统的安全管理接口，JDK标准的安全管理API<br>        if (System.getSecurityManager() != null) {<br>            //这里是一个匿名内置类，根据实例化策略创建实例对象<br>            beanInstance = AccessController.doPrivileged((PrivilegedAction<object>) () -&gt;<br>                    getInstantiationStrategy().instantiate(mbd, beanName, parent),<br>                    getAccessControlContext());<br>        }<br>        else {<br>            //将实例化的对象封装起来<br>            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);<br>        }<br>        BeanWrapper bw = new BeanWrapperImpl(beanInstance);<br>        initBeanWrapper(bw);<br>        return bw;<br>    }<br>    catch (Throwable ex) {<br>        throw new BeanCreationException(<br>                mbd.getResourceDescription(), beanName, “Instantiation of bean failed”, ex);<br>    }<br>}<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">经过对上面的代码分析，我们可以看出，对使用工厂方法和自动装配特性的 <span class="keyword">Bean </span>的实例化相当比较清楚，调用相应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作，但是对于我们最常使用的默认无参构造方法就需要使用相应的初始化策略(<span class="keyword">JDK </span>的反射机制或者 CGLib)来进行初始化了，在方法 getInstantiationStrategy().<span class="keyword">instantiate()中就具体实现类使用初始策略实例化对象。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">##### </span>执行 <span class="keyword">Bean </span>实例化</span><br><span class="line">在使用默认的无参构造方法创建 <span class="keyword">Bean </span>的实例化对象时，方法 getInstantiationStrategy().<span class="keyword">instantiate()调用了 </span>SimpleInstantiationStrategy 类中的实例化 <span class="keyword">Bean </span>的方法，其源码如下：</span><br></pre></td></tr></table></figure></object></p>
<p>//使用初始化策略实例化Bean对象<br>@Override<br>public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {<br>    // Don’t override the class with CGLIB if no overrides.<br>    //如果Bean定义中没有方法覆盖，则就不需要CGLIB父类类的方法<br>    if (!bd.hasMethodOverrides()) {<br>        Constructor&lt;?&gt; constructorToUse;<br>        synchronized (bd.constructorArgumentLock) {<br>            //获取对象的构造方法或工厂方法<br>            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;<br>            //如果没有构造方法且没有工厂方法<br>            if (constructorToUse == null) {<br>                //使用JDK的反射机制，判断要实例化的Bean是否是接口<br>                final Class&lt;?&gt; clazz = bd.getBeanClass();<br>                if (clazz.isInterface()) {<br>                    throw new BeanInstantiationException(clazz, “Specified class is an interface”);<br>                }<br>                try {<br>                    if (System.getSecurityManager() != null) {<br>                        //这里是一个匿名内置类，使用反射机制获取Bean的构造方法<br>                        constructorToUse = AccessController.doPrivileged(<br>                                (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) () -&gt; clazz.getDeclaredConstructor());<br>                    }<br>                    else {<br>                        constructorToUse =    clazz.getDeclaredConstructor();<br>                    }<br>                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;<br>                }<br>                catch (Throwable ex) {<br>                    throw new BeanInstantiationException(clazz, “No default constructor found”, ex);<br>                }<br>            }<br>        }<br>        //使用BeanUtils实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化<br>        return BeanUtils.instantiateClass(constructorToUse);<br>    }<br>    else {<br>        // Must generate CGLIB subclass.<br>        //使用CGLIB来实例化对象<br>        return instantiateWithMethodInjection(bd, beanName, owner);<br>    }<br>}<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通过上面的代码分析，我们看到了如果 <span class="keyword">Bean </span>有方法被覆盖了，则使用 <span class="keyword">JDK </span>的反射机制进行实例化，否则，使用 CGLib 进行实例化。<span class="keyword">instantiateWithMethodInjection() </span>方 法 调 用SimpleInstantiationStrategy 的 子 类CGLibSubclassingInstantiationStrategy 使用 CGLib 来进行初始化，其源码如下：</span><br></pre></td></tr></table></figure></p>
<p>//使用CGLIB进行Bean对象实例化<br>    public Object instantiate(@Nullable Constructor&lt;?&gt; ctor, @Nullable Object… args) {<br>        //创建代理子类<br>        Class&lt;?&gt; subclass = createEnhancedSubclass(this.beanDefinition);<br>        Object instance;<br>        if (ctor == null) {<br>            instance = BeanUtils.instantiateClass(subclass);<br>        }<br>        else {<br>            try {<br>                Constructor&lt;?&gt; enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());<br>                instance = enhancedSubclassConstructor.newInstance(args);<br>            }<br>            catch (Exception ex) {<br>                throw new BeanInstantiationException(this.beanDefinition.getBeanClass(),<br>                        “Failed to invoke constructor for CGLIB enhanced subclass [“ + subclass.getName() + “]”, ex);<br>            }<br>        }<br>        // SPR-10785: set callbacks directly on the instance instead of in the<br>        // enhanced class (via the Enhancer) in order to avoid memory leaks.<br>        Factory factory = (Factory) instance;<br>        factory.setCallbacks(new Callback[] {NoOp.INSTANCE,<br>                new LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),<br>                new ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});<br>        return instance;<br>    }</p>
<pre><code>private Class&lt;?&gt; createEnhancedSubclass(RootBeanDefinition beanDefinition) {
    //CGLIB中的类
    Enhancer enhancer = new Enhancer();
    //将Bean本身作为其基类
    enhancer.setSuperclass(beanDefinition.getBeanClass());
    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
    if (this.owner instanceof ConfigurableBeanFactory) {
        ClassLoader cl = ((ConfigurableBeanFactory) this.owner).getBeanClassLoader();
        enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(cl));
    }
    enhancer.setCallbackFilter(new MethodOverrideCallbackFilter(beanDefinition));
    enhancer.setCallbackTypes(CALLBACK_TYPES);
    //使用CGLIB的createClass方法生成实例对象
    return enhancer.createClass();
}
</code></pre><p>}<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGLib 是一个常用的字节码生成器的类库，它提供了一系列 API 实现 <span class="keyword">Java </span>字节码的生成和转换功能。<span class="keyword">JDK </span>的动态代理只能针对接口，如果一个类没有实现任何接口，要对其进行动态代理只能使用 CGLib。</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 准备依赖注入</span></span><br><span class="line">在前面的分析中我们已经了解到 <span class="keyword">Bean </span>的依赖注入主要分为两个步骤，首先调用 createBeanInstance()方法生成 <span class="keyword">Bean </span>所包含的 <span class="keyword">Java </span>对象实例。然后，调用 populateBean()方法，对 <span class="keyword">Bean </span>属性的依赖注入进行处理。</span><br><span class="line">上面我们已经分析了容器初始化生成 <span class="keyword">Bean </span>所包含的 <span class="keyword">Java </span>实例对象的过程，现在我们继续分析生成对象后，Spring IOC 容器是如何将 <span class="keyword">Bean </span>的属性依赖关系注入 <span class="keyword">Bean </span>实例对象中并设置好的，回到AbstractAutowireCapableBeanFactory 的 populateBean()方法，对属性依赖注入的代码如下：</span><br></pre></td></tr></table></figure></p>
<p>//将Bean属性设置到生成的实例对象上<br>protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {<br>    if (bw == null) {<br>        if (mbd.hasPropertyValues()) {<br>            throw new BeanCreationException(<br>                    mbd.getResourceDescription(), beanName, “Cannot apply property values to null instance”);<br>        }<br>        else {<br>            // Skip property population phase for null instance.<br>            return;<br>        }<br>    }</p>
<pre><code>// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
// state of the bean before properties are set. This can be used, for example,
// to support styles of field injection.
boolean continueWithPropertyPopulation = true;

if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
    for (BeanPostProcessor bp : getBeanPostProcessors()) {
        if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
                continueWithPropertyPopulation = false;
                break;
            }
        }
    }
}

if (!continueWithPropertyPopulation) {
    return;
}
//获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值
PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);

//对依赖注入处理，首先处理autowiring自动装配的依赖注入
if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
        mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
    MutablePropertyValues newPvs = new MutablePropertyValues(pvs);

    // Add property values based on autowire by name if applicable.
    //根据Bean名称进行autowiring自动装配处理
    if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {
        autowireByName(beanName, mbd, bw, newPvs);
    }

    // Add property values based on autowire by type if applicable.
    //根据Bean类型进行autowiring自动装配处理
    if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
        autowireByType(beanName, mbd, bw, newPvs);
    }

    pvs = newPvs;
}

//对非autowiring的属性进行依赖注入处理

boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);

if (hasInstAwareBpps || needsDepCheck) {
    if (pvs == null) {
        pvs = mbd.getPropertyValues();
    }
    PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
    if (hasInstAwareBpps) {
        for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof InstantiationAwareBeanPostProcessor) {
                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
                if (pvs == null) {
                    return;
                }
            }
        }
    }
    if (needsDepCheck) {
        checkDependencies(beanName, mbd, filteredPds, pvs);
    }
}

if (pvs != null) {
    //对属性进行注入
    applyPropertyValues(beanName, mbd, bw, pvs);
}
</code></pre><p>}</p>
<p>//解析并注入依赖属性的过程<br>protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {<br>    if (pvs.isEmpty()) {<br>        return;<br>    }</p>
<pre><code>//封装属性值
MutablePropertyValues mpvs = null;
List&lt;PropertyValue&gt; original;

if (System.getSecurityManager() != null) {
    if (bw instanceof BeanWrapperImpl) {
        //设置安全上下文，JDK安全机制
        ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());
    }
}

if (pvs instanceof MutablePropertyValues) {
    mpvs = (MutablePropertyValues) pvs;
    //属性值已经转换
    if (mpvs.isConverted()) {
        // Shortcut: use the pre-converted values as-is.
        try {
            //为实例化对象设置属性值
            bw.setPropertyValues(mpvs);
            return;
        }
        catch (BeansException ex) {
            throw new BeanCreationException(
                    mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);
        }
    }
    //获取属性值对象的原始类型值
    original = mpvs.getPropertyValueList();
}
else {
    original = Arrays.asList(pvs.getPropertyValues());
}

//获取用户自定义的类型转换
TypeConverter converter = getCustomTypeConverter();
if (converter == null) {
    converter = bw;
}
//创建一个Bean定义属性值解析器，将Bean定义中的属性值解析为Bean实例对象的实际值
BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);

// Create a deep copy, resolving any references for values.

//为属性的解析值创建一个拷贝，将拷贝的数据注入到实例对象中
List&lt;PropertyValue&gt; deepCopy = new ArrayList&lt;&gt;(original.size());
boolean resolveNecessary = false;
for (PropertyValue pv : original) {
    //属性值不需要转换
    if (pv.isConverted()) {
        deepCopy.add(pv);
    }
    //属性值需要转换
    else {
        String propertyName = pv.getName();
        //原始的属性值，即转换之前的属性值
        Object originalValue = pv.getValue();
        //转换属性值，例如将引用转换为IOC容器中实例化对象引用
        Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
        //转换之后的属性值
        Object convertedValue = resolvedValue;
        //属性值是否可以转换
        boolean convertible = bw.isWritableProperty(propertyName) &amp;&amp;
                !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);
        if (convertible) {
            //使用用户自定义的类型转换器转换属性值
            convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);
        }
        // Possibly store converted value in merged bean definition,
        // in order to avoid re-conversion for every created bean instance.
        //存储转换后的属性值，避免每次属性注入时的转换工作
        if (resolvedValue == originalValue) {
            if (convertible) {
                //设置属性转换之后的值
                pv.setConvertedValue(convertedValue);
            }
            deepCopy.add(pv);
        }
        //属性是可转换的，且属性原始值是字符串类型，且属性的原始类型值不是
        //动态生成的字符串，且属性的原始值不是集合或者数组类型
        else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp;
                !((TypedStringValue) originalValue).isDynamic() &amp;&amp;
                !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {
            pv.setConvertedValue(convertedValue);
            //重新封装属性的值
            deepCopy.add(pv);
        }
        else {
            resolveNecessary = true;
            deepCopy.add(new PropertyValue(pv, convertedValue));
        }
    }
}
if (mpvs != null &amp;&amp; !resolveNecessary) {
    //标记属性值已经转换过
    mpvs.setConverted();
}

// Set our (possibly massaged) deep copy.
//进行属性依赖注入
try {
    bw.setPropertyValues(new MutablePropertyValues(deepCopy));
}
catch (BeansException ex) {
    throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);
}
</code></pre><p>}<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">分析上述代码，我们可以看出，对属性的注入过程分以下两种情况：</span><br><span class="line">1)、属性值类型不需要强制转换时，不需要解析属性值，直接准备进行依赖注入。</span><br><span class="line">2)、属性值需要进行类型强制转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。</span><br><span class="line">对属性值的解析是在 BeanDefinitionValueResolver 类中的 resolveValueIfNecessary()方法中进行的，对属性值的依赖注入是通过 bw.setPropertyValues()方法实现的，在分析属性值的依赖注入之前，我们先分析一下对属性值的解析过程</span><br><span class="line"></span><br><span class="line"><span class="section">##### 解析属性注入规则</span></span><br><span class="line">当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个 Bean实例对象的引用，则容器首先需要根据属性值解析出所引用的对象，然后才能将该引用对象注入到目标实例对象的属性上去，对属性进行解析的由 resolveValueIfNecessary()方法实现。</span><br><span class="line"></span><br><span class="line">Spring IOC 容器是如何将属性的值注入到 Bean 实例对象中去的：</span><br><span class="line">1)、对于集合类型的属性，将其属性值解析为目标类型的集合后直接赋值给属性。</span><br><span class="line"></span><br><span class="line">2)、对于非集合类型的属性，大量使用了 JDK 的反射机制，通过属性的 getter()方法获取指定属性注入以前的值，同时调用属性的 setter()方法为属性设置注入后的值。看到这里相信很多人都明白了 Spring的 setter()注入原理</span><br><span class="line"></span><br><span class="line">Spring DI运行时序图</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1624288-20190628135317957-1069467007.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### 如何理解分布式事务，为什么会出现这个问题，如何去解决，了解哪些分布式事务中间件？</span></span><br><span class="line"> 分布式中间件，我自己了解的就有</span><br><span class="line"> </span><br><span class="line"><span class="bullet">- </span>seata</span><br><span class="line"><span class="bullet">- </span>tx-lcn</span><br><span class="line"><span class="bullet">- </span>easyTransaction</span><br><span class="line"><span class="bullet">- </span>serviceComb</span><br><span class="line"></span><br><span class="line"><span class="section">### Dubbo有了解没有？</span></span><br><span class="line">阿里开源的一款分布式框架。</span><br><span class="line"></span><br><span class="line"><span class="section">### Hystrix功能和在项目中怎么使用的？Hystrix怎么检测断路器是否要开启/关闭？Hystrix实现原理？除Hystrix之外的其他熔断限流中间件有了解没有，了解多少说多少？</span></span><br><span class="line"></span><br><span class="line">在一个分布式系统中，必然会有部分系统的调用会失败。Hystrix是一个通过添加超时容错和失败容错逻辑来帮助你控制这些分布式系统的交互。Hystrix通过隔离服务之间的访问，阻止他们之间的级联故障以及提供后背选项来实现这些，所有新而这些都用来提高系统的整体弹性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Hystrix被设计用来解决一下几个方面</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>通过第三方（一般来源网络）的调用，给与保护和控制延迟和失败。</span><br><span class="line"><span class="bullet">- </span>在复杂的分布式系统中复制级联失败。</span><br><span class="line"><span class="bullet">- </span>快速失败和修复。</span><br><span class="line"><span class="bullet">- </span>在可能的情况下，回滚挥着优雅的失败。</span><br><span class="line"><span class="bullet">- </span>实现几乎实时监控，警报和操作控制。</span><br><span class="line"></span><br><span class="line">复杂的分布式体系结构中的应用程序具有许多依赖关系，每个依赖关系都会在某些时候不可避免的失败。如果主机应用程序未与这些外部的故障隔离，那么可能会被这些故障拖垮。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例如:一个依赖30个SOA服务的系统,每个服务99.99%可用。</span><br><span class="line"></span><br><span class="line">99.99%的30次方 ≈ 99.7%</span><br><span class="line"></span><br><span class="line">0.3% 意味着一亿次请求 会有 3,000,00次失败</span><br><span class="line"></span><br><span class="line">换算成时间大约每月有2个小时服务不稳定.</span><br><span class="line"></span><br><span class="line">随着服务依赖数量的变多，服务不稳定的概率会成指数性提高.</span><br><span class="line">而实际中可能更糟糕。</span><br><span class="line"></span><br><span class="line"><span class="section">#### Hystrix设计模式</span></span><br><span class="line">设计详解（命令模式）</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20180719101351962.png</span>)</span><br><span class="line">流程图</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/hystrix-command-flow-chart.png</span>)</span><br><span class="line">流程说明</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>构造一个HystrixCommand或者HystrixObserverCommand对象，把需要调用的依赖放在run()中</span><br><span class="line"><span class="bullet">1. </span>执行execute/queue做同步或者异步执行</span><br><span class="line"><span class="bullet">1. </span>是否做了缓存</span><br><span class="line"><span class="bullet">1. </span>熔断是否打开</span><br><span class="line"><span class="bullet">1. </span>线程池/队列/信号量是否满了</span><br><span class="line"><span class="bullet">1. </span>调用run（）或者construct（）</span><br><span class="line"><span class="bullet">1. </span>计算熔断健康度（成功，失败，拒绝，超时）的数据，上报给熔断器，用于统计从而判断熔断器状态，可以根据这些数据来决定是否进行熔断，例如：错误率在80%以上，接口等待超过预定的时间等。</span><br><span class="line"><span class="bullet">1. </span>获取Fallback，如果fallback失败，系统报错，所以要尽量防止fallback报错，当然也可以在fallback上加上一层fallback</span><br><span class="line"><span class="bullet">1. </span>返回执行结果</span><br><span class="line"></span><br><span class="line"><span class="section">#### 功能介绍</span></span><br><span class="line"></span><br><span class="line"><span class="section">##### 熔断器</span></span><br><span class="line">下图显示了HystrixCommand或者HystrixObserverCommand如何与HystrixCircuitBreaker及哦啊胡及其逻辑和决策流程。包括计数器在断路器中的行为方式。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/hystrix-command-flow-chart.png</span>)</span><br><span class="line">熔断行为</span><br><span class="line"></span><br><span class="line">断路器打开还是关闭的步骤如下</span><br><span class="line"><span class="bullet">1. </span>假定请求的量超过预定的阈值（circuitBreakerRequestVolumeThreshold）</span><br><span class="line"><span class="bullet">1. </span>再假定错误百分比超过了设定的百分比（circuitBreakerErrorThresholdPercentage）</span><br><span class="line"><span class="bullet">1. </span>断路器会从close状态到open状态</span><br><span class="line"><span class="bullet">1. </span>当打开的状态，会短路所有针对该断路器的请求</span><br><span class="line"><span class="bullet">1. </span>过了一定时间（circuitBreakerSleepWindowInMilliseconds（短路超过一定时间会重新去请求）），下一个请求将通过，不会被短路（当前是half-open状态）。如果这个请求失败了，则断路器在睡眠窗口期间返回open状态，如果请求成功，则断路器返回close状态，并重新回到第一步逻辑判断。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 隔离</span></span><br><span class="line">Hystrix使用璧仓模式来隔离彼此的依赖关系，并限制对其中任何一个的并发访问。</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20180719101939418.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">#### 线程和线程池</span></span><br><span class="line">客户端（第三方，网络调用等）依赖和请求线程运行在不同的线程上，这个将他们从调用线程隔离开来，这样调用者就可以从一个耗时太长的依赖中隔离。如下图所示，也可以为不同的请求开启不同的线程池，彼此之间不相互干扰。</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/circuit-breaker-1280.png</span>)</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/isolation-options-12801.png</span>)</span><br><span class="line">（注：上图右边表示的是信号量模式）</span><br><span class="line"></span><br><span class="line"><span class="section">##### 线程隔离</span></span><br><span class="line"></span><br><span class="line">1、线程隔离的好处：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>整个应用的即是在客户端调用失效的情况下也能健康的运行，线程池能够保证这个线程下面的失效不会影响应用其他部分的运行</span><br><span class="line"><span class="bullet">- </span>当失效的客户端调用回复的时候，这个线程池也会被清理并且应用会立马回复健康，比tomcat那种长时间的恢复要好很多</span><br><span class="line"></span><br><span class="line">简而言之，线程隔离能够允许在不引起中断的情况下优雅的处理第三方调用的各种问题。</span><br><span class="line"></span><br><span class="line">2、线程隔离的缺点</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>主要缺点是增加了上下文切换的开销，每个明亮的执行都涉及到队列，调度和上下文切换。不过NetFix在设计这个系统的时候，已经决定接受这笔开销，以换取他的好处。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 信号量隔离</span></span><br><span class="line">你可以使用信号量（或者计数器）来限制当前依赖调用的并发数，而不是使用线程池或者队列。如果客户端是可信的，且能快速返回，可以使用信号量来代替线程隔离，降低开销。信号量的大小可以动态调节，线程池却不行。</span><br><span class="line"></span><br><span class="line">HystrixCommand和HystrixObserverCommand提供信号量隔离在下面两个地方：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Fallback：当Hystrix检索fallback的时候，他心总是调用tomcat线程上执行此操作</span><br><span class="line"><span class="bullet">- </span>如果你设置execution.isolation.strategy为SEMAPHORE的时候，Hystrix会使用信号量代替线程池去限制当前调用Command的并发数。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 请求合并</span></span><br><span class="line">设置某个时间内的请求，合并为一个发送，例如：id和ids参数</span><br><span class="line"></span><br><span class="line"><span class="section">##### 请求缓存</span></span><br><span class="line"></span><br><span class="line"><span class="section">##### 仪表盘</span></span><br><span class="line">Hystrix仪表盘</span><br><span class="line"></span><br><span class="line">主要用来实时监控Hystrix的各项指标信息。通过Hystrix DashBoard反馈的实时信息，可以帮助我们快速防线系统中存在的问题，从而及时地采取对应措施。</span><br><span class="line"></span><br><span class="line">开启仪表盘</span><br><span class="line"></span><br><span class="line">1、在服务实例中新增spring-boot-starter-actuator，监控模块已开启监控相关的端点，并且映入断路器依赖：spring-cloud-starter-hystrix</span><br><span class="line"></span><br><span class="line">2、确保在服务实例的主类中已经使用了@EnableCircuitBreaker注解，开启了断路器功能。</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/2018071910300525.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">#### 使用案例</span></span><br></pre></td></tr></table></figure></p>
<p>public class MyHystrixCommand extends HystrixCommand<string> {</string></p>
<p>   protected MyHystrixCommand(String groupKey) {<br>      super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(groupKey)));<br>   }</p>
<p>   @Override<br>   protected String run() throws Exception {<br>      //实际调用外部的地方<br>      return “reality invoke。”;<br>   }</p>
<p>   @Override<br>   protected String getFallback() {<br>      //run抛出异常，或者调用超时之后调用fallback<br>      return “invoke failed。”;<br>   }</p>
<p>   public static void main(String args[]){<br>      MyHystrixCommand hystrixCommand = new MyHystrixCommand(“myCommand”);<br>      System.out.println(hystrixCommand.execute());<br>   }<br>}<br>输出：<br>reality invoke。</p>
<p>//注解方式<br>@RequestMapping(“get-demo1-test”)<br>@HystrixCommand(fallbackMethod = “fallback”, groupKey = “userGroup”)<br>public String getDemo1Name() throws InterruptedException {<br>   //测试重试机制<br>   int sleepTime = new Random().nextInt(300);<br>   Thread.sleep(sleepTime);<br>   return demo1Service.getAppName();<br>}</p>
<p>public String fallback(Throwable t) {<br>   System.out.println(“erroe: “ + t.getMessage());<br>   return “error”;<br>}</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">#### 配置</span></span><br><span class="line"></span><br><span class="line">几个主要的配置信息：在构造方法中通过Setter设置</span><br><span class="line"></span><br><span class="line"> 1.1、execution.isolation. thread.timeoutinMilliseconds: 该属性用来配 置HystrixCommand执行的超时时间， 单位为毫秒。当HystrixCommand执行 时间超过该配置值之后， Hystrix会将该执行命令标记为TIMEOUT并进入服务降级 处理逻辑。默认值1000</span><br><span class="line"></span><br><span class="line"> 1.2、execution.isolation.semaphore.maxConcurrentRequests:当HystrixCommand的隔离策略使用信号量的时候，该属性用来配置信号量的大小（并发请求数）。 当最大并发请求数达到该设置值时， 后续的请求将会被拒绝。默认值10</span><br><span class="line"></span><br><span class="line"> 1.3、circuitBreaker.requestVolumeThreshold该属性设置滚动窗口中将使断路器跳闸的最小请求数量，默认值：20</span><br><span class="line"></span><br><span class="line">1.4、circuitBreaker.sleepWindowInMilliseconds 断路器跳闸后，在此值的时间的内，hystrix会拒绝新的请求，只有过了这个时间断路器才会打开闸门</span><br><span class="line"></span><br><span class="line">默认值：5000</span><br><span class="line"></span><br><span class="line">1.5、circuitBreaker.errorThresholdPercentage 设置失败百分比的阈值。如果失败比率超过这个值，则断路器跳闸并且进入fallback逻辑</span><br><span class="line"></span><br><span class="line">默认值：50</span><br><span class="line"></span><br><span class="line">1.6、metrics.rollingStats.timeInMilliseconds 滚动窗口时间大小，默认10s</span><br><span class="line"></span><br><span class="line"><span class="section">### Feign了解多少说多少？</span></span><br><span class="line"><span class="section">#### Feign</span></span><br><span class="line">feign是声明式的web service客户端，它让微服务之间的调用变得更简单了，类似controller调用service。Spring Cloud集成了Ribbon和Eureka，可在使用Feign时提供负载均衡的http客户端。</span><br><span class="line"></span><br><span class="line">因为feign底层是使用了ribbon作为负载均衡的客户端，而ribbon的负载均衡也是依赖于eureka 获得各个服务的地址，所以要引入eureka-client。</span><br><span class="line"></span><br><span class="line"><span class="section">##### Feign原理</span></span><br><span class="line"><span class="bullet">- </span>启动时，程序会进行包扫描，扫描所有包下所有@FeignClient注解的类，并将这些类注入到spring的IOC容器中。当定义的Feign中的接口被调用时，通过JDK的动态代理来生成RequestTemplate。</span><br><span class="line"><span class="bullet">- </span>RequestTemplate中包含请求的所有信息，如请求参数，请求URL等。</span><br><span class="line"><span class="bullet">- </span>RequestTemplate声场Request，然后将Request交给client处理，这个client默认是JDK的HTTPUrlConnection，也可以是OKhttp、Apache的HTTPClient等。</span><br><span class="line"><span class="bullet">- </span>最后client封装成LoadBaLanceClient，结合ribbon负载均衡地发起调用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">### Zookeeper，了解多少说多少？</span></span><br><span class="line">ZooKeeper是一个分布式的开源协调服务，用于分布式应用程序。它公开了一组简单的原子操作，分布式应用程序可以构建这些原子操作，以实现更高级别的服务，以实现同步，配置维护以及组和命名。</span><br><span class="line">它的设计易于编程，并使用在熟悉的文件系统目录树结构之后设计的数据模型。它运行在Java中，并且对Java和C都有绑定。</span><br><span class="line"></span><br><span class="line">周所周知，协调服务是很难做到的。它们特别容易出现诸如竞态条件和死锁等错误。ZooKeeper背后的动机是减轻分布式应用程序从头开始实施协调服务的责任。</span><br><span class="line"></span><br><span class="line"><span class="section">#### 设计目标</span></span><br><span class="line">Zookeeper是简单的。Zookeeper允许分布式进程之间彼此协调，通过一个共享的分级命名空间，它非常像标准的文件系统。</span><br><span class="line"></span><br><span class="line">ZooKeeper实现非常重视高性能，高可用性，严格有序的访问。ZooKeeper的性能方面意味着它可以在大型分布式系统中使用。</span><br><span class="line">可靠性方面使其不会成为单点故障。严格的排序意味着可以在客户端实现复杂的同步原子操作。</span><br><span class="line"></span><br><span class="line">Zookeeper是可复制的。 与它协调的分布式进程一样，ZooKeeper本身也可以在称为集合的一组主机上进行复制。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/12540413-62c81551958254dc.png</span>)</span><br><span class="line"></span><br><span class="line">组成ZooKeeper服务的服务器必须彼此了解。它们保持状态的内存映像，以及持久存储中的事务日志和快照。只要大多数服务器可用，ZooKeeper服务就可用。</span><br><span class="line">客户端连接到单个ZooKeeper服务器。客户端维护一个TCP连接，通过它发送请求，获取响应，获取观看事件并发送心跳。如果与服务器的TCP连接中断，则客户端将连接到其他服务器。</span><br><span class="line"></span><br><span class="line"><span class="strong">**Zookeeper是有序的**</span>。 ZooKeeper使用反映所有ZooKeeper事务顺序的数字标记每个更新。后续操作可以使用该顺序来实现更高级别的抽象，例如同步原子操作。</span><br><span class="line"></span><br><span class="line"><span class="strong">**Zookeeper是非常快的**</span>。 它在“读取主导”工作负载中速度特别快。ZooKeeper应用程序在数千台计算机上运行，并且在读取比写入更常见的情况下表现最佳，比率大约为10：1。</span><br><span class="line"></span><br><span class="line"><span class="section">#### 数据模型和分层名称空间</span></span><br><span class="line"></span><br><span class="line">ZooKeeper提供的名称空间非常类似于标准文件系统。名称是由斜线（/）分隔的一系列路径元素。ZooKeeper名称空间中的每个节点都由一个路径标识。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/12540413-a229d45b54a02423.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##### 节点和临时节点</span></span><br><span class="line">与标准文件系统不同的是，ZooKeeper命名空间中的每个节点都可以拥有与其相关的数据以及子级。这就像拥有一个允许文件也是目录的文件系统。（ZooKeeper旨在存储协调数据：状态信息，配置，位置信息等，因此存储在每个节点的数据通常很小，在字节到千字节范围内。）我们使用术语 znode来表明我们正在谈论ZooKeeper数据节点。</span><br><span class="line"></span><br><span class="line">Znodes维护一个stat结构，包括数据更改，ACL更改和时间戳的版本号，以允许缓存验证和协调更新。每次znode的数据更改时，版本号都会增加。例如，每当客户端检索数据时，它也会收到数据的版本。</span><br><span class="line"></span><br><span class="line">存储在名称空间中每个节点上的数据是以原子方式读取和写入的。读取获取与znode关联的所有数据字节，写入将替换所有数据。每个节点都有一个访问控制列表（ACL），限制谁可以做什么。</span><br><span class="line"></span><br><span class="line">ZooKeeper也有临时节点的概念。只要创建znode的会话处于活动状态，就会存在这些znode。当会话结束时，znode被删除。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 有条件的更新和监视</span></span><br><span class="line">ZooKeeper支持观察的概念。客户可以在znode上设置观察器。当znode更改时，将触发并删除观察器。</span><br><span class="line"></span><br><span class="line">当观察被触发时，客户端收到一个数据包，说明znode已经改变。如果客户端和其中一个Zoo Keeper服务器之间的连接断开，客户端将收到本地通知。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 担保</span></span><br><span class="line">ZooKeeper非常快速且非常简单。但是，由于其目标是构建更复杂的服务（如同步）的基础，因此它提供了一系列保证。这些是：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>顺序一致性 - 客户端的更新将按照它们发送的顺序进行应用。</span><br><span class="line"><span class="bullet">- </span>原子性 - 更新成功或失败。没有部分结果。</span><br><span class="line"><span class="bullet">- </span>单系统映像 - 无论服务器连接到哪个服务器，客户端都会看到相同的服务视图。</span><br><span class="line"><span class="bullet">- </span>可靠性 - 一旦应用更新，它将一直持续到客户覆盖更新为止。</span><br><span class="line"><span class="bullet">- </span>及时性 - 系统的客户视图保证在特定时间范围内是最新的。</span><br><span class="line"></span><br><span class="line"><span class="section">#####  简单的API</span></span><br><span class="line">ZooKeeper的设计目标之一是提供一个非常简单的编程接口。因此，它仅支持以下操作：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>创建——在树中的某个位置创建一个节点</span><br><span class="line"><span class="bullet">- </span>删除——删除节点</span><br><span class="line"><span class="bullet">- </span>存在——测试某个位置是否存在节点</span><br><span class="line"><span class="bullet">- </span>获取数据——从节点读取数据</span><br><span class="line"><span class="bullet">- </span>设定数据——将数据写入节点</span><br><span class="line"><span class="bullet">- </span>得到子节点——检索节点的子节点列表</span><br><span class="line"><span class="bullet">- </span>同步——等待数据传播</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">#### 能用zookeeper做什么</span></span><br><span class="line">1、 命名服务</span><br><span class="line"></span><br><span class="line">这个似乎最简单，在zookeeper的文件系统里创建一个目录，即有唯一的path。在我们使用tborg无法确定上游程序的部署机器时即可与下游程序约定好path，通过path即能互相探索发现，不见不散了。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">2、 配置管理</span><br><span class="line"></span><br><span class="line">程序总是需要配置的，如果程序分散部署在多台机器上，要逐个改变配置就变得困难。好吧，现在把这些配置全部放到zookeeper上去，保存在 Zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中就好。</span><br><span class="line"></span><br><span class="line"> 3、 集群管理</span><br><span class="line"></span><br><span class="line">所谓集群管理无在乎两点：是否有机器退出和加入、选举master。</span><br><span class="line"></span><br><span class="line">对于第一点，所有机器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。新机器加入 也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了。</span><br><span class="line"></span><br><span class="line">对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。</span><br><span class="line"></span><br><span class="line">4、  分布式锁</span><br><span class="line"></span><br><span class="line">有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。</span><br><span class="line"></span><br><span class="line">对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /<span class="code">``distribute_lock`</span>` 节点，最终成功创建的那个客户端也即拥有了这把锁。厕所有言：来也冲冲，去也冲冲，用完删除掉自己创建的distribute_lock 节点就释放出锁。</span><br><span class="line"></span><br><span class="line">对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。</span><br><span class="line"></span><br><span class="line">5、队列管理</span><br><span class="line"></span><br><span class="line">两种类型的队列：</span><br><span class="line"></span><br><span class="line">1、 同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。</span><br><span class="line"></span><br><span class="line">2、队列按照 FIFO 方式进行入队和出队操作。</span><br><span class="line"></span><br><span class="line">第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。</span><br><span class="line"></span><br><span class="line">第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">终于了解完我们能用zookeeper做什么了，可是作为一个程序员，我们总是想狂热了解zookeeper是如何做到这一点的，单点维护一个文件系统没有什么难度，可是如果是一个集群维护一个文件系统保持数据的一致性就非常困难了。</span><br><span class="line"></span><br><span class="line"><span class="section">#### 分布式与数据复制</span></span><br><span class="line">Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处：</span><br><span class="line"></span><br><span class="line">1、 容错</span><br><span class="line">一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；</span><br><span class="line"></span><br><span class="line">2、提高系统的扩展能力</span><br><span class="line">把负载分布到多个节点上，或者增加节点来提高系统的负载能力；</span><br><span class="line"></span><br><span class="line">3、提高性能</span><br><span class="line">让客户端本地访问就近的节点，提高用户访问速度。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">从客户端读写访问的透明度来看，数据复制集群系统分下面两种：</span><br><span class="line"></span><br><span class="line">1、写主(WriteMaster)</span><br><span class="line">对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离；</span><br><span class="line"></span><br><span class="line">2、写任意(Write Any)</span><br><span class="line">对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">对zookeeper来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</span><br><span class="line"></span><br><span class="line">我们关注的重点还是在如何保证数据在集群所有机器的一致性，这就涉及到paxos算法。</span><br><span class="line"></span><br><span class="line"><span class="section">#### 数据一致性与paxos算法</span></span><br><span class="line">据说Paxos算法的难理解与算法的知名度一样令人敬仰，所以我们先看如何保持数据的一致性，这里有个原则就是：</span><br><span class="line"></span><br><span class="line">在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。</span><br><span class="line"></span><br><span class="line">Paxos算法解决的什么问题呢，解决的就是保证每个节点执行相同的操作序列。好吧，这还不简单，master维护一个全局写队列，所有写操作都必 须放入这个队列编号，那么无论我们写多少个节点，只要写操作是按编号来的，就能保证一致性。没错，就是这样，可是如果master挂了呢。</span><br><span class="line"></span><br><span class="line">Paxos算法通过投票来对写操作进行全局编号，同一时刻，只有一个写操作被批准，同时并发的写操作要去争取选票，只有获得过半数选票的写操作才会 被批准（所以永远只会有一个写操作得到批准），其他的写操作竞争失败只好再发起一轮投票，就这样，在日复一日年复一年的投票中，所有写操作都被严格编号排 序。编号严格递增，当一个节点接受了一个编号为100的写操作，之后又接受到编号为99的写操作（因为网络延迟等很多不可预见原因），它马上能意识到自己 数据不一致了，自动停止对外服务并重启同步过程。任何一个节点挂掉都不会影响整个集群的数据一致性（总2n+1台，除非挂掉大于n台）。</span><br><span class="line"></span><br><span class="line"><span class="section">##### Paxos算法</span></span><br><span class="line"><span class="section">######  角色（核心就3个角色）</span></span><br><span class="line">Client：客户端，发起请求并等待返回。</span><br><span class="line">Proposer（提案者）：处理客户端请求，将客户端的请求发送到集群中，以便决定这个值是否可以被批准。</span><br><span class="line">Acceptor（接受者）：负责处理接收到的提议，他们的回复就是一次投票。会存储一些状态来决定是否接收一个值。</span><br><span class="line">Learner（学习者）：当有同一个value的协议被超过一半的Acceptor采纳并发送消息给Learner时，Learner采纳该协议值。</span><br><span class="line">Leader：一个特殊的Proposer。</span><br><span class="line"></span><br><span class="line"><span class="section">######  Basic-Paxos算法</span></span><br><span class="line">核心实现Paxos Instance主要包括两个阶段:</span><br><span class="line"></span><br><span class="line">准备阶段(prepare phase)和提议阶段(accept phase)</span><br><span class="line"></span><br><span class="line">简单来说，Basic Paxos 是一个经典两阶段提交（2PC）</span><br><span class="line"></span><br><span class="line">第一阶段：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>1a prepare 准备: proposer向acceptors提出一个协议，这里的协议就是期望的“一致性内容”</span><br><span class="line"><span class="bullet">- </span>1a promise 承诺: acceptor承诺只接收最大协议号的协议（包括prepare和accept），并拒绝比当前协议号N小的协议，回复proposer之前接收的所有协议值。如果当前协议号N比之前都小，那么回复拒绝。</span><br><span class="line"></span><br><span class="line">第二阶段：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>2a Accept Request 发起“accept”请求：proposer收到acceptor反馈的足够的承诺后，给协议设最大值，如果没回复，随便设置一个值。发送"accept"请求给选定值的acceptors.</span><br><span class="line"><span class="bullet">- </span>2b Accepted: acceptor接受协议（该acceptor之前没有承诺过大于该协议号的协议），并通知给proposer和learner</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170519183209291-1684980050.png</span>)</span><br><span class="line">其中prepare阶段的作用，如下图所示：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170519173152510-2089061877.png</span>)</span><br><span class="line"></span><br><span class="line">1.S1首先发起accept(1,red)，并在S1,S2和S3达成多数派，red在S1，S2，S3上持久化</span><br><span class="line"></span><br><span class="line">2.随 后S5发起accept(5,blue)，在S3，S4和S5达成多数派，blue在S</span><br><span class="line">3，S4和S5持久化</span><br><span class="line"></span><br><span class="line">3.最后的结果是，S1和S2的值是red，而S4和S5的值是blue，s3存在异议，red覆盖了blue？</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>将提议进行排序，可以为每个提议赋予一个唯一的ID，规定这个ID越大越新，很明显（5，blue）和（1，red），5比1大,所以保留blue</span><br><span class="line"><span class="bullet">- </span>采用两阶段方法，拒绝旧提议。</span><br><span class="line"></span><br><span class="line"><span class="section">###### Muti-Paxos算法</span></span><br><span class="line"></span><br><span class="line">很多文章有误解说Muti-Paxos是一阶段提交，那是仅限于leader稳定时。刚选出来一个新的leader时，依然是二阶段提交如下图：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170522174941023-1628898506.png</span>)</span><br><span class="line">如果leader稳定，不需要prepare和promise步骤，如下图（图中Proposer就是一个Leader）：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170522175104867-87240999.png</span>)</span><br><span class="line">Multi Paxos中leader用于避免活锁(例如1个leader,4个Proposer,2个提议A，2个提议B不能达成一致，导致活锁)，但leader的存在会带来其他问题，一是如何选举和保持唯一leader(虽然无leader或多leader不影响一致性，但影响决议进程progress)，二是充当leader的节点会承担更多压力，如何均衡节点的负载。Mencius[1]提出节点轮流担任leader，以达到均衡负载的目的；租约(lease)可以帮助实现唯一leader，但leader故障情况下可导致服务短期不可用。</span><br><span class="line"></span><br><span class="line"><span class="section">###### Muti-Paxos在google chubby中的应用</span></span><br><span class="line">Google Chubby是一个高可用分布式锁服务，被设计成一个需要访问中心化节点的分布式锁服务。本文只分析chubby服务端的实现。</span><br><span class="line"></span><br><span class="line"> Chubby服务端的基本架构大致分为三层</span><br><span class="line"></span><br><span class="line">　　① 最底层是容错日志系统（Fault-Tolerant Log），通过Paxos算法能够保证集群所有机器上的日志完全一致，同时具备较好的容错性。</span><br><span class="line"></span><br><span class="line">　　② 日志层之上是Key-Value类型的容错数据库（Fault-Tolerant DB），其通过下层的日志来保证一致性和容错性。</span><br><span class="line"></span><br><span class="line">　　③ 存储层之上的就是Chubby对外提供的分布式锁服务和小文件存储服务。</span><br><span class="line">　　![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170523192819976-189903080.png</span>)</span><br><span class="line">Paxos算法用于保证集群内各个副本节点的日志能够保持一致，Chubby事务日志（Transaction Log）中的每一个Value对应Paxos算法中的一个Instance（对应Proposer），由于Chubby需要对外提供不断的服务，因此事务日志会无限增长，于是在整个Chubby运行过程中，会存在多个Paxos Instance，同时，Chubby会为每个Paxos Instance都按序分配一个全局唯一的Instance编号，并将其顺序写入到事务日志中去。</span><br><span class="line"></span><br><span class="line">　　在Paxos中，每一个Paxos Instance都需要进行一轮或多轮的Prepare-&gt;Promise-&gt;Propose-&gt;Accept这样完整的二阶段请求过程来完成对一个提议值的选定，为了保证正确性的前提下尽可能地提高算法运行性能，可以让多个Instance共用一套序号分配机制，并将Prepare-&gt;Promise合并为一个阶段。具体做法如下：</span><br><span class="line"></span><br><span class="line">　　① 当某个副本节点通过选举成为Master后，就会使用新分配的编号N来广播一个Prepare消息，该Prepare消息会被所有未达成一致的Instance和目前还未开始的Instance共用。</span><br><span class="line"></span><br><span class="line">　　② 当Acceptor接收到Prepare消息后，必须对多个Instance同时做出回应，这通常可以通过将反馈信息封装在一个数据包中来实现，假设最多允许K个Instance同时进行提议值的选定，那么：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>当前之多存在K个未达成一致的Instance，将这些未决的Instance各自最后接受的提议值封装进一个数据包，并作为Promise消息返回。</span><br><span class="line"><span class="bullet">- </span>同时，判断N是否大于当前Acceptor的highestPromisedNum值（当前已经接受的最大的提议编号值），如果大于，那么就标记这些未决Instance和所有未来的Instance的highestPromisedNum的值为N，这样，这些未决Instance和所有未来Instance都不能再接受任何编号小于N的提议。</span><br><span class="line"></span><br><span class="line">　　③ Master对所有未决Instance和所有未来Instance分别执行Propose-&gt;Accept阶段的处理，如果Master能够一直稳定运行的话，那么在接下来的算法运行过程中，就不再需要进行Prepare-&gt;Promise处理了。但是，一旦Master发现Acceptor返回了一个Reject消息，说明集群中存在另一个Master并且试图使用更大的提议编号发送了Prepare消息，此时，当前Master就需要重新分配新的提议编号并再次进行Prepare-&gt;Promise阶段的处理。</span><br><span class="line"></span><br><span class="line">　　可见chubby就是一个典型的Muti-Paxos算法应用，在Master稳定运行的情况下，只需要使用同一个编号来依次执行每一个Instance的Promise-&gt;Accept阶段处理。</span><br><span class="line"></span><br><span class="line"><span class="section">### sentinel，了解多少说多少？</span></span><br><span class="line">Sentinel 是阿里中间件团队开源的，面向分布式服务架构的轻量级高可用流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。</span><br><span class="line"></span><br><span class="line">Sentinel 和之前常用的熔断降级库 Netflix Hystrix 有什么异同呢？Sentinel官网有一个对比的文章，这里摘抄一个总结的表格</span><br><span class="line"></span><br><span class="line">对比内容 | Sentinel | Hystrix</span><br><span class="line">---|--- |---</span><br><span class="line">隔离策略	 | 信号量隔离 | 线程池隔离/信号量隔离</span><br><span class="line">熔断降级策略	 | 基于响应时间或失败比率 | 基于失败比率</span><br><span class="line">实时指标实现	 | 滑动窗口 | 滑动窗口（基于 RxJava）</span><br><span class="line">规则配置	 | 支持多种数据源 | 支持多种数据源</span><br><span class="line">扩展性	 | 多个扩展点 | 插件的形式</span><br><span class="line">基于注解的支持	 | 支持 | 支持</span><br><span class="line">限流	 | 基于 QPS，支持基于调用关系的限流 | 不支持</span><br><span class="line">流量整形	 | 支持慢启动、匀速器模式 | 不支持</span><br><span class="line">系统负载保护	 | 支持 | 不支持</span><br><span class="line">控制台	 | 开箱即用，可配置规则、查看秒级监控、机器发现等 | 不完善</span><br><span class="line">常见框架的适配	 | Servlet、Spring Cloud、Dubbo、gRPC 等 | Servlet、Spring Cloud Netflix</span><br><span class="line"></span><br><span class="line"><span class="section">#### 原理解析</span></span><br><span class="line">感兴趣的可以看这篇[<span class="string">文章</span>](<span class="link">https://mp.weixin.qq.com/s/g2hyp9CquEAvTe8QmPO-3g/</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">### Spring Cloud Alibaba，了解多少说多少？</span></span><br><span class="line">Spring Cloud 是基于 Spring Boot 设计的一套微服务规范，并增强了应用上下文。Spring Cloud Alibaba 采用阿里中间件作为基础，实现了 Spring Cloud 的微服务规范。</span><br><span class="line"></span><br><span class="line"><span class="section">### 对XA、TCC的理解，了解哪些分布式事务框架，有什么缺点？</span></span><br><span class="line">事务拥有以下四个特性，习惯上被称为 ACID 特性：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</span><br><span class="line"><span class="bullet">- </span>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态是指数据库中的数据应满足完整性约束。除此之外，一致性还有另外一层语义，就是事务的中间状态不能被观察到（这层语义也有说应该属于原子性）。</span><br><span class="line"><span class="bullet">- </span>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行，如同只有这一个操作在被数据库所执行一样。</span><br><span class="line"><span class="bullet">- </span>持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。在事务结束时，此操作将不可逆转。</span><br><span class="line"></span><br><span class="line"><span class="section">#### 常见分布式事务模型 ACID 实现分析 </span></span><br><span class="line"><span class="section">##### X/Open XA 协议</span></span><br><span class="line">最早的分布式事务模型是 X/Open 国际联盟提出的 X/Open Distributed Transaction Processing（DTP）模型，也就是大家常说的 X/Open XA 协议，简称XA 协议。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG265.png</span>)</span><br><span class="line">DTP 模型中包含一个全局事务管理器（TM，Transaction Manager）和多个资源管理器（RM，Resource Manager）。全局事务管理器负责管理全局事务状态与参与的资源，协同资源一起提交或回滚；资源管理器则负责具体的资源操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">XA 协议描述了 TM 与 RM 之间的接口，允许多个资源在同一分布式事务中访问。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">基于 DTP 模型的分布式事务流程大致如下：</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG266.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>应用程序（AP，Application）向 TM 申请开始一个全局事务。</span><br><span class="line"><span class="bullet">1. </span>针对要操作的 RM，AP 会先向 TM 注册（TM 负责记录 AP 操作过哪些 RM，即分支事务），TM 通过 XA 接口函数通知相应 RM 开启分布式事务的子事务，接着 AP 就可以对该 RM 管理的资源进行操作。</span><br><span class="line"><span class="bullet">1. </span>当 AP 对所有 RM 操作完毕后，AP 根据执行情况通知 TM 提交或回滚该全局事务，TM 通过 XA 接口函数通知各 RM 完成操作。TM 会先要求各个 RM 做预提交，所有 RM 返回成功后，再要求各 RM 做正式提交，XA 协议要求，一旦 RM 预提交成功，则后续的正式提交也必须能成功；如果任意一个 RM 预提交失败，则 TM 通知各 RM 回滚。</span><br><span class="line"><span class="bullet">1. </span>所有 RM 提交或回滚完成后，全局事务结束。</span><br><span class="line"></span><br><span class="line"><span class="section">###### 原子性</span></span><br><span class="line">XA 协议使用 2PC（Two Phase Commit，两阶段提交）原子提交协议来保证分布式事务原子性。</span><br><span class="line"></span><br><span class="line">两阶段提交是指将提交过程分为两个阶段，即准备阶段（投票阶段）和提交阶段（执行阶段）：</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG267.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>准备阶段</span><br><span class="line"></span><br><span class="line">TM 向每个 RM 发送准备消息。如果 RM 的本地事务操作执行成功，则返回成功；如果 RM 的本地事务操作执行失败，则返回失败。</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>提交阶段</span><br><span class="line"></span><br><span class="line">如果 TM 收到了所有 RM 回复的成功消息，则向每个 RM 发送提交消息；否则发送回滚消息；RM 根据 TM 的指令执行提交或者回滚本地事务操作，释放所有事务处理过程中使用的锁资源。</span><br><span class="line"></span><br><span class="line"><span class="section">###### 隔离性</span></span><br><span class="line">XA 协议中没有描述如何实现分布式事务的隔离性，但是 XA 协议要求DTP 模型中的每个 RM 都要实现本地事务，也就是说，基于 XA 协议实现的分布式事务的隔离性是由每个 RM 本地事务的隔离性来保证的，当一个分布式事务的所有子事务都是隔离的，那么这个分布式事务天然的就实现了隔离性。</span><br><span class="line"></span><br><span class="line">以 MySQL 来举例，MySQL 使用 2PL（Two-Phase Locking，两阶段锁）机制来控制本地事务的并发，保证隔离性。2PL 与 2PC 类似，也是将锁操作分为加锁和解锁两个阶段，并且保证两个阶段完全不相交。加锁阶段，只加锁，不放锁。解锁阶段，只放锁，不加锁。</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG268.png</span>)</span><br><span class="line">如上图所示，在一个本地事务中，每执行一条更新操作之前，都会先获取对应的锁资源，只有获取锁资源成功才会执行该操作，并且一旦获取了锁资源就会持有该锁资源直到本事务执行结束。</span><br><span class="line"></span><br><span class="line">MySQL 通过这种 2PL 机制，可以保证在本地事务执行过程中，其他并发事务不能操作相同资源，从而实现了事务隔离。</span><br><span class="line"></span><br><span class="line"><span class="section">###### 一致性</span></span><br><span class="line">前面提到一致性有两层语义，一层是确保事务执行结束后，数据库从一个一致状态转变为另一个一致状态。另一层语义是事务执行过程中的中间状态不能被观察到。</span><br><span class="line"></span><br><span class="line">前一层语义的实现很简单，通过原子性、隔离性以及 RM 自身一致性的实现就可以保证。至于后一层语义，我们先来看看单个 RM 上的本地事务是怎么实现的。还是以 MySQL 举例，MySQL 通过 MVCC（Multi Version Concurrency Control，多版本并发控制）机制，为每个一致性状态生成快照（Snapshot），每个事务看到的都是各Snapshot对应的一致性状态，从而也就保证了本地事务的中间状态不会被观察到。</span><br><span class="line"></span><br><span class="line">虽然单个 RM 上实现了Snapshot，但是在分布式应用架构下，会遇到什么问题呢？</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG269.png</span>)</span><br><span class="line">如上图所示，在 RM1 的本地子事务提交完毕到 RM2 的本地子事务提交完毕之间，只能读到 RM1 上子事务执行的内容，读不到 RM2 上的子事务。也就是说，虽然在单个 RM 上的本地事务是一致的，但是从全局来看，一个全局事务执行过程的中间状态被观察到了，全局一致性就被破坏了。</span><br><span class="line"></span><br><span class="line">XA 协议并没有定义怎么实现全局的 Snapshot，像 MySQL 官方文档里就建议使用串行化的隔离级别来保证分布式事务一致性：</span><br><span class="line"></span><br><span class="line">“As with nondistributed transactions, SERIALIZABLE may be preferred if your applications are sensitive to read phenomena. REPEATABLE READ may not be sufficient for distributed transactions.”（对于分布式事务来说，可重复读隔离级别不足以保证事务一致性，如果你的程序有全局一致性读要求，可以考虑串行化隔离级别.）</span><br><span class="line"></span><br><span class="line">当然，由于串行化隔离级别的性能较差，所以很多分布式数据库都自己实现了分布式 MVCC 机制来提供全局的一致性读。一个基本思路是用一个集中式或者逻辑上单调递增的东西来控制生成全局 Snapshot，每个事务或者每条 SQL 执行时都去获取一次，从而实现不同隔离级别下的一致性。比如 Google 的 Spanner 就是用 TrueTime 来控制访问全局 Snapshot。</span><br><span class="line"></span><br><span class="line"><span class="section">###### 小结</span></span><br><span class="line">XA 协议通常实现在数据库资源层，直接作用于资源管理器上。因此，基于 XA 协议实现的分布式事务产品，无论是分布式数据库，还是分布式事务框架，对业务几乎都没有侵入，就像使用普通数据库一样。</span><br><span class="line"></span><br><span class="line">XA 协议严格保障事务 ACID 特性，能够满足所有业务领域的功能需求，但是，这同样是一把双刃剑。</span><br><span class="line"></span><br><span class="line">由于隔离性的互斥要求，在事务执行过程中，所有的资源都被锁定，只适用于执行时间确定的短事务。同时，整个事务期间都是独占数据，对于热点数据的并发性能可能会很低，实现了分布式 MVCC 或乐观锁（optimistic locking）以后，性能可能会有所提升。    </span><br><span class="line"></span><br><span class="line">同时，为了保障一致性，要求所有 RM 同等可信、可靠，要求故障恢复机制可靠、快速，在网络故障隔离的情况下，服务基本不可用。</span><br><span class="line"></span><br><span class="line"><span class="section">##### TCC 模型</span></span><br><span class="line">TCC（Try-Confirm-Cancel）分布式事务模型相对于 XA 等传统模型，其特征在于它不依赖资源管理器（RM）对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。</span><br><span class="line"></span><br><span class="line">TCC 模型认为对于业务系统中一个特定的业务逻辑，其对外提供服务时，必须接受一些不确定性，即对业务逻辑初步操作的调用仅是一个临时性操作，调用它的主业务服务保留了后续的取消权。如果主业务服务认为全局事务应该回滚，它会要求取消之前的临时性操作，这就对应从业务服务的取消操作。而当主业务服务认为全局事务应该提交时，它会放弃之前临时性操作的取消权，这对应从业务服务的确认操作。每一个初步操作，最终都会被确认或取消。</span><br><span class="line"></span><br><span class="line">因此，针对一个具体的业务服务，TCC 分布式事务模型需要业务系统提供三段业务逻辑：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>初步操作 Try：完成所有业务检查，预留必须的业务资源。</span><br><span class="line"><span class="bullet">1. </span>确认操作 Confirm：真正执行的业务逻辑，不作任何业务检查，只使用 Try 阶段预留的业务资源。因此，只要 Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一笔分布式事务有且只能成功一次。</span><br><span class="line"><span class="bullet">1. </span>取消操作 Cancel：释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG270.png</span>)</span><br><span class="line">TCC 分布式事务模型包括三部分：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>主业务服务：主业务服务为整个业务活动的发起方，服务的编排者，负责发起并完成整个业务活动。</span><br><span class="line"><span class="bullet">- </span>从业务服务：从业务服务是整个业务活动的参与方，负责提供 TCC 业务操作，实现初步操作（Try）、确认操作（Confirm）、取消操作（Cancel）三个接口，供主业务服务调用。</span><br><span class="line"><span class="bullet">- </span>业务活动管理器：业务活动管理器管理控制整个业务活动，包括记录维护 TCC 全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时调用所有从业务服务的 Confirm 操作，在业务活动取消时调用所有从业务服务的 Cancel 操作。</span><br><span class="line"></span><br><span class="line">一个完整的 TCC 分布式事务流程如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.	</span>主业务服务首先开启本地事务；</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.	</span>主业务服务向业务活动管理器申请启动分布式事务主业务活动；</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.	</span>然后针对要调用的从业务服务，主业务活动先向业务活动管理器注册从业务活动，然后调用从业务服务的 Try 接口；</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.	</span>当所有从业务服务的 Try 接口调用成功，主业务服务提交本地事务；若调用失败，主业务服务回滚本地事务；</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.	</span>若主业务服务提交本地事务，则 TCC 模型分别调用所有从业务服务的 Confirm 接口；若主业务服务回滚本地事务，则分别调用 Cancel 接口；</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.	</span>所有从业务服务的 Confirm 或 Cancel 操作完成后，全局事务结束。</span><br><span class="line"></span><br><span class="line"><span class="section">###### 原子性</span></span><br><span class="line">TCC 模型也使用 2PC 原子提交协议来保证事务原子性。Try 操作对应2PC 的一阶段准备（Prepare）；Confirm 对应 2PC 的二阶段提交（Commit），Cancel 对应 2PC 的二阶段回滚（Rollback），可以说 TCC 就是应用层的 2PC。</span><br><span class="line"></span><br><span class="line"><span class="section">###### 隔离性</span></span><br><span class="line">TCC 分布式事务模型仅提供两阶段原子提交协议，保证分布式事务原子性。事务的隔离交给业务逻辑来实现。</span><br><span class="line"></span><br><span class="line">隔离的本质是控制并发，防止并发事务操作相同资源而引起的结果错乱。</span><br><span class="line"></span><br><span class="line">举个例子，比如金融行业里管理用户资金，当用户发起交易时，一般会先检查用户资金，如果资金充足，则扣除相应交易金额，增加卖家资金，完成交易。如果没有事务隔离，用户同时发起两笔交易，两笔交易的检查都认为资金充足，实际上却只够支付一笔交易，结果两笔交易都支付成功，导致资损。</span><br><span class="line"></span><br><span class="line">可以发现，并发控制是业务逻辑执行正确的保证，但是像两阶段锁这样的并发访问控制技术要求一直持有数据库资源锁直到整个事务执行结束，特别是在分布式事务架构下，要求持有锁到分布式事务第二阶段执行结束，也就是说，分布式事务会加长资源锁的持有时间，导致并发性能进一步下降。</span><br><span class="line"></span><br><span class="line">因此，TCC 模型的隔离性思想就是通过业务的改造，在第一阶段结束之后，从底层数据库资源层面的加锁过渡为上层业务层面的加锁，从而释放底层数据库锁资源，放宽分布式事务锁协议，提高业务并发性能。</span><br><span class="line"></span><br><span class="line">还是以上面的例子举例：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.	</span>第一阶段：检查用户资金，如果资金充足，冻结用户本次交易资金，这笔资金被业务隔离，不允许除本事务之外的其它并发事务动用。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.	</span>第二阶段：扣除第一阶段预冻结的用户资金，增加卖家资金，完成交易。</span><br><span class="line"></span><br><span class="line">采用业务加锁的方式，隔离用户冻结资金，在第一阶段结束后直接释放底层资源锁，该用户和卖家的其他交易都可以立刻并发执行，而不用等到整个分布式事务结束，可以获得更高的并发交易能力。</span><br><span class="line"></span><br><span class="line"><span class="section">###### 一致性</span></span><br><span class="line">再来看看 TCC 分布式事务模型下的一致性实现。与 XA 协议实现一致性第一层语义类似，通过原子性保证事务的原子提交、业务隔离性控制事务的并发访问，实现分布式事务的一致性状态转变。</span><br><span class="line"></span><br><span class="line">至于第二层语义：事务的中间状态不能被观察到。我们来看看，在 SOA分布式应用环境下是否是必须的。</span><br><span class="line"></span><br><span class="line">还是以账务服务举例。转账业务（用户 A  -&gt; 用户 B），由交易服务和账务服务组成分布式事务，交易服务作为主业务服务，账务服务作为从业务服务，账务服务的 Try 操作预冻结用户 A 的资金；Commit 操作扣除用户 A 的预冻结资金，增加用户 B 的可用资金；Cancel 操作解冻用户 A 的预冻结资金。</span><br><span class="line"></span><br><span class="line">当账务服务执行完 Try 阶段后，交易主业务就可以 Commit 了，然后由TCC 框架调用账务的 Commit 阶段。在账务 Commit 阶段还没执行结束的时候，用户 A 可以查询到自己的余额已扣除，但是，此时用户 B 的可用资金还没增加。</span><br><span class="line"></span><br><span class="line">从系统的角度来看，确实有问题与不确定性。在第一阶段执行结束到第二阶段执行结束之间，有一段时间的延时，在这段时间内，看似任何用户都不享有这笔资产。</span><br><span class="line"></span><br><span class="line">但是，从用户的角度来考虑这个问题的话，这个时间间隔可能就无所谓或者根本就不存在。特别是当这个时间间隔仅仅是几秒钟，对于具体沟通资产转移的用户来讲，这个过程是隐蔽的或确实可以接受的，且保证了结果的最终一致性。</span><br><span class="line"></span><br><span class="line">当然，对于这样的系统，如果确实需要查看系统的某个一致性状态，可以采用额外的方法实现。</span><br><span class="line"></span><br><span class="line">一般来讲，服务之间的一致性比服务内部的一致性要更加容易弱化，这也是为什么 XA 等直接在资源层面上实现通用分布式事务的模型会注重一致性的保证，而当上升到服务层面，服务与服务之间已经实现了功能的划分，逻辑的解耦，也就更容易弱化一致性，这就是 SOA 架构下 BASE 理论的最终一致性思想。</span><br><span class="line"></span><br><span class="line">BASE 理论是指 BA（Basic Availability，基本业务可用性）；S（Soft state，柔性状态）；E（Eventual consistency，最终一致性）。该理论认为为了可用性、性能与降级服务的需要，可以适当降低一点一致性的要求，即“基本可用，最终一致”。</span><br><span class="line"></span><br><span class="line">业内通常把严格遵循 ACID 的事务称为刚性事务；而基于 BASE 思想实现的事务称为柔性事务。柔性事务并不是完全放弃了 ACID，仅仅是放宽了一致性要求：事务完成后的一致性严格遵循，事务中的一致性可适当放宽。</span><br><span class="line"></span><br><span class="line"><span class="section">###### 小结</span></span><br><span class="line">TCC 分布式事务模型的业务实现特性决定了其可以跨 DB、跨服务实现资源管理，将对不同的 DB 访问、不同的业务操作通过 TCC 模型协调为一个原子操作，解决了分布式应用架构场景下的事务问题。</span><br><span class="line"></span><br><span class="line">TCC 模型通过 2PC 原子提交协议保证分布式事务的的原子性，把资源层的隔离性上升到业务层，交给业务逻辑来实现。TCC 的每个操作对于资源层来说，就是单个本地事务的使用，操作结束则本地事务结束，规避了资源层在 2PC 和 2PL 下对资源占用导致的性能低下问题。</span><br><span class="line"></span><br><span class="line">同时，TCC 模型也可以根据业务需要，做一些定制化的功能，比如交易异步化实现削峰填谷等。</span><br><span class="line"></span><br><span class="line">但是，业务接入 TCC 模型需要拆分业务逻辑成两个阶段，并实现 Try、Confirm、Cancel 三个接口，定制化程度高，开发成本高。</span><br><span class="line"></span><br><span class="line"><span class="section">#### 总结</span></span><br><span class="line">本文首先介绍了典型的分布式事务的架构场景。分布式事务刚开始是为解决单服务多数据库资源的场景而诞生的。随着技术的发展，特别是 SOA 分布式应用架构以及微服务时代的到来，服务变成了基本业务单元。因此，又产生了跨服务的分布式事务需求。</span><br><span class="line"></span><br><span class="line">然后从 XA 和 TCC 两种常用的分布式事务模型入手，介绍了其实现机制，着重分析了各模型是如何实现分布式事务 ACID 特性的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">## 相关工具使用</span></span><br><span class="line"><span class="section">### Redis</span></span><br><span class="line"><span class="section">#### Redis 中有几种类型 &amp; 各自底层怎么实现的 &amp; 项目中哪个地方用了什么类型，怎么使用的？</span></span><br><span class="line"></span><br><span class="line">[<span class="string">redis底层原理</span>](<span class="link">https://blog.csdn.net/wcf373722432/article/details/78678504</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</span><br><span class="line"><span class="bullet">- </span>使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。</span><br><span class="line"></span><br><span class="line">1 单线程模型</span><br><span class="line"></span><br><span class="line">Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。</span><br><span class="line"></span><br><span class="line">2 单线程模型每秒万级别处理能力的原因</span><br><span class="line"></span><br><span class="line">（1）纯内存访问。数据存放在内存中，内存的响应时间大约是100纳秒，这是Redis每秒万亿级别访问的重要基础。</span><br><span class="line"></span><br><span class="line">（2）非阻塞I/O，Redis采用epoll做为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I/O上浪费过多的时间。</span><br><span class="line"></span><br><span class="line">（3）单线程避免了线程切换和竞态产生的消耗。</span><br><span class="line"></span><br><span class="line">（4）Redis采用单线程模型，每条命令执行如果占用大量时间，会造成其他线程阻塞，对于Redis这种高性能服务是致命的，所以Redis是面向高速执行的数据库。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 字符串string</span></span><br><span class="line">字符串类型是Redis中最为基础的数据存储类型，是一个由字节组成的序列，他在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据货Json对象描述信息等，是标准的key-value，一般来存字符串，整数和浮点数。Value最多可以容纳的数据长度为512MB</span><br><span class="line">应用场景：很常见的场景用于统计网站访问数量，当前在线人数等。incr命令(++操作)</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1267939-20171218173355068-1009075048.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##### 列表list</span></span><br><span class="line">Redis的列表允许用户从序列的两端推入或者弹出元素，列表由多个字符串值组成的有序可重复的序列，是链表结构，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。List中可以包含的最大元素数量是4294967295。</span><br><span class="line">应用场景：1.最新消息排行榜。2.消息队列，以完成多程序之间的消息交换。可以用push操作将任务存在list中（生产者），然后线程在用pop操作将任务取出进行执行。（消费者）</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1267939-20171218173319896-1986145136.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##### 散列hash</span></span><br><span class="line">Redis中的散列可以看成具有String key和String value的map容器，可以将多个key-value存储到一个key中。每一个Hash可以存储4294967295个键值对。</span><br><span class="line">应用场景：例如存储、读取、修改用户属性（name，age，pwd等）</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1267939-20171218173425803-1568128972.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##### 集合set</span></span><br><span class="line">Redis的集合是无序不可重复的，和列表一样，在执行插入和删除和判断是否存在某元素时，效率是很高的。集合最大的优势在于可以进行交集并集差集操作。Set可包含的最大元素数量是4294967295。</span><br><span class="line">应用场景：1.利用交集求共同好友。2.利用唯一性，可以统计访问网站的所有独立IP。3.好友推荐的时候根据tag求交集，大于某个threshold（临界值的）就可以推荐。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1267939-20171218173450459-219862735.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##### 有序集合sorted set</span></span><br><span class="line">和set很像，都是字符串的集合，都不允许重复的成员出现在一个set中。他们之间差别在于有序集合中每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。尽管有序集合中的成员必须是卫衣的，但是分数(score)却可以重复。</span><br><span class="line">应用场景：可以用于一个大型在线游戏的积分排行榜，每当玩家的分数发生变化时，可以执行zadd更新玩家分数(score)，此后在通过zrange获取几分top ten的用户信息。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1267939-20171218173530318-1825724249.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##### key的通用操作</span></span><br><span class="line">所有的数据类型都可以使用的</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1267939-20171218173804350-2060665680.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">#### Redis如何实现分布式锁，zk如何实现分布式锁，两者的区别。如果service还没执行完，分布式锁在Redis中已经过期了，怎么解决这种问题？</span></span><br><span class="line"></span><br><span class="line">解决redis分布式锁过期时间到了业务没执行完问题</span><br><span class="line"></span><br><span class="line">很多同学在用分布式锁时,都是直接百度搜索找一个Redis分布式锁工具类就直接用了，其实Redis分布式锁比较正确的姿势是采用redisson这个客户端工具</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190311091746328.jpg</span>)</span><br><span class="line"></span><br><span class="line">默认情况下,加锁的时间是30秒.如果加锁的业务没有执行完,那么到 30-10 = 20秒的时候,就会进行一次续期,把锁重置成30秒.那这个时候可能又有同学问了,那业务的机器万一宕机了呢?宕机了定时任务跑不了,就续不了期,那自然30秒之后锁就解开了呗。</span><br><span class="line"></span><br><span class="line"><span class="section">##### Redisson分布式锁的底层原理 </span></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190328230407942.jpg</span>)</span><br><span class="line"></span><br><span class="line">1）加锁机制</span><br><span class="line"></span><br><span class="line">咱们来看上面那张图，现在某个客户端要加锁。如果该客户端面对的是一个redis cluster集群，他首先会根据hash节点选择一台机器。</span><br><span class="line"></span><br><span class="line">这里注意，仅仅只是选择一台机器！这点很关键！</span><br><span class="line"></span><br><span class="line">紧接着，就会发送一段lua脚本到redis上，那段lua脚本如下所示：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190328230720469.jpg</span>)</span><br><span class="line"></span><br><span class="line">为啥要用lua脚本呢？</span><br><span class="line"></span><br><span class="line">因为一大坨复杂的业务逻辑，可以通过封装在lua脚本中发送给redis，保证这段复杂业务逻辑执行的原子性。</span><br><span class="line"></span><br><span class="line">那么，这段lua脚本是什么意思呢？</span><br><span class="line"></span><br><span class="line">KEYS[1]代表的是你加锁的那个key，比如说：</span><br></pre></td></tr></table></figure>
<p>RLock lock = redisson.getLock(“myLock”);<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里你自己设置了加锁的那个锁key就是“myLock”。</span><br><span class="line"></span><br><span class="line">ARGV[<span class="number">1</span>]代表的就是锁key的默认生存时间，默认<span class="number">30</span>秒。</span><br><span class="line"></span><br><span class="line">ARGV[<span class="number">2</span>]代表的是加锁的客户端的ID，类似于下面这样：</span><br><span class="line"></span><br><span class="line">``<span class="number">8743</span>c9c0<span class="number">-0795</span><span class="number">-4907</span><span class="number">-87</span>fd<span class="number">-6</span>c719a6b4586:<span class="number">1</span>``</span><br><span class="line"></span><br><span class="line">给大家解释一下，第一段<span class="keyword">if</span>判断语句，就是用“exists myLock”命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。</span><br><span class="line"></span><br><span class="line">如何加锁呢？很简单，用下面的命令：</span><br></pre></td></tr></table></figure></p>
<p>hset myLock<br>8743c9c0-0795-4907-87fd-6c719a6b4586:1 1<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通过这个命令设置一个hash数据结构，这行命令执行后，会出现一个类似下面的数据结构：</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190328230756937.jpg</span>)</span><br><span class="line"></span><br><span class="line">上述就代表“8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端对“myLock”这个锁key完成了加锁。</span><br><span class="line"></span><br><span class="line">接着会执行“pexpire myLock 30000”命令，设置myLock这个锁key的生存时间是30秒。</span><br><span class="line"></span><br><span class="line">好了，到此为止，ok，加锁完成了。</span><br><span class="line"></span><br><span class="line">（2）锁互斥机制</span><br><span class="line"></span><br><span class="line">那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？</span><br><span class="line"></span><br><span class="line">很简单，第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在了。</span><br><span class="line"></span><br><span class="line">接着第二个if判断，判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。</span><br><span class="line"></span><br><span class="line">所以，客户端2会获取到pttl myLock返回的一个数字，这个数字代表了myLock这个锁key的剩余生存时间。比如还剩15000毫秒的生存时间。</span><br><span class="line"></span><br><span class="line">此时客户端2会进入一个while循环，不停的尝试加锁。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">（3）watch dog自动延期机制</span><br><span class="line"></span><br><span class="line">客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</span><br><span class="line"></span><br><span class="line">简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">（4）可重入加锁机制</span><br><span class="line"></span><br><span class="line">那如果客户端1都已经持有了这把锁了，结果可重入的加锁会怎么样呢？</span><br><span class="line"></span><br><span class="line">比如下面这种代码：</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190328231154539.png</span>)</span><br><span class="line"></span><br><span class="line">这时我们来分析一下上面那段lua脚本。</span><br><span class="line"></span><br><span class="line">第一个if判断肯定不成立，“exists myLock”会显示锁key已经存在了。</span><br><span class="line"></span><br><span class="line">第二个if判断会成立，因为myLock的hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是<span class="code">``8743c9c0-0795-4907-87fd-6c719a6b4586:1`</span>`</span><br><span class="line"></span><br><span class="line">此时就会执行可重入加锁的逻辑，他会用：</span><br></pre></td></tr></table></figure></p>
<p>incrby myLock </p>
<p> 8743c9c0-0795-4907-87fd-6c71a6b4586:1 1<br> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通过这个命令，对客户端1的加锁次数，累加1。</span><br><span class="line"></span><br><span class="line">此时myLock数据结构变为下面这样：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190328231220198.jpg</span>)</span><br><span class="line">（5）释放锁机制</span><br><span class="line"></span><br><span class="line">如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。</span><br><span class="line"></span><br><span class="line">其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。</span><br><span class="line"></span><br><span class="line">如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：</span><br><span class="line"></span><br><span class="line">“del myLock”命令，从redis里删除这个key。</span><br><span class="line"></span><br><span class="line">然后呢，另外的客户端2就可以尝试完成加锁了。</span><br><span class="line"></span><br><span class="line">这就是所谓的分布式锁的开源Redisson框架的实现机制。</span><br><span class="line"></span><br><span class="line">一般我们在生产系统中，可以用Redisson框架提供的这个类库来基于redis进行分布式锁的加锁与释放锁。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">（6）上述Redis分布式锁的缺点</span><br><span class="line"></span><br><span class="line">其实上面那种方案最大的问题，就是如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master slave实例。</span><br><span class="line"></span><br><span class="line">但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。</span><br><span class="line"></span><br><span class="line">接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。</span><br><span class="line"></span><br><span class="line">此时就会导致多个客户端对一个分布式锁完成了加锁。</span><br><span class="line"></span><br><span class="line">这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">所以这个就是redis cluster，或者是redis master-slave架构的主从异步复制导致的redis分布式锁的最大缺陷：在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。</span><br><span class="line"></span><br><span class="line"><span class="section">#### Ehcache支持哪些缓存？</span></span><br><span class="line"><span class="section">##### Ehcache</span></span><br><span class="line">EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。Ehcache是一种广泛使用的开源Java分布式缓存。</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"><span class="bullet">- </span>快速</span><br><span class="line"><span class="bullet">- </span>简单</span><br><span class="line"><span class="bullet">- </span>缓存数据有两级：内存和磁盘，因此无需担心容量问题</span><br><span class="line"><span class="bullet">- </span>缓存数据会在虚拟机重启的过程中写入磁盘</span><br><span class="line"><span class="bullet">- </span>可以通过RMI、可插入API等方式进行分布式缓存</span><br><span class="line"><span class="bullet">- </span>具有缓存和缓存管理器的侦听接口</span><br><span class="line"><span class="bullet">- </span>支持多缓存管理器实例，以及一个实例的多个缓存区域</span><br><span class="line"><span class="bullet">- </span>提供Hibernate的缓存实现</span><br><span class="line"><span class="bullet">- </span>多种缓存策略，Ehcache提供了对大数据的内存和硬盘的存储，最近版本允许多实例、保存对象高灵活性、提供LRU、LFU、FIFO淘汰算法，基础属性支持热配置、支持的插件多</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"><span class="bullet">- </span>使用磁盘Cache的时候非常占用磁盘空间；</span><br><span class="line"><span class="bullet">- </span>不能保证数据的安全</span><br><span class="line"></span><br><span class="line"><span class="section">##### memcache</span></span><br><span class="line">memcache 是一种高性能、分布式对象缓存系统，最初设计于缓解动态网站数据库加载数据的延迟性，你可以把它想象成一个大的内存HashTable，就是一个key-value键值缓存。</span><br><span class="line"></span><br><span class="line">memcache C语言所编写，依赖于最近版本的GCC和libevent。多线程支持</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line">一.部分容灾</span><br><span class="line"></span><br><span class="line">假设只用一台memcache，如果这台memcache服务器挂掉了，那么请求将不断的冲击数据库，这样有可能搞死数据库，从而引发”雪崩“。如果使用多台memcache服务器，由于memcache使用一致性哈希算法，万一其中一台挂掉了，部分请求还是可以在memcache中命中，为修复系统赢得一些时间。</span><br><span class="line"></span><br><span class="line">二.容量问题</span><br><span class="line"></span><br><span class="line">一台memcache服务器的容量毕竟有限，可以使用多台memcache服务器，增加缓存容量。</span><br><span class="line"></span><br><span class="line">三.均衡请求</span><br><span class="line"></span><br><span class="line">使用多台memcache服务器，可以均衡请求，避免所有请求都冲进一台memcache服务器，导致服务器挂掉。</span><br><span class="line"></span><br><span class="line">四.利用memcache分布式特性</span><br><span class="line"></span><br><span class="line">使用一台memcache服务器，并没有利用memcache的数据分布式特性。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>不能持久化存储</span><br><span class="line"><span class="bullet">- </span>存储数据有限制：1M 【大于1M，认为就行分割】（内存碎片）</span><br><span class="line"><span class="bullet">- </span>mm存储数据只能key-value</span><br><span class="line"><span class="bullet">- </span>集群数据没有复制和同步机制 【崩溃不会影响程序，会从数据库中取数据】</span><br><span class="line"><span class="bullet">- </span>内存回收不能及时 LRU(算法)：未使用内存》过期内存》最近最少使用内存 这是惰性删除</span><br><span class="line"></span><br><span class="line"><span class="section">##### redis</span></span><br><span class="line">单线程、读写性能优异、支持数据持久化，支持AOF和RDB两种持久化方式、支持主从复制，主机会自动将数据同步到从机，可以进行读写分离；数据结构丰富：除了支持string类型的value外还支持string、hash、set、sortedset、list等数据结构。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">1 Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</span><br><span class="line"></span><br><span class="line">2 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</span><br><span class="line"></span><br><span class="line">3 Redis的主从复制采用全量复制，复制过程中主机会fork出一个子进程对内存做一份快照，并将子进程的内存快照保存为文件发送给从机，这一过程需要确保主机有足够多的空余内存。若快照文件较大，对集群的服务能力会产生较大的影响，而且复制过程是在从机新加入集群或者从机和主机网络断开重连时都会进行，也就是网络波动都会造成主机和从机间的一次全量的数据复制，这对实际的系统运营造成了不小的麻烦。</span><br><span class="line"></span><br><span class="line">4 Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</span><br><span class="line"></span><br><span class="line">ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。</span><br><span class="line">redis是通过socket访问到缓存服务，效率比ecache低，比数据库要快很多，处理集群和分布式缓存方便，有成熟的方案。</span><br><span class="line">如果是单个应用或者对缓存访问要求很高的应用，用ehcache。</span><br><span class="line">如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。</span><br><span class="line"></span><br><span class="line"><span class="section">#### Redis是单线程的还是多线程的，为什么这么快？</span></span><br><span class="line">Redis是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。</span><br><span class="line"></span><br><span class="line">它支持多种类型的数据结构，如字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。</span><br><span class="line"></span><br><span class="line">Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。</span><br><span class="line"></span><br><span class="line">Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。</span><br><span class="line"></span><br><span class="line">Redis不使用表，他的数据库不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。</span><br><span class="line"></span><br><span class="line">数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。</span><br><span class="line"></span><br><span class="line">（1）硬盘数据库的工作模式：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20170307142145648.png</span>)</span><br><span class="line">（2）内存数据库的工作模式：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20170307142210929.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##### Redis为什么这么快</span></span><br><span class="line">1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</span><br><span class="line"></span><br><span class="line">2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</span><br><span class="line"></span><br><span class="line">3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</span><br><span class="line"></span><br><span class="line">4、使用多路I/O复用模型，非阻塞IO；</span><br><span class="line"></span><br><span class="line">5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</span><br><span class="line"></span><br><span class="line">以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：</span><br><span class="line"></span><br><span class="line">（1）多路 I/O 复用模型</span><br><span class="line"></span><br><span class="line">多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</span><br><span class="line"></span><br><span class="line">这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 那么为什么Redis是单线程的</span></span><br><span class="line">我们首先要明白，上边的种种分析，都是为了营造一个Redis很快的氛围！官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</span><br><span class="line"></span><br><span class="line">看到这里，你可能会气哭！本以为会有什么重大的技术要点才使得Redis使用单线程就可以这么快，没想到就是一句官方看似糊弄我们的回答！但是，我们已经可以很清楚的解释了为什么Redis这么快，并且正是由于在单线程模式的情况下已经很快了，就没有必要在使用多线程了！</span><br><span class="line"></span><br><span class="line">但是，我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善！</span><br><span class="line"></span><br><span class="line">警告1：这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行（具体是子线程还是子进程待读者深入研究）；例如我在测试服务器上查看Redis进程，然后找到该进程下的线程：</span><br><span class="line"></span><br><span class="line"><span class="section">#### Redis Hash中某个key过大，变为String类型的大key，怎么处理，使用中如何避免出现这种问题?</span></span><br><span class="line">由于redis是单线程运行的，如果一次操作的value很大会对整个redis的响应时间造成负面影响，所以，业务上能拆则拆，下面举几个典型的分拆方案。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 单个简单的key存储的value很大</span></span><br><span class="line">1.1、 改对象需要每次都整存整取</span><br><span class="line">可以尝试将对象分拆成几个key-value， 使用multiGet获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响； </span><br><span class="line"></span><br><span class="line">1.2、该对象每次只需要存取部分数据</span><br><span class="line">可以像第一种做法一样，分拆成几个key-value， 也可以将这个存储在一个hash中，每个field代表一个具体的属性，使用hget,hmget来获取部分的value，使用hset，hmset来更新部分属性 </span><br><span class="line"></span><br><span class="line"><span class="section">#####  hash， set，zset，list 中存储过多的元素</span></span><br><span class="line">类似于场景一种的第一个做法，可以将这些元素分拆。</span><br><span class="line"></span><br><span class="line">以hash为例，原先的正常存取流程是 <span class="code">``hget(hashKey, field)`</span><span class="code">` ; `</span><span class="code">`hset(hashKey, field, value)`</span>`</span><br><span class="line">现在，固定一个桶的数量，比如 10000， 每次存取的时候，先在本地计算field的hash值，模除 10000， 确定了该field落在哪个key上。</span><br></pre></td></tr></table></figure></p>
<p>newHashKey  =  hashKey + (<em>hash</em>(field) % 10000）;<br>hset (newHashKey, field, value) ;<br>hget(newHashKey, field)<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">set, zset, list 也可以类似上述做法.</span><br><span class="line"></span><br><span class="line">但有些不适合的场景，比如，要保证 lpop 的数据的确是最早push到list中去的，这个就需要一些附加的属性，或者是在 key的拼接上做一些工作（比如list按照时间来分拆）。</span><br><span class="line"></span><br><span class="line">#### 哨兵机制、Redis两种备份方式的区别，项目中用的哪种，为什么？</span><br><span class="line">##### 持久化机制</span><br><span class="line">　为了解决一旦断电或者宕机，内存数据库中的数据将会全部丢失这个缺点，Redis提供了将内存数据持久化到硬盘，以及用持久化文件来恢复数据的功能。Redis 支持两种形式的持久化，一种是RDB快照（snapshotting），另外一种是AOF（append-only-file）。</span><br><span class="line">　</span><br><span class="line">　（<span class="number">1</span>）RDB是把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里，RDB持久化有两种触发机制，分别是自动触发和手动触发。在redis.windows.conf(linux就是redis.conf)文件的SNAPSHOTTING 下有个自动触发rdb持久化的策略：</span><br><span class="line">　</span><br><span class="line">　![image](https:<span class="comment">//minios.strongsickcat.com/dinghuang-blog-picture/20190712111253693.png)</span></span><br><span class="line">　其中分别表示<span class="number">900</span>s内，如果至少有一个key值变化，则保存到rdb；<span class="number">300</span>s内，至少有<span class="number">10</span>个key变化就保存；<span class="number">60</span>s内至少有<span class="number">10000</span>个key变化就保存。如果只需要redis的缓存功能那么就可以关掉rdb持久化，使用空串停用，如：save “”“”。</span><br><span class="line"></span><br><span class="line">在这个配置下面还有几个关于rdb持久化的配置：</span><br><span class="line"></span><br><span class="line">- ``stop-writes-on-bgsave-error yes``：默认yes，表示在后台通过rdb保存数据失败之后是否停止向redis写入数据（接收数据）。这样可以让用户意识到后台持久化失败了，避免后面数据不能持久化。</span><br><span class="line">- ``rdbcompression yes``：默认yes，表示存储的rdb快照是否进行压缩存储，如果关闭则快照会比较大。</span><br><span class="line">- ``rdbchecksum yes``：默认yes，存储之后是否对数据进行校验，若希望提升redis性能可以关闭。</span><br><span class="line">- ``dbfilename dump.rdb``：存储的rdb快照文件名。</span><br><span class="line">- ``dir ./``：设置快照存放路径，必须是目录，默认和当前配置文件在同一目录。</span><br><span class="line"></span><br><span class="line">手动触发rdb快照保存可以使用save和bgsave命令。save会阻塞当前redis，redis不能处理其他命令直到rdb过程完成，而bgsave会在后台异步进行保存（redis会执行fork操作创建一个子进程），阻塞只会在fork短时间内，redis内部rdb自动保存都是采用bgsave命令。</span><br><span class="line"></span><br><span class="line">将备份文件dump.rdb放到配置文件指定的目录（默认是和redis配置文件同一目录）下，启动redis就会自动将数据加载到内存中。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）AOF 持久化是通过保存Redis服务器所执行的写命令来记录数据库状态。在redis的配置文件中APPEND ONLY MODE的下有关于AOF持久化的相关配置。</span><br><span class="line"></span><br><span class="line">![image](https:<span class="comment">//minios.strongsickcat.com/dinghuang-blog-picture/20190712113151519.png)</span></span><br><span class="line">- ``appendonly``：表示是否开启AOF持久化，因为redis默认的是rdb方式，打开aof需要改为yes。</span><br><span class="line">- ``appendfilename``：aof文件名。</span><br><span class="line">- ``appendsync``：aof持久化策略配置。no表示不执行fsync，有系统保证数据同步到磁盘，速度最快但不安全；always表示每次写入都要执行fsync，以保证数据完全同步到磁盘，效率低；everysec则是每秒保存一次，可能会丢失者<span class="number">1</span>s数据，兼顾安全和效率。</span><br><span class="line">- ``no-appendfsync-on-rewrite``：设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是<span class="number">30</span>秒。可能丢失<span class="number">30</span>秒数据。默认值为no。</span><br><span class="line">- ``auto-aof-rewrite-percentage``：默认值为<span class="number">100</span>。aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。</span><br><span class="line">- ``auto-aof-rewrite-min-size``：<span class="number">64</span>mb。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。</span><br><span class="line">- ``aof-load-truncated``：aof文件可能在尾部是不完整的（宕机或者断电等），如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。默认值为 yes</span><br><span class="line"></span><br><span class="line">AOF文件不完整需要恢复可以使用命令：redis-check-aof --fix 进行修复。aof文件过大的时候也需要重写，和rdb的bgsave模式相似，都是创建子进程，设置重写缓冲区，在重写完成之后再将缓冲区文件写入aof文件。</span><br><span class="line"></span><br><span class="line">###### 总结</span><br><span class="line">AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失 <span class="number">1</span> 秒的数据而已。</span><br><span class="line"></span><br><span class="line">AOF 文件使用 Redis 命令追加的形式来构造，因此，即使 Redis 只能向 AOF 文件写入命令的片断，使用 redis-check-aof 工具也很容易修正 AOF 文件。</span><br><span class="line"></span><br><span class="line">AOF 文件的格式可读性较强，这也为使用者提供了更灵活的处理方式。例如，如果我们不小心错用了 FLUSHALL 命令，在重写还没进行时，我们可以手工将最后的 FLUSHALL 命令去掉，然后再使用 AOF 来恢复数据。</span><br><span class="line"></span><br><span class="line">对于具有相同数据的的 Redis，AOF 文件通常会比 RDB文件体积更大。</span><br><span class="line"></span><br><span class="line">虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。</span><br><span class="line"></span><br><span class="line">RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 方式更健壮。官方文档也指出，AOF 的确也存在一些 BUG，这些 BUG 在 RDB 没有存在。</span><br><span class="line"></span><br><span class="line">##### 主从复制</span><br><span class="line">复制三份配置文件，分别更改端口号，并且配置文件的名字以端口号区分。</span><br><span class="line">![image](https:<span class="comment">//minios.strongsickcat.com/dinghuang-blog-picture/20190712115045340.png)</span></span><br><span class="line">之后再更改每份配置文件：rdb文件名（dbfilename）、log日志文件名（logfile），之后使用下面三个命令启动三个redis服务端。</span><br></pre></td></tr></table></figure></p>
<p>redis-server.exe redis.windows.conf<br>redis-server.exe redis.windows-10087.conf<br>redis-server.exe redis.windows-10088.conf<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">通过info replication查看各个节点信息。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190712133813784.png</span>)</span><br><span class="line">此时都是master节点，接着设置slave节点。使用slaveof命令把10087和10088设为slave。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/2019071213421423.png</span>)</span><br><span class="line">此时设为slave节点之后再使用info replication命令查看就发现role已经变为了slave了。现再在master节点写，在slave读。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/2019071213445880.png</span>)</span><br><span class="line">可以看见现在主从关系已经成功建立了。注：</span><br><span class="line"></span><br><span class="line">（1）如果master以前还存在一些key，那么slave节点也是会有的，因为master会全量复制到slave。</span><br><span class="line"></span><br><span class="line">（2）默认从节点是不能够执行写命令的，配置文件中slave-read-only默认是yes。</span><br><span class="line"></span><br><span class="line">（3）主节点down掉之后，另外两个slave角色依然不变，并且在master恢复之后，仍然是master并且有两个slave节点。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 哨兵模式</span></span><br><span class="line">哨兵模式就是不时地监控redis是否按照预期良好地运行（至少是保证主节点是存在的），若一台主机出现问题时，哨兵会自动将该主机下的某一个从机设置为新的主机，并让其他从机和新主机建立主从关系（如果监控主机发生故障，就根据投票数自动将从库转化为主库）。首先启动多个redis，并配置主从关系，下面再配置哨兵监控master。</span><br><span class="line"></span><br><span class="line">（1）在配置文件目录下面使用touch命令新建sentinel.conf文件，然后配置内容：</span><br><span class="line"></span><br><span class="line">sentinel monitor 被监控主机名（自己起） ip地址 端口 得票数 如<span class="code">``：sentinel monitor my6379 127.0.0.1 6379 1`</span>`。1表示当主机挂掉之后得票数&gt;=1便成为主机。</span><br><span class="line"></span><br><span class="line">（2）启动哨兵监控</span><br><span class="line"></span><br><span class="line">使用命令：<span class="code">``./redis-sentinel /mrliu_project/redis/sentinel.conf`</span><span class="code">` 注：`</span><span class="code">`/mrliu_project/redis/sentinel.conf`</span>` 是配置文件所在目录</span><br><span class="line"></span><br><span class="line">（3）exit退出master主机，之后查看哨兵控制台打印的日志，会发现在重新选择master。</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 在redis稳定版之后，挂掉的主机在选举之后重新连接上，会设置为新选举的msater的从节点。</span></span><br><span class="line"></span><br><span class="line">启动三台带有redis的服务器133，132，130</span><br><span class="line">分别更改redis.conf文件，并指定配置启动redis-server和redis-sentinel</span><br><span class="line"></span><br><span class="line">进入redis的src目录：<span class="code">``./redis-server`</span><span class="code">` `</span><span class="code">`../redis.config`</span><span class="code">` `</span><span class="code">`./redis-sentinel`</span><span class="code">` `</span><span class="code">`../sentinel.conf`</span>`(哨兵配置需要自己touch)</span><br><span class="line"></span><br><span class="line">133启动一个master和哨兵的服务器，</span><br><span class="line"></span><br><span class="line">132启动两个redis服务(两份配置文件)，分别设为133的slave</span><br><span class="line"></span><br><span class="line">130启动一个redis服务，设为133的slave</span><br><span class="line"></span><br><span class="line">redis-config更改了一些目录和端口等，我大概改了如下内容：</span><br></pre></td></tr></table></figure></p>
<p>daemonize yes<br>logfile<br>port </p>
<p> #bind.1 注释掉了<br>protected-mode no //关闭了<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">注意（出现设置了slaveof之后发现主机一直未down可能是如下原因）：</span><br><span class="line"></span><br><span class="line">（1）每个启动的redis服务需要注释掉bind(代表可以访问的主机)，不然其他redis服务器不能感知到该redis服务的存在</span><br><span class="line"></span><br><span class="line"> (2)每个redis服务需要更改protected-mode 为no，</span><br><span class="line"></span><br><span class="line">（3）每台linux服务器需要打开端口，不然直接关闭firewall或者是iptables也行，命令systemctl <span class="keyword">stop</span> firewalld和service iptables <span class="keyword">stop</span>。 永久关闭防火墙使用<span class="keyword">disable</span>。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）建议redis-<span class="keyword">server</span>都配置为守护进程，daemon设为yes即可。</span><br><span class="line"></span><br><span class="line">哨兵需要自建配置文件，在redis的src目录下使用 <span class="string">``</span>./redis-sentinel ../sentinel_liu.conf<span class="string">``</span> 启动，其中后面的是自己的哨兵配置文件，简易配置如下:</span><br></pre></td></tr></table></figure></p>
<p>port 26379</p>
<p>sentinel monitor liu_master 192.168.15.130 6379 1//监控的主机，后面代表超过机票就成为leader<br>sentinel down-after-milliseconds liu_master 10000//可选，多久没心跳就认为down<br>sentinel failover-timeout liu_master 10000//可选，代表每次选举间隔<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line">几台服务器如下:</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190822113301779.png</span>)</span><br><span class="line">之后进入133使用info确认从节点有三个，</span><br><span class="line"></span><br><span class="line">之后查看哨兵启动日志</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190822113645587.png</span>)</span><br><span class="line">注：sdown代表哨兵主观任务下线，（后面是master断开之后的日志）odown是客观下线，当出现odown的时候，哨兵将不会监控该服务，任务确实下线了，然后开始选举。</span><br><span class="line"></span><br><span class="line"><span class="strong">**断开133的master，观察哨兵日志**</span></span><br><span class="line">可以进入133的客户端，使用shutdown关掉，也可以在redis的src目录下使用./redis-cli shutdown关，也可以杀redis进程关。</span><br><span class="line"></span><br><span class="line">哨兵日志如下（我这儿选了这么多次原因是其他机器防火墙开着，所以关了就选举成功了）:</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190822114009994.png</span>)</span><br><span class="line"></span><br><span class="line">出现failover-end即是选举成功了，switch代表切换master到了130服务器节点，随后发现 +fix-slave-config日志，代表将132的6379redis服务和132的6380redis服务设为了130的slave节点，这时候130成为master，132的两个redis服务是slave节点。</span><br><span class="line"></span><br><span class="line"><span class="strong">**重新上线之前断开的133master，查看哨兵日志**</span></span><br><span class="line"></span><br><span class="line">发现新上线的133设为了130redis服务的slave，下面去130服务器登上redis客户端输入info验证</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/2019082211453965.png</span>)</span><br><span class="line"></span><br><span class="line">发现回归后的master变为了新选举的master的slave节点。</span><br><span class="line"></span><br><span class="line"><span class="section">#### 哨兵机制、选举算法</span></span><br><span class="line">Redis Sentinel是一个分布式系统，为Redis提供高可用性解决方案。可以在一个架构中运行多个 Sentinel 进程(progress)， 这些进程使用流言协议(gossip protocols)来 接收关于主服务器是否下线的信息， 并使用投票协议(agreement protocols)来决定是否执行自动故 障迁移， 以及选择哪个从服务器作为新的主服务器。</span><br><span class="line"></span><br><span class="line">Redis 的 Sentinel 系统用于管理多个 Redis 服务器(instance) 该系统执行以下三个任务:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>监控(Monitoring): Sentinel 会不断地定期检查你的主服务器和从服务器是否运作正常。</span><br><span class="line"><span class="bullet">- </span>提醒(Notification): 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</span><br><span class="line"><span class="bullet">- </span>自动故障迁移(Automaticfailover): 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中 一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器; 当客 户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主 服务器代替失效服务器。</span><br><span class="line"></span><br><span class="line"><span class="section">##### Sentinel 工作原理分析</span></span><br><span class="line">（1）哨兵文件详解</span><br><span class="line"></span><br><span class="line"> 配置一：<span class="code">``sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;`</span>`</span><br><span class="line"></span><br><span class="line"> 这个配置表达的是 哨兵节点定期监控 名字叫做 <span class="code">``&lt;master-name&gt;`</span><span class="code">`  并且 IP 为 `</span><span class="code">`&lt;ip&gt;`</span><span class="code">` 端口号为 `</span><span class="code">`&lt;port&gt;`</span><span class="code">` 的主节点。`</span><span class="code">`&lt;quorum&gt;`</span><span class="code">` 表示的是哨兵判断主节点是否发生故障的票数。也就是说如果我们将`</span><span class="code">`&lt;quorum&gt;`</span>`设置为2就代表至少要有两个哨兵认为主节点故障了，才算这个主节点是客观下线的了，一般是设置为sentinel节点数的一半加一。</span><br><span class="line"></span><br><span class="line">配置二：<span class="code">``sentinel down-after-milliseconds &lt;master-name&gt; &lt;times&gt;`</span>`</span><br><span class="line"></span><br><span class="line"> 每个哨兵节点会定期发送ping命令来判断Redis节点和其余的哨兵节点是否是可达的，如果超过了配置的<span class="code">``&lt;times&gt;`</span><span class="code">`时间没有收到pong回复，就主观判断节点是不可达的,`</span><span class="code">`&lt;times&gt;`</span>`的单位为毫秒。</span><br><span class="line"></span><br><span class="line">配置三：<span class="code">``sentinel parallel-syncs &lt;master-name&gt; &lt;nums&gt;`</span>`</span><br><span class="line"></span><br><span class="line"> 当哨兵节点都认为主节点故障时，哨兵投票选出的leader会进行故障转移，选出新的主节点，原来的从节点们会向新的主节点发起复制，这个配置就是控制在故障转移之后，每次可以向新的主节点发起复制的节点的个数，最多为<span class="code">``&lt;nums&gt;`</span>`个，因为如果不加控制会对主节点的网络和磁盘IO资源很大的开销。</span><br><span class="line"></span><br><span class="line">配置四：<span class="code">``sentinel failover-timeout &lt;master-name&gt;  &lt;times&gt;`</span>`</span><br><span class="line"></span><br><span class="line"> 这个代表哨兵进行故障转移时如果超过了配置的<span class="code">``&lt;times&gt;`</span>`时间就表示故障转移超时失败。</span><br><span class="line"></span><br><span class="line">配置五： <span class="code">``sentinel auth-pass &lt;master-name&gt; &lt;password&gt;`</span>`</span><br><span class="line"></span><br><span class="line"> 如果主节点设置了密码，则需要这个配置，否则哨兵无法对主节点进行监控。</span><br><span class="line"> </span><br><span class="line">（2）为什么要用到哨兵</span><br><span class="line"></span><br><span class="line">哨兵(Sentinel)主要是为了解决在主从复制架构中出现宕机的情况,主要分为两种情况:</span><br><span class="line"></span><br><span class="line">1).从Redis宕机</span><br><span class="line"></span><br><span class="line">这个相对而言比较简单,在Redis中从库重新启动后会自动加入到主从架构中,自动完成同步数据。在Redis2.8版本后,主从断线后恢复</span><br><span class="line">的情况下实现增量复制。</span><br><span class="line"></span><br><span class="line">2).主Redis宕机</span><br><span class="line"></span><br><span class="line">这个相对而言就会复杂一些,需要以下2步才能完成</span><br><span class="line"></span><br><span class="line">a. 在从数据库中执行SLAVEOF NO ONE命令,断开主从关系并且提升为主库继续服务</span><br><span class="line"></span><br><span class="line">b. 第二步,将主库重新启动后,执行SLAVEOF命令,将其设置为其他库的从库,这时数据就能更新回来</span><br><span class="line"></span><br><span class="line">由于这个手动完成恢复的过程其实是比较麻烦的并且容易出错,所以Redis提供的哨兵(sentinel)的功能来解决</span><br><span class="line"></span><br><span class="line">（3）哨兵机制（sentinel）的高可用</span><br><span class="line">Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506151546683-1575264043.png</span>)</span><br><span class="line"></span><br><span class="line">在Server1 掉线后：</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506151713821-882289333.png</span>)</span><br><span class="line"></span><br><span class="line">升级Server2 为新的主服务器：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506151845249-976936123.png</span>)</span><br><span class="line"></span><br><span class="line">（4）哨兵的定时监控</span><br><span class="line"></span><br><span class="line">任务1：每个哨兵节点每10秒会向主节点和从节点发送info命令获取最拓扑结构图，哨兵配置时只要配置对主节点的监控即可，通过向主节点发送info，获取从节点的信息，并当有新的从节点加入时可以马上感知到</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506152235025-339114870.png</span>)</span><br><span class="line"></span><br><span class="line">任务2：每个哨兵节点每隔2秒会向redis数据节点的指定频道上发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，同时每个哨兵节点也会订阅该频道，来了解其它哨兵节点的信息及对主节点的判断，其实就是通过消息publish和subscribe来完成的</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506152337815-746306143.png</span>)</span><br><span class="line"></span><br><span class="line">任务3：每隔1秒每个哨兵会向主节点、从节点及其余哨兵节点发送一次ping命令做一次心跳检测，这个也是哨兵用来判断节点是否正常的重要依据</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506152441725-1928086557.png</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">主观下线：所谓主观下线，就是单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。</span><br><span class="line"></span><br><span class="line">sentinel会以每秒一次的频率向所有与其建立了命令连接的实例（master，从服务，其他sentinel）发ping命令，通过判断ping回复是有效回复，还是无效回复来判断实例时候在线（对该sentinel来说是“主观在线”）。</span><br><span class="line"></span><br><span class="line">sentinel配置文件中的down-after-milliseconds设置了判断主观下线的时间长度，如果实例在down-after-milliseconds毫秒内，返回的都是无效回复，那么sentinel回认为该实例已（主观）下线，修改其flags状态为SRI<span class="emphasis">_S_</span>DOWN。如果多个sentinel监视一个服务，有可能存在多个sentinel的down-after-milliseconds配置不同，这个在实际生产中要注意。</span><br><span class="line"></span><br><span class="line">客观下线：当主观下线的节点是主节点时，此时该哨兵3节点会通过指令sentinel is-masterdown-by-addr寻求其它哨兵节点对主节点的判断，如果其他的哨兵也认为主节点主观线下了，则当认为主观下线的票数超过了quorum（选举）个数，此时哨兵节点则认为该主节点确实有问题，这样就客观下线了，大部分哨兵节点都同意下线操作，也就说是客观下线</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506155733210-1331107316.png</span>)</span><br><span class="line"></span><br><span class="line">（5）哨兵lerder选举流程</span><br><span class="line"></span><br><span class="line">如果主节点被判定为客观下线之后，就要选取一个哨兵节点来完成后面的故障转移工作，选举出一个leader的流程如下:</span><br><span class="line"></span><br><span class="line">a)每个在线的哨兵节点都可以成为领导者，当它确认（比如哨兵3）主节点下线时，会向其它哨兵发is-master-down-by-addr命令，征求判断并要求将自己设置为领导者，由领导者处理故障转移；</span><br><span class="line"></span><br><span class="line">b)当其它哨兵收到此命令时，可以同意或者拒绝它成为领导者；</span><br><span class="line"></span><br><span class="line">c)如果哨兵3发现自己在选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举…………</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506155956342-1186812006.png</span>)</span><br><span class="line"></span><br><span class="line">（6）自动故障转移机制</span><br><span class="line"></span><br><span class="line">在从节点中选择新的主节点</span><br><span class="line"></span><br><span class="line">sentinel状态数据结构中保存了主服务的所有从服务信息，领头sentinel按照如下的规则从从服务列表中挑选出新的主服务</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>过滤掉主观下线的节点 </span><br><span class="line"><span class="bullet">- </span>选择slave-priority最高的节点，如果由则返回没有就继续选择</span><br><span class="line"><span class="bullet">- </span>选择出复制偏移量最大的系节点，因为复制便宜量越大则数据复制的越完整，如果由就返回了，没有就继续</span><br><span class="line"><span class="bullet">- </span>选择run_id最小的节点</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506160701394-131033031.png</span>)</span><br><span class="line"></span><br><span class="line">更新主从状态</span><br><span class="line"></span><br><span class="line">通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。</span><br><span class="line"></span><br><span class="line"> 将已下线的主节点设置成新的主节点的从节点，当其回复正常时，复制新的主节点，变成新的主节点的从节点</span><br><span class="line">同理，当已下线的服务重新上线时，sentinel会向其发送slaveof命令，让其成为新主的从</span><br><span class="line"></span><br><span class="line"><span class="section">##### Sentinel获取服务器信息</span></span><br><span class="line">（1） Sentinel获取主服务器信息</span><br><span class="line"></span><br><span class="line">　　　　Sentinel默认会以每10秒一次的频率，通过命令连接向主服务器发送info命令，通过分析info命令的回复来获取主服务器的当前信息，就像在上篇讲到的复制功能，在客户端输入info replication 命令一样，Sentinel可以获取以下两方面的信息：</span><br><span class="line"></span><br><span class="line">　　　　(1) 关于主服务器本身的信息，包括服务器run_id，role的服务器角色。</span><br><span class="line"></span><br><span class="line">　　　　(2) 关于所有从服务器的信息，每个从服务器都由一个slave字符串开头的行记录，记录了从服务器IP和端口(主服务器中有从库的配置信息)。</span><br><span class="line"></span><br><span class="line">（2）Sentinel获取从服务器信息</span><br><span class="line"></span><br><span class="line">　　　　当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构(sentinelRedisInstance)之外，Sentinel还会创建连接到从服务器的命令连接和订阅连接。Sentinel默认会以每10秒一次的频率通过命令连接从服务器发送info命令，通过分析info命令的回复来获取从服务器的当前信息。包括:从服务器运行run<span class="emphasis">_ID、从服务器角色role、主服务器的ip及端口、主从服务器的连接状态master_</span>link<span class="emphasis">_status、从服务器的优先级slave_</span>priority。</span><br><span class="line"></span><br><span class="line"> （3）Sentinel向主从服务器发送信息</span><br><span class="line"> </span><br><span class="line"> 　　　　在默认情况下, Sentinel会以每2秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506170747983-891987765.png</span>)</span><br><span class="line">　这条命令向服务器的<span class="emphasis">_sentinel_</span>:hello频道发送了一条信息，信息的内容由多个参数组成：</span><br><span class="line"></span><br><span class="line">　　　　(1) 以s_开头以参数记录的是sentinel本身的信息。</span><br><span class="line"></span><br><span class="line">　　　　(2) 而m_开头的参数记录的则是主服务器的信息，如果sentinel正在监视的是主服务器，那么这些参数就是主服务器的信息，如果sentinel正在监视的是从服务器，那么这些参数记录就是从服务器正在复制的主服务器的信息。</span><br><span class="line">　　　　</span><br><span class="line">　　　　</span><br><span class="line"></span><br><span class="line">参数 | 描述</span><br><span class="line">---|---</span><br><span class="line">S_ip | Sentinel的ip地址</span><br><span class="line">S_port | Sentinel的端口号</span><br><span class="line">S_runid | Sentinel的运行ID</span><br><span class="line">S_epoch | Sentinel 的当前配置纪元</span><br><span class="line">m_name | 主服务器的名字</span><br><span class="line">M_ip | 主服务器的IP地址</span><br><span class="line">M_port | 主服务器的端口号</span><br><span class="line">M_epoch | 主服务器的当前配置纪元</span><br><span class="line"></span><br><span class="line">以下是一条sentinel通过publish命令向主服务器发送的信息示例：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506164653763-1864655064.png</span>)</span><br><span class="line"></span><br><span class="line">这个示例中sentinel的ip地址为172.0.0.1端口号为26379, 运行ID为后面一串，当前纪元为0。主服务器的名字为mymaster,ip地址为127.0.0.1,端口号为6379, 当前纪元为0。</span><br><span class="line"></span><br><span class="line">4）sentinel接收来自主服务器和从服务器的频道信息</span><br><span class="line"></span><br><span class="line">　　　　当sentinel与一个主服务器或者从服务器建立起订阅连接之后,Sentinel就会通过订阅连接，向服务器发送以下命令：<span class="code">``subscribe_sentinel_:hello`</span><span class="code">` 。对于每个与Sentinel连接的服务器，Sentinel既通过命令连向服务器的`</span><span class="code">`_sentinel_:hello`</span><span class="code">`频道发送信息，又通过订阅连接从服务器的`</span><span class="code">`_sentinel_:hello`</span>`频道接收信息。</span><br><span class="line"></span><br><span class="line">　　　　当有三个sentinel，分别是sentinel1、sentinel2 、sentinel3。三个sentinel在监视同一个服务器，那么当sentinel1向服务器的<span class="code">``_sentinel_:hello`</span><span class="code">`频道发送一条信息时，所有订阅了`</span><span class="code">`_sentinel_:hello`</span>`频道的sentinel(包括sentinel1自己在内)都会收到这条信息。</span><br><span class="line"></span><br><span class="line">　　　　当一个sentinel从<span class="code">``_sentinel_:hello`</span>`频道收到一条信息时，sentinel会对这条信息进行分析，提取出信息中sentinel 的 ip 、port、runID等8个参数，并进行以下检查：</span><br><span class="line"></span><br><span class="line">　　　　(1) 如果信息中记录的sentinel运行ID和接收信息的sentinel运行ID相同，那么说明这条信息是sentinel自己发送的，sentinel将丢弃这条信息，不做进一步处理。</span><br><span class="line"></span><br><span class="line">　　　　(2) 相反地，如果信息中记录的sentinel运行ID和接收信息的sentinel运行ID不相同，那说明这条信息监视同一个服务器的其它sentinel发来的，接收信息的sentinel将根据信息中的参数，对相应主服务器的实例结构进行更新。</span><br><span class="line"></span><br><span class="line"> （5）sentinel更新自己的sentinels字典</span><br><span class="line">　　　　sentinel为主服务器创建实例结构中的sentinels字典，保存了sentinel本身，还监视这个主服务器的其他sentinel的资料。当一个sentinel接收到其他sentinels发来的信息时，接收的sentinel会从信息中分析并提取出两方面参数:</span><br><span class="line"></span><br><span class="line">　　　　(1)与sentinel有关的参数，包括sentinel的ip、port、runid、配置纪元。</span><br><span class="line"></span><br><span class="line">　　　　(2)与主服务器有关的参数, 包括监视主服务器的ip、port、runid、配置纪元。</span><br><span class="line"></span><br><span class="line">　　　　假设分别有三个sentinel: 127.0.0.1:26379、127.0.0.1:26380、127.0.0.1:26381。三个sentinel正在监视主服务器127.0.0.1:6379, 那么当127.0.0.1:26379这个sentinel接收到以下消息时：</span><br><span class="line">　　　　</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506163455227-1906082072.png</span>)</span><br><span class="line"></span><br><span class="line">这个sentinel将执行以下动作：</span><br><span class="line"></span><br><span class="line">　　　　(1) 第一条信息发送者为自己，信息忽略。</span><br><span class="line"></span><br><span class="line">　　　　(2) 第二条信息发送者为26381, sentinel会根据信息提取出内容，对sentinels字典中26381对应的实例结构进行更新。</span><br><span class="line"></span><br><span class="line">　　　　(3) 第三条信息发送者为23680，同样更新字典中的23680对应的实例结构。</span><br><span class="line"></span><br><span class="line">　　　　每个sentinel都有自己的一个sentinels字典， 对于26379的sentinel它的sentinels字典信息保存了26380和26381两个sentinel信息。其它sentinel也一样。</span><br><span class="line">　　　　</span><br><span class="line">（6）sentinel创建连向其他sentinel的命令连接</span><br><span class="line"></span><br><span class="line">　　　　当sentinel通过频道信息发现一个新的sentinel时，不仅更新sentinels字典，还会创建一个连向sentinel命令连接，而新的sentinel也会创建连向这个sentinel的命令连接，最终监视同一个主服务器的多个sentinel将形成相互连接的网络。如下图所示：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1382244-20190506163243221-854536312.png</span>)</span><br><span class="line"></span><br><span class="line">4.Sentinel的工作原理总结</span><br><span class="line"></span><br><span class="line"> 1)：每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。</span><br><span class="line"></span><br><span class="line"> 2)：如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。 </span><br><span class="line"></span><br><span class="line"> 3)：如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 </span><br><span class="line"></span><br><span class="line"> 4)：当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。</span><br><span class="line"></span><br><span class="line"> 5)：在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 。</span><br><span class="line"></span><br><span class="line"> 6)：当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 。</span><br><span class="line"></span><br><span class="line"> 7)：若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。 </span><br><span class="line"></span><br><span class="line"> 若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</span><br><span class="line"></span><br><span class="line"><span class="section">### 消息中间件</span></span><br><span class="line"><span class="section">#### 如何保证RocketMQ 消息的顺序性，如何解决重复消费问题。</span></span><br><span class="line">分布式消息系统作为实现分布式系统可扩展、可伸缩性的关键组件，需要具有高吞吐量、高可用等特点。而谈到消息系统的设计，就回避不了两个问题：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>消息的顺序问题</span><br><span class="line"><span class="bullet">- </span>消息的重复问题</span><br><span class="line"></span><br><span class="line">RocketMQ作为阿里开源的一款高性能、高吞吐量的消息中间件，它是怎样来解决这两个问题的？RocketMQ有哪些关键特性？其实现原理是怎样的？</span><br><span class="line"></span><br><span class="line">关键特性及其实现原理</span><br><span class="line"></span><br><span class="line"><span class="section">##### 顺序消息</span></span><br><span class="line">消息有序指的是可以按照消息的发送顺序来消费。例如：一笔订单产生了 3 条消息，分别是订单创建、订单付款、订单完成。消费时，要按照顺序依次消费才有意义。与此同时多笔订单之间又是可以并行消费的。首先来看如下示例：</span><br><span class="line"></span><br><span class="line">假如生产者产生了2条消息：M1、M2，要保证这两条消息的顺序，应该怎样做？你脑中想到的可能是这样：</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/0818e67d14dc4a09ba046f4c92094917_th.jpeg</span>)</span><br><span class="line"></span><br><span class="line">你可能会采用这种方式保证消息顺序</span><br><span class="line"></span><br><span class="line">假定M1发送到S1，M2发送到S2，如果要保证M1先于M2被消费，那么需要M1到达消费端被消费后，通知S2，然后S2再将M2发送到消费端。</span><br><span class="line"></span><br><span class="line">这个模型存在的问题是，如果M1和M2分别发送到两台Server上，就不能保证M1先达到MQ集群，也不能保证M1被先消费。换个角度看，如果M2先于M1达到MQ集群，甚至M2被消费后，M1才达到消费端，这时消息也就乱序了，说明以上模型是不能保证消息的顺序的。如何才能在MQ集群保证消息的顺序？一种简单的方式就是将M1、M2发送到同一个Server上：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/fc2bc23834e4455d882487b14c3f287e_th.png</span>)</span><br><span class="line"></span><br><span class="line">保证消息顺序，你改进后的方法</span><br><span class="line"></span><br><span class="line">这样可以保证M1先于M2到达MQServer（生产者等待M1发送成功后再发送M2），根据先达到先被消费的原则，M1会先于M2被消费，这样就保证了消息的顺序。</span><br><span class="line"></span><br><span class="line">这个模型也仅仅是理论上可以保证消息的顺序，在实际场景中可能会遇到下面的问题：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/f36a6e83f4b640f88a54c6f800ac6140_th.png</span>)</span><br><span class="line"></span><br><span class="line">网络延迟问题</span><br><span class="line"></span><br><span class="line">只要将消息从一台服务器发往另一台服务器，就会存在网络延迟问题。如上图所示，如果发送M1耗时大于发送M2的耗时，那么M2就仍将被先消费，仍然不能保证消息的顺序。即使M1和M2同时到达消费端，由于不清楚消费端1和消费端2的负载情况，仍然有可能出现M2先于M1被消费的情况。</span><br><span class="line"></span><br><span class="line">那如何解决这个问题？将M1和M2发往同一个消费者，且发送M1后，需要消费端响应成功后才能发送M2。</span><br><span class="line"></span><br><span class="line">聪明的你可能已经想到另外的问题：如果M1被发送到消费端后，消费端1没有响应，那是继续发送M2呢，还是重新发送M1？一般为了保证消息一定被消费，肯定会选择重发M1到另外一个消费端2，就如下图所示。</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/a19132aff6024e5cadd9ff5bb3da0595_th.jpeg</span>)</span><br><span class="line"></span><br><span class="line">保证消息顺序的正确姿势</span><br><span class="line"></span><br><span class="line">这样的模型就严格保证消息的顺序，细心的你仍然会发现问题，消费端1没有响应Server时有两种情况，一种是M1确实没有到达(数据在网络传送中丢失)，另外一种消费端已经消费M1且已经发送响应消息，只是MQ Server端没有收到。如果是第二种情况，重发M1，就会造成M1被重复消费。也就引入了我们要说的第二个问题，消息重复问题，这个后文会详细讲解。</span><br><span class="line"></span><br><span class="line">回过头来看消息顺序问题，严格的顺序消息非常容易理解，也可以通过文中所描述的方式来简单处理。总结起来，要实现严格的顺序消息，简单且可行的办法就是：</span><br><span class="line"></span><br><span class="line">保证生产者 - MQServer - 消费者是一对一对一的关系</span><br><span class="line"></span><br><span class="line">这样的设计虽然简单易行，但也会存在一些很严重的问题，比如：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>并行度就会成为消息系统的瓶颈（吞吐量不够）</span><br><span class="line"><span class="bullet">- </span>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。</span><br><span class="line"></span><br><span class="line">但我们的最终目标是要集群的高容错性和高吞吐量。这似乎是一对不可调和的矛盾，那么阿里是如何解决的？</span><br><span class="line"></span><br><span class="line">世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！</span><br><span class="line"></span><br><span class="line">有些问题，看起来很重要，但实际上我们可以通过合理的设计或者将问题分解来规避。如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。从这个角度来看消息的顺序问题，我们可以得出两个结论：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>不关注乱序的应用实际大量存在</span><br><span class="line"><span class="bullet">- </span>队列无序并不意味着消息无序</span><br><span class="line"></span><br><span class="line">所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是不是我们应该寻求的一种更合理的方式？</span><br><span class="line"></span><br><span class="line">最后我们从源码角度分析RocketMQ怎么实现发送顺序消息的。</span><br><span class="line"></span><br><span class="line">RocketMQ通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。比如下面的示例中，订单号相同的消息会被先后发送到同一个队列中：</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/4bdaf71241734f4082e2fb58288deea1_th.png</span>)</span><br><span class="line">在获取到路由信息以后，会根据MessageQueueSelector实现的算法来选择一个队列，同一个OrderId获取到的肯定是同一个队列。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/04e532402dfd4928803ec7b7a3e28458_th.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##### 消息重复</span></span><br><span class="line">上面在解决消息顺序问题时，引入了一个新的问题，就是消息重复。那么RocketMQ是怎样解决消息重复的问题呢？还是“恰好”不解决。</span><br><span class="line"></span><br><span class="line">造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</span><br><span class="line"></span><br><span class="line">消费端处理消息的业务逻辑保持幂等性</span><br><span class="line"></span><br><span class="line">保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现</span><br><span class="line"></span><br><span class="line">第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。</span><br><span class="line"></span><br><span class="line">第1条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。第2条可以消息系统实现，也可以业务端实现。正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以最好还是由业务端自己处理消息重复的问题，这也是RocketMQ不解决消息重复的问题的原因。</span><br><span class="line"></span><br><span class="line"><span class="section">###### 那么如何解决消息重复投递的问题？</span></span><br><span class="line">以我们支付宝转账到余额宝为例，如果相同的消息被重复投递两次，那么我们余额宝账户将会增加2万而不是1万了(上面讲顺序消费是讲过，这里再提一下)。</span><br><span class="line"></span><br><span class="line">为什么相同的消息会被重复投递？比如余额宝处理完消息msg后，发送了处理成功的消息给支付宝，正常情况下支付宝应该要删除消息msg，但如果支付宝这时候悲剧的挂了，重启后一看消息msg还在，就会继续发送消息msg。</span><br><span class="line"></span><br><span class="line">解决方法很简单，在余额宝这边增加消息应用状态表（message_apply）（这就是上文说的去重表吧），通俗来说就是个账本，用于记录消息的消费情况，每次来一个消息，在真正执行之前，先去消息应用状态表中查询一遍，如果找到说明是重复消息，丢弃即可，如果没找到才执行，同时插入到消息应用状态表（同一事务） 。</span><br></pre></td></tr></table></figure></p>
<p>for each msg in queue </p>
<p>Begin transaction </p>
<p>  select count(*) as cnt from message_apply where msg_id=msg.msg_id; </p>
<p>  if cnt==0 then </p>
<pre><code>update B set amount=amount+10000 where userId=1; 

insert into message_apply(msg_id) values(msg.msg_id); 
</code></pre><p>End transaction </p>
<p>commit;<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">##### 事务消息</span></span><br><span class="line">RocketMQ除了支持普通消息，顺序消息，另外还支持事务消息。首先讨论一下什么是事务消息以及支持事务消息的必要性。我们以一个转帐的场景为例来说明这个问题：Bob向Smith转账100块。</span><br><span class="line"></span><br><span class="line">在单机环境下，执行事务的情况，大概是下面这个样子：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/71a6eae6558e40f2b716e287d2366cd4.png</span>)</span><br><span class="line"></span><br><span class="line">单机环境下转账事务示意图</span><br><span class="line"></span><br><span class="line">当用户增长到一定程度，Bob和Smith的账户及余额信息已经不在同一台服务器上了，那么上面的流程就变成了这样：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/91d61404bbb04736ac801f37266d584d.jpeg</span>)</span><br><span class="line">集群环境下转账事务示意图</span><br><span class="line"></span><br><span class="line">这时候你会发现，同样是一个转账的业务，在集群环境下，耗时居然成倍的增长，这显然是不能够接受的。那如何来规避这个问题？</span><br><span class="line"></span><br><span class="line">大事务 = 小事务 + 异步</span><br><span class="line"></span><br><span class="line">将大事务拆分成多个小事务异步执行。这样基本上能够将跨机事务的执行效率优化到与单机一致。转账的事务就可以分解成如下两个小事务：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/280154e1893e413db9c40e36f522688e_th.jpeg</span>)</span><br><span class="line">小事务+异步消息</span><br><span class="line"></span><br><span class="line">图中执行本地事务（Bob账户扣款）和发送异步消息应该保证同时成功或者同时失败，也就是扣款成功了，发送消息一定要成功，如果扣款失败了，就不能再发送消息。那问题是：我们是先扣款还是先发送消息呢？</span><br><span class="line"></span><br><span class="line">首先看下先发送消息的情况，大致的示意图如下：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/6cb4f66c5afb43eaa2e485c5d0b60a49_th.jpeg</span>)</span><br><span class="line"></span><br><span class="line">事务消息：先发送消息</span><br><span class="line"></span><br><span class="line">存在的问题是：如果消息发送成功，但是扣款失败，消费端就会消费此消息，进而向Smith账户加钱。</span><br><span class="line"></span><br><span class="line">先发消息不行，那就先扣款吧，大致的示意图如下：</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/c63941056fe94a348a30dc2463caf186_th.jpeg</span>)</span><br><span class="line">事务消息-先扣款</span><br><span class="line"></span><br><span class="line">存在的问题跟上面类似：如果扣款成功，发送消息失败，就会出现Bob扣钱了，但是Smith账户未加钱。</span><br><span class="line"></span><br><span class="line">可能大家会有很多的方法来解决这个问题，比如：直接将发消息放到Bob扣款的事务中去，如果发送失败，抛出异常，事务回滚。这样的处理方式也符合“恰好”不需要解决的原则。在https://blog.csdn.net/yinni11/article/details/81122093中的非事务消息中间件就是采用的这种方法</span><br><span class="line"></span><br><span class="line">这里需要说明一下：如果使用Spring来管理事物的话，大可以将发送消息的逻辑放到本地事物中去，发送消息失败抛出异常，Spring捕捉到异常后就会回滚此事物，以此来保证本地事物与发送消息的原子性。</span><br><span class="line"></span><br><span class="line">RocketMQ支持事务消息，下面来看看RocketMQ是怎样来实现的。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/ed14eabe547e42588bf6e8606a64553f_th.jpeg</span>)</span><br><span class="line">RocketMQ实现发送事务消息</span><br><span class="line"></span><br><span class="line">RocketMQ第一阶段发送Prepared消息时，会拿到消息的地址，第二阶段执行本地事物，第三阶段通过第一阶段拿到的地址去访问消息，并修改消息的状态。</span><br><span class="line"></span><br><span class="line">细心的你可能又发现问题了，如果确认消息发送失败了怎么办？RocketMQ会定期扫描消息集群中的事物消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认，Bob的钱到底是减了还是没减呢？如果减了是回滚还是继续发送确认消息呢？RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</span><br><span class="line"></span><br><span class="line">那我们来看下RocketMQ源码，是如何处理事务消息的。客户端发送事务消息的部分（完整代码请查看：rocketmq-example工程下的com.alibaba.rocketmq.example.transaction.TransactionProducer）：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/d42a1f2bba2648058450df7154f3bcad_th.jpeg</span>)</span><br><span class="line">接着查看sendMessageInTransaction方法的源码，总共分为3个阶段：发送Prepared消息、执行本地事务、发送确认消息。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20837a4e8bd64356b211f857c6e2d290_th.png</span>)</span><br><span class="line">endTransaction方法会将请求发往broker(mq server)去更新事务消息的最终状态：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>根据sendResult找到Prepared消息 ，sendResult包含事务消息的ID</span><br><span class="line"><span class="bullet">- </span>根据localTransaction更新消息的最终状态</span><br><span class="line"></span><br><span class="line">如果endTransaction方法执行失败，数据没有发送到broker，导致事务消息的 状态更新失败，broker会有回查线程定时（默认1分钟）扫描每个存储事务状态的表格文件，如果是已经提交或者回滚的消息直接跳过，如果是prepared状态则会向Producer发起CheckTransaction请求，Producer会调用DefaultMQProducerImpl.checkTransactionState()方法来处理broker的定时回调请求，而checkTransactionState会调用我们的事务设置的决断方法来决定是回滚事务还是继续执行，最后调用endTransactionOneway让broker来更新消息的最终状态。</span><br><span class="line"></span><br><span class="line">再回到转账的例子，如果Bob的账户的余额已经减少，且消息已经发送成功，Smith端开始消费这条消息，这个时候就会出现消费失败和消费超时两个问题，解决超时问题的思路就是一直重试，直到消费端消费消息成功，整个过程中有可能会出现消息重复的问题，按照前面的思路解决即可。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/e111cda6fc964e0389da7fbd42175928_th.jpeg</span>)</span><br><span class="line">消费事务消息</span><br><span class="line"></span><br><span class="line">这样基本上可以解决消费端超时问题，但是如果消费失败怎么办？阿里提供给我们的解决方法是：人工解决。大家可以考虑一下，按照事务的流程，因为某种原因Smith加款失败，那么需要回滚整个流程。如果消息系统要实现这个回滚流程的话，系统复杂度将大大提升，且很容易出现Bug，估计出现Bug的概率会比消费失败的概率大很多。这也是RocketMQ目前暂时没有解决这个问题的原因，在设计实现消息系统时，我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，这也是大家在解决疑难问题时需要多多思考的地方。</span><br><span class="line"></span><br><span class="line">20160321补充：在3.2.6版本中移除了事务消息的实现，所以此版本不支持事务消息，具体情况请参考rocketmq的issues：</span><br><span class="line"></span><br><span class="line"><span class="section">##### Producer如何发送消息</span></span><br><span class="line">Producer轮询某topic下的所有队列的方式来实现发送方的负载均衡，如下图所示：</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/88780089598541bbbcc602da9d7494a8_th.png</span>)</span><br><span class="line"></span><br><span class="line">producer发送消息负载均衡</span><br><span class="line"></span><br><span class="line">首先分析一下RocketMQ的客户端发送消息的源码：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/2d9ab52fe1e94d0a99bc8523bd8ca1a1_th.jpeg</span>)</span><br><span class="line">在整个应用生命周期内，生产者需要调用一次start方法来初始化，初始化主要完成的任务有：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>如果没有指定namesrv地址，将会自动寻址</span><br><span class="line"><span class="bullet">2. </span>启动定时任务：更新namesrv地址、从namsrv更新topic路由信息、清理已经挂掉的broker、向所有broker发送心跳...</span><br><span class="line"><span class="bullet">3. </span>启动负载均衡的服务</span><br><span class="line"></span><br><span class="line">初始化完成后，开始发送消息，发送消息的主要代码如下：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/313fdaa1964640f193da2fce673773ae_th.png</span>)</span><br><span class="line"></span><br><span class="line">代码中需要关注的两个方法tryToFindTopicPublishInfo和selectOneMessageQueue。前面说过在producer初始化时，会启动定时任务获取路由信息并更新到本地缓存，所以tryToFindTopicPublishInfo会首先从缓存中获取topic路由信息，如果没有获取到，则会自己去namesrv获取路由信息。selectOneMessageQueue方法通过轮询的方式，返回一个队列，以达到负载均衡的目的。</span><br><span class="line"></span><br><span class="line">如果Producer发送消息失败，会自动重试，重试的策略：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>重试次数 <span class="xml"><span class="tag">&lt; <span class="attr">retryTimesWhenSendFailed</span>（可配置）</span></span></span><br><span class="line"><span class="xml">1. 总的耗时（包含重试n次的耗时） <span class="tag">&lt; <span class="attr">sendMsgTimeout</span>（发送消息时传入的参数）</span></span></span><br><span class="line"><span class="xml">1. 同时满足上面两个条件后，Producer会选择另外一个队列发送消息</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">##### 消息存储</span></span><br><span class="line"><span class="xml">RocketMQ的消息存储是由consume queue和commit log配合完成的。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">###### Consume Queue</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">consume queue是消息的逻辑队列，相当于字典的目录，用来指定消息在物理文件commit log上的位置。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">我们可以在配置中指定consumequeue与commitlog存储的目录</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">每个topic下的每个queue都有一个对应的consumequeue文件，比如：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/b9d346319a074ab781f72c5e0a1ae8f5.png)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">Consume Queue文件组织，如图所示：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/f7c9a71cce0545358507496a03806ba0.png)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">Consume Queue文件组织示意图</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">1. 根据topic和queueId来组织文件，图中TopicA有两个队列0,1，那么TopicA和QueueId=0组成一个ConsumeQueue，TopicA和QueueId=1组成另一个ConsumeQueue。</span></span><br><span class="line"><span class="xml">1. 按照消费端的GroupName来分组重试队列，如果消费端消费失败，消息将被发往重试队列中，比如图中的%RETRY%ConsumerGroupA。</span></span><br><span class="line"><span class="xml">1. 按照消费端的GroupName来分组死信队列，如果消费端消费失败，并重试指定次数后，仍然失败，则发往死信队列，比如图中的%DLQ%ConsumerGroupA。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">死信队列（Dead Letter Queue）一般用于存放由于某种原因无法传递的消息，比如处理失败或者已经过期的消息。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">Consume Queue中存储单元是一个20字节定长的二进制数据，顺序写顺序读，如下图所示：</span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/f5690b5d29304b048e2079bda73cd48f.png)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">consumequeue文件存储单元格式</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">1. CommitLog Offset是指这条消息在Commit Log文件中的实际偏移量</span></span><br><span class="line"><span class="xml">1. Size存储中消息的大小</span></span><br><span class="line"><span class="xml">1. Message Tag HashCode存储消息的Tag的哈希值：主要用于订阅时消息过滤（订阅时如果指定了Tag，会根据HashCode来快速查找到订阅的消息）</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">###### Commit Log</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">CommitLog：消息存放的物理文件，每台broker上的commitlog被本机所有的queue共享，不做任何区分。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">文件的默认位置如下，仍然可通过配置文件修改：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">``$&#123;user.home&#125; store$&#123;commitlog&#125;$&#123;fileName&#125;``</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">CommitLog的消息存储单元长度不固定，文件顺序写，随机读。消息的存储结构如下表所示，按照编号顺序以及编号对应的内容依次存储。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/93fecfed6a8b4ee99a60482514ae3b26_th.jpeg)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">Commit Log存储单元结构图</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">###### 消息存储实现</span></span><br><span class="line"><span class="xml">消息存储实现，比较复杂，也值得大家深入了解，后面会单独成文来分析(目前正在收集素材)，这小节只以代码说明一下具体的流程。</span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/918cf67691cd4ad395f0f5e90f2a1da7_th.jpeg)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/a3be14c9234c49f29ce2447ed61df899_th.png)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">###### 消息的索引文件</span></span><br><span class="line"><span class="xml">如果一个消息包含key值的话，会使用IndexFile存储消息索引，文件的内容结构如图：</span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/7be0f86310834ed89c999fd1aa8d024f_th.png)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">消息索引</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">索引文件主要用于根据key来查询消息的，流程主要是：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">1. 根据查询的 key 的 hashcode%slotNum 得到具体的槽的位置(slotNum 是一个索引文件里面包含的最大槽的数目，例如图中所示 slotNum=5000000)</span></span><br><span class="line"><span class="xml">1. 根据 slotValue(slot 位置对应的值)查找到索引项列表的最后一项(倒序排列,slotValue 总是指向最新的一个索引项)</span></span><br><span class="line"><span class="xml">1. 遍历索引项列表返回查询时间范围内的结果集(默认一次最大返回的 32 条记录)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">##### 消息订阅</span></span><br><span class="line"><span class="xml">RocketMQ消息订阅有两种模式，一种是Push模式，即MQServer主动向消费端推送；另外一种是Pull模式，即消费端在需要时，主动到MQServer拉取。但在具体实现时，Push和Pull模式都是采用消费端主动拉取的方式。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">首先看下消费端的负载均衡：</span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/19384b17d8a344ca83294c58f28c6bfd_th.png)</span></span><br><span class="line"><span class="xml">消费端负载均衡</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">消费端会通过RebalanceService线程，10秒钟做一次基于topic下的所有队列负载：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">1. 遍历Consumer下的所有topic，然后根据topic订阅所有的消息</span></span><br><span class="line"><span class="xml">1. 获取同一topic和Consumer Group下的所有Consumer</span></span><br><span class="line"><span class="xml">1. 然后根据具体的分配策略来分配消费队列，分配的策略包含：平均分配、消费端配置等</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">如同上图所示：如果有 5 个队列，2 个 consumer，那么第一个 Consumer 消费 3 个队列，第二 consumer 消费 2 个队列。这里采用的就是平均分配策略，它类似于分页的过程，TOPIC下面的所有queue就是记录，Consumer的个数就相当于总的页数，那么每页有多少条记录，就类似于某个Consumer会消费哪些队列。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">通过这样的策略来达到大体上的平均消费，这样的设计也可以很方便的水平扩展Consumer来提高消费能力。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">消费端的Push模式是通过长轮询的模式来实现的，就如同下图：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/a551bcd8b42c40b4a92545f3aab0f781.png)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">Push模式示意图</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">Consumer端每隔一段时间主动向broker发送拉消息请求，broker在收到Pull请求后，如果有消息就立即返回数据，Consumer端收到返回的消息后，再回调消费者设置的Listener方法。如果broker在收到Pull请求时，消息队列里没有数据，broker端会阻塞请求直到有数据传递或超时才返回。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">当然，Consumer端是通过一个线程将阻塞队列``LinkedBlockingQueue<span class="tag">&lt;<span class="name">PullRequest</span>&gt;</span></span>``中的PullRequest发送到broker拉取消息，以防止Consumer一致被阻塞。而Broker端，在接收到Consumer的PullRequest时，如果发现没有消息，就会把PullRequest扔到ConcurrentHashMap中缓存起来。broker在启动时，会启动一个线程不停的从ConcurrentHashMap取出PullRequest检查，直到有数据返回。</span><br><span class="line"></span><br><span class="line"><span class="section">##### RocketMQ的其他特性</span></span><br><span class="line">前面的6个特性都是基本上都是点到为止，想要深入了解，还需要大家多多查看源码，多多在实际中运用。当然除了已经提到的特性外，RocketMQ还支持：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>定时消息</span><br><span class="line"><span class="bullet">- </span>消息的刷盘策略</span><br><span class="line"><span class="bullet">- </span>主动同步策略：同步双写、异步复制</span><br><span class="line"><span class="bullet">- </span>海量消息堆积能力</span><br><span class="line"><span class="bullet">- </span>高效通信</span><br><span class="line"><span class="bullet">- </span>.......</span><br><span class="line"></span><br><span class="line">其中涉及到的很多设计思路和解决方法都值得我们深入研究：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>消息的存储设计：既要满足海量消息的堆积能力，又要满足极快的查询效率，还要保证写入的效率。</span><br><span class="line"><span class="bullet">- </span>高效的通信组件设计：高吞吐量，毫秒级的消息投递能力都离不开高效的通信。</span><br><span class="line"><span class="bullet">- </span>.......</span><br><span class="line"></span><br><span class="line">RocketMQ最佳实践</span><br><span class="line"></span><br><span class="line">一、Producer最佳实践</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>一个应用尽可能用一个 Topic，消息子类型用 tags 来标识，tags 可以由应用自由设置。只有发送消息设置了tags，消费方在订阅消息时，才可以利用 tags 在 broker 做消息过滤。</span><br><span class="line"><span class="bullet">- </span>每个消息在业务层面的唯一标识码，要设置到 keys 字段，方便将来定位消息丢失问题。由于是哈希索引，请务必保证 key 尽可能唯一，这样可以避免潜在的哈希冲突。</span><br><span class="line"><span class="bullet">- </span>消息发送成功或者失败，要打印消息日志，务必要打印 sendresult 和 key 字段。</span><br><span class="line"><span class="bullet">- </span>对于消息不可丢失应用，务必要有消息重发机制。例如：消息发送失败，存储到数据库，能有定时程序尝试重发或者人工触发重发。</span><br><span class="line"><span class="bullet">- </span>某些应用如果不关注消息是否发送成功，请直接使用sendOneWay方法发送消息。</span><br><span class="line"></span><br><span class="line">二、Consumer最佳实践</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>消费过程要做到幂等（即消费端去重）</span><br><span class="line"><span class="bullet">- </span>尽量使用批量方式消费方式，可以很大程度上提高消费吞吐量。</span><br><span class="line"><span class="bullet">- </span>优化每条消息消费过程</span><br><span class="line"></span><br><span class="line">三、其他配置</span><br><span class="line"></span><br><span class="line">线上应该关闭autoCreateTopicEnable，即在配置文件中将其设置为false。</span><br><span class="line"></span><br><span class="line">RocketMQ在发送消息时，会首先获取路由信息。如果是新的消息，由于MQServer上面还没有创建对应的Topic，这个时候，如果上面的配置打开的话，会返回默认TOPIC的（RocketMQ会在每台broker上面创建名为TBW102的TOPIC）路由信息，然后Producer会选择一台Broker发送消息，选中的broker在存储消息时，发现消息的topic还没有创建，就会自动创建topic。后果就是：以后所有该TOPIC的消息，都将发送到这台broker上，达不到负载均衡的目的。</span><br><span class="line"></span><br><span class="line">所以基于目前RocketMQ的设计，建议关闭自动创建TOPIC的功能，然后根据消息量的大小，手动创建TOPIC。</span><br><span class="line"></span><br><span class="line">RocketMQ设计相关</span><br><span class="line"></span><br><span class="line">RocketMQ的设计假定：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>每台PC机器都可能宕机不可服务</span><br><span class="line"><span class="bullet">- </span>任意集群都有可能处理能力不足</span><br><span class="line"><span class="bullet">- </span>最坏的情况一定会发生</span><br><span class="line"><span class="bullet">- </span>内网环境需要低延迟来提供最佳用户体验</span><br><span class="line"></span><br><span class="line">RocketMQ的关键设计：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>分布式集群化</span><br><span class="line"><span class="bullet">- </span>强数据安全</span><br><span class="line"><span class="bullet">- </span>海量数据堆积</span><br><span class="line"><span class="bullet">- </span>毫秒级投递延迟（推拉模式）</span><br><span class="line"></span><br><span class="line">这是RocketMQ在设计时的假定前提以及需要到达的效果。我想这些假定适用于所有的系统设计。随着我们系统的服务的增多，每位开发者都要注意自己的程序是否存在单点故障，如果挂了应该怎么恢复、能不能很好的水平扩展、对外的接口是否足够高效、自己管理的数据是否足够安全...... 多多规范自己的设计，才能开发出高效健壮的程序。</span><br><span class="line"></span><br><span class="line"><span class="section">#### Kafka 如何保证消息顺序消费、在consumer group 中新增一个consumer  会提高消费消息的速度吗、那如果我想提高消息消费的速度，我要怎么办？</span></span><br><span class="line"></span><br><span class="line">Kafka是一种分布式的，基于发布/订阅的消息系统。主要设计目标如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>以时间复杂度为O(1)的方式提供消息持久化能力，并保证即使对TB级以上数据也能保证常数时间的访问性能</span><br><span class="line"><span class="bullet">- </span>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输</span><br><span class="line"><span class="bullet">- </span>支持Kafka Server间的消息分区，及分布式消息消费，同时保证每个partition内的消息顺序传输</span><br><span class="line"><span class="bullet">- </span>同时支持离线数据处理和实时数据处理</span><br><span class="line"></span><br><span class="line"><span class="section">##### 为什么要用Message Queue</span></span><br><span class="line"><span class="bullet">- </span>解耦 </span><br><span class="line"><span class="code">    - 在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息队列在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束</span></span><br><span class="line"><span class="bullet">- </span>冗余 </span><br><span class="line"><span class="code">    - 有时在处理数据的时候处理过程会失败。除非数据被持久化，否则将永远丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在被许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理过程明确的指出该消息已经被处理完毕，确保你的数据被安全的保存直到你使用完毕。</span></span><br><span class="line"><span class="bullet">- </span>扩展性 </span><br><span class="line"><span class="code">    - 因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的；只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</span></span><br><span class="line"><span class="bullet">- </span>灵活性 &amp; 峰值处理能力 </span><br><span class="line"><span class="code">    - 在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住增长的访问压力，而不是因为超出负荷的请求而完全崩溃。</span></span><br><span class="line"><span class="bullet">- </span>可恢复性 </span><br><span class="line"><span class="code">    - 当体系的一部分组件失效，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。而这种允许重试或者延后处理请求的能力通常是造就一个略感不便的用户和一个沮丧透顶的用户之间的区别。</span></span><br><span class="line"><span class="bullet">- </span>送达保证 </span><br><span class="line"><span class="code">    - 消息队列提供的冗余机制保证了消息能被实际的处理，只要一个进程读取了该队列即可。在此基础上，IronMQ提供了一个”只送达一次”保证。无论有多少进程在从队列中领取数据，每一个消息只能被处理一次。这之所以成为可能，是因为获取一个消息只是”预定”了这个消息，暂时把它移出了队列。除非客户端明确的表示已经处理完了这个消息，否则这个消息会被放回队列中去，在一段可配置的时间之后可再次被处理。</span></span><br><span class="line"><span class="bullet">- </span>顺序保证 </span><br><span class="line"><span class="code">    - 在许多情况下，数据处理的顺序都很重要。消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。IronMO保证消息浆糊通过FIFO（先进先出）的顺序来处理，因此消息在队列中的位置就是从队列中检索他们的位置。</span></span><br><span class="line"><span class="bullet">- </span>缓冲 </span><br><span class="line"><span class="code">    - 在任何重要的系统中，都会有需要不同的处理时间的元素。例如,加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行—写入队列的处理会尽可能的快速，而不受从队列读的预备处理的约束。该缓冲有助于控制和优化数据流经过系统的速度。</span></span><br><span class="line"><span class="bullet">- </span>理解数据流 </span><br><span class="line"><span class="code">    - 在一个分布式系统里，要得到一个关于用户操作会用多长时间及其原因的总体印象，是个巨大的挑战。消息系列通过消息被处理的频率，来方便的辅助确定那些表现不佳的处理过程或领域，这些地方的数据流都不够优化。</span></span><br><span class="line"><span class="bullet">- </span>异步通信 </span><br><span class="line"><span class="code">    - 很多时候，你不想也不需要立即处理消息。消息队列提供了异步处理机制，允许你把一个消息放入队列，但并不立即处理它。你想向队列中放入多少消息就放多少，然后在你乐意的时候再去处理它们。</span></span><br><span class="line"></span><br><span class="line"><span class="section">##### 常用Message Queue对比</span></span><br><span class="line"><span class="bullet">- </span>RabbitMQ </span><br><span class="line"><span class="code">    - RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。</span></span><br><span class="line"><span class="bullet">- </span>Redis </span><br><span class="line"><span class="code">    - Redis是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</span></span><br><span class="line"><span class="bullet">- </span>ZeroMQ </span><br><span class="line"><span class="code">    - ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演了这个服务角色。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果down机，数据将会丢失。其中，Twitter的Storm中默认使用ZeroMQ作为数据流的传输。</span></span><br><span class="line"><span class="bullet">- </span>ActiveMQ </span><br><span class="line"><span class="code">    - ActiveMQ是Apache下的一个子项目。 类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。</span></span><br><span class="line"><span class="bullet">- </span>Kafka/Jafka </span><br><span class="line"><span class="code">    - Kafka是Apache下的一个子项目，是一个高性能跨语言分布式Publish/Subscribe消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现复杂均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制来统一了在线和离线的消息处理，这一点也是本课题所研究系统所看重的。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">##### Kafka解析</span></span><br><span class="line">Terminology</span><br><span class="line"><span class="bullet">- </span>Broker </span><br><span class="line"><span class="code">    - Kafka集群包含一个或多个服务器，这种服务器被称为broker</span></span><br><span class="line"><span class="bullet">- </span>Topic </span><br><span class="line"><span class="code">    - 每条发布到Kafka集群的消息都有一个类别，这个类别被称为topic。（物理上不同topic的消息分开存储，逻辑上一个topic的消息虽然保存于一个或多个broker上但用户只需指定消息的topic即可生产或消费数据而不必关心数据存于何处）</span></span><br><span class="line"><span class="bullet">- </span>Partition </span><br><span class="line"><span class="code">    - parition是物理上的概念，每个topic包含一个或多个partition，创建topic时可指定parition数量。每个partition对应于一个文件夹，该文件夹下存储该partition的数据和索引文件</span></span><br><span class="line"><span class="bullet">- </span>Producer </span><br><span class="line"><span class="code">    - 负责发布消息到Kafka broker</span></span><br><span class="line"><span class="bullet">- </span>Consumer </span><br><span class="line"><span class="code">    - 消费消息。每个consumer属于一个特定的consuer group（可为每个consumer指定group name，若不指定group name则属于默认的group）。使用consumer high level API时，同一topic的一条消息只能被同一个consumer group内的一个consumer消费，但多个consumer group可同时消费这一消息。</span></span><br><span class="line"></span><br><span class="line"><span class="section">##### Kafka架构</span></span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/0924-1.jpg</span>)</span><br><span class="line"></span><br><span class="line">如上图所示，一个典型的kafka集群中包含若干producer（可以是web前端产生的page view，或者是服务器日志，系统CPU、memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干consumer group，以及一个Zookeeper 集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在consumer group发生变化时进行rebalance。producer使用push模式将消息发布到broker，consumer使用pull模式从broker订阅并消费消息。</span><br><span class="line"></span><br><span class="line"><span class="section">###### Push vs. Pull</span></span><br><span class="line">作为一个messaging system，Kafka遵循了传统的方式，选择由producer向broker push消息并由consumer从broker pull消息。一些logging-centric system，比如Facebook的 Scribe 和Cloudera的 Flume ,采用非常不同的push模式。事实上，push模式和pull模式各有优劣。</span><br><span class="line"></span><br><span class="line">push模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据consumer的消费能力以适当的速率消费消息。</span><br><span class="line"></span><br><span class="line"><span class="section">###### Topic &amp; Partition</span></span><br><span class="line"></span><br><span class="line">Topic在逻辑上可以被认为是一个在的queue，每条消费都必须指定它的topic，可以简单理解为必须指明把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以水平扩展，物理上把topic分成一个或多个partition，每个partition在物理上对应一个文件夹，该文件夹下存储这个partition的所有消息和索引文件。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/0924-2.jpg</span>)</span><br><span class="line"></span><br><span class="line">每个日志文件都是“log entries”序列，每一个 log entry 包含一个4字节整型数（值为N），其后跟N个字节的消息体。每条消息都有一个当前partition下唯一的64字节的offset，它指明了这条消息的起始位置。磁盘上存储的消费格式如下：</span><br></pre></td></tr></table></figure></p>
<p>message length ： 4 bytes (value: 1+4+n)</p>
<p>“magic” value ： 1 byte</p>
<p>crc ： 4 bytes</p>
<p>payload ： n bytes<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这个“log entries”并非由一个文件构成，而是分成多个segment，每个segment名为该segment第一条消息的offset和“.kafka”组成。另外会有一个索引文件，它标明了每个segment下包含的 log entry 的offset范围，如下图所示。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/0924-3.jpg</span>)</span><br><span class="line"></span><br><span class="line">因为每条消息都被append到该partition中，是顺序写磁盘，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/0924-4.jpg</span>)</span><br><span class="line"></span><br><span class="line">每一条消息被发送到broker时，会根据paritition规则选择被存储到哪一个partition。如果partition规则设置的合理，所有消息可以均匀分布到不同的partition里，这样就实现了水平扩展。（如果一个topic对应一个文件，那这个文件所在的机器I/O将会成为这个topic的性能瓶颈，而partition解决了这个问题）。在创建topic时可以在<span class="code">``$KAFKA_HOME/config/server.properties`</span>` 中指定这个partition的数量(如下所示)，当然也可以在topic创建之后去修改parition数量。</span><br></pre></td></tr></table></figure></p>
<h1 id="The-default-number-of-log-partitions-per-topic-More-partitions-allow-greater"><a href="#The-default-number-of-log-partitions-per-topic-More-partitions-allow-greater" class="headerlink" title="The default number of log partitions per topic. More partitions allow greater"></a>The default number of log partitions per topic. More partitions allow greater</h1><h1 id="parallelism-for-consumption-but-this-will-also-result-in-more-files-across"><a href="#parallelism-for-consumption-but-this-will-also-result-in-more-files-across" class="headerlink" title="parallelism for consumption, but this will also result in more files across"></a>parallelism for consumption, but this will also result in more files across</h1><h1 id="the-brokers"><a href="#the-brokers" class="headerlink" title="the brokers."></a>the brokers.</h1><p>num.partitions=3<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在发送一条消息时，可以指定这条消息的key，producer根据这个key和partition机制来判断将这条消息发送到哪个parition。paritition机制可以通过指定``producer的paritition. <span class="keyword">class</span>``这一参数来指定，该<span class="keyword">class</span>必须实现 ``kafka.producer.Partitioner`` 接口。本例中如果key可以被解析为整数则将对应的整数与partition总数取余，该消息会被发送到该数对应的partition。（每个parition都会有个序号）</span><br></pre></td></tr></table></figure></p>
<p>import kafka.producer.Partitioner;<br>import kafka.utils.VerifiableProperties;<br>public class JasonPartitioner<t> implements Partitioner {<br>  public JasonPartitioner(VerifiableProperties verifiableProperties) {}<br>  @Override<br>  public int partition(Object key, int numPartitions) {<br>    try {<br>      int partitionNum = Integer.parseInt((String) key);<br>      return Math.abs(Integer.parseInt((String) key) % numPartitions);<br>    } catch (Exception e) {<br>      return Math.abs(key.hashCode() % numPartitions);<br>    }<br>  }<br>}<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果将上例中的class作为partition.class，并通过如下代码发送<span class="number">20</span>条消息（<span class="type">key</span>分别为<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>）至topic2（包含<span class="number">4</span>个partition）。</span><br></pre></td></tr></table></figure></t></p>
<p>public void sendMessage() throws InterruptedException{<br>　　for(int i = 1; i &lt;= 5; i++){<br>　　      List messageList = new ArrayList&lt;KeyedMessage&lt;String, String&gt;&gt;();<br>　　      for(int j = 0; j &lt; 4; j++）{<br>　　          messageList.add(new KeyedMessage&lt;String, String&gt;(“topic2”, j+””, “The “ + i + “ message for key “ + j));<br>　　      }<br>　　      producer.send(messageList);<br>    }<br>　　producer.close();<br>}<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">则key相同的消息会被发送并存储到同一个partition里，而且key的序号正好和partition序号相同。（partition序号从0开始，本例中的key也正好从0开始）。如下图所示。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/0924-5.jpg</span>)</span><br><span class="line"></span><br><span class="line">对于传统的message queue而言，一般会删除已经被消费的消息，而Kafka集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此Kafka提供两种策略去删除旧数据。一是基于时间，二是基于partition文件大小。例如可以通过配置<span class="code">``$KAFKA_HOME/config/server.properties`</span>` ，让Kafka删除一周前的数据，也可通过配置让Kafka在partition文件超过1GB时删除旧数据，如下所示。</span><br></pre></td></tr></table></figure></p>
<p>　############################# Log Retention Policy #############################</p>
<h1 id="The-following-configurations-control-the-disposal-of-log-segments-The-policy-can"><a href="#The-following-configurations-control-the-disposal-of-log-segments-The-policy-can" class="headerlink" title="The following configurations control the disposal of log segments. The policy can"></a>The following configurations control the disposal of log segments. The policy can</h1><h1 id="be-set-to-delete-segments-after-a-period-of-time-or-after-a-given-size-has-accumulated"><a href="#be-set-to-delete-segments-after-a-period-of-time-or-after-a-given-size-has-accumulated" class="headerlink" title="be set to delete segments after a period of time, or after a given size has accumulated."></a>be set to delete segments after a period of time, or after a given size has accumulated.</h1><h1 id="A-segment-will-be-deleted-whenever-either-of-these-criteria-are-met-Deletion-always-happens"><a href="#A-segment-will-be-deleted-whenever-either-of-these-criteria-are-met-Deletion-always-happens" class="headerlink" title="A segment will be deleted whenever either of these criteria are met. Deletion always happens"></a>A segment will be deleted whenever <em>either</em> of these criteria are met. Deletion always happens</h1><h1 id="from-the-end-of-the-log"><a href="#from-the-end-of-the-log" class="headerlink" title="from the end of the log."></a>from the end of the log.</h1><h1 id="The-minimum-age-of-a-log-file-to-be-eligible-for-deletion"><a href="#The-minimum-age-of-a-log-file-to-be-eligible-for-deletion" class="headerlink" title="The minimum age of a log file to be eligible for deletion"></a>The minimum age of a log file to be eligible for deletion</h1><p>log.retention.hours=168</p>
<h1 id="A-size-based-retention-policy-for-logs-Segments-are-pruned-from-the-log-as-long-as-the-remaining"><a href="#A-size-based-retention-policy-for-logs-Segments-are-pruned-from-the-log-as-long-as-the-remaining" class="headerlink" title="A size-based retention policy for logs. Segments are pruned from the log as long as the remaining"></a>A size-based retention policy for logs. Segments are pruned from the log as long as the remaining</h1><h1 id="segments-don’t-drop-below-log-retention-bytes"><a href="#segments-don’t-drop-below-log-retention-bytes" class="headerlink" title="segments don’t drop below log.retention.bytes."></a>segments don’t drop below log.retention.bytes.</h1><p>#log.retention.bytes=1073741824</p>
<h1 id="The-maximum-size-of-a-log-segment-file-When-this-size-is-reached-a-new-log-segment-will-be-created"><a href="#The-maximum-size-of-a-log-segment-file-When-this-size-is-reached-a-new-log-segment-will-be-created" class="headerlink" title="The maximum size of a log segment file. When this size is reached a new log segment will be created."></a>The maximum size of a log segment file. When this size is reached a new log segment will be created.</h1><p>log.segment.bytes=1073741824</p>
<h1 id="The-interval-at-which-log-segments-are-checked-to-see-if-they-can-be-deleted-according"><a href="#The-interval-at-which-log-segments-are-checked-to-see-if-they-can-be-deleted-according" class="headerlink" title="The interval at which log segments are checked to see if they can be deleted according"></a>The interval at which log segments are checked to see if they can be deleted according</h1><h1 id="to-the-retention-policies"><a href="#to-the-retention-policies" class="headerlink" title="to the retention policies"></a>to the retention policies</h1><p>log.retention.check.interval.ms=300000</p>
<h1 id="By-default-the-log-cleaner-is-disabled-and-the-log-retention-policy-will-default-to"><a href="#By-default-the-log-cleaner-is-disabled-and-the-log-retention-policy-will-default-to" class="headerlink" title="By default the log cleaner is disabled and the log retention policy will default to"></a>By default the log cleaner is disabled and the log retention policy will default to</h1><p>#just delete segments after their retention expires.</p>
<h1 id="If-log-cleaner-enable-true-is-set-the-cleaner-will-be-enabled-and-individual-logs"><a href="#If-log-cleaner-enable-true-is-set-the-cleaner-will-be-enabled-and-individual-logs" class="headerlink" title="If log.cleaner.enable=true is set the cleaner will be enabled and individual logs"></a>If log.cleaner.enable=true is set the cleaner will be enabled and individual logs</h1><p>#can then be marked for log compaction.<br>log.cleaner.enable=false<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这里要注意，因为Kafka读取特定消息的时间复杂度为O(<span class="number">1</span>)，即与文件大小无关，所以这里删除文件与Kafka性能无关，选择怎样的删除策略只与磁盘以及具体的需求有关。另外，Kafka会为每一个consumer group保留一些metadata信息—当前消费的消息的position，也即offset。这个offset由consumer控制。正常情况下consumer会在消费完一条消息后线性增加这个offset。当然，consumer也可将offset设成一个较小的值，重新消费一些消息。因为offet由consumer控制，所以Kafka broker是无状态的，它不需要标记哪些消息被哪些consumer过，不需要通过broker去保证同一个consumer group只有一个consumer能消费某一条消息，因此也就不需要锁机制，这也为Kafka的高吞吐率提供了有力保障。</span><br><span class="line"></span><br><span class="line">###### Replication &amp; Leader election</span><br><span class="line">Kafka从<span class="number">0.8</span>开始提供partition级别的replication，replication的数量可在``$KAFKA_HOME/config/server.properties ``中配置。</span><br></pre></td></tr></table></figure></p>
<p>default.replication.factor = 1<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">该 Replication与<span class="built_in">leader</span> election配合提供了自动的failover机制。replication对Kafka的吞吐率是有一定影响的，但极大的增强了可用性。默认情况下，Kafka的replication数量为<span class="number">1</span>。 每个partition都有一个唯一的<span class="built_in">leader</span>，所有的读写操作都在<span class="built_in">leader</span>上完成，<span class="built_in">leader</span>批量从<span class="built_in">leader</span>上pull数据。一般情况下partition的数量大于等于broker的数量，并且所有partition的<span class="built_in">leader</span>均匀分布在broker上。follower上的日志和其<span class="built_in">leader</span>上的完全一样。</span><br><span class="line"></span><br><span class="line">和大部分分布式系统一样，Kakfa处理失败需要明确定义一个broker是否<span class="built_in">alive</span>。对于Kafka而言，Kafka存活包含两个条件，一是它必须维护与Zookeeper的session(这个通过Zookeeper的heartbeat机制来实现)。二是follower必须能够及时将<span class="built_in">leader</span>的writing复制过来，不能“落后太多”。</span><br><span class="line"></span><br><span class="line"><span class="built_in">leader</span>会track“<span class="built_in">in</span> sync”的node <span class="built_in">list</span>。如果一个follower宕机，或者落后太多，<span class="built_in">leader</span>将把它从”<span class="built_in">in</span> sync” <span class="built_in">list</span>中移除。这里所描述的“落后太多”指follower复制的消息落后于<span class="built_in">leader</span>后的条数超过预定值，该值可在 ``$KAFKA_HOME/config/server.properties`` 中配置</span><br></pre></td></tr></table></figure></p>
<p>#If a replica falls more than this many messages behind the leader, the leader will remove the follower from ISR and treat it as dead<br>replica.lag.max.messages=4000</p>
<p>#If a follower hasn’t sent any fetch requests for this window of time, the leader will remove the follower from ISR (in-sync replicas) and treat it as dead<br>replica.lag.time.max.ms=10000<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br></pre></td><td class="code"><pre><span class="line">需要说明的是，Kafka只解决”fail/recover”，不处理“Byzantine”（“拜占庭”）问题。</span><br><span class="line"></span><br><span class="line">一条消息只有被“in sync” list里的所有follower都从leader复制过去才会被认为已提交。这样就避免了部分数据被写进了leader，还没来得及被任何follower复制就宕机了，而造成数据丢失（consumer无法消费这些数据）。而对于producer而言，它可以选择是否等待消息commit，这可以通过`` request.required.acks`` 来设置。这种机制确保了只要“in sync” list有一个或以上的flollower，一条被commit的消息就不会丢失。</span><br><span class="line"></span><br><span class="line">这里的复制机制即不是同步复制，也不是单纯的异步复制。事实上，同步复制要求“活着的”follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率（高吞吐率是Kafka非常重要的一个特性）。而异步复制方式下，follower异步的从leader复制数据，数据只要被leader写入log就被认为已经commit，这种情况下如果follwer都落后于leader，而leader突然宕机，则会丢失数据。而Kafka的这种使用“in sync” list的方式则很好的均衡了确保数据不丢失以及吞吐率。follower可以批量的从leader复制数据，这样极大的提高复制性能（批量写磁盘），极大减少了follower与leader的差距（前文有说到，只要follower落后leader不太远，则被认为在“in sync” list里）。</span><br><span class="line"></span><br><span class="line">上文说明了Kafka是如何做replication的，另外一个很重要的问题是当leader宕机了，怎样在follower中选举出新的leader。因为follower可能落后许多或者crash了，所以必须确保选择“最新”的follower作为新的leader。一个基本的原则就是，如果leader不在了，新的leader必须拥有原来的leader commit的所有消息。这就需要作一个折衷，如果leader在标明一条消息被commit前等待更多的follower确认，那在它die之后就有更多的follower可以作为新的leader，但这也会造成吞吐率的下降。</span><br><span class="line"></span><br><span class="line">一种非常常用的选举leader的方式是“majority 灵秀”（“少数服从多数”），但Kafka并未采用这种方式。这种模式下，如果我们有2f+1个replica（包含leader和follower），那在commit之前必须保证有f+1个replica复制完消息，为了保证正确选出新的leader，fail的replica不能超过f个。因为在剩下的任意f+1个replica里，至少有一个replica包含有最新的所有消息。这种方式有个很大的优势，系统的latency只取决于最快的几台server，也就是说，如果replication factor是3，那latency就取决于最快的那个follower而非最慢那个。majority vote也有一些劣势，为了保证leader election的正常进行，它所能容忍的fail的follower个数比较少。如果要容忍1个follower挂掉，必须要有3个以上的replica，如果要容忍2个follower挂掉，必须要有5个以上的replica。也就是说，在生产环境下为了保证较高的容错程度，必须要有大量的replica，而大量的replica又会在大数据量下导致性能的急剧下降。这就是这种算法更多用在 Zookeeper 这种共享集群配置的系统中而很少在需要存储大量数据的系统中使用的原因。例如HDFS的HA feature是基于 majority-vote-based journal ，但是它的数据存储并没有使用这种expensive的方式。</span><br><span class="line"></span><br><span class="line">实际上，leader election算法非常多，比如Zookeper的 Zab , Raft 和 Viewstamped Replication 。而Kafka所使用的leader election算法更像微软的 PacificA 算法。</span><br><span class="line"></span><br><span class="line">Kafka在Zookeeper中动态维护了一个ISR（in-sync replicas） set，这个set里的所有replica都跟上了leader，只有ISR里的成员才有被选为leader的可能。在这种模式下，对于f+1个replica，一个Kafka topic能在保证不丢失已经ommit的消息的前提下容忍f个replica的失败。在大多数使用场景中，这种模式是非常有利的。事实上，为了容忍f个replica的失败，majority vote和ISR在commit前需要等待的replica数量是一样的，但是ISR需要的总的replica的个数几乎是majority vote的一半。</span><br><span class="line"></span><br><span class="line">虽然majority vote与ISR相比有不需等待最慢的server这一优势，但是Kafka作者认为Kafka可以通过producer选择是否被commit阻塞来改善这一问题，并且节省下来的replica和磁盘使得ISR模式仍然值得。</span><br><span class="line"></span><br><span class="line">上文提到，在ISR中至少有一个follower时，Kafka可以确保已经commit的数据不丢失，但如果某一个partition的所有replica都挂了，就无法保证数据不丢失了。这种情况下有两种可行的方案：</span><br><span class="line"></span><br><span class="line">-<span class="ruby"> 等待ISR中的任一个replica“活”过来，并且选它作为leader</span></span><br><span class="line"><span class="ruby">- 选择第一个“活”过来的replica（不一定是ISR中的）作为leader</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">这就需要在可用性和一致性当中作出一个简单的平衡。如果一定要等待ISR中的replica“活”过来，那不可用的时间就可能会相对较长。而且如果ISR中的所有replica都无法“活”过来了，或者数据都丢失了，这个partition将永远不可用。选择第一个“活”过来的replica作为leader，而这个replica不是ISR中的replica，那即使它并不保证已经包含了所有已commit的消息，它也会成为leader而作为consumer的数据源（前文有说明，所有读写都由leader完成）。Kafka<span class="number">0</span>.<span class="number">8</span>.*使用了第二种方式。根据Kafka的文档，在以后的版本中，Kafka支持用户通过配置选择这两种方式中的一种，从而根据不同的使用场景选择高可用性还是强一致性。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">上文说明了一个parition的replication过程，然尔Kafka集群需要管理成百上千个partition，Kafka通过round-robin的方式来平衡partition从而避免大量partition集中在了少数几个节点上。同时Kafka也需要平衡leader的分布，尽可能的让所有partition的leader均匀分布在不同broker上。另一方面，优化leadership election的过程也是很重要的，毕竟这段时间相应的partition处于不可用状态。一种简单的实现是暂停宕机的broker上的所有partition，并为之选举leader。实际上，Kafka选举一个broker作为controller，这个controller通过watch Zookeeper检测所有的broker failure，并负责为所有受影响的parition选举leader，再将相应的leader调整命令发送至受影响的broker，过程如下图所示。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">6</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">这样做的好处是，可以批量的通知leadership的变化，从而使得选举过程成本更低，尤其对大量的partition而言。如果controller失败了，幸存的所有broker都会尝试在Zookeeper中创建/controller-&gt;&#123;this broker id&#125;，如果创建成功（只可能有一个创建成功），则该broker会成为controller，若创建不成功，则该broker会等待新controller的命令。</span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">7</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">###### Consumer group</span></span></span><br><span class="line"><span class="ruby">（本节所有描述都是基于consumer hight level API而非low level API）。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">每一个consumer实例都属于一个consumer group，每一条消息只会被同一个consumer group里的一个consumer实例消费。（不同consumer group可以同时消费同一条消息）</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">8</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">很多传统的message queue都会在消息被消费完后将消息删除，一方面避免重复消费，另一方面可以保证queue的长度比较少，提高效率。而如上文所将，Kafka并不删除已消费的消息，为了实现传统message queue消息只被消费一次的语义，Kafka保证保证同一个consumer group里只有一个consumer会消费一条消息。与传统message queue不同的是，Kafka还允许不同consumer group同时消费同一条消息，这一特性可以为消息的多元化处理提供了支持。实际上，Kafka的设计理念之一就是同时提供离线处理和实时处理。根据这一特性，可以使用Storm这种实时流处理系统对消息进行实时在线处理，同时使用Hadoop这种批处理系统进行离线处理，还可以同时将数据实时备份到另一个数据中心，只需要保证这三个操作所使用的consumer在不同的consumer group即可。下图展示了Kafka在Linkedin的一种简化部署。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">9</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">为了更清晰展示Kafka consumer group的特性，笔者作了一项测试。创建一个topic (名为topic1)，创建一个属于group1的consumer实例，并创建三个属于group2的consumer实例，然后通过producer向topic1发送key分别为<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>r的消息。结果发现属于group1的consumer收到了所有的这三条消息，同时group2中的<span class="number">3</span>个consumer分别收到了key为<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>的消息。如下图所示。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">10</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">###### Consumer Rebalance</span></span></span><br><span class="line"><span class="ruby">（本节所讲述内容均基于Kafka consumer high level API）</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Kafka保证同一consumer group中只有一个consumer会消息某条消息，实际上，Kafka保证的是稳定状态下每一个consumer实例只会消费某一个或多个特定partition的数据，而某个partition的数据只会被某一个特定的consumer实例所消费。这样设计的劣势是无法让同一个consumer group里的consumer均匀消费数据，优势是每个consumer不用都跟大量的broker通信，减少通信开销，同时也降低了分配难度，实现也更简单。另外，因为同一个partition里的数据是有序的，这种设计可以保证每个partition里的数据也是有序被消费。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">如果某consumer group中consumer数量少于partition数量，则至少有一个consumer会消费多个partition的数据，如果consumer的数量与partition数量相同，则正好一个consumer消费一个partition的数据，而如果consumer的数量多于partition的数量时，会有部分consumer无法消费该topic下任何一条消息。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">如下例所示，如果topic1有<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>共三个partition，当group1只有一个consumer(名为consumer1)时，该 consumer可消费这<span class="number">3</span>个partition的所有数据。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">11</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">增加一个consumer(consumer2)后，其中一个consumer（consumer1）可消费<span class="number">2</span>个partition的数据，另外一个consumer(consumer2)可消费另外一个partition的数据。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">12</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">再增加一个consumer(consumer3)后，每个consumer可消费一个partition的数据。consumer1消费partition<span class="number">0</span>，consumer2消费partition1，consumer3消费partition2</span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">13</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">再增加一个consumer（consumer4）后，其中<span class="number">3</span>个consumer可分别消费一个partition的数据，另外一个consumer（consumer4）不能消费topic1任何数据。</span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">14</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">此时关闭consumer1，剩下的consumer可分别消费一个partition的数据。</span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">15</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">接着关闭consumer2，剩下的consumer3可消费<span class="number">2</span>个partition，consumer4可消费<span class="number">1</span>个partition。</span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">16</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">再关闭consumer3，剩下的consumer4可同时消费topic1的<span class="number">3</span>个partition。</span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">17</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">consumer rebalance算法如下：</span></span><br><span class="line"><span class="ruby">- Sort PT (all partitions <span class="keyword">in</span> topic T)</span></span><br><span class="line"><span class="ruby">- Sort CG(all consumers <span class="keyword">in</span> consumer group G)</span></span><br><span class="line"><span class="ruby">- Let i be the index position of Ci <span class="keyword">in</span> CG <span class="keyword">and</span> let N=size(PT)/size(CG)</span></span><br><span class="line"><span class="ruby">- Remove current entries owned by Ci from the partition owner registry</span></span><br><span class="line"><span class="ruby">- Assign partitions from i N to (i+<span class="number">1</span>) N-<span class="number">1</span> to consumer Ci</span></span><br><span class="line"><span class="ruby">- Add newly assigned partitions to the partition owner registry</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">目前consumer rebalance的控制策略是由每一个consumer通过Zookeeper完成的。具体的控制方式如下：</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">- Register itself <span class="keyword">in</span> the consumer id registry under its group.</span></span><br><span class="line"><span class="ruby">- Register a watch on changes under the consumer id registry.</span></span><br><span class="line"><span class="ruby">- Register a watch on changes under the broker id registry.</span></span><br><span class="line"><span class="ruby">- If the consumer creates a message stream using a topic filter, it also registers a watch on changes under the broker topic registry.</span></span><br><span class="line"><span class="ruby">- Force itself to rebalance within <span class="keyword">in</span> its consumer group.</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">在这种策略下，每一个consumer或者broker的增加或者减少都会触发consumer rebalance。因为每个consumer只负责调整自己所消费的partition，为了保证整个consumer group的一致性，所以当一个consumer触发了rebalance时，该consumer group内的其它所有consumer也应该同时触发rebalance。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">目前（<span class="number">2015</span>-<span class="number">01</span>-<span class="number">19</span>）最新版（<span class="number">0</span>.<span class="number">8.2</span>）Kafka采用的是上述方式。但该方式有不利的方面：</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">- Herd effect </span></span><br><span class="line"><span class="ruby">    - 任何broker或者consumer的增减都会触发所有的consumer的rebalance</span></span><br><span class="line"><span class="ruby">- Split Brain </span></span><br><span class="line"><span class="ruby">    - 每个consumer分别单独通过Zookeeper判断哪些partition down了，那么不同consumer从Zookeeper“看”到的view就可能不一样，这就会造成错误的reblance尝试。而且有可能所有的consumer都认为rebalance已经完成了，但实际上可能并非如此。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">根据Kafka官方文档，Kafka作者正在考虑在还未发布的 <span class="number">0</span>.<span class="number">9</span>.x版本中使用中心协调器(coordinator) 。大体思想是选举出一个broker作为coordinator，由它watch Zookeeper，从而判断是否有partition或者consumer的增减，然后生成rebalance命令，并检查是否这些rebalance在所有相关的consumer中被执行成功，如果不成功则重试，若成功则认为此次rebalance成功（这个过程跟replication controller非常类似，所以我很奇怪为什么当初设计replication controller时没有使用类似方式来解决consumer rebalance的问题）。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">18</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">###### 消息Deliver guarantee</span></span></span><br><span class="line"><span class="ruby">通过上文介绍，想必读者已经明天了producer和consumer是如何工作的，以及Kafka是如何做replication的，接下来要讨论的是Kafka如何确保消息在producer和consumer之间传输。有这么几种可能的delivery guarantee：</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">- At most once 消息可能会丢，但绝不会重复传输</span></span><br><span class="line"><span class="ruby">- At least one 消息绝不会丢，但可能会重复传输</span></span><br><span class="line"><span class="ruby">- Exactly once 每条消息肯定会被传输一次且仅传输一次，很多时候这是用户所想要的。</span></span><br><span class="line"><span class="ruby">- Kafka的delivery guarantee semantic非常直接。当producer向broker发送消息时，一旦这条消息被commit，因数replication的存在，它就不会丢。但是如果producer发送数据给broker后，遇到的网络问题而造成通信中断，那producer就无法判断该条消息是否已经commit。这一点有点像向一个自动生成primary key的数据库表中插入数据。虽然Kafka无法确定网络故障期间发生了什么，但是producer可以生成一种类似于primary key的东西，发生故障时幂等性的<span class="keyword">retry</span>多次，这样就做到了Exactly one 。截止到目前(Kafka <span class="number">0</span>.<span class="number">8.2</span>版本，<span class="number">2015</span>-<span class="number">01</span>-<span class="number">25</span>)，这一feature还并未实现，有希望在Kafka未来的版本中实现。（所以目前默认情况下一条消息从producer和broker是确保了 At least once ，但可通过设置producer异步发送实现 At most once ）。</span></span><br><span class="line"><span class="ruby">- 接下来讨论的是消息从broker到consumer的delivery guarantee semantic。（仅针对Kafka consumer high level API）。consumer在从broker读取消息后，可以选择commit，该操作会在Zookeeper中存下该consumer在该partition下读取的消息的offset。该consumer下一次再读该partition时会从下一条开始读取。如未commit，下一次读取的开始位置会跟上一次commit之后的开始位置相同。当然可以将consumer设置为autocommit，即consumer一旦读到数据立即自动commit。如果只讨论这一读取消息的过程，那Kafka是确保了 Exactly once 。但实际上实际使用中consumer并非读取完数据就结束了，而是要进行进一步处理，而数据处理与commit的顺序在很大程度上决定了消息从broker和consumer的delivery guarantee semantic。</span></span><br><span class="line"><span class="ruby">- 读完消息先commit再处理消息。这种模式下，如果consumer在commit后还没来得及处理消息就crash了，下次重新开始工作后就无法读到刚刚已提交而未处理的消息，这就对应于 At most once</span></span><br><span class="line"><span class="ruby">- 读完消息先处理再commit。这种模式下，如果处理完了消息在commit之前consumer crash了，下次重新开始工作时还会处理刚刚未commit的消息，实际上该消息已经被处理过了。这就对应于 At least once 。在很多情况使用场景下，消息都有一个primary key，所以消息的处理往往具有幂等性，即多次处理这一条消息跟只处理一次是等效的，那就可以认为是 Exactly once 。（人个感觉这种说法有些牵强，毕竟它不是Kafka本身提供的机制，而且primary key本身不保证操作的幂等性。而且实际上我们说delivery guarantee semantic是讨论被处理多少次，而非处理结果怎样，因为处理方式多种多样，我们的系统不应该把处理过程的特性—如是否幂等性，当成Kafka本身的feature）</span></span><br><span class="line"><span class="ruby">- 如果一定要做到 Exactly once ，就需要协调offset和实际操作的输出。精典的做法是引入两阶段提交。如果能让offset和操作输入存在同一个地方，会更简洁和通用。这种方式可能更好，因为许多输出系统可能不支持两阶段提交。比如，consumer拿到数据后可能把数据放到HDFS，如果把最新的offset和数据本身一起写到HDFS，那就可以保证数据的输出和offset的更新要么都完成，要么都不完成，间接实现 Exactly once 。（目前就high level API而言，offset是存于Zookeeper中的，无法存于HDFS，而low level API的offset是由自己去维护的，可以将之存于HDFS中） </span></span><br><span class="line"><span class="ruby">- 总之，Kafka默认保证 At least once ，并且允许通过设置producer异步提交来实现 At most once 。而 Exactly once 要求与目标存储系统协作，幸运的是Kafka提供的offset可以使用这种方式非常直接非常容易。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">###### Benchmark</span></span></span><br><span class="line"><span class="ruby">纸上得来终觉浅，绝知些事要躬行。笔者希望能亲自测一下Kafka的性能，而非从网上找一些测试数据。所以笔者曾在<span class="number">0</span>.<span class="number">8</span>发布前两个月做过详细的Kafka<span class="number">0</span>.<span class="number">8</span>性能测试，不过很可惜测试报告不慎丢失。所幸在网上找到了Kafka的创始人之一的 Jay Kreps的bechmark 。以下描述皆基于该benchmark。（该benchmark基于Kafka<span class="number">0</span>.<span class="number">8.1</span>）</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">##### 测试环境</span></span></span><br><span class="line"><span class="ruby"><span class="comment">###### producer吞吐率</span></span></span><br><span class="line"><span class="ruby">该项测试只测producer的吞吐率，也就是数据只被持久化，没有consumer读数据。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">###### 1个producer线程，无replication</span></span></span><br><span class="line"><span class="ruby">在这一测试中，创建了一个包含<span class="number">6</span>个partition且没有replication的topic。然后通过一个线程尽可能快的生成<span class="number">50</span> million条比较短（payload10<span class="number">0</span>字节长）的消息。测试结果是<span class="number">821</span>,<span class="number">557</span> records/second （ <span class="number">78.3</span>MB/second ）。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">之所以使用短消息，是因为对于消息系统来说这种使用场景更难。因为如果使用MB/second来表征吞吐率，那发送长消息无疑能使得测试结果更好。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">整个测试中，都是用每秒钟delivery的消息的数量乘以payload的长度来计算MB/second的，没有把消息的元信息算在内，所以实际的网络使用量会比这个大。对于本测试来说，每次还需传输额外的<span class="number">22</span>个字节，包括一个可选的key，消息长度描述，CRC等。另外，还包含一些请求相关的overhead，比如topic，partition，acknowledgement等。这就导致我们比较难判断是否已经达到网卡极限，但是把这些overhead都算在吞吐率里面应该更合理一些。因此，我们已经基本达到了网卡的极限。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">初步观察此结果会认为它比人们所预期的要高很多，尤其当考虑到Kafka要把数据持久化到磁盘当中。实际上，如果使用随机访问数据系统，比如RDBMS，或者key-velue store，可预期的最高访问频率大概是<span class="number">5000</span>到<span class="number">50000</span>个请求每秒，这和一个好的RPC层所能接受的远程请求量差不多。而该测试中远超于此的原因有两个。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">- Kafka确保写磁盘的过程是线性磁盘I/O，测试中使用的<span class="number">6</span>块廉价磁盘线性I/O的最大吞吐量是<span class="number">822</span>MB/second，这已经远大于<span class="number">1</span>Gb网卡所能带来的吞吐量了。许多消息系统把数据持久化到磁盘当成是一个开销很大的事情，这是因为他们对磁盘的操作都不是线性I/O。</span></span><br><span class="line"><span class="ruby">- 在每一个阶段，Kafka都尽量使用批量处理。如果想了解批处理在I/O操作中的重要性，可以参考David Patterson的” Latency Lags Bandwidth “</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">###### 1个producer线程，3个异步replication</span></span></span><br><span class="line"><span class="ruby">该项测试与上一测试基本一样，唯一的区别是每个partition有<span class="number">3</span>个replica（所以网络传输的和写入磁盘的总的数据量增加了<span class="number">3</span>倍）。每一个broker即要写作为leader的partition，也要读（从leader读数据）写（将数据写到磁盘）作为follower的partition。测试结果为 <span class="number">786</span>,<span class="number">980</span> records/second （ <span class="number">75.1</span>MB/second ）。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">该项测试中replication是异步的，也就是说broker收到数据并写入本地磁盘后就acknowledge producer，而不必等所有replica都完成replication。也就是说，如果leader crash了，可能会丢掉一些最新的还未备份的数据。但这也会让message acknowledgement延迟更少，实时性更好。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">这项测试说明，replication可以很快。整个集群的写能力可能会由于<span class="number">3</span>倍的replication而只有原来的三分之一，但是对于每一个producer来说吞吐率依然足够好。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">###### 1个producer线程，3个同步replication</span></span></span><br><span class="line"><span class="ruby">该项测试与上一测试的唯一区别是replication是同步的，每条消息只有在被 <span class="keyword">in</span> sync 集合里的所有replica都复制过去后才会被置为committed（此时broker会向producer发送acknowledgement）。在这种模式下，Kafka可以保证即使leader crash了，也不会有数据丢失。测试结果为 <span class="number">421</span>,<span class="number">823</span> records/second （ <span class="number">40.2</span>MB/second）。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Kafka同步复制与异步复制并没有本质的不同。leader会始终track follower replica从而监控它们是否还alive，只有所有 <span class="keyword">in</span> sync 集合里的replica都acknowledge的消息才可能被consumer所消费。而对follower的等待影响了吞吐率。可以通过增大batch size来改善这种情况，但为了避免特定的优化而影响测试结果的可比性，本次测试并没有做这种调整。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">###### 3个producer,3个异步replication</span></span></span><br><span class="line"><span class="ruby">该测试相当于把上文中的<span class="number">1</span>个producer,复制到了<span class="number">3</span>台不同的机器上（在<span class="number">1</span>台机器上跑多个实例对吞吐率的增加不会有太大帮忙，因为网卡已经基本饱和了），这<span class="number">3</span>个producer同时发送数据。整个集群的吞吐率为 <span class="number">2</span>,<span class="number">024</span>,<span class="number">032</span> records/second （ <span class="number">193</span>,0MB/second）。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">###### Producer Throughput Vs. Stored Data</span></span></span><br><span class="line"><span class="ruby">消息系统的一个潜在的危险是当数据能都存于内存时性能很好，但当数据量太大无法完全存于内存中时（然后很多消息系统都会删除已经被消费的数据，但当消费速度比生产速度慢时，仍会造成数据的堆积），数据会被转移到磁盘，从而使得吞吐率下降，这又反过来造成系统无法及时接收数据。这样就非常糟糕，而实际上很多情景下使用queue的目的就是解决数据消费速度和生产速度不一致的问题。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">但Kafka不存在这一问题，因为Kafka始终以O（<span class="number">1</span>）的时间复杂度将数据持久化到磁盘，所以其吞吐率不受磁盘上所存储的数据量的影响。为了验证这一特性，做了一个长时间的大数据量的测试，下图是吞吐率与数据量大小的关系图。</span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">19</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">上图中有一些variance的存在，并可以明显看到，吞吐率并不受磁盘上所存数据量大小的影响。实际上从上图可以看到，当磁盘数据量达到<span class="number">1</span>TB时，吞吐率和磁盘数据只有几百MB时没有明显区别。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">这个variance是由Linux I/O管理造成的，它会把数据缓存起来再批量flush。上图的测试结果是在生产环境中对Kafka集群做了些tuning后得到的，这些tuning方法可参考 这里 。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">###### consumer吞吐率</span></span></span><br><span class="line"><span class="ruby">需要注意的是，replication factor并不会影响consumer的吞吐率测试，因为consumer只会从每个partition的leader读数据，而与replicaiton factor无关。同样，consumer吞吐率也与同步复制还是异步复制无关。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">**<span class="number">1</span>个consumer**</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">该测试从有<span class="number">6</span>个partition，<span class="number">3</span>个replication的topic消费<span class="number">50</span> million的消息。测试结果为<span class="number">940</span>,<span class="number">521</span> records/second （ <span class="number">89.7</span>MB/second ）。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">可以看到，Kafkar的consumer是非常高效的。它直接从broker的文件系统里读取文件块。Kafka使用 sendfile API 来直接通过操作系统直接传输，而不用把数据拷贝到用户空间。该项测试实际上从log的起始处开始读数据，所以它做了真实的I/O。在生产环境下，consumer可以直接读取producer刚刚写下的数据（它可能还在缓存中）。实际上，如果在生产环境下跑 I/O stat ，你可以看到基本上没有物理“读”。也就是说生产环境下consumer的吞吐率会比该项测试中的要高。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">**<span class="number">3</span>个consumer**</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">将上面的consumer复制到<span class="number">3</span>台不同的机器上，并且并行运行它们（从同一个topic上消费数据）。测试结果为 <span class="number">2</span>,<span class="number">615</span>,<span class="number">968</span> records/second （ <span class="number">249.5</span>MB/second ）。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">正如所预期的那样，consumer的吞吐率几乎线性增涨。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">###### Producer and Consumer</span></span></span><br><span class="line"><span class="ruby">上面的测试只是把producer和consumer分开测试，而该项测试同时运行producer和consumer，这更接近使用场景。实际上目前的replication系统中follower就相当于consumer在工作。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">该项测试，在具有<span class="number">6</span>个partition和<span class="number">3</span>个replica的topic上同时使用<span class="number">1</span>个producer和<span class="number">1</span>个consumer，并且使用异步复制。测试结果为 <span class="number">795</span>,<span class="number">064</span> records/second （<span class="number">75.8</span>MB/second ）。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">可以看到，该项测试结果与单独测试<span class="number">1</span>个producer时的结果几乎一致。所以说consumer非常轻量级。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">###### 消息长度对吞吐率的影响</span></span></span><br><span class="line"><span class="ruby">上面的所有测试都基于短消息（payload <span class="number">100</span>字节），而正如上文所说，短消息对Kafka来说是更难处理的使用方式，可以预期，随着消息长度的增大，records/second会减小，但MB/second会有所提高。下图是records/second与消息长度的关系图。</span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">20</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">正如我们所预期的那样，随着消息长度的增加，每秒钟所能发送的消息的数量逐渐减小。但是如果看每秒钟发送的消息的总大小，它会随着消息长度的增加而增加，如下图所示。</span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/0924-<span class="number">21</span>.jpg)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">从上图可以看出，当消息长度为<span class="number">10</span>字节时，因为要频繁入队，花了太多时间获取锁，CPU成了瓶颈，并不能充分利用带宽。但从<span class="number">100</span>字节开始，我们可以看到带宽的使用逐渐趋于饱和（虽然MB/second还是会随着消息长度的增加而增加，但增加的幅度也越来越小）。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">###### 端到端的Latency</span></span></span><br><span class="line"><span class="ruby">上文中讨论了吞吐率，那消息传输的latency如何呢？也就是说消息从producer到consumer需要多少时间呢？该项测试创建<span class="number">1</span>个producer和<span class="number">1</span>个consumer并反复计时。结果是， <span class="number">2</span> ms (median), <span class="number">3</span>ms (<span class="number">99</span>th percentile, <span class="number">14</span>ms (<span class="number">99.9</span>th percentile) 。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">（这里并没有说明topic有多少个partition，也没有说明有多少个replica，replication是同步还是异步。实际上这会极大影响producer发送的消息被commit的latency，而只有committed的消息才能被consumer所消费，所以它会最终影响端到端的latency）</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">##### Kafka 如何保证消息顺序消费</span></span></span><br><span class="line"><span class="ruby">两种方案：</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">方案一，kafka topic 只设置一个partition分区  </span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">方案二，producer将消息发送到指定partition分区</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">解析：</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">方案一：kafka默认保证同一个partition分区内的消息是有序的，则可以设置topic只使用一个分区，这样消息就是全局有序，缺点是只能被consumer group里的一个消费者消费，降低了性能，不适用高并发的情况</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">方案二：既然kafka默认保证同一个partition分区内的消息是有序的，则producer可以在发送消息时可以指定需要保证顺序的几条消息发送到同一个分区，这样消费者消费时，消息就是有序。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">producer发送消息时具体到topic的哪一个partition分区，提供了三种方式</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="number">1</span>）指定分区</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="number">2</span>）不指定分区，有指定key 则根据key的hash值与分区数进行运算后确定发送到哪个partition分区</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="number">3</span>）不指定分区，不指定key，则轮询各分区发送</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">##### 提高消费者速度</span></span></span><br><span class="line"><span class="ruby">一般来说有几类</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="number">1</span>.增加分区（题上不让）</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="number">2</span>.关闭autocommit（偏移量手工提交可以按需减少分区偏移量的更新，有利于提升消费速度）</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="number">3</span>.增加单次拉取消息的大小（大量消息的场景下可减少拉取消息的次数）</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">比较另类的：</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="number">1</span>.如果不考虑数据一致性，可以将key值平均一下，这样每个分区的消息大小都差不多，有利于负载均衡</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="number">2</span>.如果没有开启压缩，最好开启压缩（需要重启集群），可大大提高通信效率，有得消费速度提升</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">### 其他</span></span></span><br><span class="line"><span class="ruby">- JUC有研究没有，讲一讲？</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">## 数据库相关</span></span></span><br><span class="line"><span class="ruby"><span class="comment">### 读过MyBatis源码没有？</span></span></span><br><span class="line"><span class="ruby">[可以参考本文](<span class="symbol">https:</span>/<span class="regexp">/www.cnblogs.com/zhjh</span>256/p/<span class="number">8512392</span>.html)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">### 聊一聊对分库分表的理解。</span></span></span><br><span class="line"><span class="ruby">上面有</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">### mysql有哪些索引类型？有哪些存储引擎？有什么区别</span></span></span><br><span class="line"><span class="ruby">    - 索引类型</span></span><br><span class="line"><span class="ruby">        - FULLTEXT：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%<span class="string">"这类针对文本的模糊查询效率较低的问题。</span></span></span><br><span class="line"><span class="ruby">        - HASH：由于HASH的唯一（几乎<span class="number">100</span>%的唯一）及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“<span class="keyword">in</span>”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</span></span><br><span class="line"><span class="ruby">        - BTREE：BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。</span></span><br><span class="line"><span class="ruby">        - RTREE：RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，RTREE的优势在于范围查找。</span></span><br><span class="line"><span class="ruby">    - 索引种类：</span></span><br><span class="line"><span class="ruby">        - 普通索引：仅加速查询。</span></span><br><span class="line"><span class="ruby">        - 唯一索引：加速查询 + 列值唯一（可以有null）</span></span><br><span class="line"><span class="ruby">        - 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</span></span><br><span class="line"><span class="ruby">        - 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</span></span><br><span class="line"><span class="ruby">        - 全文索引：对文本的内容进行分词，进行搜索</span></span><br><span class="line"><span class="ruby">    - 存储引擎</span></span><br><span class="line"><span class="ruby">        - InnoDB</span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/<span class="number">1343758042_8526</span>.png)</span></span><br><span class="line"><span class="ruby">            - InnoDB 也采用 B+Tree这种数据结构来实现 B-Tree索引。而很大的区别在于，InnoDB 存储引擎采用“聚集索引”的数据存储方式实现B-Tree索引，所谓“聚集”，就是指数据行和相邻的键值紧凑地存储在一起，注意 InnoDB 只能聚集一个叶子页（<span class="number">16</span>K）的记录（即聚集索引满足一定的范围的记录），因此包含相邻键值的记录可能会相距甚远。</span></span><br><span class="line"><span class="ruby">            - 当InnoDB做全表扫描时并不高效，因为 InnoDB 实际上并没有顺序读取,在大多情况下是在随机读取。做全表扫描时,InnoDB 会按主键顺序扫描页面和行。这应用于所有的InnoDB 表，包括碎片化的表。如果主键页表没有碎片（存储主键和行的页表),全表扫描是相当快，因为读取顺序接近物理存储顺序。但是当主键页有碎片时，该扫描就会变得十分缓慢</span></span><br><span class="line"><span class="ruby">            - 遵循ACID原则(atomicity原子性，consistency一致性，isolation隔离性，durability持久性)，具有事务特性的能力：commit，rollback，crash-recovery。</span></span><br><span class="line"><span class="ruby">                - 仅InnoDB和NDB(Network DB clustered database engine)支持事务和MVCC</span></span><br><span class="line"><span class="ruby">            - 行级锁和Oracle风格的读一致性，提高多用户下的并发度和性能，提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read <span class="keyword">in</span> SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=<span class="number">1</span> where name like “%aaa%”。</span></span><br><span class="line"><span class="ruby">                - 只有通过索引条件检索数据，InnoDB才使用行级锁，否则仍然使用表锁</span></span><br><span class="line"><span class="ruby">                - 读一致性：query时使用snapshot快照，允许其他事务进行修改，之后再根据undo log调整数据</span></span><br><span class="line"><span class="ruby">                - 默认的隔离级别是可重复读，即同一个事务中多次读取，数据相同</span></span><br><span class="line"><span class="ruby">            - 使用主键优化查询，主键索引是聚集索引(Clustered index，仅InnoDB支持)，使查询主键时的I/O最小化</span></span><br><span class="line"><span class="ruby">                - 聚集索引是指整个表是按照这个索引来组织的，物理存储顺序与索引顺序相同，所以聚集索引字段的修改需要很大开销</span></span><br><span class="line"><span class="ruby">                - InnoDB聚集索引的实现方式，同时也体现了一张 innoDB表的结构，可以看到，InnoDB 中，主键索引和数据是一体的，没有分开。</span></span><br><span class="line"><span class="ruby">            - 支持外码约束</span></span><br><span class="line"><span class="ruby">            - 崩溃后能很好地恢复</span></span><br><span class="line"><span class="ruby">                - 未完成的事务将根据<span class="keyword">redo</span> log的数据重做</span></span><br><span class="line"><span class="ruby">                - 已提交但未写入的修改，将从doublewrite buffer重做</span></span><br><span class="line"><span class="ruby">                - 系统闲时会purge buffer</span></span><br><span class="line"><span class="ruby">            - 维护一个内存中的buffer pool缓冲池，数据被访问时，表和索引数据会被缓存</span></span><br><span class="line"><span class="ruby">            - 对增删改的change buffering策略，如果被修改数据的页不在缓冲池中，则这个修改可以存在change buffer中，等相应页被放进缓冲池(发生对该页的访问)时，再写入修改，称为merge</span></span><br><span class="line"><span class="ruby">            - adaptive hash index，经常被访问的页会自动在内存建立一个哈希索引，适于=和IN的查询。buffer pool中会预留这种索引需要的内存空间。建立在已有的B树索引基础上，哈希索引可以是部分的，B树索引不需要全部缓存在缓冲池中</span></span><br><span class="line"><span class="ruby">            - 使用checksum校验和机制检测内存或硬盘的损坏</span></span><br><span class="line"><span class="ruby">            - InnoDB是为处理巨大数据量的最大性能设计</span></span><br><span class="line"><span class="ruby">            - 可以在一个查询中join混用InnoDB引擎的表和其他引擎的表</span></span><br><span class="line"><span class="ruby">        - MyISAM</span></span><br><span class="line"><span class="ruby">![image](<span class="symbol">https:</span>/<span class="regexp">/minios.strongsickcat.com/dinghuang</span>-blog-picture/<span class="number">1343757655_1008</span>.png)</span></span><br><span class="line"><span class="ruby">            - 适用场景：read-only <span class="keyword">or</span> read-mostly workloads <span class="keyword">in</span> Web <span class="keyword">and</span> data warehousing configurations(查询效率很高，适合大量读操作的场景)</span></span><br><span class="line"><span class="ruby">            - 每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。MyISAM索引文件【.MYI (MYIndex)】和数据文件【.MYD (MYData)】是分离的，索引文件仅保存记录所在页的指针（物理位置），通过这些地址来读取页，进而读取被索引的行</span></span><br><span class="line"><span class="ruby">            - MyISAM 默认会把索引读入内存，直接在内存中操作</span></span><br><span class="line"><span class="ruby">            - Innodb强调多功能性，支持的拓展功能比较多，myisam主要侧重于性能</span></span><br><span class="line"><span class="ruby">            - 将创建<span class="number">3</span>个文件，一个.frm文件，一个.MYD(MYData)文件存数据，一个.MYI(MYIndex)文件存索引</span></span><br><span class="line"><span class="ruby">            - 数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</span></span><br><span class="line"><span class="ruby">            - 所有数据值都按小字节(low byte first)存储，因此独立于操作系统(可移植性)。但没有明显降低速度，只是需要多处理一下对齐问题，况且获取列值所花的时间不是最主要的</span></span><br><span class="line"><span class="ruby">            - 所有数字键都按大字节(high byte first)存储，利于压缩</span></span><br><span class="line"><span class="ruby">            - BLOB和TEXT列可以创建索引</span></span><br><span class="line"><span class="ruby">            - 每一个character列可以使用不同的字符编码</span></span><br><span class="line"><span class="ruby">            - 会保存表的具体行数</span></span><br><span class="line"><span class="ruby">            - 使用B树索引，string索引会被压缩，当string是索引第一项时还会压缩前缀</span></span><br><span class="line"><span class="ruby">            - 支持真正的变长字段varchar</span></span><br><span class="line"><span class="ruby">            - 支持并发的insert</span></span><br><span class="line"><span class="ruby">        - 区别</span></span><br><span class="line"><span class="ruby">            - InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在<span class="keyword">begin</span>和commit之间，组成一个事务；</span></span><br><span class="line"><span class="ruby">            - InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</span></span><br><span class="line"><span class="ruby">            - InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</span></span><br><span class="line"><span class="ruby">            - Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</span></span><br><span class="line"><span class="ruby">        - 如何选择</span></span><br><span class="line"><span class="ruby">            - 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</span></span><br><span class="line"><span class="ruby">            - 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。</span></span><br><span class="line"><span class="ruby">            - 系统奔溃后，MyISAM恢复起来更困难，能否接受；</span></span><br><span class="line"><span class="ruby">            - MySQL5.<span class="number">5</span>版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</span></span><br><span class="line"><span class="ruby">        - ARCHIVE</span></span><br><span class="line"><span class="ruby">            - 适用场景：作为仓库，存储大量的独立的作为历史记录的数据(插入速度快但查询支持较差）</span></span><br><span class="line"><span class="ruby">            - 不支持索引</span></span><br><span class="line"><span class="ruby">            - 没有存储大小限制(InnoDB是<span class="number">64</span>TB)</span></span><br><span class="line"><span class="ruby">            - 能很好地压缩数据</span></span><br><span class="line"><span class="ruby">            - 使用行级锁</span></span><br><span class="line"><span class="ruby">            - 支持INSERT, REPLACE, SELECT, 不支持 DELETE, UPDATE</span></span><br><span class="line"><span class="ruby">            - 使用zlib 无损数据压缩。数据insert后即被压缩，放在一个压缩缓冲区中，select操作会导致清空缓冲区，此时数据被真正存储。支持批处理insert。</span></span><br><span class="line"><span class="ruby">            - 行会根据需要解压，不设缓冲。select会导致全表扫描。select是读一致性的。大量查询during insertion会影响压缩。使用REPAIR TABLE或OPTIMIZE TABLE能获取更好的压缩。</span></span><br><span class="line"><span class="ruby">        - BLACKHOLE</span></span><br><span class="line"><span class="ruby">            - 适用场景<span class="symbol">:</span>转发器（会保存SQL语句的日志，并且复制给slave servers）</span></span><br><span class="line"><span class="ruby">            - 过滤器（设置使用黑洞引擎的“dummy” slave进程，依据一定规则将master的日志进行过滤并在BLACKHOLE表写一个新的日志，再复制给slaves，这样只会导致很少的开销）</span></span><br><span class="line"><span class="ruby">            - 像黑洞一样接受数据但不存储</span></span><br><span class="line"><span class="ruby">            - 创建table A会生成一个A.frm表文件，没有其他文件</span></span><br><span class="line"><span class="ruby">            - 支持所有索引</span></span><br><span class="line"><span class="ruby">            - 会保存SQL语句的日志，并且复制给slave servers，适合做转发器或过滤器</span></span><br><span class="line"><span class="ruby">            - 会导致错误，因为不论log文件是row-based还是statement-based，blackhole表不会存储自增列的数据，所以在slaves上insert时会出现重复的主码错误</span></span><br><span class="line"><span class="ruby">            - 使用row-based replication时，如果slaves的表的字段比master少，那么过滤机制其实是在slaves上。如果缺失字段是私密的，不能给slaves获取的；或是有很多slaves，需要在发送数据前就把数据过滤掉以减少网络负载，就不适合这种方式。BLACKHOLE表就能实现在master上进行过滤。</span></span><br><span class="line"><span class="ruby">        - MRG_MYISAM</span></span><br><span class="line"><span class="ruby">            - 适用场景：Good <span class="keyword">for</span> VLDB environments such as data warehousing</span></span><br><span class="line"><span class="ruby">            - 要求多个Mylsam表要有相同的列信息(包括顺序)和索引信息(包括索引的order)</span></span><br><span class="line"><span class="ruby">            - 这些信息不同不会影响表合并</span></span><br><span class="line"><span class="ruby">                - 列名和索引名</span></span><br><span class="line"><span class="ruby">                - 所有的备注comment</span></span><br><span class="line"><span class="ruby">                - 表的选项，例如 <span class="string">``</span>AVG_ROW_LENGTH<span class="string">``</span>, <span class="string">``</span>MAX_ROWS<span class="string">``</span>, <span class="keyword">or</span> <span class="string">``</span>PACK_KEYS<span class="string">``</span></span></span><br><span class="line"><span class="ruby">            - 创建merge表时会创建<span class="number">2</span>个文件，一个是存数据的.frm文件，一个是.mrg文件(存储哪些表应当merge起来使用)</span></span><br><span class="line"><span class="ruby">            - merge表中的表可以存于不同的数据库中</span></span><br><span class="line"><span class="ruby">            - 支持merge表的增删改查，前提是必须拥有处理其中所有表的权限</span></span><br><span class="line"><span class="ruby">            - drop table只是删除了merge表，实际存储数据的表不会被删除</span></span><br><span class="line"><span class="ruby">            - 建表需要指定UNION=(list-of-tables)表明使用哪些表，以及INSERT_METHOD=LAST/FIRST表明在哪一个表中插入数据，否则无法执行insert操作</span></span><br><span class="line"><span class="ruby">            - merge表没有主键，因为不能强制实行唯一索引</span></span><br><span class="line"><span class="ruby">        - FEDERATED</span></span><br><span class="line"><span class="ruby">            - 适用场景：Very good <span class="keyword">for</span> distributed <span class="keyword">or</span> data mart environments</span></span><br><span class="line"><span class="ruby">            - 数据不存储在本地，而是在远程数据库，本地访问时会pull远程数据库的数据</span></span><br><span class="line"><span class="ruby">            - 远程数据库的表可以是任何存储引擎的表</span></span><br><span class="line"><span class="ruby">            - 本地表和远程表应有相同的定义</span></span><br><span class="line"><span class="ruby">            - 本地用.frm文件存储表定义，并且包含一个指向远程数据库的连接字符串</span></span><br><span class="line"><span class="ruby">            - 本地执行操作时，会发送给远程去执行，使用MySQL client API</span></span><br><span class="line"><span class="ruby">            - 远程表可以是一个FEDERATED表，但注意不要造成一个循环</span></span><br><span class="line"><span class="ruby">            - FEDERATED表不支持一般意义上的索引，要远程表上有索引才有效</span></span><br><span class="line"><span class="ruby">            - 如果一个查询语句不能使用远程表的索引，会导致全表扫描，本地数据库会获取全表数据（存在本地内存中，如果数据量过大会引起交换和挂起），再在本地进行过滤</span></span><br><span class="line"><span class="ruby">            - 不支持alter table或drop table，执行drop table只会删除本地FEDERATED表</span></span><br><span class="line"><span class="ruby">            - 不支持分区</span></span><br><span class="line"><span class="ruby">            - 如果远程表改变，本地表无法获知</span></span><br><span class="line"><span class="ruby">        - PERFORMANCE_SCHEMA</span></span><br><span class="line"><span class="ruby">            - 关注收集mysql server运行中的性能数据，会监视server的所有events</span></span><br><span class="line"><span class="ruby">            - performance_schema数据库名及其表名都是小写的，查询时要用小写</span></span><br><span class="line"><span class="ruby">            - 很多表都是只读的，对数据库所有表的GRANT ALL授权是不允许的</span></span><br><span class="line"><span class="ruby">            - 数据库中表的更改不会写在日志中</span></span><br><span class="line"><span class="ruby">            - 是完全<span class="keyword">in</span>-memory的，不占用磁盘空间，mysql服务启动时表会被重新填充，关闭服务时便丢弃</span></span><br><span class="line"><span class="ruby">            - 数据收集的实现是在源码中添加<span class="string">"监控点"</span>(instrumentation)，没有用额外的线程(不像<span class="string">"复制"</span>或<span class="string">"事件调度"</span>)</span></span><br><span class="line"><span class="ruby">            - 用户不能创建存储该类型的表</span></span><br><span class="line"><span class="ruby">        - MEMORY</span></span><br><span class="line"><span class="ruby">            - 适用场景：存储临时、不重要的数据，例如作为缓存，适合大量读的情形 (limited updates)</span></span><br><span class="line"><span class="ruby">            - 不支持变长的数据类型variable-length data types (including BLOB <span class="keyword">and</span> TEXT)</span></span><br><span class="line"><span class="ruby">            - 不支持外码约束</span></span><br><span class="line"><span class="ruby">            - 不支持压缩</span></span><br><span class="line"><span class="ruby">            - 不支持MVCC</span></span><br><span class="line"><span class="ruby">            - 支持哈希索引和B树索引，不支持全文索引和T树索引</span></span><br><span class="line"><span class="ruby">            - mysql服务关闭或重启，数据会消失(表还在)</span></span><br><span class="line"><span class="ruby">            - 数据量不能超过内存大小</span></span><br><span class="line"><span class="ruby">            - 性能限制</span></span><br><span class="line"><span class="ruby">                - 单线程执行</span></span><br><span class="line"><span class="ruby">                - 表更新用表级锁(高并发读写情形下，表级锁严重降低性能，还不如InnoDB快)</span></span><br><span class="line"><span class="ruby">            - 内置的临时表(也在内存中)太大时会自动转成磁盘存储，但用户自创的内存表永远不会转化</span></span><br><span class="line"><span class="ruby">            - 可以从persistent data source装载数据到内存表</span></span><br><span class="line"><span class="ruby">            - 被删除的row会放进一个链表(不会回收内存)，等插入新数据时拿出来复用，只有整个表被删除后才会回收内存。采用定长的行存储，即使是varchar也是定长存储的。</span></span><br><span class="line"><span class="ruby">            - 默认使用哈希索引，并且允许非唯一的哈希索引(但如果字段含大量重复值，性能会很低，这种情况最好用B树索引)，被索引字段可以有NULL。</span></span><br><span class="line"><span class="ruby">        - CSV</span></span><br><span class="line"><span class="ruby">            - 创建一个csv表，除了.frm文件外，还创建一个.csv文件用于存储数据，还有一个.csm文件存储表状态、行数等信息，称为metafile</span></span><br><span class="line"><span class="ruby">            - 所有字段都必须NOT NULL</span></span><br><span class="line"><span class="ruby">            - 不支持索引、分区</span></span><br><span class="line"><span class="ruby">            </span></span><br><span class="line"><span class="ruby"><span class="comment">### 对索引的理解，组合索引，索引的最佳实践</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">####  索引类型</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">- B-Tree 索引：MySQL 中最主要的索引；</span></span><br><span class="line"><span class="ruby">- RTREE 索引：仅仅是 MyISAM，GIS；</span></span><br><span class="line"><span class="ruby">- 哈希索引：MyISAM，<span class="number">5.6</span> 开始的 Innodb。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">####  BTREE 索引能做什么？</span></span></span><br><span class="line"><span class="ruby">- 直接查看 KEY=<span class="number">5</span> 的所有列；</span></span><br><span class="line"><span class="ruby">- 找到 KEY &gt; <span class="number">5</span> 的列，范围查找；</span></span><br><span class="line"><span class="ruby">- 查找 <span class="number">5</span>&lt;KEY&lt;<span class="number">10</span> 之间的所有列，封闭范围查找；</span></span><br><span class="line"><span class="ruby">- 不能找到 KEY 的最后一个数字是 <span class="number">0</span> 的列（这个不是范围查找）。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">####   字符串索引</span></span></span><br><span class="line"><span class="ruby">- 字符串索引实际上也没什么不同，按照字典顺序排列，例如 ”AAAA<span class="string">" &lt; "</span>AAAB<span class="string">";</span></span></span><br><span class="line"><span class="ruby">- like 前缀是一个特殊排序，例如 LIKE “ABC%” 意味着 “ABC[LOWEST]”&lt;KEY&lt;“ABC[HIGHEST]”，但是 LIKE “%ABC” 不走索引。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">#### 多列索引</span></span></span><br><span class="line"><span class="ruby">- 按照定义的顺序从左往右进行比较，例如在 KEY(col1,col2,col3) 中，(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) &lt; (<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)；</span></span><br><span class="line"><span class="ruby">- 多列索引仍然是一个 BTREE 索引，但不是每列都是一个单独的 BTREE。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">#### MySQL 怎么使用索引</span></span></span><br><span class="line"><span class="ruby"><span class="comment">##### 在数据查询中使用索引</span></span></span><br><span class="line"><span class="ruby">用了索引 LAST_NAME</span></span><br><span class="line"><span class="ruby"><span class="string">``</span>SELECT * FROM EMPLOYEES WHERE LAST_NAME=“Smith”;<span class="string">``</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">用了索引 (DEPT,LAST_NAME)</span></span><br></pre></td></tr></table></figure></p>
<p>SELECT * FROM EMPLOYEES WHERE<br> LAST_NAME=“Smith” AND<br> DEPT=“Accounting”<br> <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">这里虽然索引字段顺序和查询的顺序颠倒，依然会走索引，不是因为最左匹配不走索引。</span><br><span class="line"></span><br><span class="line">多列索引会变的困难，对于索引 (A,B,C)：</span><br><span class="line"></span><br><span class="line">-<span class="ruby"> 下面的条件会走索引<span class="symbol">:</span></span></span><br><span class="line"><span class="ruby">    - A&gt;<span class="number">5</span></span></span><br><span class="line"><span class="ruby">    - A=<span class="number">5</span> AND B&gt;<span class="number">6</span></span></span><br><span class="line"><span class="ruby">    - A=<span class="number">5</span> AND B=<span class="number">6</span> AND C=<span class="number">7</span></span></span><br><span class="line"><span class="ruby">    - A=<span class="number">5</span> AND B IN (<span class="number">2</span>,<span class="number">3</span>) AND C&gt;<span class="number">5</span></span></span><br><span class="line"><span class="ruby">    - 下面的条件不走索引，因为不符合最左匹配，缺少第一列</span></span><br><span class="line"><span class="ruby">    - B &gt; <span class="number">5</span></span></span><br><span class="line"><span class="ruby">    - B = <span class="number">6</span> AND C = <span class="number">7</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">&gt; 在 MySQL5.<span class="number">7</span> 中使用 explain 执行了一下，发现还是会走索引的，估计 MySQL 底层做了什么优化？</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">- 下面条件会走部分索引</span></span><br><span class="line"><span class="ruby">    - A&gt;<span class="number">5</span> AND B=<span class="number">2</span></span></span><br><span class="line"><span class="ruby">    - A=<span class="number">5</span> AND B&gt;<span class="number">6</span> AND C=<span class="number">2</span></span></span><br><span class="line"><span class="ruby">    </span></span><br><span class="line"><span class="ruby">SQL 优化的第一原则：</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">MySQL 在多列索引中，一遇到 （&lt;,&gt;,between）就会停止使用 key，然而能继续使用 key 直到 <span class="keyword">in</span> 范围的右边。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">##### 在排序中使用索引</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">排序</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="string">``</span>SELECT * FROM PLAYERS ORDER BY SCORE DESC LIMIT <span class="number">10</span><span class="string">``</span></span></span><br><span class="line"><span class="ruby">- 该 SQL 会使用建立在 SCORE 列上的 索引；</span></span><br><span class="line"><span class="ruby">- 如果排序的时候没有使用索引，将会导致非常耗时的文件排序；</span></span><br><span class="line"><span class="ruby">- 在排序中经常会考虑组合索引， 例如下面的 SQL 可以考虑(COUNTRY,SCORE) 索引：</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="string">``</span>SELECT * FROM PLAYERS WHERE COUNTRY=“US” ORDER BY   SCORE DESC LIMIT <span class="number">10</span><span class="string">``</span></span></span><br><span class="line"><span class="ruby">使用多列索引进行高效的排序，在排序中使用索引有很多的限制，对于 KEY(A，B）<span class="symbol">:</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">- 下面排序会使用索引：</span></span><br><span class="line"><span class="ruby">    - ORDER BY A：主列索引；</span></span><br><span class="line"><span class="ruby">    - A=<span class="number">5</span> ORDER BY B：通过第一列过滤数据，第二列进行排序；</span></span><br><span class="line"><span class="ruby">    - ORDER BY A DESC, B DESC：用相同的排序进行排序；</span></span><br><span class="line"><span class="ruby">    - A&gt;<span class="number">5</span> ORDER BY A：主列上进行查询和排序</span></span><br><span class="line"><span class="ruby">- 下面的语句不会使用索引：</span></span><br><span class="line"><span class="ruby">    - ORDER BY B ：非主列索引排序；</span></span><br><span class="line"><span class="ruby">    - A&gt;<span class="number">5</span> ORDER BY B：第一列上使用范围，第二列进行排序；</span></span><br><span class="line"><span class="ruby">    - A IN(<span class="number">1</span>,<span class="number">2</span>) ORDER BY B：第一列上用 IN；</span></span><br><span class="line"><span class="ruby">    - ORDER BY A ASC, B DESC：两列的排列顺序不同。</span></span><br><span class="line"><span class="ruby">    </span></span><br><span class="line"><span class="ruby">使用索引进行排序的规则</span></span><br><span class="line"><span class="ruby">- 两列的排列顺序不能不一致；</span></span><br><span class="line"><span class="ruby">- 非排序的列中索引部分只能用 =，<span class="keyword">in</span> 也不能用。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">##### 表中存在多个索引</span></span></span><br><span class="line"><span class="ruby">- MySQL 中可以存在多个索引：会有索引合并；</span></span><br><span class="line"><span class="ruby">- SELECT * FROM TBL WHERE A=<span class="number">5</span> AND B=<span class="number">6</span>：该语句能分别使用在 A 和 B 上的索引，但是在 （A,B) 上建立索引是更好的；</span></span><br><span class="line"><span class="ruby">- SELECT * FROM TBL WHERE A=<span class="number">5</span> OR B=<span class="number">6</span>：该语句使用两个独立的索引，但不会使用在（A,B) 上建立的索引</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">##### 前缀索引</span></span></span><br><span class="line"><span class="ruby">可以在索引最左边一列上建立前缀索引：</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">- ALTER TABLE TITLE ADD KEY(TITLE(<span class="number">20</span>));</span></span><br><span class="line"><span class="ruby">- 需要在 BLOB/TEXT 上建立索引；</span></span><br><span class="line"><span class="ruby">- 能显著的提升效率；</span></span><br><span class="line"><span class="ruby">- 不能被用作覆盖索引；</span></span><br><span class="line"><span class="ruby">- 选择合适的前缀长度是一个问题。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">### Explain命令详解</span></span></span><br><span class="line"><span class="ruby">** EXPLAIN 输出格式**</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">EXPLAIN 命令的输出内容大致如下<span class="symbol">:</span></span></span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; explain select <em> from user_info where id = 2\G<br><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: user_info<br>   partitions: NULL<br>         type: const<br>possible_keys: PRIMARY<br>          key: PRIMARY<br>      key_len: 8<br>          ref: const<br>         rows: 1<br>     filtered: 100.00<br>        Extra: NULL<br>1 row in set, 1 warning (0.00 sec)<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">各列的含义如下:</span><br><span class="line"></span><br><span class="line">-<span class="ruby"> <span class="symbol">id:</span> SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</span></span><br><span class="line"><span class="ruby">- <span class="symbol">select_type:</span> SELECT 查询的类型.</span></span><br><span class="line"><span class="ruby">- <span class="symbol">table:</span> 查询的是哪个表</span></span><br><span class="line"><span class="ruby">- <span class="symbol">partitions:</span> 匹配的分区</span></span><br><span class="line"><span class="ruby">- <span class="symbol">type:</span> join 类型</span></span><br><span class="line"><span class="ruby">- <span class="symbol">possible_keys:</span> 此次查询中可能选用的索引</span></span><br><span class="line"><span class="ruby">- <span class="symbol">key:</span> 此次查询中确切使用到的索引.</span></span><br><span class="line"><span class="ruby">- <span class="symbol">ref:</span> 哪个字段或常数与 key 一起被使用</span></span><br><span class="line"><span class="ruby">- <span class="symbol">rows:</span> 显示此查询一共扫描了多少行. 这个是一个估计值.</span></span><br><span class="line"><span class="ruby">- <span class="symbol">filtered:</span> 表示此查询条件所过滤的数据的百分比</span></span><br><span class="line"><span class="ruby">- <span class="symbol">extra:</span> 额外的信息</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">接下来我们来重点看一下比较重要的几个字段.</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="comment">#### select_type</span></span></span><br><span class="line"><span class="ruby">select_type 表示了查询的类型, 它的常用取值有<span class="symbol">:</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">- SIMPLE, 表示此查询不包含 UNION 查询或子查询</span></span><br><span class="line"><span class="ruby">- PRIMARY, 表示此查询是最外层的查询</span></span><br><span class="line"><span class="ruby">- UNION, 表示此查询是 UNION 的第二或随后的查询</span></span><br><span class="line"><span class="ruby">- DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</span></span><br><span class="line"><span class="ruby">- UNION RESULT, UNION 的结果</span></span><br><span class="line"><span class="ruby">- SUBQUERY, 子查询中的第一个 SELECT</span></span><br><span class="line"><span class="ruby">- DEPENDENT <span class="symbol">SUBQUERY:</span> 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型, 例如<span class="symbol">:</span></span></span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; explain select <em> from user_info where id = 2\G<br><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: user_info<br>   partitions: NULL<br>         type: const<br>possible_keys: PRIMARY<br>          key: PRIMARY<br>      key_len: 8<br>          ref: const<br>         rows: 1<br>     filtered: 100.00<br>        Extra: NULL<br>1 row in set, 1 warning (0.00 sec)<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果我们使用了 <span class="built_in">UNION</span> 查询, 那么 EXPLAIN 输出 的结果类似如下:</span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; EXPLAIN (SELECT <em> FROM user_info  WHERE id IN (1, 2, 3))<br>    -&gt; UNION<br>    -&gt; (SELECT </em> FROM user_info WHERE id IN (3, 4, 5));<br>+—-+————–+————+————+——-+—————+———+———+——+——+———-+—————–+<br>| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |<br>+—-+————–+————+————+——-+—————+———+———+——+——+———-+—————–+<br>|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |<br>|  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |<br>| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |<br>+—-+————–+————+————+——-+—————+———+———+——+——+———-+—————–+<br>3 rows in set, 1 warning (0.00 sec)<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#### table</span></span><br><span class="line">表示查询涉及的表或衍生表</span><br><span class="line"></span><br><span class="line"><span class="comment">#### type</span></span><br><span class="line">type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过<span class="built_in"> type </span>字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.</span><br><span class="line"></span><br><span class="line"><span class="comment">##### type 常用类型</span></span><br><span class="line">type 常用的取值有:</span><br><span class="line"></span><br><span class="line">- system: 表中只有一条数据. 这个类型是特殊的 const 类型.</span><br><span class="line">- const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.</span><br><span class="line">- 例如下面的这个查询, 它使用了主键索引, 因此<span class="built_in"> type </span>就是 const 类型的.</span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; explain select <em> from user_info where id = 2\G<br><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: user_info<br>   partitions: NULL<br>         type: const<br>possible_keys: PRIMARY<br>          key: PRIMARY<br>      key_len: 8<br>          ref: const<br>         rows: 1<br>     filtered: 100.00<br>        Extra: NULL<br>1 row in set, 1 warning (0.00 sec)<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>eq<span class="emphasis">_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</span></span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; EXPLAIN SELECT <em> FROM user_info, order_info WHERE user_info.id = order_info.user_id\G<br><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: order_info<br>   partitions: NULL<br>         type: index<br>possible_keys: user_product_detail_index<br>          key: user_product_detail_index<br>      key_len: 314<br>          ref: NULL<br>         rows: 9<br>     filtered: 100.00<br>        Extra: Using where; Using index<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 2. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: user_info<br>   partitions: NULL<br>         type: eq_ref<br>possible_keys: PRIMARY<br>          key: PRIMARY<br>      key_len: 8<br>          ref: test.order_info.user_id<br>         rows: 1<br>     filtered: 100.00<br>        Extra: NULL<br>2 rows in set, 1 warning (0.00 sec)<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">ref</span>: 此类型通常出现在多表的 <span class="keyword">join</span> 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.</span><br><span class="line">例如下面这个例子中, 就使用到了 <span class="keyword">ref</span> 类型的查询:</span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; EXPLAIN SELECT <em> FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\G<br><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: user_info<br>   partitions: NULL<br>         type: const<br>possible_keys: PRIMARY<br>          key: PRIMARY<br>      key_len: 8<br>          ref: const<br>         rows: 1<br>     filtered: 100.00<br>        Extra: NULL<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 2. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: order_info<br>   partitions: NULL<br>         type: ref<br>possible_keys: user_product_detail_index<br>          key: user_product_detail_index<br>      key_len: 9<br>          ref: const<br>         rows: 1<br>     filtered: 100.00<br>        Extra: Using index<br>2 rows in set, 1 warning (0.01 sec)<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS <span class="literal">NULL</span>, &lt;=&gt;, BETWEEN, <span class="keyword">IN</span>() 操作中.</span><br><span class="line">当<span class="built_in"> type </span>是 range 时, 那么 EXPLAIN 输出的 ref 字段为 <span class="literal">NULL</span>, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.</span><br><span class="line"></span><br><span class="line">例如下面的例子就是一个范围查询:</span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; EXPLAIN SELECT <em><br>    -&gt;         FROM user_info<br>    -&gt;         WHERE id BETWEEN 2 AND 8 \G<br><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: user_info<br>   partitions: NULL<br>         type: range<br>possible_keys: PRIMARY<br>          key: PRIMARY<br>      key_len: 8<br>          ref: NULL<br>         rows: 7<br>     filtered: 100.00<br>        Extra: Using where<br>1 row in set, 1 warning (0.00 sec)<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="built_in">index</span>: 表示全索引扫描(full <span class="built_in">index</span> <span class="built_in">scan</span>), 和 <span class="built_in">ALL</span> 类型类似, 只不过 <span class="built_in">ALL</span> 类型是全表扫描, 而 <span class="built_in">index</span> 类型则仅仅扫描所有的索引, 而不扫描数据.</span><br><span class="line"><span class="built_in">index</span> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using <span class="built_in">index</span>.</span><br><span class="line"></span><br><span class="line">例如:</span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; EXPLAIN SELECT name FROM  user_info \G<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: user_info<br>   partitions: NULL<br>         type: index<br>possible_keys: NULL<br>          key: name_index<br>      key_len: 152<br>          ref: NULL<br>         rows: 10<br>     filtered: 100.00<br>        Extra: Using index<br>1 row in set, 1 warning (0.00 sec)<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下,<span class="built_in"> type </span>的值是 index, 并且 Extra 的值是 Using index.</span><br><span class="line"></span><br><span class="line">- ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</span><br><span class="line">下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 <span class="literal">NULL</span>, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \G<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: user_info<br>   partitions: NULL<br>         type: ALL<br>possible_keys: NULL<br>          key: NULL<br>      key_len: NULL<br>          ref: NULL<br>         rows: 10<br>     filtered: 10.00<br>        Extra: Using where<br>1 row in set, 1 warning (0.00 sec)<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">**type 类型的性能比较**</span><br><span class="line"></span><br><span class="line">通常来说, 不同的 type 类型的性能关系如下:</span><br><span class="line">``ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system``</span><br><span class="line">ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</span><br><span class="line">而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</span><br><span class="line">后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</span><br><span class="line"></span><br><span class="line">#### possible_keys</span><br><span class="line">``possible_keys`` 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 ``possible_keys`` 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</span><br><span class="line"></span><br><span class="line">#### key</span><br><span class="line">此字段是 MySQL 在当前查询时所真正使用到的索引.</span><br><span class="line"></span><br><span class="line">#### key_len</span><br><span class="line">表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.</span><br><span class="line">key_len 的计算规则如下:</span><br><span class="line"></span><br><span class="line">-<span class="ruby"> 字符串</span></span><br><span class="line"><span class="ruby">    - char(n): n 字节长度</span></span><br><span class="line"><span class="ruby">    - varchar(n): 如果是 utf8 编码, 则是 <span class="number">3</span> n + <span class="number">2</span>字节; 如果是 utf8mb4 编码, 则是 <span class="number">4</span> n + <span class="number">2</span> 字节.</span></span><br><span class="line"><span class="ruby">- 数值类型<span class="symbol">:</span></span></span><br><span class="line"><span class="ruby">    - <span class="symbol">TINYINT:</span> <span class="number">1</span>字节</span></span><br><span class="line"><span class="ruby">    - <span class="symbol">SMALLINT:</span> <span class="number">2</span>字节</span></span><br><span class="line"><span class="ruby">    - <span class="symbol">MEDIUMINT:</span> <span class="number">3</span>字节</span></span><br><span class="line"><span class="ruby">    - <span class="symbol">INT:</span> <span class="number">4</span>字节</span></span><br><span class="line"><span class="ruby">    - <span class="symbol">BIGINT:</span> <span class="number">8</span>字节 </span></span><br><span class="line"><span class="ruby">- 时间类型</span></span><br><span class="line"><span class="ruby">    - <span class="symbol">DATE:</span> <span class="number">3</span>字节</span></span><br><span class="line"><span class="ruby">    - <span class="symbol">TIMESTAMP:</span> <span class="number">4</span>字节</span></span><br><span class="line"><span class="ruby">    - <span class="symbol">DATETIME:</span> <span class="number">8</span>字节</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">我们来举两个简单的栗子<span class="symbol">:</span></span></span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; EXPLAIN SELECT <em> FROM order_info WHERE user_id &lt; 3 AND product_name = ‘p1’ AND productor = ‘WHH’ \G<br><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: order_info<br>   partitions: NULL<br>         type: range<br>possible_keys: user_product_detail_index<br>          key: user_product_detail_index<br>      key_len: 9<br>          ref: NULL<br>         rows: 5<br>     filtered: 11.11<br>        Extra: Using where; Using index<br>1 row in set, 1 warning (0.00 sec)<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面的例子是从表 ``order_info ``中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 ``order_info`` 有一个联合索引:</span><br></pre></td></tr></table></figure></p>
<p>KEY <code>user_product_detail_index</code> (<code>user_id</code>, <code>product_name</code>, <code>productor</code>)<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不过此查询语句 ``WHERE user_id &lt; <span class="number">3</span> AND product_name = <span class="string">'p1'</span> AND productor = <span class="string">'WHH'</span>`` 中, 因为先进行 ``user_id`` 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 ``user_id``, 因此在 EXPLAIN 中, 显示的 ``key_len`` 为 <span class="number">9.</span> 因为 ``user_id`` 字段是 BIGINT, 占用 <span class="number">8</span> 字节, 而 NULL 属性占用一个字节, 因此总共是 <span class="number">9</span> 个字节. 若我们将``user_id`` 字段改为 ``BIGINT(<span class="number">20</span>) NOT NULL DEFAULT <span class="string">'0'</span>``, 则 ``key_length`` 应该是<span class="number">8.</span></span><br><span class="line"></span><br><span class="line">上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</span><br><span class="line"></span><br><span class="line">接下来我们来看一下下一个例子:</span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; EXPLAIN SELECT <em> FROM order_info WHERE user_id = 1 AND product_name = ‘p1’ \G;<br><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: order_info<br>   partitions: NULL<br>         type: ref<br>possible_keys: user_product_detail_index<br>          key: user_product_detail_index<br>      key_len: 161<br>          ref: const,const<br>         rows: 2<br>     filtered: 100.00<br>        Extra: Using index<br>1 row in set, 1 warning (0.00 sec)<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">这次的查询中, 我们没有使用到范围查询, ``key_len`` 的值为 <span class="number">161.</span> 为什么呢? 因为我们的查询条件 ``WHERE user_id = <span class="number">1</span> AND product_name = <span class="string">'p1'</span>`` 中, 仅仅使用到了联合索引中的前两个字段, 因此 ``keyLen(user_id) + keyLen(product_name) = <span class="number">9</span> + <span class="number">50</span> * <span class="number">3</span> + <span class="number">2</span> = <span class="number">161</span>``</span><br><span class="line"></span><br><span class="line">#### rows</span><br><span class="line">rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.</span><br><span class="line">这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</span><br><span class="line"></span><br><span class="line">#### Extra</span><br><span class="line">EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</span><br><span class="line"></span><br><span class="line">- Using filesort</span><br><span class="line">    - 当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</span><br><span class="line"></span><br><span class="line">例如下面的例子:</span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; EXPLAIN SELECT <em> FROM order_info ORDER BY product_name \G<br><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: order_info<br>   partitions: NULL<br>         type: index<br>possible_keys: NULL<br>          key: user_product_detail_index<br>      key_len: 253<br>          ref: NULL<br>         rows: 9<br>     filtered: 100.00<br>        Extra: Using index; Using filesort<br>1 row in set, 1 warning (0.00 sec)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们的索引是</span><br></pre></td></tr></table></figure></p>
<p>KEY <code>user_product_detail_index</code> (<code>user_id</code>, <code>product_name</code>, <code>productor</code>)<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">但是上面的查询中根据 ``product_name`` 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.</span><br><span class="line">如果我们将排序依据改为`` ORDER BY user_id, product_name,`` 那么就不会出现 ``Using filesort`` 了. 例如:</span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; EXPLAIN SELECT <em> FROM order_info ORDER BY user_id, product_name \G<br><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: order_info<br>   partitions: NULL<br>         type: index<br>possible_keys: NULL<br>          key: user_product_detail_index<br>      key_len: 253<br>          ref: NULL<br>         rows: 9<br>     filtered: 100.00<br>        Extra: Using index<br>1 row in set, 1 warning (0.00 sec)<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>Using index</span><br><span class="line"><span class="code">    - "覆盖索引扫描", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</span></span><br><span class="line"><span class="bullet">- </span>Using temporary</span><br><span class="line"><span class="code">    - 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？</span></span><br><span class="line"><span class="section">#### 产生原因</span></span><br><span class="line">主要有两种情况，会导致缓存和 DB 的一致性问题：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>并发的场景下，导致读取老的 DB 数据，更新到缓存中。</span><br><span class="line"><span class="bullet">- </span>缓存和 DB 的操作，不在一个事务中，可能只有一个操作成功，而另一个操作失败，导致不一致。</span><br><span class="line"></span><br><span class="line">当然，有一点我们要注意，缓存和 DB 的一致性，我们指的更多的是最终一致性。我们使用缓存只要是提高读操作的性能，真正在写操作的业务逻辑，还是以数据库为准。例如说，我们可能缓存用户钱包的余额在缓存中，在前端查询钱包余额时，读取缓存，在使用钱包余额时，读取数据库。</span><br><span class="line"></span><br><span class="line"><span class="section">#### 更新缓存的设计模式</span></span><br><span class="line"><span class="section">##### Cache Aside Pattern(旁路缓存)</span></span><br><span class="line">这是最常用最常用的pattern了。其具体逻辑如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</span><br><span class="line"><span class="bullet">- </span>命中：应用程序从cache中取数据，取到后返回。</span><br><span class="line"><span class="bullet">- </span>更新：先把数据存到数据库中，成功后，再让缓存失效。</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225116942.png</span>)</span><br><span class="line"></span><br><span class="line">一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。</span></span><br><span class="line"></span><br><span class="line"><span class="section">##### Read/Write Through Pattern</span></span><br><span class="line">在上面的Cache Aside套路中，我们的应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。</span><br><span class="line"></span><br><span class="line">Read Through</span><br><span class="line"></span><br><span class="line">Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</span><br><span class="line"></span><br><span class="line">Write Through</span><br><span class="line"></span><br><span class="line">Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）</span><br><span class="line"></span><br><span class="line">下图自来Wikipedia的Cache词条。其中的Memory你可以理解为就是我们例子里的数据库。</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225333630.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##### Write Behind Caching Pattern</span></span><br><span class="line">Write Behind 又叫 Write Back。write back就是Linux文件系统的Page Cache的算法。</span><br><span class="line"></span><br><span class="line">Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</span></span><br><span class="line"></span><br><span class="line">但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道Unix/Linux非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍Trade-Off。</span><br><span class="line"></span><br><span class="line">另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。</span><br><span class="line"></span><br><span class="line">在wikipedia上有一张write back的流程图，基本逻辑如下：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225423934.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">#### 缓存架构设计</span></span><br><span class="line"><span class="section">##### 更新缓存 VS 淘汰缓存</span></span><br><span class="line">更新缓存：数据不但写入数据库，还会写入缓存；优点：缓存不会增加一次miss，命中率高</span><br><span class="line"></span><br><span class="line">淘汰缓存：数据只会写入数据库，不会写入缓存，只会把数据淘汰掉；优点：简单</span><br><span class="line"></span><br><span class="line">这两者的选择主要取决于“更新缓存的复杂度”。</span><br><span class="line"></span><br><span class="line">例如，上述场景，只是简单的把余额money设置成一个值，那么：</span><br><span class="line"></span><br><span class="line">（1）淘汰缓存的操作为deleteCache(uid)</span><br><span class="line"></span><br><span class="line">（2）更新缓存的操作为setCache(uid, money)</span><br><span class="line"></span><br><span class="line">更新缓存的代价很小，此时我们应该更倾向于更新缓存，以保证更高的缓存命中率</span><br><span class="line"></span><br><span class="line">如果余额是通过很复杂的数据计算得出来的，例如业务上除了账户表account，还有商品表product，折扣表discount</span><br><span class="line"></span><br><span class="line">account(uid, money)</span><br><span class="line"></span><br><span class="line">product(pid, type, price, pinfo)</span><br><span class="line"></span><br><span class="line">discount(type, zhekou)</span><br><span class="line"></span><br><span class="line">业务场景是用户买了一个商品product，这个商品的价格是price，这个商品从属于type类商品，type类商品在做促销活动要打折扣zhekou，购买了商品过后，这个余额的计算就复杂了，需要：</span><br><span class="line"></span><br><span class="line">（1）先把商品的品类，价格取出来：SELECT type, price FROM product WHERE pid=XXX</span><br><span class="line"></span><br><span class="line">（2）再把这个品类的折扣取出来：SELECT zhekou FROM discount WHERE type=XXX</span><br><span class="line"></span><br><span class="line">（3）再把原有余额从缓存中查询出来money = getCache(uid)</span><br><span class="line"></span><br><span class="line">（4）再把新的余额写入到缓存中去setCache(uid, money-price*zhekou)</span><br><span class="line"></span><br><span class="line">更新缓存的代价很大，此时我们应该更倾向于淘汰缓存。</span><br><span class="line"></span><br><span class="line">总之，淘汰缓存操作简单，并且带来的副作用只是增加了一次cache miss，建议作为通用的处理方式。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 先操作数据库 vs 先操作缓存</span></span><br><span class="line">当写操作发生时，假设淘汰缓存作为对缓存通用的处理方式，又面临两种抉择：</span><br><span class="line"></span><br><span class="line">（1）先写数据库，再淘汰缓存</span><br><span class="line"></span><br><span class="line">（2）先淘汰缓存，再写数据库</span><br><span class="line"></span><br><span class="line">对于一个不能保证事务性的操作，一定涉及“哪个任务先做，哪个任务后做”的问题，解决这个问题的方向是：如果出现不一致，谁先做对业务的影响较小，就谁先执行。</span><br><span class="line"></span><br><span class="line">由于写数据库与淘汰缓存不能保证原子性，谁先谁后同样要遵循上述原则。</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225728222.png</span>)</span><br><span class="line"></span><br><span class="line">假设先写数据库，再淘汰缓存：第一步写数据库操作成功，第二步淘汰缓存失败，则会出现DB中是新数据，Cache中是旧数据，数据不一致。</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225736738.png</span>)</span><br><span class="line"></span><br><span class="line">假设先淘汰缓存，再写数据库：第一步淘汰缓存成功，第二步写数据库失败，则只会引发一次Cache miss。</span><br><span class="line"></span><br><span class="line">结论：数据和缓存的操作时序：先淘汰缓存，再写数据库。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 缓存架构优化</span></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225756637.png</span>)</span><br><span class="line"></span><br><span class="line">上述缓存架构有一个缺点：业务方需要同时关注缓存与DB，主要有两种优化方案：</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/2019070822580935.png</span>)</span><br><span class="line"></span><br><span class="line">一种方案是服务化：加入一个服务层，向上游提供帅气的数据访问接口，向上游屏蔽底层数据存储的细节，这样业务线不需要关注数据是来自于cache还是DB。</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225823969.png</span>)</span><br><span class="line"></span><br><span class="line">另一种方案是异步缓存更新：业务线所有的写操作都走数据库，所有的读操作都总缓存，由一个异步的工具来做数据库与缓存之间数据的同步，具体细节是：</span><br><span class="line"></span><br><span class="line">（1）要有一个init cache的过程，将需要缓存的数据全量写入cache</span><br><span class="line"></span><br><span class="line">（2）如果DB有写操作，异步更新程序读取binlog，更新cache</span><br><span class="line"></span><br><span class="line">在（1）和（2）的合作下，cache中有全部的数据，这样：</span><br><span class="line"></span><br><span class="line">（a）业务线读cache，一定能够hit（很短的时间内，可能有脏数据），无需关注数据库</span><br><span class="line"></span><br><span class="line">（b）业务线写DB，cache中能得到异步更新，无需关注缓存</span><br><span class="line"></span><br><span class="line">这样将大大简化业务线的调用逻辑，存在的缺点是，如果缓存的数据业务逻辑比较复杂，async-update异步更新的逻辑可能也会比较复杂。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 结论</span></span><br><span class="line">（1）淘汰缓存是一种通用的缓存处理方式</span><br><span class="line"></span><br><span class="line">（2）先淘汰缓存，再写数据库</span><br><span class="line"></span><br><span class="line">（3）服务化是向业务方屏蔽底层数据库与缓存复杂性的一种通用方式</span><br><span class="line"></span><br><span class="line"><span class="section">#### 缓存和DB一致性的解决方案</span></span><br><span class="line"><span class="section">##### 先淘汰缓存，再写数据库</span></span><br><span class="line">因为先淘汰缓存，所以数据的最终一致性是可以得到有效的保证的。因为先淘汰缓存，即使写数据库发生异常，也就是下次缓存读取时，多读取一次数据库。</span><br><span class="line"></span><br><span class="line">但是，这种方案会存在缓存和 DB 的数据会不一致的情况，参照《缓存与数据库一致性优化》 所说。</span><br><span class="line"></span><br><span class="line">我们需要解决缓存并行写，实现串行写。比较简单的方式，引入分布式锁。</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>在写请求时，先淘汰缓存之前，获取该分布式锁。</span><br><span class="line"><span class="bullet">- </span>在读请求时，发现缓存不存在时，先获取分布式锁。</span><br><span class="line"></span><br><span class="line">这样，缓存的并行写就成功的变成串行写落。写请求时，是否主动更新缓存，根据自己业务的需要，是否有，都没问题。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 先写数据库，再更新缓存</span></span><br><span class="line">按照“先写数据库，再更新缓存”，我们要保证 DB 和缓存的操作，能够在“同一个事务”中，从而实现最终一致性。</span><br><span class="line"></span><br><span class="line">基于定时任务来实现</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>首先，写入数据库。</span><br><span class="line"><span class="bullet">- </span>然后，在写入数据库所在的事务中，插入一条记录到任务表。该记录会存储需要更新的缓存 KEY 和 VALUE 。</span><br><span class="line"><span class="bullet">- </span>【异步】最后，定时任务每秒扫描任务表，更新到缓存中，之后删除该记录。</span><br><span class="line"></span><br><span class="line">基于消息队列来实现</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>首先，写入数据库。</span><br><span class="line"><span class="bullet">- </span>然后，发送带有缓存 KEY 和 VALUE 的事务消息。此时，需要有支持事务消息特性的消息队列，或者我们自己封装消息队列，支持事务消息。</span><br><span class="line"><span class="bullet">- </span>【异步】最后，消费者消费该消息，更新到缓存中。</span><br><span class="line"></span><br><span class="line">这两种方式，可以进一步优化，可以先尝试更新缓存，如果失败，则插入任务表，或者事务消息。</span><br><span class="line"></span><br><span class="line">另外，极端情况下，如果并发写执行时，先更新成功 DB 的，结果后更新缓存：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225900770.png</span>)</span><br><span class="line"></span><br><span class="line">理论来说，希望的更新缓存顺序是，线程 1 快于线程 2 ，但是实际线程1 晚于线程 2 ，导致数据不一致。</span><br><span class="line"></span><br><span class="line">图中一直是基于定时任务或消息队列来实现异步更新缓存，如果网络抖动，导致【插入任务表，或者事务消息】的顺序不一致。</span><br><span class="line"></span><br><span class="line">那么怎么解决呢？需要做如下三件事情：</span><br><span class="line"></span><br><span class="line">1、在缓存值中，拼接上数据版本号或者时间戳。例如说：value = &#123;value: 原值, version: xxx&#125; 。</span><br><span class="line"></span><br><span class="line">2、在任务表的记录，或者事务消息中，增加上数据版本号或者时间戳的字段。</span><br><span class="line"></span><br><span class="line">3、在定时任务或消息队列执行更新缓存时，先读取缓存，对比版本号或时间戳，大于才进行更新。 当然，此处也会有并发问题，所以还是得引入分布式锁或 CAS 操作。</span><br><span class="line"></span><br><span class="line">关于 Redis 分布式锁，可以看看 [<span class="string">《精尽 Redis 面试题》</span>](<span class="link">http://svip.iocoder.cn/Redis/Interview</span>) 的 [<span class="string">「如何使用 Redis 实现分布式锁？」 </span>](<span class="link">http://svip.iocoder.cn/Cache/Interview/#</span>)问题。</span><br><span class="line"></span><br><span class="line">关于 Redis CAS 操作，可以看看 [<span class="string">《精尽 Redis 面试题》</span>](<span class="link">http://svip.iocoder.cn/Redis/Interview</span>) 的 [<span class="string">「什么是 Redis 事务？」 </span>](<span class="link">http://svip.iocoder.cn/Cache/Interview/#</span>)问题。</span><br><span class="line"></span><br><span class="line"><span class="section">##### 基于数据库的 binlog 日志</span></span><br><span class="line"><span class="section">###### 重客户端</span></span><br><span class="line"></span><br><span class="line">写入缓存：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230031559.png</span>)</span><br><span class="line"><span class="bullet">- </span>应用同时更新数据库和缓存</span><br><span class="line"><span class="bullet">- </span>如果数据库更新成功，则开始更新缓存，否则如果数据库更新失败，则整个更新过程失败。</span><br><span class="line"><span class="bullet">- </span>判断更新缓存是否成功，如果成功则返回</span><br><span class="line"><span class="bullet">- </span>如果缓存没有更新成功，则将数据发到MQ中</span><br><span class="line"><span class="bullet">- </span>应用监控MQ通道，收到消息后继续更新Redis。</span><br><span class="line"></span><br><span class="line">问题点：如果更新Redis失败，同时在将数据发到MQ之前的时间，应用重启了，这时候MQ就没有需要更新的数据，如果Redis对所有数据没有设置过期时间，同时在读多写少的场景下，只能通过人工介入来更新缓存。</span><br><span class="line"></span><br><span class="line">读缓存：</span><br><span class="line"></span><br><span class="line">如何来解决这个问题？那么在写入Redis数据的时候，在数据中增加一个时间戳插入到Redis中。在从Redis中读取数据的时候，首先要判断一下当前时间有没有过期，如果没有则从缓存中读取，如果过期了则从数据库中读取最新数据覆盖当前Redis数据并更新时间戳。具体过程如下图所示：</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230102585.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">###### 客户端数据库与缓存解耦</span></span><br><span class="line">上述方案对于应用的研发人员来讲比较重，需要研发人员同时考虑数据库和Redis是否成功来做不同方案，如何让研发人员只关注数据库层面，而不用关心缓存层呢？请看下图：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230139385.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>应用直接写数据到数据库中。</span><br><span class="line"><span class="bullet">- </span>数据库更新binlog日志。</span><br><span class="line"><span class="bullet">- </span>利用Canal中间件读取binlog日志。</span><br><span class="line"><span class="bullet">- </span>Canal借助于限流组件按频率将数据发到MQ中。</span><br><span class="line"><span class="bullet">- </span>应用监控MQ通道，将MQ的数据更新到Redis缓存中。</span><br><span class="line"></span><br><span class="line">可以看到这种方案对研发人员来说比较轻量，不用关心缓存层面，而且这个方案虽然比较重，但是却容易形成统一的解决方案。</span><br><span class="line"></span><br><span class="line">PS：下面这两种比较实用</span><br><span class="line"></span><br><span class="line">“先淘汰缓存，再写数据库”的方案，并且无需引入分布式锁。</span><br><span class="line"></span><br><span class="line">“先写数据库，再更新缓存”的方案，并且无需引入定时任务或者消息队列。</span><br><span class="line"></span><br><span class="line">使用缓存过程中，经常会遇到缓存数据的不一致性和脏读现象。一般情况下，采取缓存双淘汰机制，在更新数据库的前淘汰缓存。此外，设定超时时间，例如三十分钟。</span><br><span class="line"></span><br><span class="line">极端场景下，即使有脏数据进入缓存，这个脏数据也最存在一段时间后自动销毁。</span><br><span class="line"></span><br><span class="line"><span class="section">#### [主从DB与cache一致性优化](https://www.w3cschool.cn/architectroad/architectroad-consistency-of-cache-with-master-and-slave-database.html)</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 聚簇索引/非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 二叉搜索树</span></span><br><span class="line"> 1.所有非叶子结点至多拥有两个儿子（Left和Right）；</span><br><span class="line"></span><br><span class="line">2.所有结点存储一个关键字；</span><br><span class="line"></span><br><span class="line">3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/1.JPG</span>)</span><br><span class="line"></span><br><span class="line">二叉搜索树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；</span><br><span class="line"></span><br><span class="line">否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入</span><br><span class="line"></span><br><span class="line">右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；</span><br><span class="line"></span><br><span class="line">如果 二叉搜索树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么 二叉搜索树</span><br><span class="line"></span><br><span class="line">的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变 二叉搜索树结构</span><br><span class="line"></span><br><span class="line">（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/2.JPG</span>)</span><br><span class="line"></span><br><span class="line">但 二叉搜索树在经过多次插入与删除后，有可能导致不同的结构：</span><br><span class="line"></span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/31.JPG</span>)</span><br><span class="line"></span><br><span class="line">右边也是一个 二叉搜索树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的</span><br><span class="line"></span><br><span class="line">树结构索引；所以，使用 二叉搜索树还要考虑尽可能让 二叉搜索树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；      </span><br><span class="line"></span><br><span class="line">实际使用的 二叉搜索树都是在原二叉搜索树的基础上加上平衡算法，即“平衡二叉树”；如何保持 二叉搜索树</span><br><span class="line"></span><br><span class="line">结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在 二叉搜索树中插入和删除结点的策略；</span><br><span class="line"></span><br><span class="line"><span class="section">#### B-树</span></span><br><span class="line">是一种多路搜索树（并不是二叉的）：</span><br><span class="line"></span><br><span class="line">1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；</span><br><span class="line"></span><br><span class="line">2.根结点的儿子数为[2, M]；</span><br><span class="line"></span><br><span class="line">3.除根结点以外的非叶子结点的儿子数为[M/2, M]；</span><br><span class="line"></span><br><span class="line">4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</span><br><span class="line"></span><br><span class="line">5.非叶子结点的关键字个数=指向儿子的指针个数-1；</span><br><span class="line"></span><br><span class="line">6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] <span class="xml"><span class="tag">&lt; <span class="attr">K</span>[<span class="attr">i</span>+<span class="attr">1</span>]；</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">8.所有叶子结点位于同一层；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">如：（M=3）</span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/4.JPG)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">空，或已经是叶子结点；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">B-树的特性：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">1.关键字集合分布在整颗树中；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">2.任何一个关键字出现且只出现在一个结点中；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">3.搜索有可能在非叶子结点结束；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">4.其搜索性能等价于在关键字全集内做一次二分查找；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">5.自动层次控制；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">利用率，其最底搜索性能为：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/0.JPG)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">其中，M为设定的非叶子结点最多子树个数，N为关键字总数；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">#### B+树</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"> B+树是B-树的变体，也是一种多路搜索树：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">1.其定义基本与B-树同，除了：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">2.非叶子结点的子树指针与关键字个数相同；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">（B-树是开区间）；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">5.为所有叶子结点增加一个链指针；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">6.所有关键字都在叶子结点出现；</span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/5.JPG)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"> B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">B+的特性：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">是有序的；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">2.不可能在非叶子结点命中；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">（关键字）数据的数据层；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">4.更适合文件索引系统；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">#### B*树</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/6.JPG)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">``B*``树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">（代替B+树的1/2）；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</span></span><br><span class="line"><span class="xml">       </span></span><br><span class="line"><span class="xml">#### 小结</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">#### 聚簇索引</span></span><br><span class="line"><span class="xml">所谓聚簇索引，就是指主索引文件和数据文件为同一份文件，聚簇索引主要用在Innodb存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引，如下图所示：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">#### 非聚簇索引</span></span><br><span class="line"><span class="xml">非聚簇索引就是指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。主要用在MyISAM存储引擎中</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111257402.png)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111258238.png)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">InnoDB索引实现</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111259913.png)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111300494.png)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">- MyisAM顺序储存数据，索引叶子节点保存对应数据行地址，辅助索引跟主键索引相差无几（主键索引key不能相同）；InnoDB主键节点同时保存数据行，其他辅助索引保存的是主键索引的值；</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调(可能是指“非递增”的意思)的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调(可能是指“非递增”的意思)的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">#### 为什么选用B+/-Tree</span></span><br><span class="line"><span class="xml">一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">B-Tree：如果一次检索需要访问4个节点，数据库系统设计者利用磁盘预读原理，把节点的大小设计为一个页，那读取一个节点只需要一次I/O操作，完成这次检索操作，最多需要3次I/O(根节点常驻内存)。数据记录越小，每个节点存放的数据就越多，树的高度也就越小，I/O操作就少了，检索效率也就上去了。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">B+Tree：非叶子节点只存key，大大滴减少了非叶子节点的大小，那么每个节点就可以存放更多的记录，树更矮了，I/O操作更少了。所以B+Tree拥有更好的性能。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">### MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">#### MySQL事务隔离级别</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">事务隔离级别 | 脏读 | 不可重复读 | 幻读</span></span><br><span class="line"><span class="xml">---|---|---|---|---</span></span><br><span class="line"><span class="xml">读未提交（read-uncommitted） | 是 | 是 | 是</span></span><br><span class="line"><span class="xml">不可重复读（read-committed） | 否 | 是 | 是</span></span><br><span class="line"><span class="xml">可重复读（repeatable-read）| 否 | 否 | 是</span></span><br><span class="line"><span class="xml">串行化（serializable） | 否 | 否 | 否</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">- mysql 默认的隔离级别:可重复读</span></span><br><span class="line"><span class="xml">- Oracle 默认的隔离</span></span><br><span class="line"><span class="xml">- 级别:读已提交</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">#### MVCC</span></span><br><span class="line"><span class="xml">MVCC(Multi Version Concurrency Control的简称)，代表多版本并发控制。与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。</span></span><br><span class="line"><span class="xml">MVCC最大的优势：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">了解MVCC前，我们先学习下Mysql架构和数据库事务隔离级别</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">##### MYSQL 架构</span></span><br><span class="line"><span class="xml">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/20190706105542781.png)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">MySQL从概念上可以分为四层，顶层是接入层，不同语言的客户端通过mysql的协议与mysql服务器进行连接通信，接入层进行权限验证、连接池管理、线程管理等。下面是mysql服务层，包括sql解析器、sql优化器、数据缓冲、缓存等。再下面是mysql中的存储引擎层，mysql中存储引擎是基于表的。最后是系统文件层，保存数据、索引、日志等。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">##### MVCC是为了解决什么问题?</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">- 大多数的MYSQL事务型存储引擎,如,InnoDB，Falcon以及PBXT都不使用一种简单的行锁机制.事实上,他们都和MVCC–多版本并发控制来一起使用。</span></span><br><span class="line"><span class="xml">- 大家都应该知道,锁机制可以控制并发操作,但是其系统开销较大,而MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">##### MVCC具体实现</span></span><br><span class="line"><span class="xml">MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</span></span><br><span class="line"><span class="xml">下面看一下在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">- SELECT</span></span><br><span class="line"><span class="xml">    - InnoDB会根据以下两个条件检查每行记录：</span></span><br><span class="line"><span class="xml">        - 1、InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</span></span><br><span class="line"><span class="xml">        - 2、行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</span></span><br><span class="line"><span class="xml">        - 只有符合上述两个条件的记录，才能返回作为查询结果。</span></span><br><span class="line"><span class="xml">- INSERT</span></span><br><span class="line"><span class="xml">    - InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</span></span><br><span class="line"><span class="xml">- DELETE</span></span><br><span class="line"><span class="xml">    - InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</span></span><br><span class="line"><span class="xml">- UPDATE</span></span><br><span class="line"><span class="xml">    - InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</span></span><br><span class="line"><span class="xml">    - 保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">举例Demo</span></span><br></pre></td></tr></table></figure></p>
<p>create table riemann(<br>id int primary key auto_increment,<br>name varchar(20));<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transaction</span> <span class="number">1</span>:</span><br></pre></td></tr></table></figure></p>
<p>start transaction;<br>insert into riemann values(NULL,’riemann’);<br>insert into riemann values(NULL,’chow’);<br>commit;<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">假设系统初始事务ID为1；</span><br><span class="line"></span><br><span class="line">ID |<span class="string"> NAME </span>|<span class="string"> 创建时间(事务ID) </span>|<span class="string"> 过期时间(事务ID)</span></span><br><span class="line"><span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span></span><br><span class="line"><span class="string">1 </span>|<span class="string"> riemann </span>|<span class="string"> 1 </span>|<span class="string"> undefined</span></span><br><span class="line"><span class="string">2 </span>|<span class="string"> chow </span>|<span class="string"> 1 </span>|<span class="string"> undefined</span></span><br><span class="line"></span><br><span class="line"><span class="string">transaction 2:</span></span><br></pre></td></tr></table></figure></p>
<p>start transaction;<br>select <em> from riemann ;  //(1)<br>select </em> from riemann ;  //(2)<br>commit<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### SELECT</span><br><span class="line"></span><br><span class="line">假设当执行事务<span class="number">2</span>的过程中，准备执行语句(<span class="number">2</span>)时，开始执行事务<span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">transaction <span class="number">3</span>:</span><br></pre></td></tr></table></figure></p>
<p>start transaction;<br>insert into riemann values(NULL,’peng’);<br>commit;<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ID |<span class="string"> NAME </span>|<span class="string"> 创建时间(事务ID) </span>|<span class="string"> 过期时间(事务ID)</span></span><br><span class="line"><span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span></span><br><span class="line"><span class="string">1 </span>|<span class="string"> riemann </span>|<span class="string"> 1 </span>|<span class="string"> undefined</span></span><br><span class="line"><span class="string">2 </span>|<span class="string"> chow </span>|<span class="string"> 1 </span>|<span class="string"> undefined</span></span><br><span class="line"><span class="string">3 </span>|<span class="string"> peng </span>|<span class="string"> 3 </span>|<span class="string"> undefined</span></span><br><span class="line"></span><br><span class="line"><span class="string">事务3执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2的，所以事务3新增的记录在事务2中是查不出来的，这就通过乐观锁的方式避免了幻读的产生。</span></span><br><span class="line"></span><br><span class="line"><span class="string">###### UPDATE</span></span><br><span class="line"><span class="string">假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务4：</span></span><br><span class="line"></span><br><span class="line"><span class="string">transaction session 4:</span></span><br></pre></td></tr></table></figure></p>
<p>start transaction;<br>update riemann set name = ‘edgar’ where id = 2;<br>commit;<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要UPDATE的行的删除时间。</span><br><span class="line"></span><br><span class="line">ID |<span class="string"> NAME </span>|<span class="string"> 创建时间(事务ID) </span>|<span class="string"> 过期时间(事务ID)</span></span><br><span class="line"><span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span></span><br><span class="line"><span class="string">1 </span>|<span class="string"> riemann </span>|<span class="string"> 1 </span>|<span class="string"> undefined</span></span><br><span class="line"><span class="string">2 </span>|<span class="string"> chow </span>|<span class="string"> 1 </span>|<span class="string"> 4</span></span><br><span class="line"><span class="string">3 </span>|<span class="string"> edgar </span>|<span class="string"> 4 </span>|<span class="string"> undefined</span></span><br><span class="line"></span><br><span class="line"><span class="string">事务4执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2的，所以事务修改的记录在事务2中是查不出来的，这样就保证了事务在两次读取时读取到的数据的状态是一致的。</span></span><br><span class="line"></span><br><span class="line"><span class="string">###### DELETE</span></span><br><span class="line"><span class="string">假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务5：</span></span><br><span class="line"></span><br><span class="line"><span class="string">transaction session 5:</span></span><br></pre></td></tr></table></figure></p>
<p>start transaction;<br>delete from riemann where id = 2;<br>commit;<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ID | NAME | 创建时间(事务ID) | 过期时间(事务ID)</span><br><span class="line">---|---|---|---</span><br><span class="line">1 | riemann | 1 | undefined</span><br><span class="line">2 | chow | 1 | 5</span><br><span class="line"></span><br><span class="line">事务5执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2、并且过期时间大于等于2，所以id=2的记录在事务2 语句2中，也是可以查出来的,这样就保证了事务在两次读取时读取到的数据的状态是一致的。</span><br><span class="line"></span><br><span class="line">#### RR</span><br><span class="line">MVCC(Multi-Version Concurrent Control)：多版本并发控制，只作用于RC和RR隔离级别，主要是为了避免脏读、非重复读，而非幻读，很多文章说通过MVCC避免幻读，其实这种说法是不完善的，RR隔离级别是通过next-key lock 来避免幻读。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">优点：避免了许多需要加锁的情形</span><br><span class="line"></span><br><span class="line">缺点：需要维护每行记录版本号，造成额外资源消耗</span><br><span class="line"></span><br><span class="line">怎么避免脏读、不可重复读、幻读？</span><br><span class="line"></span><br><span class="line">采用RR隔离级别，结合MVCC特性，可以避免脏读、非重复读，有些文章说MVCC用来避免幻读，其实这是不准确的，MVCC通过多版本并发控制来避免非重复读，像幻读定义所说的情况即使有MVCC还是会存在。RR隔离级别是通过禁用innodb_locks_unsafe_for_binlog，在搜索和扫描索引的时候使用next-key locks来避免幻读（下面有对锁说明）。也就是为什么RR隔离级别下，非主键索引DML的操作并发性能会下降的原因了。</span><br><span class="line"></span><br><span class="line">为了减少Next-key lock影响，可以设置innodb_locks_unsafe_for_binlog=1，就是disable Next-Key lock，但是并不建议。</span><br><span class="line"></span><br><span class="line">想要真正避免幻读只能采取serializable串行化隔离级别，因为都要加表级共享锁或排他锁，所以性能会很差，一般不会采用。</span><br><span class="line"></span><br><span class="line">MVCC如何避免非重复读：</span><br><span class="line"></span><br><span class="line">MVCC为查询提供了一个基于时间的点的快照。这个查询只能看到在自己之前提交的数据，而在查询开始之后提交的数据是不可以看到的。</span><br><span class="line"></span><br><span class="line">在每行记录后面记录两个隐藏的列，一个记录创建时间，一个记录删除时间，记录的是版本号，这里可以理解为事物号。</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span>：Innodb 为新插入的每一行保存当前系统版本号作为行版本号；</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span>：Innodb 为删除的每一行保存当前系统版本号作为行删除标识；</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span>：Innodb 为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</span><br><span class="line"></span><br><span class="line">##### RR隔离级别下锁介绍</span><br><span class="line">###### Record Lock</span><br><span class="line"></span><br><span class="line">在主键或唯一索引上对单行记录加锁</span><br><span class="line"></span><br><span class="line">###### Gap Lock</span><br><span class="line"></span><br><span class="line">针对非唯一索引而言，锁定一个范围的记录，但不包括记录本身。锁加在未使用的空闲空间上，可能是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。</span><br><span class="line"></span><br><span class="line">如果更新两端的记录会影响到间隙锁，那么操作会被挂起，等待间隙锁释放。</span><br><span class="line"></span><br><span class="line">比如锁定范围（<span class="number">4</span>，<span class="number">7</span>），<span class="keyword">update</span> table <span class="keyword">set</span> v1=<span class="number">6</span> <span class="keyword">where</span> v1=<span class="number">1</span>; 虽然1不在此范围，但是6在（4，7）范围还是会锁定。</span><br><span class="line"></span><br><span class="line">###### Next-Key Lock</span><br><span class="line"></span><br><span class="line">针对非唯一索引而言，行记录锁与间隙锁组合起来用就叫做Next-Key Lock。锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</span><br><span class="line"></span><br><span class="line">通过一个例子介绍间隙锁</span><br><span class="line"></span><br><span class="line">表test5中存在如下数据：</span><br><span class="line"></span><br><span class="line">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/20180727113023312.png)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test5 <span class="keyword">where</span> v1=<span class="number">45</span> <span class="keyword">for</span> <span class="keyword">update</span>; 对v1=45的行加X锁，此时会对(40,45][45,50)加间隙锁，其他事物不能操作在此范围内的数据。</span><br><span class="line"></span><br><span class="line">但是为什么在左侧值为40，右侧值为50的时候，有时候操作会被挂起，有时候操作不会挂起呢？</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> table <span class="keyword">set</span> v1=<span class="number">41</span> <span class="keyword">where</span> v1=<span class="number">40</span>;41在(40，50)范围会被锁定。</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> table <span class="keyword">set</span> v1=<span class="number">39</span> <span class="keyword">where</span> v1=<span class="number">40</span>; 39不在(40，50)范围不会被锁定。</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> table <span class="keyword">set</span> v1=<span class="number">42</span> <span class="keyword">where</span> v1=<span class="number">1</span>; 42在(40，50)范围会被锁定。</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> table <span class="keyword">set</span> v1=<span class="number">30</span> <span class="keyword">where</span> v1=<span class="number">45</span>; 30不在(40，50)范围，但是45行上面存在的行级record lock，45行记录也被加了锁。</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table(id,name) <span class="keyword">values</span>(<span class="number">14</span>,<span class="number">40</span>);可以插入</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table(id,name) <span class="keyword">values</span>(<span class="number">20</span>,<span class="number">40</span>);不可以插入</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table(id,name) <span class="keyword">values</span>(<span class="number">13</span>,<span class="number">50</span>);不可以插入</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table(id,name) <span class="keyword">values</span>(<span class="number">21</span>,<span class="number">40</span>);可以插入</span><br><span class="line"></span><br><span class="line">当插入左侧值的时候，即插入v1=40的时候，要求插入的id值小于id=16的范围。当v1=40的记录有多条的时候，插入的id值要小于其中的最大id值。则可以成功插入；</span><br><span class="line"></span><br><span class="line">当插入右侧值的时候，即插入v1=50的时候，要求插入的id值要大于id=18的范围。当v1=50的记录有多条的时候，插入的id值要大于其中的最小id值。则可以成功插入。</span><br><span class="line"></span><br><span class="line">所以为什么RR隔离级别下并发性能会有所下降，就是因为存在间隙锁。我们应该尽量使用主键或唯一索引，因为唯一索引会把Next-Key Lock降级为Record Lock。</span><br><span class="line"></span><br><span class="line">###### AUTO-INC Lock</span><br><span class="line">只针对存在主键的<span class="keyword">insert</span>操作，由innodb_autoinc_lock_mode参数决定锁粒度。</span><br><span class="line"></span><br><span class="line">在了解自增锁前需要知道mysql都有哪些<span class="keyword">insert</span>操作：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 锁类型 | 描述</span><br><span class="line">---|---</span><br><span class="line"><span class="keyword">INSERT</span>-<span class="keyword">like</span> | 所有可以向表中增加行的语句</span><br><span class="line">Simple inserts | 可以预先确定要插入的行数<span class="keyword">insert</span>...<span class="keyword">values</span>…</span><br><span class="line">Bulk inserts | 事先不知道要插入的行数（<span class="keyword">INSERT</span>…<span class="keyword">SELECT</span>,<span class="built_in">REPLACE</span>…<span class="keyword">SELECT</span>,LOAD  DATA）</span><br><span class="line">Mixed-mode inserts | 一些是“Simple  inserts”语句但是有一些是<span class="literal">null</span>的自增值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">innodb_autoinc_lock_mode= <span class="number">0</span> 传统锁定模式（所有<span class="keyword">insert</span>采用传统AUTO-INC机制），所有“<span class="keyword">INSERT</span>-<span class="keyword">like</span>”语句获得一个特殊的表级AUTO-INC锁，在存在自增列的表获得一个特殊的表级AUTO-INC锁，(statement-based replication)操作是安全。</span><br><span class="line"></span><br><span class="line">innodb_autoinc_lock_mode= <span class="number">1</span> 默认锁定模式（bulk-<span class="keyword">insert</span>采用表级锁）</span><br><span class="line"></span><br><span class="line">“bulk inserts”仍然使用AUTO-INC表级锁,并保持到语句结束；“Simple inserts”（要插入的行数事先已知）通过在mutex（轻量锁）的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁，只在分配的时间内持有，不是整个语句，(statement-based replication)操作是安全。</span><br><span class="line"></span><br><span class="line">innodb_autoinc_lock_mode= <span class="number">2</span> 轻量锁定模式(所有<span class="keyword">insert</span>采用轻量级）</span><br><span class="line"></span><br><span class="line">所有类<span class="keyword">INSERT</span>(“<span class="keyword">INSERT</span>-<span class="keyword">like</span>” )语句都不会使用表级AUTO-INC lock，<span class="string">"批量插入"</span>时，在由任何给定语句分配的自动递增值中可能存在间隙，(statement-based replication)操作是不安全。</span><br><span class="line"></span><br><span class="line">可以汇总为如下表格：</span><br><span class="line">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/<span class="number">20180727113110216.</span>png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例：innodb_autoinc_lock_mode= <span class="number">1</span>时不连续</span><br></pre></td></tr></table></figure></p>
<p>创建一个表id为自增主键：</p>
<p>CREATE TABLE <code>test6</code> (</p>
<p>id int(11) NOT NULL AUTO_INCREMENT,<br>name int(11),<br>modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,<br>PRIMARY KEY (<code>id</code>)<br>) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">先插入一条记录，然后再多次自插入数据，发现id没有5、10~12，如下：</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/20180727113601623.png</span>)</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/2018072711355127.png</span>)</span><br><span class="line">![<span class="string">image</span>](<span class="link">https://minios.strongsickcat.com/dinghuang-blog-picture/2018072711351276.png</span>)</span><br><span class="line"></span><br><span class="line">这种情况就是上面锁说的，insert...select...属于Bulk insert，不能预判要插入多少条数据，所以在自增值分配上每次都会按照2^n-1分配：</span><br><span class="line"></span><br><span class="line">第一次，先分配一个自增值，因为只有一条数据，正好</span><br><span class="line"></span><br><span class="line">第二次，先分配一个自增值3，发现还有数据，继续按2^n-1分配，分配4、5，此时只剩一条数据4，但5已经被分配出去。</span><br><span class="line"></span><br><span class="line">第三次，因为5已经被分配出去，此时只能从6开始，以此类推。</span><br><span class="line"></span><br><span class="line"><span class="section">###### Dead lock</span></span><br><span class="line"></span><br><span class="line">是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。</span><br><span class="line"></span><br><span class="line">死锁检测开关innodb<span class="emphasis">_deadlock_</span>detect 5.7.15后引入，关闭会提升性能，一般应用在秒杀等场景。</span><br><span class="line"></span><br><span class="line">出现死锁场景很多，绝大多数是高并发下同时操作一行数据，加锁顺序相反引起。</span><br><span class="line"></span><br><span class="line">先删再插，两条insert当需要进行唯一性冲突检测时，需要先加一个S锁，也会产生死锁。</span><br><span class="line"></span><br><span class="line">那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</span><br><span class="line"></span><br><span class="line"><span class="section">#### MySQL 中RC和RR隔离级别的区别</span></span><br><span class="line"></span><br><span class="line">MySQL数据库中默认隔离级别为RR，但是实际情况是使用RC 和 RR隔离级别的都不少。好像淘宝、网易都是使用的 RC 隔离级别。那么在MySQL中 RC 和 RR有什么区别呢？我们该如何选择呢？为什么MySQL将RR作为默认的隔离级别呢？</span><br><span class="line"></span><br><span class="line"><span class="section">##### RC 与 RR 在锁方面的区别</span></span><br><span class="line">1&gt; 显然 RR 支持 gap lock(next-key lock)，而RC则没有gap lock。因为MySQL的RR需要gap lock来解决幻读问题。而RC隔离级别则是允许存在不可重复读和幻读的。所以RC的并发一般要好于RR；</span><br><span class="line"></span><br><span class="line">2&gt; RC 隔离级别，通过 where 条件过滤之后，不符合条件的记录上的行锁，会释放掉(虽然这里破坏了“两阶段加锁原则”)；但是RR隔离级别，即使不符合where条件的记录，也不会是否行锁和gap lock；所以从锁方面来看，RC的并发应该要好于RR；另外 insert into t select ... from s where 语句在s表上的锁也是不一样的，参见下面的例子2；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下面是来自 [<span class="string">github</span>](<span class="link">http://www.itpub.net/thread-1941624-1-1.html</span>) 的一个例子：</span><br><span class="line"></span><br><span class="line">MySQL5.6, 隔离级别RR，autocommit=off;</span><br><span class="line"></span><br><span class="line">表结构：</span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; show create table t1\G<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>       Table: t1<br>Create Table: CREATE TABLE <code>t1</code> (<br>  <code>a</code> int(11) NOT NULL,<br>  <code>b</code> int(11) NOT NULL,<br>  <code>c</code> int(11) NOT NULL,<br>  <code>d</code> int(11) NOT NULL,<br>  <code>e</code> varchar(20) DEFAULT NULL,<br>  PRIMARY KEY (<code>a</code>),<br>  KEY <code>idx_t1_bcd</code> (<code>b</code>,<code>c</code>,<code>d</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=latin1<br>1 row in set (0.00 sec)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表数据：</span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; select * from t1;<br>+—+—+—+—+——+<br>| a | b | c | d | e    |<br>+—+—+—+—+——+<br>| 1 | 1 | 1 | 1 | a    |<br>| 2 | 2 | 2 | 2 | b    |<br>| 3 | 3 | 2 | 2 | c    |<br>| 4 | 3 | 1 | 1 | d    |<br>| 5 | 2 | 3 | 5 | e    |<br>| 6 | 6 | 4 | 4 | f    |<br>| 7 | 4 | 5 | 5 | g    |<br>| 8 | 8 | 8 | 8 | h    |<br>+—+—+—+—+——+<br>8 rows in set (0.00 sec)<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">session</span> <span class="number">1</span>:</span><br></pre></td></tr></table></figure></p>
<p>delete from t1 where b&gt;2 and b&lt;5 and c=2;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行计划如下：</span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; explain select <em> from t1 where b&gt;2 and b&lt;5 and c=2\G<br><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>           id: 1<br>  select_type: SIMPLE<br>        table: t1<br>         type: range<br>possible_keys: idx_t1_bcd<br>          key: idx_t1_bcd<br>      key_len: 4<br>          ref: NULL<br>         rows: 2<br>        Extra: Using index condition<br>1 row in set (0.00 sec)<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">session</span> <span class="number">2</span>:</span><br></pre></td></tr></table></figure></p>
<p>delete from t1 where a=4<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结果 session<span class="number"> 2 </span>被锁住。</span><br><span class="line">session 3:</span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; select * from information_schema.innodb_locks;<br>+—————+————-+———–+———–+————-+————+————+———–+———-+———–+<br>| lock_id       | lock_trx_id | lock_mode | lock_type | lock_table  | lock_index | lock_space | lock_page | lock_rec | lock_data |<br>+—————+————-+———–+———–+————-+————+————+———–+———-+———–+<br>| 38777:390:3:5 | 38777       | X         | RECORD    | <code>test</code>.<code>t1</code> | PRIMARY    |        390 |         3 |        5 | 4         |<br>| 38771:390:3:5 | 38771       | X         | RECORD    | <code>test</code>.<code>t1</code> | PRIMARY    |        390 |         3 |        5 | 4         |<br>+—————+————-+———–+———–+————-+————+————+———–+———-+———–+<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">根据锁及ICP的知识，此时加锁的情况应该是在索引  ``idx_t1_bcd`` 上的``b&gt;<span class="number">2</span> and b&lt;<span class="number">5</span>``之间加``gap lock``, ``idx_t1_bcd ``上的c=<span class="number">2</span> 加 X锁主键 a=<span class="number">3</span> 加 x 锁。</span><br><span class="line">应该a=<span class="number">4</span>上是没有加X锁的，可以进行删除与更改。</span><br><span class="line">但是从session3上的结果来，此时a=<span class="number">4</span>上被加上了X锁。</span><br><span class="line">求大牛解惑，谢谢。</span><br><span class="line"></span><br><span class="line">要理解这里为什么 a=<span class="number">4</span> 被锁住了，需要理解 gap lock，锁处理 RR 隔离级别和RC隔离级别的区别等等。</span><br><span class="line"></span><br><span class="line">这里的原因如下：</span><br><span class="line"></span><br><span class="line">很简单，我们注意到：``key_len``: <span class="number">4</span> 和 Extra: Using index condition</span><br><span class="line">这说明了，仅仅使用了索引 ``idx_t1_bcd`` 中的 b 一列，没有使用到 c 这一列。c 这一列是在ICP时进行过滤的。所以：</span><br><span class="line"></span><br><span class="line">``delete <span class="keyword">from</span> t1 <span class="keyword">where</span> b&gt;<span class="number">2</span> and b&lt;<span class="number">5</span> and c=<span class="number">2</span>`` 其实锁定的行有：</span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; select * from t1 where b&gt;2 and b&lt;=6;<br>+—+—+—+—+——+<br>| a | b | c | d | e    |<br>+—+—+—+—+——+<br>| 3 | 3 | 2 | 2 | c    |<br>| 4 | 3 | 1 | 1 | d    |<br>| 6 | 6 | 4 | 4 | f    |<br>| 7 | 4 | 5 | 5 | g    |<br>+—+—+—+—+——+<br>4 rows in set (0.00 sec)<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">所以显然 ``<span class="keyword">delete</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a=<span class="number">4</span> <span class="symbol">``</span>就被阻塞了。那么为什么 <span class="symbol">``</span><span class="keyword">delete</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a=<span class="number">6</span><span class="symbol">``</span> 也会被阻塞呢？？？</span><br><span class="line"></span><br><span class="line">这里 <span class="symbol">``</span>b&lt;=<span class="number">6</span> <span class="symbol">``</span>的原因是，b 列中没有等于 <span class="number">5</span> 的记录，所以 <span class="symbol">``</span><span class="keyword">and</span> b&lt;<span class="number">5</span><span class="symbol">``</span> 实现为锁定 <span class="symbol">``</span>b&lt;=<span class="number">6</span><span class="symbol">``</span> 的所有索引记录，这里有等于号的原因是，如果我们不锁定 =<span class="number">6</span> 的索引记录，那么怎么实现锁定 <span class="symbol">``</span>&lt;<span class="number">5</span><span class="symbol">``</span> 的gap 呢？也就是说锁定 b=<span class="number">6</span> 的索引记录，是为了实现锁定 <span class="symbol">``</span>b&lt; <span class="number">5</span><span class="symbol">``</span> 的gap。也就是不能删除 b=<span class="number">6</span> 记录的原因。</span><br><span class="line">而这里 b &gt;<span class="number">2</span> 没有加等于号(b&gt;=<span class="number">2</span>) 的原因，是因为 b&gt;<span class="number">2</span>的这个gap 是由 b=<span class="number">3</span>这个索引记录(的gap)来实现的，不是由 b=<span class="number">2</span>索引记录(的gap) 来实现的，b=<span class="number">2</span>的索引记录的gap lock只能实现锁定<span class="symbol">``</span>&lt;<span class="number">2</span><span class="symbol">``</span>的gap，b&gt;<span class="number">2</span>的gap锁定功能，需要由 b=<span class="number">3</span>的索引记录对应的gap来实现(b&gt;<span class="number">2</span>，<span class="symbol">``</span>b&lt;<span class="number">3</span><span class="symbol">``</span>的gap)。</span><br><span class="line">所以我们在session2中可以删除：a=<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>的记录，但是不能删除 a=<span class="number">6</span>(因为该行的b=<span class="number">6</span>)的记录。</span><br><span class="line"></span><br><span class="line">如果我们使用 RC 隔离级别时，则不会发生阻塞，其原因就是：</span><br><span class="line"></span><br><span class="line">RC和RR隔离级别中的锁处理不一样，RC隔离级别时，在使用c列进行ICP <span class="keyword">where</span>条件过滤时，对于不符合条件的记录，锁会释放掉，而RR隔离级别时，即使不符合条件的记录，锁也不会释放(虽然违反了“<span class="number">2</span>阶段锁”原则)。所以RC隔离级别时session <span class="number">2</span>不会被阻塞。</span><br><span class="line"></span><br><span class="line">Gap lock: This <span class="keyword">is</span> a lock <span class="keyword">on</span> a gap <span class="keyword">between</span> <span class="keyword">index</span> records, <span class="keyword">or</span> a lock <span class="keyword">on</span> the gap before the <span class="keyword">first</span> <span class="keyword">or</span> after the <span class="keyword">last</span> <span class="keyword">index</span> record.</span><br><span class="line"></span><br><span class="line">例子<span class="number">2</span>：<span class="symbol">``</span><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> ... <span class="keyword">from</span> s <span class="keyword">where</span><span class="symbol">``</span> 在RC 和 RR隔离级别下的加锁过程</span><br><span class="line"></span><br><span class="line">下面是官方文档中的[说明](http://dev.mysql.com/doc/refman/<span class="number">5.6</span>/en/innodb-locks-<span class="keyword">set</span>.html)：</span><br></pre></td></tr></table></figure></p>
<p>INSERT INTO T SELECT … FROM S WHERE … sets an exclusive index record lock (without a gap lock) on each row inserted into T. If the transaction isolation level is READ COMMITTED, or innodb_locks_unsafe_for_binlog is enabled and the transaction isolation level is not SERIALIZABLE, InnoDB does the search on S as a consistent read (no locks). Otherwise, InnoDB sets shared next-key locks on rows from S. InnoDB has to set locks in the latter case: In roll-forward recovery from a backup, every SQL statement must be executed in exactly the same way it was done originally.</p>
<p>CREATE TABLE … SELECT … performs the SELECT with shared next-key locks or as a consistent read, as for INSERT … SELECT.</p>
<p>When a SELECT is used in the constructs REPLACE INTO t SELECT … FROM s WHERE … or UPDATE t … WHERE col IN (SELECT … FROM s …), InnoDB sets shared next-key locks on rows from table s.</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">``<span class="keyword">insert</span> inot t <span class="keyword">select</span> ... <span class="keyword">from</span> s <span class="keyword">where</span> ... <span class="symbol">``</span>语句和 <span class="symbol">``</span><span class="keyword">create</span> table ... <span class="keyword">select</span> ... <span class="keyword">from</span> s <span class="keyword">where</span> <span class="symbol">``</span>加锁过程是相似的(RC 和 RR 加锁不一样)：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt; RC 隔离级别时和 RR隔离级别但是设置<span class="symbol">``</span>innodb_locks_unsafe_for_binlog=<span class="number">1</span><span class="symbol">``</span> 时，<span class="symbol">``</span><span class="keyword">select</span> ... <span class="keyword">from</span> s <span class="keyword">where</span> <span class="symbol">``</span>对 s 表进行的是一致性读，所以是无需加锁的；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>&gt; 如果是RR隔离级别(默认<span class="symbol">``</span>innodb_locks_unsafe_for_binlog<span class="symbol">``</span>=<span class="number">0</span>)，或者是 serializable隔离级别，那么对 s 表上的每一行都要加上 <span class="symbol">``</span>shared next-<span class="keyword">key</span> lock<span class="symbol">``</span>.</span><br><span class="line"></span><br><span class="line">这个区别是一个很大的不同，下面是生成中的一个 <span class="symbol">``</span><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> ... <span class="keyword">from</span> s <span class="keyword">where</span> <span class="symbol">``</span>导致的系统宕机的案例：</span><br><span class="line"></span><br><span class="line">一程序猿执行一个分表操作：</span><br></pre></td></tr></table></figure>
<p>insert into tb_async_src_acct_201508 select * from tb_async_src_acct </p>
<p>where src_status=3 and create_time&gt;=’2015-08-01 00:00:00’ and create_time &lt;= ‘2015-08-31 23:59:59’;<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">表 ``tb_async_src_acct``有4000W数据。分表的目的是想提升下性能。结果一执行该语句，该条SQL被卡住，然后所有向 ``tb_async_src_acct``的写操作，要么是 get lock fail, 要么是 lost connection，全部卡住，然后主库就宕机了。</span><br><span class="line"></span><br><span class="line">显然这里的原因，就是不知道默认RR隔离级别中 ``<span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> ... <span class="keyword">from</span> s <span class="keyword">where</span> <span class="symbol">``</span>语句的在 s 表上的加锁过程，该语句一执行，所有符合 <span class="keyword">where</span> 条件的 s 表中的行记录都会加上 <span class="symbol">``</span>shared next-<span class="keyword">key</span> lock<span class="symbol">``</span>(如果没有使用到索引，还会锁住表中所有行)，在整个事务过程中一直持有，因为表 <span class="symbol">``</span>tb_async_src_acct<span class="symbol">``</span> 数据很多，所以运行过程是很长的，所以加锁过程也是很长，所以其它所有的对<span class="symbol">``</span> tb_async_src_acct<span class="symbol">``</span> 的<span class="keyword">insert</span>, <span class="keyword">delete</span>, <span class="keyword">update</span>, DDL 都会被阻塞掉，这样被阻塞的事务就越来越多，而事务也会申请其它的表中的行锁，结果就是系统中被卡住的事务越来越多，系统自然就宕机了。</span><br><span class="line"></span><br><span class="line">##### RC 与 RR 在复制方面的区别</span><br><span class="line">- RC 隔离级别不支持 statement 格式的bin <span class="built_in">log</span>，因为该格式的复制，会导致主从数据的不一致；只能使用 mixed 或者 row 格式的bin <span class="built_in">log</span>; 这也是为什么MySQL默认使用RR隔离级别的原因。复制时，我们最好使用：``binlog_format=row``</span><br><span class="line">-  MySQL5.6 的早期版本，RC隔离级别是可以设置成使用statement格式的bin log，后期版本则会直接报错；</span><br><span class="line"></span><br><span class="line">##### RC 与 RR 在一致性读方面的区别</span><br><span class="line">简单而且，RC隔离级别时，事务中的每一条<span class="keyword">select</span>语句会读取到他自己执行时已经提交了的记录，也就是每一条<span class="keyword">select</span>都有自己的一致性读ReadView; 而RR隔离级别时，事务中的一致性读的ReadView是以第一条<span class="keyword">select</span>语句的运行时，作为本事务的一致性读snapshot的建立时间点的。只能读取该时间点之前已经提交的数据。</span><br><span class="line"></span><br><span class="line">##### RC 支持半一致性读，RR不支持</span><br><span class="line">RC隔离级别下的<span class="keyword">update</span>语句，使用的是半一致性读(<span class="keyword">semi</span> consistent)；而RR隔离级别的<span class="keyword">update</span>语句使用的是当前读；当前读会发生锁的阻塞。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt; 半一致性读：</span><br><span class="line"></span><br><span class="line">&gt; A <span class="built_in">type</span> of read operation used <span class="keyword">for</span> <span class="keyword">UPDATE</span> statements, that <span class="keyword">is</span> a combination of read committed <span class="keyword">and</span> consistent read. <span class="keyword">When</span> an <span class="keyword">UPDATE</span> statement examines a row that <span class="keyword">is</span> already locked, InnoDB returns the latest committed version <span class="keyword">to</span> MySQL so that MySQL can determine whether the row matches the <span class="keyword">WHERE</span> condition of the <span class="keyword">UPDATE</span>. <span class="keyword">If</span> the row matches (must be updated), MySQL reads the row again, <span class="keyword">and</span> this time InnoDB either locks it <span class="keyword">or</span> waits <span class="keyword">for</span> a lock <span class="keyword">on</span> it. This <span class="built_in">type</span> of read operation can only happen <span class="keyword">when</span> the <span class="keyword">transaction</span> has the read committed isolation level, <span class="keyword">or</span> <span class="keyword">when</span> the innodb_locks_unsafe_for_binlog <span class="keyword">option</span> <span class="keyword">is</span> enabled.</span><br><span class="line"></span><br><span class="line">简单来说，<span class="keyword">semi</span>-consistent read是read committed与consistent read两者的结合。一个<span class="keyword">update</span>语句，如果读到一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足 <span class="keyword">update</span>的<span class="keyword">where</span>条件。若满足(需要更新)，则MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)。<span class="keyword">semi</span>-consistent read只会发生在read committed隔离级别下，或者是参数<span class="symbol">``</span>innodb_locks_unsafe_for_binlog<span class="symbol">``</span>被设置为<span class="literal">true</span>(该参数即将被废弃)。</span><br><span class="line"></span><br><span class="line">对比RR隔离级别，<span class="keyword">update</span>语句会使用当前读，如果一行被锁定了，那么此时会被阻塞，发生锁等待。而不会读取最新的提交版本，然后来判断是否符合<span class="keyword">where</span>条件。</span><br><span class="line"></span><br><span class="line">半一致性读的优点：</span><br><span class="line"></span><br><span class="line">减少了<span class="keyword">update</span>语句时行锁的冲突；对于不满足<span class="keyword">update</span>更新条件的记录，可以提前放锁，减少并发冲突的概率。</span><br><span class="line"></span><br><span class="line">具体可以[参见](http://hedengcheng.com/?p=<span class="number">220</span>)：</span><br><span class="line"></span><br><span class="line">Oracle中的<span class="keyword">update</span>好像有“重启动”的概念。</span><br><span class="line"></span><br><span class="line">### MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁</span><br><span class="line"></span><br><span class="line">#### 间隙锁</span><br><span class="line"></span><br><span class="line">之前我们介绍了排他锁，其实innodb下的记录锁（也叫行锁），间隙锁，next-<span class="keyword">key</span>锁统统属于排他锁。</span><br><span class="line"></span><br><span class="line">行锁</span><br><span class="line">记录锁其实很好理解，对表中的记录加锁，叫做记录锁，简称行锁。</span><br><span class="line"></span><br><span class="line">生活中的间隙锁</span><br><span class="line">编程的思想源于生活，生活中的例子能帮助我们更好的理解一些编程中的思想。</span><br><span class="line">生活中排队的场景，小明，小红，小花三个人依次站成一排，此时，如何让新来的小刚不能站在小红旁边，这时候只要将小红和她前面的小明之间的空隙封锁，将小红和她后面的小花之间的空隙封锁，那么小刚就不能站到小红的旁边。</span><br><span class="line">这里的小红，小明，小花，小刚就是数据库的一条条记录。</span><br><span class="line">他们之间的空隙也就是间隙，而封锁他们之间距离的锁，叫做间隙锁。</span><br><span class="line"></span><br><span class="line">Mysql中的间隙锁</span><br><span class="line">下表中（见图一），id为主键，<span class="keyword">number</span>字段上有非唯一索引的二级索引，有什么方式可以让该表不能再插入<span class="keyword">number</span>=<span class="number">5</span>的记录？</span><br><span class="line">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/<span class="number">2604566</span>-ad0d50c44dc041be.png)</span><br><span class="line"></span><br><span class="line">图一</span><br><span class="line">根据上面生活中的例子，我们自然而然可以想到，只要控制几个点，<span class="keyword">number</span>=<span class="number">5</span>之前不能插入记录，<span class="keyword">number</span>=<span class="number">5</span>现有的记录之间不能再插入新的记录，<span class="keyword">number</span>=<span class="number">5</span>之后不能插入新的记录，那么新的<span class="keyword">number</span>=<span class="number">5</span>的记录将不能被插入进来。</span><br><span class="line"></span><br><span class="line">那么，mysql是如何控制<span class="keyword">number</span>=<span class="number">5</span>之前，之中，之后不能有新的记录插入呢（防止幻读）？</span><br><span class="line">答案是用间隙锁，在RR级别下，mysql通过间隙锁可以实现锁定<span class="keyword">number</span>=<span class="number">5</span>之前的间隙，<span class="keyword">number</span>=<span class="number">5</span>记录之间的间隙，<span class="keyword">number</span>=<span class="number">5</span>之后的间隙，从而使的新的记录无法被插入进来。</span><br><span class="line"></span><br><span class="line">间隙是怎么划分的？</span><br><span class="line"></span><br><span class="line">注：为了方面理解，我们规定（id=A,<span class="keyword">number</span>=B）代表一条字段id=A,字段<span class="keyword">number</span>=B的记录，（C，D）代表一个区间，代表C-D这个区间范围。</span><br><span class="line"></span><br><span class="line">图一中，根据<span class="keyword">number</span>列，我们可以分为几个区间：（无穷小，<span class="number">2</span>），（<span class="number">2</span>，<span class="number">4</span>），（<span class="number">4</span>，<span class="number">5</span>），（<span class="number">5</span>，<span class="number">5</span>），（<span class="number">5</span>,<span class="number">11</span>），（<span class="number">11</span>，无穷大）。</span><br><span class="line">只要这些区间对应的两个临界记录中间可以插入记录，就认为区间对应的记录之间有间隙。</span><br><span class="line">例如：区间（<span class="number">2</span>，<span class="number">4</span>）分别对应的临界记录是（id=<span class="number">1</span>,<span class="keyword">number</span>=<span class="number">2</span>），（id=<span class="number">3</span>，<span class="keyword">number</span>=<span class="number">4</span>），这两条记录中间可以插入（id=<span class="number">2</span>,<span class="keyword">number</span>=<span class="number">3</span>）等记录，那么就认为（id=<span class="number">1</span>,<span class="keyword">number</span>=<span class="number">2</span>）与（id=<span class="number">3</span>，<span class="keyword">number</span>=<span class="number">4</span>）之间存在间隙。</span><br><span class="line"></span><br><span class="line">很多人会问，那记录（id=<span class="number">6</span>，<span class="keyword">number</span>=<span class="number">5</span>）与（id=<span class="number">8</span>，<span class="keyword">number</span>=<span class="number">5</span>）之间有间隙吗？</span><br><span class="line">答案是有的，（id=<span class="number">6</span>，<span class="keyword">number</span>=<span class="number">5</span>）与（id=<span class="number">8</span>，<span class="keyword">number</span>=<span class="number">5</span>）之间可以插入记录（id=<span class="number">7</span>，<span class="keyword">number</span>=<span class="number">5</span>），因此（id=<span class="number">6</span>,<span class="keyword">number</span>=<span class="number">5</span>）与（id=<span class="number">8</span>,<span class="keyword">number</span>=<span class="number">5</span>）之间有间隙的，</span><br><span class="line"></span><br><span class="line">间隙锁锁定的区域</span><br><span class="line">根据检索条件向左寻找最靠近检索条件的记录值A，作为左区间，向右寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为（A，B）。</span><br><span class="line">图一中，<span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">5</span>的话，那么间隙锁的区间范围为（<span class="number">4</span>,<span class="number">11</span>）；</span><br><span class="line"></span><br><span class="line">间隙锁的目的是为了防止幻读，其主要通过两个方面实现这个目的：</span><br><span class="line">（<span class="number">1</span>）防止间隙内有新数据被插入</span><br><span class="line">（<span class="number">2</span>）防止已存在的数据，更新成间隙内的数据（例如防止numer=<span class="number">3</span>的记录通过<span class="keyword">update</span>变成<span class="keyword">number</span>=<span class="number">5</span>）</span><br><span class="line"></span><br><span class="line">innodb自动使用间隙锁的条件：</span><br><span class="line">（<span class="number">1</span>）必须在RR级别下</span><br><span class="line">（<span class="number">2</span>）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）</span><br><span class="line"></span><br><span class="line">接下来，通过实际操作观察下间隙锁的作用范围</span><br><span class="line"></span><br><span class="line">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/<span class="number">2604566</span>-ad0d50c44dc041be.png)</span><br><span class="line"></span><br><span class="line">##### 案例一</span><br></pre></td></tr></table></figure></p>
<p>session 1:<br>start  transaction ;<br>select  * from news where number=4 for update ;</p>
<p>session 2:<br>start  transaction ;<br>insert into news value(2,4);#（阻塞）<br>insert into news value(2,2);#（阻塞）<br>insert into news value(4,4);#（阻塞）<br>insert into news value(4,5);#（阻塞）<br>insert into news value(7,5);#（执行成功）<br>insert into news value(9,5);#（执行成功）<br>insert into news value(11,5);#（执行成功）<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">检索条件<span class="built_in">number</span>=<span class="number">4</span>,向左取得最靠近的值<span class="number">2</span>作为左区间，向右取得最靠近的<span class="number">5</span>作为右区间，因此，session <span class="number">1</span>的间隙锁的范围（<span class="number">2</span>，<span class="number">4</span>），（<span class="number">4</span>，<span class="number">5</span>），如下图所示：</span><br><span class="line"></span><br><span class="line">![image](<span class="keyword">https</span>://minios.strongsickcat.com/dinghuang-blog-picture/<span class="number">2604566</span>-b1ddc3677c81c9b5.png)</span><br><span class="line"></span><br><span class="line">间隙锁锁定的区间为（<span class="number">2</span>，<span class="number">4</span>），（<span class="number">4</span>，<span class="number">5</span>），即记录（id=<span class="number">1</span>,<span class="built_in">number</span>=<span class="number">2</span>）和记录（id=<span class="number">3</span>,<span class="built_in">number</span>=<span class="number">4</span>）之间间隙会被锁定，记录（id=<span class="number">3</span>,<span class="built_in">number</span>=<span class="number">4</span>）和记录（id=<span class="number">6</span>,<span class="built_in">number</span>=<span class="number">5</span>）之间间隙被锁定。</span><br><span class="line"></span><br><span class="line">因此记录（id=<span class="number">2</span>,<span class="built_in">number</span>=<span class="number">4</span>），（id=<span class="number">2</span>,<span class="built_in">number</span>=<span class="number">2</span>），（id=<span class="number">4</span>,<span class="built_in">number</span>=<span class="number">4</span>），（id=<span class="number">4</span>,<span class="built_in">number</span>=<span class="number">5</span>）正好处在（id=<span class="number">3</span>,<span class="built_in">number</span>=<span class="number">4</span>）和（id=<span class="number">6</span>,<span class="built_in">number</span>=<span class="number">5</span>）之间，所以插入不了，需要等待锁的释放，而记录(id=<span class="number">7</span>,<span class="built_in">number</span>=<span class="number">5</span>)，（id=<span class="number">9</span>,<span class="built_in">number</span>=<span class="number">5</span>），（id=<span class="number">11</span>,<span class="built_in">number</span>=<span class="number">5</span>）不在上述锁定的范围内，因此都会插入成功。</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 案例二</span></span><br></pre></td></tr></table></figure></p>
<p>session 1:<br>start  transaction ;<br>select  * from news where number=13 for update ;</p>
<p>session 2:<br>start  transaction ;<br>insert into news value(11,5);#(执行成功)<br>insert into news value(12,11);#(执行成功)<br>insert into news value(14,11);#(阻塞)<br>insert into news value(15,12);#(阻塞)<br>update news set id=14 where number=11;#(阻塞)<br>update news set id=11 where number=11;#(执行成功)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">检索条件number=13,向左取得最靠近的值11作为左区间，向右由于没有记录因此取得无穷大作为右区间，因此，session 1的间隙锁的范围（11，无穷大），如下图所示：</span><br><span class="line">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-1f499d02104728e0.png)</span><br><span class="line"></span><br><span class="line">此表中没有number=13的记录的，innodb依然会为该记录左右两侧加间隙锁，间隙锁的范围（11，无穷大）。</span><br><span class="line"></span><br><span class="line">有人会问，为啥<span class="keyword">update</span> news <span class="keyword">set</span> <span class="keyword">id</span>=<span class="number">14</span> <span class="keyword">where</span> <span class="built_in">number</span>=<span class="number">11</span>会阻塞，但是<span class="keyword">update</span> news <span class="keyword">set</span> <span class="keyword">id</span>=<span class="number">11</span> <span class="keyword">where</span> <span class="built_in">number</span>=<span class="number">11</span>却执行成功呢？</span><br><span class="line"></span><br><span class="line">间隙锁采用在指定记录的前面和后面以及中间的间隙上加间隙锁的方式避免数据被插入，此图间隙锁锁定的区域是（<span class="number">11</span>，无穷大），也就是记录（<span class="keyword">id</span>=<span class="number">13</span>,<span class="built_in">number</span>=<span class="number">11</span>）之后不能再插入记录，<span class="keyword">update</span> news <span class="keyword">set</span> <span class="keyword">id</span>=<span class="number">14</span> <span class="keyword">where</span> <span class="built_in">number</span>=<span class="number">11</span>这条语句如果执行的话，将会被插入到（<span class="keyword">id</span>=<span class="number">13</span>,<span class="built_in">number</span>=<span class="number">11</span>）的后面，也就是在区间（<span class="number">11</span>，无穷大）之间，由于该区间被间隙锁锁定，所以只能阻塞等待，而<span class="keyword">update</span> news <span class="keyword">set</span> <span class="keyword">id</span>=<span class="number">11</span> <span class="keyword">where</span> <span class="built_in">number</span>=<span class="number">11</span>执行后是会被插入到（<span class="keyword">id</span>=<span class="number">13</span>,<span class="built_in">number</span>=<span class="number">11</span>）的记录前面，也就不在（<span class="number">11</span>，无穷大）的范围内，所以无需等待，执行成功。</span><br><span class="line"></span><br><span class="line">##### 案例三</span><br></pre></td></tr></table></figure></p>
<p>session 1:<br>start  transaction ;<br>select  * from news where number=5 for update;</p>
<p>session 2:<br>start  transaction ;<br>insert into news value(4,4);#(阻塞)<br>insert into news value(4,5);#(阻塞)<br>insert into news value(5,5);#(阻塞)<br>insert into news value(7,11);#(阻塞)<br>insert into news value(9,12);#(执行成功)<br>insert into news value(12,11);#(阻塞)<br>update news set number=5 where id=1;#(阻塞)<br>update news set id=11 where number=11;#(阻塞)<br>update news set id=2 where number=4 ;#（执行成功）<br>update news set id=4 where number=4 ;#（阻塞）<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">检索条件number=5,向左取得最靠近的值4作为左区间，向右取得11为右区间，因此，session 1的间隙锁的范围（4，5），（5，11），如下图所示：</span><br><span class="line">![image](https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-35dc3a0aed8a0f9a.png)</span><br><span class="line"></span><br><span class="line">有人会问，为啥``<span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">9</span>,<span class="number">12</span>)<span class="string">``</span>会执行成功？间隙锁采用在指定记录的前面和后面以及中间的间隙上加间隙锁的方式避免数据被插入，（<span class="keyword">id</span>=<span class="number">9</span>,<span class="built_in">number</span>=<span class="number">12</span>）很明显在记录（<span class="number">13</span>,<span class="number">11</span>）的后面，因此不再锁定的间隙范围内。</span><br><span class="line"></span><br><span class="line">为啥u<span class="string">``</span>pdate news <span class="keyword">set</span> <span class="built_in">number</span>=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span><span class="string">``</span>会阻塞？</span><br><span class="line"><span class="built_in">number</span>=<span class="number">5</span>的记录的前面，后面包括中间都被封锁了，你这个<span class="keyword">update</span> news <span class="keyword">set</span> <span class="built_in">number</span>=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>根本没法执行，因为<span class="keyword">innodb</span>已经把你可以存放的位置都锁定了，因为只能等待。</span><br><span class="line"></span><br><span class="line">同理，<span class="string">``</span><span class="keyword">update</span> news <span class="keyword">set</span> <span class="keyword">id</span>=<span class="number">11</span> <span class="keyword">where</span> <span class="built_in">number</span>=<span class="number">11</span><span class="string">``</span>由于记录（<span class="keyword">id</span>=<span class="number">10</span>,<span class="built_in">number</span>=<span class="number">5</span>）与记录（<span class="keyword">id</span>=<span class="number">13</span>,<span class="built_in">number</span>=<span class="number">11</span>）中间的间隙被封锁了，你这句<span class="keyword">sql</span>也没法执行，必须等待，因为存放的位置被封锁了。</span><br><span class="line"></span><br><span class="line">##### 案例四</span><br></pre></td></tr></table></figure></p>
<p>session 1:<br>start  transaction;<br>select * from news where number&gt;4 for update;</p>
<p>session 2:<br>start  transaction;<br>update news set id=2 where number=4 ;#(执行成功)<br>update news set id=4 where number=4 ;#(阻塞)<br>update news set id=5 where number=5 ;#(阻塞)<br>insert into news value(2,3);#(执行成功)<br>insert into news value(null,13);#(阻塞)<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">检索条件number&gt;<span class="number">4</span>,向左取得最靠近的值<span class="number">4</span>作为左区间，向右取无穷大，因此，session <span class="number">1</span>的间隙锁的范围（<span class="number">4</span>，无穷大），如下图所示：</span><br><span class="line">![image](https:<span class="comment">//minios.strongsickcat.com/dinghuang-blog-picture/2604566-3e7aaef9e3865926.png)</span></span><br><span class="line"></span><br><span class="line">session2中之所以有些阻塞，有些执行成功，其实就是因为插入的区域被锁定，从而阻塞。</span><br><span class="line"></span><br><span class="line">next-key锁</span><br><span class="line"></span><br><span class="line">next-key锁其实包含了记录锁和间隙锁，即锁定一个范围，并且锁定记录本身，InnoDB默认加锁方式是next-key 锁。</span><br><span class="line">上面的案例一session <span class="number">1</span>中的sql是：select * <span class="keyword">from</span> news <span class="keyword">where</span> number=<span class="number">4</span> for update ;</span><br><span class="line">next-key锁锁定的范围为间隙锁+记录锁，即区间（<span class="number">2</span>，<span class="number">4</span>），（<span class="number">4</span>，<span class="number">5</span>）加间隙锁，同时number=<span class="number">4</span>的记录加记录锁。</span><br><span class="line"></span><br><span class="line">#### 死锁</span><br><span class="line"></span><br><span class="line">##### 概念</span><br><span class="line">MySQL有三种锁的级别：页级、表级、行级。</span><br><span class="line"></span><br><span class="line">表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</span><br><span class="line"></span><br><span class="line">行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</span><br><span class="line"></span><br><span class="line">页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">算法：</span><br><span class="line"></span><br><span class="line">next KeyLocks锁，同时锁住记录(数据)，并且锁住记录前面的Gap    </span><br><span class="line">Gap锁，不锁记录，仅仅记录前面的Gap</span><br><span class="line"></span><br><span class="line">Recordlock锁（锁数据，不锁Gap）</span><br><span class="line"></span><br><span class="line">所以其实 Next-KeyLocks=Gap锁+ Recordlock锁</span><br><span class="line"></span><br><span class="line">###### 什么情况下会造成死锁</span><br><span class="line">所谓死锁``&lt;DeadLock&gt;``: 是指两个或两个以上的进程在执行过程中,</span><br><span class="line">因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.</span><br><span class="line">此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.</span><br><span class="line">表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.</span><br><span class="line"></span><br><span class="line">死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。</span><br><span class="line"></span><br><span class="line">那么对应的解决死锁问题的关键就是：让不同的session加锁有次序</span><br><span class="line"></span><br><span class="line">#####  一些常见的死锁案例</span><br><span class="line">###### 案例一</span><br><span class="line">需求：将投资的钱拆成几份随机分配给借款人。</span><br><span class="line"></span><br><span class="line">起初业务程序思路是这样的：</span><br><span class="line"></span><br><span class="line">投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条``select for update`` 去更新借款人表里面的余额等。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">抽象出来就是一个session通过for循环会有几条如下的语句：</span><br><span class="line">``Select * <span class="keyword">from</span> xxx <span class="keyword">where</span> id=<span class="string">'随机id'</span> for update``</span><br><span class="line"></span><br><span class="line">基本来说，程序开启后不一会就死锁。</span><br><span class="line">这可以是说最经典的死锁情形了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例如两个用户同时投资，A用户金额随机分为<span class="number">2</span>份，分给借款人<span class="number">1</span>，<span class="number">2</span></span><br><span class="line">B用户金额随机分为<span class="number">2</span>份，分给借款人<span class="number">2</span>，<span class="number">1</span>由于加锁的顺序不一样，死锁当然很快就出现了。</span><br><span class="line"></span><br><span class="line">对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。</span><br><span class="line"></span><br><span class="line">``Select * <span class="keyword">from</span> xxx <span class="keyword">where</span> id <span class="keyword">in</span> (xx,xx,xx) for update``</span><br><span class="line"></span><br><span class="line">在<span class="keyword">in</span>里面的列表值mysql是会自动从小到大排序，加锁也是一条条从小到大加的锁</span><br></pre></td></tr></table></figure></p>
<p>例如（以下会话id为主键）：</p>
<p>Session1:</p>
<p>mysql&gt; select * from t3 where id in (8,9) for update;</p>
<p>+—-+——–+——+———————+</p>
<p>| id | course | name | ctime               |</p>
<p>+—-+——–+——+———————+</p>
<p>|  8 | WA     | f    | 2016-03-02 11:36:30 |</p>
<p>|  9 | JX     | f    | 2016-03-01 11:36:30 |</p>
<p>+—-+——–+——+———————+<br>rows in set (0.04 sec)</p>
<p>Session2:</p>
<p>select * from t3 where id in (10,8,5) for update;</p>
<p>锁等待中……</p>
<p>其实这个时候id=10这条记录没有被锁住的，但id=5的记录已经被锁住了，锁的等待在id=8的这里。</p>
<p>不信请看</p>
<p>Session3:</p>
<p>mysql&gt; select * from t3 where id=5 for update;</p>
<p>锁等待中</p>
<p>Session4:</p>
<p>mysql&gt; select * from t3 where id=10 for update;</p>
<p>+—-+——–+——+———————+</p>
<p>| id | course | name | ctime               |</p>
<p>+—-+——–+——+———————+</p>
<p>| 10 | JB     | g    | 2016-03-10 11:45:05 |</p>
<p>+—-+——–+——+———————+<br>row in set (0.00 sec)</p>
<p>在其它session中id=5是加不了锁的，但是id=10是可以加上锁的。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">###### 案例2</span><br><span class="line">在开发中，经常会做这类的判断需求：根据字段值查询（有索引），如果不存在，则插入；否则更新。</span><br></pre></td></tr></table></figure></p>
<p>以id为主键为例，目前还没有id=22的行</p>
<p>Session1:</p>
<p>select * from t3 where id=22 for update;</p>
<p>Empty set (0.00 sec)</p>
<p>session2:</p>
<p>select * from t3 where id=23  for update;</p>
<p>Empty set (0.00 sec)</p>
<p>Session1:</p>
<p>insert into t3 values(22,’ac’,’a’,now());</p>
<p>锁等待中……</p>
<p>Session2:</p>
<p>insert into t3 values(23,’bc’,’b’,now());</p>
<p>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当对存在的行进行锁的时候(主键)，mysql就只有行锁。</span><br><span class="line"></span><br><span class="line">当对未存在的行进行锁的时候(即使条件为主键)，mysql是会锁住一段范围（有gap锁）</span><br><span class="line"></span><br><span class="line">锁住的范围为：</span><br><span class="line"></span><br><span class="line">(无穷小或小于表中锁住id的最大值，无穷大或大于表中锁住id的最小值)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">如：如果表中目前有已有的id为（<span class="number">11</span> ， <span class="number">12</span>）</span><br><span class="line"></span><br><span class="line">那么就锁住（<span class="number">12</span>，无穷大）</span><br><span class="line"></span><br><span class="line">如果表中目前已有的id为（<span class="number">11</span> ， <span class="number">30</span>）</span><br><span class="line"></span><br><span class="line">那么就锁住（<span class="number">11</span>，<span class="number">30</span>）</span><br><span class="line"></span><br><span class="line">对于这种死锁的解决办法是：</span><br><span class="line"></span><br><span class="line">``insert into t3(xx,xx) on duplicate key update `xx`=<span class="string">'XX'</span>;``</span><br><span class="line"></span><br><span class="line">用mysql特有的语法来解决此问题。因为insert语句对于主键来说，插入的行不管有没有存在，都会只有行锁。</span><br><span class="line"></span><br><span class="line">###### 案例<span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>mysql&gt; select * from t3 where id=9 for update;</p>
<p>+—-+——–+——+———————+</p>
<p>| id | course | name | ctime               |</p>
<p>+—-+——–+——+———————+</p>
<p>|  9 | JX     | f    | 2016-03-01 11:36:30 |</p>
<p>+—-+——–+——+———————+<br>row in set (0.00 sec)</p>
<p>Session2:</p>
<p>mysql&gt; select * from t3 where id&lt;20 for update;</p>
<p>锁等待中</p>
<p>Session1:</p>
<p>mysql&gt; insert into t3 values(7,’ae’,’a’,now());</p>
<p>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">这个跟案例一其它是差不多的情况，只是session1不按常理出牌了，</span><br><span class="line"></span><br><span class="line">Session2在等待Session1的id=<span class="number">9</span>的锁，session2又持了<span class="number">1</span>到<span class="number">8</span>的锁（注意<span class="number">9</span>到<span class="number">19</span>的范围并没有被session2锁住），最后，session1在插入新行时又得等待session2,故死锁发生了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这种一般是在业务需求中基本不会出现，因为你锁住了id=<span class="number">9</span>，却又想插入id=<span class="number">7</span>的行，这就有点跳了，当然肯定也有解决的方法，那就是重理业务需求，避免这样的写法。</span><br><span class="line"></span><br><span class="line">### 有两个表，table a，table b，写SQL查询出仅在table a中的数据、仅在table b中的数据、既在table a 又在table b 中的数据？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">## 操作系统相关</span><br><span class="line">### 什么是socket，网络传输有哪几个层级</span><br><span class="line"></span><br><span class="line">#### 什么是socket</span><br><span class="line">网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</span><br><span class="line">![image](https:<span class="comment">//minios.strongsickcat.com/dinghuang-blog-picture/6c224f4a20a446230b22bd709422720e0cf3d733.jpg)</span></span><br><span class="line"></span><br><span class="line">建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口;HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。</span><br><span class="line"></span><br><span class="line">Socket的英文原义是<span class="string">"孔"</span>或<span class="string">"插座"</span>。作为BSD UNIX的进程通信机制，取后一种意思。通常也称作<span class="string">"套接字"</span>，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。</span><br><span class="line"></span><br><span class="line">Socket正如其英文原意那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供<span class="number">220</span>伏交流电， 有的提供<span class="number">110</span>伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。</span><br><span class="line"></span><br><span class="line">#### 网络传输有哪几个层级</span><br><span class="line"></span><br><span class="line">所谓的协议就是双方进行数据传输的一种格式。</span><br><span class="line"></span><br><span class="line">网络中，一帧以太网数据包的格式：</span><br><span class="line">![image](https:<span class="comment">//minios.strongsickcat.com/dinghuang-blog-picture/656312-e4cc3edef27a091d.png)</span></span><br><span class="line"></span><br><span class="line">层级 | 名称 | 包含的协议</span><br><span class="line">---|---|---</span><br><span class="line"><span class="number">7</span> | 应用层 | 例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP</span><br><span class="line"><span class="number">6</span> | 表示层 | 例如XDR、ASN<span class="number">.1</span>、SMB、AFP、NCP</span><br><span class="line"><span class="number">5</span> | 会话层 | 例如ASAP、TLS、SSH、ISO <span class="number">8327</span> / CCITT X<span class="number">.225</span>、RPC、NetBIOS、ASP、Winsock、BSD sockets</span><br><span class="line"><span class="number">4</span> | 传输层 | 例如TCP、UDP、RTP、SCTP、SPX、ATP、IL</span><br><span class="line"><span class="number">3</span> | 网络层 | 例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、 X<span class="number">.25</span></span><br><span class="line"><span class="number">2</span> | 数据链路层 | 例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE <span class="number">802.11</span>、FDDI、PPP</span><br><span class="line"><span class="number">1</span> | 物理层	 | 例如线路、无线电、光纤、信鸽</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">层级 | 名称 | 功能</span><br><span class="line">---|---|---</span><br><span class="line"><span class="number">7</span> | 应用层 | 文件传输，电子邮件，文件服务，虚拟终端</span><br><span class="line"><span class="number">6</span> | 表示层 | 数据格式化，代码转换，数据加密</span><br><span class="line"><span class="number">5</span> | 会话层 | 解除或建立与别的结点的联系</span><br><span class="line"><span class="number">4</span> | 传输层 | 提供端对端的接口</span><br><span class="line"><span class="number">3</span> | 网络层 | 为数据包选择路由</span><br><span class="line"><span class="number">2</span> | 数据链路层 | 传输有地址的帧以及错误检测功能</span><br><span class="line"><span class="number">1</span> | 物理层	 | 以二进制数据形式在物理媒体上传输数据</span><br><span class="line"></span><br><span class="line">TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。</span><br><span class="line"></span><br><span class="line">把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。(可以这样理解:TCP和UDP都是用来传输其他协议的)</span><br><span class="line"></span><br><span class="line">而Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</span><br><span class="line"></span><br><span class="line">ip地址</span><br><span class="line"></span><br><span class="line">每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。</span><br><span class="line"></span><br><span class="line">Internet委员会定义了<span class="number">5</span>种IP地址类型以适合不同容量的网络，即A类~E类。</span><br><span class="line">其中A、B、C3类（如下表格）由InternetNIC在全球范围内统一分配，D、E类为特殊地址</span><br><span class="line"></span><br><span class="line">![image](https:<span class="comment">//minios.strongsickcat.com/dinghuang-blog-picture/656312-4926f3bcdcdc2369.png)</span></span><br><span class="line"></span><br><span class="line">#### TIME_WAIT是什么状态还记得吗，什么情况下网络会出现这个状态</span><br><span class="line">##### 出现原因分析</span><br><span class="line">TCP连接的终止 </span><br><span class="line">TCP建立一个连接至少需要交换三个分组，也因此称之为TCP的三路握手（three-way handshake），然而在TCP终止连接时，由于双方都需要发送一个FIN分节给对端确认，因此TCP终止连接一般是需要交换四个分节。具体来看： </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、 应用进程（active close）首先调用close，于是导致TCP发送一个FIN分节，表示数据已分送完毕，请求关闭套接字。 </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、 另一端应用进程（passive close）接受收到FIN，并由该端的TCP确认（确认的过程是TCP发送ACK分节给对端套接字）。FIN的接受也作为文件结束符传递给上层应用进程。这里的文件结束符并非应用进程的EOF，在TCP字节流中，EOF的读或写通过收发一个特殊的FIN分节来实现</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、 另端（passive close）应用进程在接受到文件束符后，会调用close关闭它的套接字，这导致该端的TCP也发送了一个FIN分节。 </span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、 主动关闭端（active close）接受到这个FIN后，TCP对它进行确认。（TCP发送ACK分节，值得注意的是主动关闭端在未接受到FIN之前，它的状态就是TIME_WAIT）。 </span><br><span class="line"></span><br><span class="line">![image](https:<span class="comment">//minios.strongsickcat.com/dinghuang-blog-picture/39ffa41f-7d9a-3b5f-b3c3-4dfd3605b121.gif)</span></span><br><span class="line"></span><br><span class="line">综上所述：``TIME_WAIT``状态出现场景是主动关闭端在未接受到FIN之前，它的状态就是``TIME_WAIT``。</span><br><span class="line"></span><br><span class="line">##### TCP为什么如此设计</span><br><span class="line"><span class="number">1</span>。防止上一次连接中的包(特别是最后一个ACK包)，迷路后重新出现，影响新连接  （经过<span class="number">2</span>MSL(max segment lifetime)，上一次连接中所有的重复包都会消失）。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>。可靠的关闭TCP连接  在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发</span><br><span class="line">  fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以  主动方要处于 ``TIME_WAIT`` 状态，而不能是 CLOSED 。``TIME_WAIT`` 并不会占用很大资源的，除非受到攻击。还有，如果一方 send 或 recv 超时，就会直接进入 CLOSED 状态。</span><br><span class="line"></span><br><span class="line">##### 规避大量出现TIME_WAIT的方法</span><br><span class="line"></span><br><span class="line">- ``net.ipv4.tcp_tw_reuse``和``net.ipv4.tcp_tw_recycle``的开启都是为了回收处于``TIME_WAIT``状态的资源。</span><br><span class="line">- ``net.ipv4.tcp_fin_timeout``这个时间可以减少在异常情况下服务器从``FIN-WAIT<span class="number">-2</span>``转到``TIME_WAIT``的时间。</span><br><span class="line">- ``net.ipv4.tcp_keepalive_*``一系列参数，是用来设置服务器检测连接存活的相关配置。</span><br><span class="line"></span><br><span class="line">在服务器的日常维护过程中，会经常用到下面的命令：</span><br></pre></td></tr></table></figure></p>
<p>netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它会显示例如下面的信息：</span><br></pre></td></tr></table></figure></p>
<p>TIME_WAIT 814<br>CLOSE_WAIT 1<br>FIN_WAIT1 1<br>ESTABLISHED 634<br>SYN_RECV 2<br>LAST_ACK 1<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">常用的三个状态是：``ESTABLISHED`` 表示正在通信，``TIME_WAIT`` 表示主动关闭，``CLOSE_WAIT`` 表示被动关闭。</span><br><span class="line"></span><br><span class="line">##### 三次握手的详细描述</span><br><span class="line">第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为<span class="number">1</span>，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</span><br><span class="line"></span><br><span class="line">第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+<span class="number">1</span>(Sequence Number+<span class="number">1</span>)；同时，自己自己还要发送SYN请求信息，将SYN位置为<span class="number">1</span>，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</span><br><span class="line"></span><br><span class="line">第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+<span class="number">1</span>，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</span><br><span class="line"></span><br><span class="line">##### 为什么要三次握手</span><br><span class="line">既然总结了TCP的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那TCP为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的：</span><br><span class="line"></span><br><span class="line">&gt; 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</span><br><span class="line"></span><br><span class="line">在书中同时举了一个例子，如下：</span><br><span class="line"></span><br><span class="line">&gt; “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</span><br><span class="line"></span><br><span class="line">这就很明白了，防止了服务器端的一直等待而浪费资源。</span><br><span class="line"></span><br><span class="line">##### 四次挥手的详细描述</span><br><span class="line">当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 第一次分手：主机<span class="number">1</span>（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机<span class="number">2</span>发送一个FIN报文段；此时，主机<span class="number">1</span>进入``FIN_WAIT_1``状态；这表示主机<span class="number">1</span>没有数据要发送给主机<span class="number">2</span>了；</span><br><span class="line"><span class="number">1.</span> 第二次分手：主机<span class="number">2</span>收到了主机<span class="number">1</span>发送的FIN报文段，向主机<span class="number">1</span>回一个ACK报文段，Acknowledgment Number为Sequence Number加<span class="number">1</span>；主机<span class="number">1</span>进入``FIN_WAIT_2``状态；主机<span class="number">2</span>告诉主机<span class="number">1</span>，我也没有数据要发送了，可以进行关闭连接了；</span><br><span class="line"><span class="number">1.</span> 第三次分手：主机<span class="number">2</span>向主机<span class="number">1</span>发送FIN报文段，请求关闭连接，同时主机<span class="number">2</span>进入``CLOSE_WAIT``状态；</span><br><span class="line"><span class="number">1.</span> 第四次分手：主机<span class="number">1</span>收到主机<span class="number">2</span>发送的FIN报文段，向主机<span class="number">2</span>发送ACK报文段，然后主机<span class="number">1</span>进入``TIME_WAIT``状态；主机<span class="number">2</span>收到主机<span class="number">1</span>的ACK报文段以后，就关闭连接；此时，主机<span class="number">1</span>等待<span class="number">2</span>MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机<span class="number">1</span>也可以关闭连接了。</span><br><span class="line"></span><br><span class="line">至此，TCP的四次分手就这么愉快的完成了。当你看到这里，你的脑子里会有很多的疑问，很多的不懂，感觉很凌乱；没事，我们继续总结。</span><br><span class="line"></span><br><span class="line">##### 为什么要四次分手</span><br><span class="line">那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机<span class="number">1</span>发出FIN报文段时，只是表示主机<span class="number">1</span>已经没有数据要发送了，主机<span class="number">1</span>告诉主机<span class="number">2</span>，它的数据已经全部发送完毕了；但是，这个时候主机<span class="number">1</span>还是可以接受来自主机<span class="number">2</span>的数据；当主机<span class="number">2</span>返回ACK报文段时，表示它已经知道主机<span class="number">1</span>没有数据发送了，但是主机<span class="number">2</span>还是可以发送数据到主机<span class="number">1</span>的；当主机<span class="number">2</span>也发送了FIN报文段时，这个时候就表示主机<span class="number">2</span>也没有数据要发送了，就会告诉主机<span class="number">1</span>，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</span><br><span class="line"></span><br><span class="line">- ``FIN_WAIT_1``: 这个状态要好好解释一下，其实``FIN_WAIT_1``和``FIN_WAIT_2``状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：``FIN_WAIT_1``状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到``FIN_WAIT_1``状态。而当对方回应ACK报文后，则进入到``FIN_WAIT_2``状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以``FIN_WAIT_1``状态一般是比较难见到的，而``FIN_WAIT_2``状态还有时常常可以用netstat看到。（主动方）</span><br><span class="line">- ``FIN_WAIT_2``：上面已经详细解释了这种状态，实际上``FIN_WAIT_2``状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</span><br><span class="line">- ``CLOSE_WAIT``：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到``CLOSE_WAIT``状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在``CLOSE_WAIT``状态下，需要完成的事情是等待你去关闭连接。（被动方）</span><br><span class="line">- ``LAST_ACK``: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</span><br><span class="line">- ``TIME_WAIT``: 表示收到了对方的FIN报文，并发送出了ACK报文，就等<span class="number">2</span>MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到``TIME_WAIT``状态，而无须经过``FIN_WAIT_2``状态。（主动方）</span><br><span class="line">- ``CLOSED``: 表示连接中断。</span><br><span class="line"></span><br><span class="line">### 哪些典型的应用用的是UDP？</span><br><span class="line">##### TCP应用</span><br><span class="line">（<span class="number">1</span>）FTP：文件传输协议；</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）SSH：安全登录、文件传送(SCP)和端口重定向；</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）Telnet：不安全的文本传送；</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）SMTP：简单邮件传输协议Simple Mail Transfer Protocol (E-mail)；</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）HTTP：超文本传送协议 (WWW)；</span><br><span class="line"></span><br><span class="line">![image](https:<span class="comment">//minios.strongsickcat.com/dinghuang-blog-picture/730e0cf3d7ca7bcb389cf0c8b0096b63f724a875.png)</span></span><br><span class="line"></span><br><span class="line">##### UDP应用</span><br><span class="line">（<span class="number">1</span>）流媒体</span><br><span class="line"></span><br><span class="line">采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送，延迟会越来越大。基于UDP的协议如WebRTC是极佳的选择。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）实时游戏</span><br><span class="line"></span><br><span class="line">对实时要求较为严格的情况下，采用自定义的可靠UDP协议，比如Enet、RakNet（用户有sony online game、minecraft）等，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。</span><br><span class="line"></span><br><span class="line">采用UDP的经典游戏如FPS游戏Quake、CS，著名的游戏引擎Unity3D采用的也是RakNet。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）物联网</span><br><span class="line"></span><br><span class="line"><span class="number">2014</span>年google旗下的Nest建立Thread Group，推出了物联网通信协议Thread，完善物联网通信。</span><br><span class="line"></span><br><span class="line">全球将近<span class="number">50</span>%的人都在使用互联网，人们不断的追求更快、更好的服务，一切都在变化，在越来越多的领域，UDP将会抢占TCP的主导地位。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）QQ 文件传输、QQ语音、QQ视频</span><br><span class="line"></span><br><span class="line">对于网络通讯质量要求不高的情况下，要求网络通讯速度能尽量快捷方便，就可以使用UDP技术。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 内核态和用户态、cas 和 sout 哪个用到了内核态和用户态的切换</span><br><span class="line">究竟什么是用户态，什么是内核态，这两个基本概念以前一直理解得不是很清楚，根本原因个人觉得是在于因为大部分时候我们在写程序时关注的重点和着眼的角度放在了实现的功能和代码的逻辑性上，先看一个例子：</span><br></pre></td></tr></table></figure></p>
<p>void testfork(){  </p>
<pre><code>if(0 = = fork()){  

     printf(“create new process success!\n”);  

 }  

printf(“testfork ok\n”);  
</code></pre><p> }<br><code>`</code></p>
<p>这段代码很简单，从功能的角度来看，就是实际执行了一个fork()，生成一个新的进程，从逻辑的角度看，就是判断了如果fork()返回的是则打印相关语句，然后函数最后再打印一句表示执行完整个testfork()函数。代码的执行逻辑和功能上看就是如此简单，一共四行代码，从上到下一句一句执行而已，完全看不出来哪里有体现出用户态和进程态的概念。</p>
<p>如果说前面两种是静态观察的角度看的话，我们还可以从动态的角度来看这段代码，即它被转换成CPU执行的指令后加载执行的过程，这时这段程序就是一个动态执行的指令序列。而究竟加载了哪些代码，如何加载就是和操作系统密切相关了。</p>
<h4 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h4><p>熟悉Unix/Linux系统的人都知道，fork的工作实际上是以系统调用的方式完成相应功能的，具体的工作是由sys_fork负责实施。其实无论是不是Unix或者Linux，对于任何操作系统来说，创建一个新的进程都是属于核心功能，因为它要做很多底层细致地工作，消耗系统的物理资源，比如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录页表等等，这些显然不能随便让哪个程序就能去做，于是就自然引出特权级别的概念，显然，最关键性的权力必须由高特权级的程序来执行，这样才可以做到集中管理，减少有限资源的访问和使用冲突。</p>
<p>特权级显然是非常有效的管理和控制程序执行的手段，因此在硬件上对特权级做了很多支持，就Intel x86架构的CPU来说一共有0~3四个特权级，0级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查，相关的概念有 CPL、DPL和RPL，这里不再过多阐述。硬件已经提供了一套特权级使用的相关机制，软件自然就是好好利用的问题，这属于操作系统要做的事情，对于 Unix/Linux来说，只使用了0级特权级和3级特权级。也就是说在Unix/Linux系统中，一条工作在级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力。</p>
<h4 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h4><p>现在我们从特权级的调度来理解用户态和内核态就比较好理解了，当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在级特权级上时，就可以称之为运行在内核态。</p>
<p>虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序，比如上面例子中的<code>testfork()</code>就不能直接调用 <code>sys_fork()</code>，因为前者是工作在用户态，属于用户态程序，而<code>sys_fork()</code>是工作在内核态，属于内核态程序。</p>
<p>当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态，比如testfork()最初运行在用户态进程下，当它调用fork()最终触发 sys_fork()的执行时，就切换到了内核态。</p>
<h5 id="用户态和内核态的转换"><a href="#用户态和内核态的转换" class="headerlink" title="用户态和内核态的转换"></a>用户态和内核态的转换</h5><p>1）用户态切换到内核态的3种方式</p>
<p>a. 系统调用</p>
<p>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
<p>b. 异常             </p>
<p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
<p>c. 外围设备的中断</p>
<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<p>这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。</p>
<p>2）具体的切换操作</p>
<p>从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态的步骤主要包括：</p>
<p>[1] 从当前进程的描述符中提取其内核栈的ss0及esp0信息。</p>
<p>[2] 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个</p>
<p>过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一</p>
<p>条指令。</p>
<p>[3] 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始</p>
<p>执行中断处理程序，这时就转到了内核态的程序执行了。</p>
<h2 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h2><ul>
<li>递归使用中有什么需要注意的地方，递归写法一般可以用什么去替换？</li>
<li>如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG230.png" alt="image"></li>
<li>设计一个发号器，考虑集群和高并发的情况，要求发号器生成的id是递增趋势，通过id可以区分出来是今天生成的id还是昨天生成的id，但是生成的id中不能直接带有日期，要具有一定的混淆功能，白纸写代码</li>
<li>一个二位数组，每个元素都可以往上下左右四个方向走，寻找最长递增路径。如下图所示，最长递增路径即红色字体路径。白纸写代码。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG231.png" alt="image"></li>
<li>反转链表，要求时间复杂度O(N)，空间复杂度O(1)  </li>
<li>非递归实现斐波那契数列 </li>
<li>这一周股市价格为[2,6,1,4,8]，求哪一天买入哪一天卖出，可获得最大收益，最大收益为多少</li>
<li>按照箭头方向查找二叉树<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG233.png" alt="image"></li>
<li>表a b c之间用ID关联，求阴影部分的数据<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG234.png" alt="image"></li>
<li>一个整形无序数组，里面三个数只和等于一个目标值，求这三个数</li>
<li>链表问题<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG235.png" alt="image"></li>
<li>扑克牌问题<br>有十张扑克牌，从上面开始抽，抽出一张放桌子上，然后再抽出一张放扑克牌的最下面，这样循环往复的操作，直到手里的牌都没有了。这时，桌子上牌的顺序正好是1 2 3 4 5 6 7 8 9 10。要求写代码求出原顺序</li>
<li>手写大顶堆</li>
<li>手写LRU 算法</li>
<li>字符串相加<br>两个数字类型的字符串，直接转int或者double肯定都放不下，然后求这两个数的和，返回值还是字符串，15分钟时间，要求无Bug</li>
<li>寻找目标值位置<br>有一个二维数组，数组横向有序，纵向有序，求目标值的位置，10分钟时间</li>
<li>求字符串“efabcbaefehiabcba”中最长的回文数，不去重</li>
<li>反转int类型的值x，不要借用String，只用int 即可。&amp;&amp; 针对该程序，写出其应有的测试用例</li>
<li>top K 问题</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/03/26/Spring Data Redis与Redisson对比/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/26/Spring Data Redis与Redisson对比/" itemprop="url">Spring Data Redis与Redisson对比</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-26T20:47:00+08:00">
                2019-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/26/Spring Data Redis与Redisson对比/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/03/26/Spring Data Redis与Redisson对比/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring-Data-Redis与Redisson对比"><a href="#Spring-Data-Redis与Redisson对比" class="headerlink" title="Spring Data Redis与Redisson对比"></a>Spring Data Redis与Redisson对比</h1><h2 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h2><p><a href="https://spring.io/projects/spring-data-redis" target="_blank" rel="noopener">Spring Data Redis</a>是更大的Spring Data系列的一部分，可以从Spring应用程序轻松配置和访问Redis。它提供了与商店交互的低级和高级抽象，使用户免于基础设施问题。Spring Boot 从 2.0版本开始，将默认的Redis客户端Jedis替换问Lettuce。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>连接包作为多个Redis驱动程序/连接器的低级抽象（<a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">Jedis</a>和<a href="https://github.com/mp911de/lettuce" target="_blank" rel="noopener">Lettuce</a>。不推荐支持<a href="https://github.com/alphazero/jredis" target="_blank" rel="noopener">JRedis</a>和<a href="https://github.com/spullara/redis-protocol" target="_blank" rel="noopener">SRP</a>。）</li>
<li><a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:connectors" target="_blank" rel="noopener">异常</a>转换到Spring的便携式数据访问异常层次结构Redis的驱动程序例外</li>
<li><a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:template" target="_blank" rel="noopener">RedisTemplate</a>，提供高级抽象，用于执行各种Redis操作，异常转换和序列化支持</li>
<li><a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#pubsub" target="_blank" rel="noopener">Pubsub</a>支持（例如消息驱动的POJO的MessageListenerContainer）</li>
<li><a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:sentinel" target="_blank" rel="noopener">Redis Sentinel</a>和<a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#cluster" target="_blank" rel="noopener">Redis Cluster</a>支持</li>
<li>JDK，String，JSON和Spring Object / XML映射<a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:serializer" target="_blank" rel="noopener">序列化程序</a></li>
<li>在Redis之上的JDK Collection实现</li>
<li>原子<a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:support" target="_blank" rel="noopener">计数器</a>支持classes</li>
<li>排序和流水线功能</li>
<li>专门支持SORT，SORT / GET模式和返回的批量值</li>
<li>Redis <a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:support:cache-abstraction" target="_blank" rel="noopener">实现</a>了Spring 3.1缓存抽象</li>
<li>自动实现Repository接口，包括支持自定义查找程序方法@EnableRedisRepositories</li>
<li>CDI对存储库的支持</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在<code>pom.xml</code>中加入<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>application.yml</code>中加入<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">6</span>  <span class="comment">#Redis索引0~15，默认为0</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    password:</span>  <span class="comment">#密码（默认为空）</span></span><br><span class="line"><span class="attr">    pool:</span></span><br><span class="line"><span class="attr">      max-active:</span> <span class="number">8</span>   <span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">      max-wait:</span> <span class="bullet">-1</span><span class="string">ms</span>  <span class="comment">#连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">      max-idle:</span> <span class="number">5</span>     <span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="attr">      min-idle:</span> <span class="number">0</span>     <span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">10000</span><span class="string">ms</span>    <span class="comment">#连接超时时间（毫秒）</span></span><br></pre></td></tr></table></figure></p>
<p>加入配置类<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RedisConfiguration</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RedisTemplate配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param redisConnectionFactory redisConnectionFactory</span></span><br><span class="line"><span class="comment">     * @return RedisTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    public <span class="type">RedisTemplate</span>&lt;<span class="type">String</span>, <span class="type">Object</span>&gt; redisTemplate(<span class="type">RedisConnectionFactory</span> redisConnectionFactory) &#123;</span><br><span class="line">        <span class="comment">// 配置redisTemplate</span></span><br><span class="line">        <span class="type">RedisTemplate</span>&lt;<span class="type">String</span>, <span class="type">Object</span>&gt; redisTemplate = <span class="keyword">new</span> <span class="type">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//key序列化</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="type">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">//value序列化</span></span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> <span class="type">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码使用<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> test()&#123;</span><br><span class="line">    <span class="comment">//设置键值对</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"test:set1"</span>, <span class="string">"testValue1"</span>);</span><br><span class="line">    <span class="comment">//设置键值对数组</span></span><br><span class="line">    redisTemplate.opsForSet().add(<span class="string">"test:set2"</span>, <span class="string">"asdf"</span>);</span><br><span class="line">    <span class="comment">//数据hash存入</span></span><br><span class="line">    redisTemplate.opsForHash().<span class="built_in">put</span>(<span class="string">"hash1"</span>, <span class="string">"name1"</span>, <span class="string">"lms1"</span>);</span><br><span class="line">    redisTemplate.opsForHash().<span class="built_in">put</span>(<span class="string">"hash1"</span>, <span class="string">"name2"</span>, <span class="string">"lms2"</span>);</span><br><span class="line">    redisTemplate.opsForHash().<span class="built_in">put</span>(<span class="string">"hash1"</span>, <span class="string">"name3"</span>, <span class="string">"lms3"</span>);</span><br><span class="line">    <span class="comment">//获取</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(redisTemplate.opsForValue().<span class="built_in">get</span>(<span class="string">"test:set"</span>));</span><br><span class="line">    <span class="comment">//hash获取</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(redisTemplate.opsForHash().<span class="built_in">get</span>(<span class="string">"hash1"</span>, <span class="string">"name1"</span>));</span><br><span class="line">    <span class="comment">//发布、订阅消息（更多请参考 https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/</span></span><br><span class="line">    <span class="keyword">String</span> message = <span class="string">"dinghuang123@gmail.com"</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] msg = message.getBytes();</span><br><span class="line">    <span class="keyword">byte</span>[] channel = message.getBytes();</span><br><span class="line">    redisConnectionFactory.getConnection().publish(msg, channel);</span><br><span class="line">    redisTemplate.convertAndSend(<span class="string">"hello!"</span>, <span class="string">"world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如图所示<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g1fxturm52j219e0k2ac6.jpg" alt=""></p>
<h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p><a href="https://redisson.org" target="_blank" rel="noopener">Redisson</a>是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。能够完美的在云计算环境里使用，并且支持AWS ElastiCache主备版，AWS ElastiCache集群版，Azure Redis Cache和阿里云（Aliyun）的云数据库Redis版。Redisson底层采用的是Netty 框架。支持Redis 2.8以上版本，支持Java1.6+以上版本。</p>
<p>Redisson作为独立节点 可以用于独立执行其他节点发布到分布式执行服务 和 分布式调度任务服务 里的远程任务。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g1f1ntysocj21b60ycgn7.jpg" alt=""></p>
<h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ul>
<li>复制的Redis服务器模式（还支持<a href="http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Replication.html" target="_blank" rel="noopener">AWS ElastiCache</a>和<a href="https://azure.microsoft.com/en-us/services/cache/" target="_blank" rel="noopener">Azure Redis</a>缓存）：<ul>
<li>自动主服务器更改发现</li>
</ul>
</li>
<li>群集Redis服务器模式（还支持<a href="http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Replication.html" target="_blank" rel="noopener">AWS ElastiCache</a>和<a href="https://azure.microsoft.com/en-us/services/cache/" target="_blank" rel="noopener">Azure Redis</a>缓存：<ul>
<li>自动主从服务器发现</li>
<li>自动状态和拓扑更新</li>
<li>自动插槽更改发现</li>
</ul>
</li>
<li>Sentinel Redis服务器模式：<ul>
<li>自动主，从和服务器发现</li>
<li>自动状态和拓扑更新</li>
</ul>
</li>
<li>掌握Slave Redis服务器模式</li>
<li>单Redis服务器模式</li>
<li>线程安全的实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/3.-operations-execution#32-reactive-way" target="_blank" rel="noopener">Reactive Streams</a> API</li>
<li><a href="https://github.com/redisson/redisson/wiki/3.-operations-execution#31-async-way" target="_blank" rel="noopener">异步</a> API</li>
<li>异步连接池</li>
<li>Lua脚本</li>
<li><a href="https://github.com/redisson/redisson/wiki/6.-Distributed-objects" target="_blank" rel="noopener">分布式Java对象</a><br>Object holder，Binary stream holder，Geospatial holder，BitSet，AtomicLong，AtomicDouble，PublishSubscribe，Bloom filter，HyperLogLog</li>
<li><a href="https://github.com/redisson/redisson/wiki/7.-Distributed-collections" target="_blank" rel="noopener">分布式Java集合</a><br>Map，Multimap，Set，List，SortedSet，ScoredSortedSet，LexSortedSet，Queue，Deque，Blocking Queue，Bounded Blocking Queue，Blocking Deque，Delayed Queue，Priority Queue，Priority Deque</li>
<li><a href="https://github.com/redisson/redisson/wiki/8.-Distributed-locks-and-synchronizers" target="_blank" rel="noopener">分布式Java锁和同步器</a><br>Lock，FairLock，MultiLock，RedLock，ReadWriteLock，Semaphore，PermitExpirableSemaphore，CountDownLatch</li>
<li><a href="https://github.com/redisson/redisson/wiki/9.-distributed-services" target="_blank" rel="noopener">分布式服务</a><br>远程服务，Live Object服务，Executor服务，Scheduler服务，MapReduce服务</li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration%20with%20frameworks#141-spring-framework" target="_blank" rel="noopener">Spring框架</a></li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration%20with%20frameworks/#142-spring-cache" target="_blank" rel="noopener">Spring Cache</a>实现<br>-<a href="https://github.com/redisson/redisson/wiki/14.-Integration-with-frameworks/#147-spring-transaction-manager" target="_blank" rel="noopener"> Spring Transaction API</a>实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration-with-frameworks/#148-spring-data-redis" target="_blank" rel="noopener">Spring Data Redis</a>集成</li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration-with-frameworks/#149-spring-boot-starter" target="_blank" rel="noopener">Spring Boot Starter</a>实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration%20with%20frameworks/#143-hibernate-cache" target="_blank" rel="noopener">Hibernate Cache</a>实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/10.-Additional-features#104-transactions" target="_blank" rel="noopener">Transactions API</a><br>-<a href="https://github.com/redisson/redisson/wiki/10.-additional-features/#105-xa-transactions" target="_blank" rel="noopener"> XA Transaction API</a>实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration%20with%20frameworks/#144-jcache-api-jsr-107-implementation" target="_blank" rel="noopener">JCache API（JSR-107）</a>实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration%20with%20frameworks#145-tomcat-redis-session-manager" target="_blank" rel="noopener">Tomcat会话管理器</a>实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration%20with%20frameworks/#146-spring-session" target="_blank" rel="noopener">Spring Session</a>实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/10.-additional-features#102-execution-batches-of-commands" target="_blank" rel="noopener">Redis流水线</a>（命令批处理）</li>
<li>支持Android平台</li>
<li>支持自动重新连接</li>
<li>支持无法发送命令自动重试</li>
<li>支持OSGi</li>
<li>支持SSL</li>
<li>支持许多流行的编解码器（<a href="https://github.com/FasterXML/jackson" target="_blank" rel="noopener">Jackson JSON</a>，<a href="http://avro.apache.org/" target="_blank" rel="noopener">Avro</a>，<a href="http://wiki.fasterxml.com/SmileFormatSpec" target="_blank" rel="noopener">Smile</a>，<a href="http://cbor.io/" target="_blank" rel="noopener">CBOR</a>，<a href="http://msgpack.org/" target="_blank" rel="noopener">MsgPack</a>，<a href="https://github.com/EsotericSoftware/kryo" target="_blank" rel="noopener">Kryo</a>，<a href="https://amzn.github.io/ion-docs/" target="_blank" rel="noopener">Amazon Ion</a>，<a href="https://github.com/RuedigerMoeller/fast-serialization" target="_blank" rel="noopener">FST</a>，<a href="https://github.com/jpountz/lz4-java" target="_blank" rel="noopener">LZ4</a>，<a href="https://github.com/xerial/snappy-java" target="_blank" rel="noopener">Snappy</a>和JDK Serialization）</li>
<li>超过1800个单元测试</li>
</ul>
<h3 id="与spring-data-redis结合使用"><a href="#与spring-data-redis结合使用" class="headerlink" title="与spring-data-redis结合使用"></a>与spring-data-redis结合使用</h3><p><code>pom.xml</code>加入依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-data-21<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.10.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>resources</code>文件夹添加配置文件<code>redisson.yml</code><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Redisson配置</span></span><br><span class="line"><span class="attr">singleServerConfig:</span></span><br><span class="line"><span class="attr">  address:</span> <span class="string">"redis://127.0.0.1:6379"</span></span><br><span class="line"><span class="attr">  password:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  clientName:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  database:</span> <span class="number">7</span> <span class="comment">#选择使用哪个数据库0~15</span></span><br><span class="line"><span class="attr">  idleConnectionTimeout:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">  pingTimeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">  connectTimeout:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">  retryAttempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  retryInterval:</span> <span class="number">1500</span></span><br><span class="line"><span class="attr">  reconnectionTimeout:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">  failedAttempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  subscriptionsPerConnection:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  subscriptionConnectionMinimumIdleSize:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  subscriptionConnectionPoolSize:</span> <span class="number">50</span></span><br><span class="line"><span class="attr">  connectionMinimumIdleSize:</span> <span class="number">32</span></span><br><span class="line"><span class="attr">  connectionPoolSize:</span> <span class="number">64</span></span><br><span class="line"><span class="attr">  dnsMonitoringInterval:</span> <span class="number">5000</span></span><br><span class="line">  <span class="comment">#dnsMonitoring: false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">threads:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">nettyThreads:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">codec:</span></span><br><span class="line"><span class="attr">  class:</span> <span class="string">"org.redisson.codec.JsonJacksonCodec"</span></span><br><span class="line"><span class="attr">transportMode:</span> <span class="string">"NIO"</span></span><br></pre></td></tr></table></figure></p>
<p>注册<code>RedissonConnectionFactory</code><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonSpringDataConfig</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> RedissonConnectionFactory redissonConnectionFactory(RedissonClient redisson) &#123;</span><br><span class="line">       <span class="keyword">return</span> new RedissonConnectionFactory(redisson);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Bean(destroyMethod = <span class="meta-string">"shutdown"</span>)</span></span><br><span class="line">   <span class="keyword">public</span> RedissonClient redisson(<span class="meta">@Value(<span class="meta-string">"classpath:/redisson.yml"</span>)</span> Resource configFile) throws IOException &#123;</span><br><span class="line">       Config config = Config.fromYAML(configFile.getInputStream());</span><br><span class="line">       <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码使用<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//设置键值对</span></span><br><span class="line">    RBucket&lt;String&gt; keyObj = redissonClient.getBucket(<span class="string">"k1"</span>);</span><br><span class="line">    keyObj.set(<span class="string">"v1236"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>spring-data-redis 支持的基本能够满足对redis的操作，提供了2种客户端连接，也支持redis集群的模式。如果涉及到利用redis做分布式锁的话，redisson封装了更多的工具和基础原子对象进行操作，redisson是优先选择，其次redisson兼容了很多的框架，那么多star不是没有道理的= =。同时也可以通过redisson与RxJava结合，实现线程安全的异步任务等等。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/03/20/Servicecomb实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/20/Servicecomb实践/" itemprop="url">Servicecomb实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-20T15:47:00+08:00">
                2019-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/20/Servicecomb实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/03/20/Servicecomb实践/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Servicecomb实践"><a href="#Servicecomb实践" class="headerlink" title="Servicecomb实践"></a>Servicecomb实践</h1><p><a href="https://github.com/apache/servicecomb-pack/blob/master" target="_blank" rel="noopener">Git地址</a></p>
<p>Apache ServiceComb Pack 是华为开源的一个微服务应用的数据最终一致性解决方案。</p>
<h2 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h2><ul>
<li>高可用：支持高可用的集群模式部署。</li>
<li>高可靠：所有的关键事务事件都持久化存储在数据库中。</li>
<li>高性能：事务事件是通过高性能gRPC来上报的，且事务的请求和响应消息都是通过Kyro进行序列化和反序列化。</li>
<li>低侵入：仅需2-3个注解和编写对应的补偿方法即可引入分布式事务。</li>
<li>部署简单：支持通过容器（Docker）进行快速部署和交付。</li>
<li>补偿机制灵活：支持前向恢复（重试）及后向恢复（补偿）功能。</li>
<li>扩展简单：基于Pack架构很容实现多种协调协议，目前支持TCC、Saga协议，未来还可以添加其他协议支持。</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>ServiceComb Pack 架构是由 alpha 和 omega组成，其中：</p>
<ul>
<li>alpha充当协调者的角色，主要负责对事务进行管理和协调。</li>
<li>omega是微服务中内嵌的一个agent，负责对调用请求进行拦截并向alpha上报事务事件。</li>
</ul>
<p>下图展示了alpha, omega以及微服务三者的关系： </p>
<p><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16q1uo7a2j20mp07yweq.jpg" alt=""></p>
<p>基础上我们除了实现saga协调协议以外，还实现了<a href="https://github.com/apache/servicecomb-pack/blob/master/docs/design_zh.md" target="_blank" rel="noopener">TCC协调协议</a>。 详情可浏览ServiceComb Pack 设计文档。</p>
<h3 id="Omega内部运行机制"><a href="#Omega内部运行机制" class="headerlink" title="Omega内部运行机制"></a>Omega内部运行机制</h3><p>omega是微服务中内嵌的一个agent。当服务收到请求时，omega会将其拦截并从中提取请求信息中的全局事务id作为其自身的全局事务id（即Saga事件id），并提取本地事务id作为其父事务id。在预处理阶段，alpha会记录事务开始的事件；在后处理阶段，alpha会记录事务结束的事件。因此，每个成功的子事务都有一一对应的开始及结束事件。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16q8mdkrvj20wo0haaau.jpg" alt=""></p>
<h3 id="服务间通信流程"><a href="#服务间通信流程" class="headerlink" title="服务间通信流程"></a>服务间通信流程</h3><p>服务间通信的流程与Zipkin的类似。在服务生产方，omega会拦截请求中事务相关的id来提取事务的上下文。在服务消费方，omega会在请求中注入事务相关的id来传递事务的上下文。通过服务提供方和服务消费方的这种协作处理，子事务能连接起来形成一个完整的全局事务。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16q92b65tj20wi0ca74s.jpg" alt=""></p>
<h3 id="Saga-具体处理流程"><a href="#Saga-具体处理流程" class="headerlink" title="Saga 具体处理流程"></a>Saga 具体处理流程</h3><p>Saga处理场景是要求相关的子事务提供事务处理函数同时也提供补偿函数。Saga协调器alpha会根据事务的执行情况向omega发送相关的指令，确定是否向前重试或者向后恢复。</p>
<h4 id="成功场景"><a href="#成功场景" class="headerlink" title="成功场景"></a>成功场景</h4><p>成功场景下，每个事务都会有开始和有对应的结束事件。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16q9lthpvj21cw0qijsz.jpg" alt=""></p>
<h4 id="异常场景"><a href="#异常场景" class="headerlink" title="异常场景"></a>异常场景</h4><p>异常场景下，omega会向alpha上报中断事件，然后alpha会向该全局事务的其它已完成的子事务发送补偿指令，确保最终所有的子事务要么都成功，要么都回滚。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qaa8gjwj21cr0rkwg6.jpg" alt=""></p>
<h4 id="超时场景-需要调整）"><a href="#超时场景-需要调整）" class="headerlink" title="超时场景 (需要调整）"></a>超时场景 (需要调整）</h4><p>超时场景下，已超时的事件会被alpha的定期扫描器检测出来，与此同时，该超时事务对应的全局事务也会被中断。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qatqfjbj21cu0rgwfx.jpg" alt=""></p>
<h3 id="TCC-具体处理流程"><a href="#TCC-具体处理流程" class="headerlink" title="TCC 具体处理流程"></a>TCC 具体处理流程</h3><p>TCC(try-confirm-cancel)与Saga事务处理方式相比多了一个Try方法。事务调用的发起方来根据事务的执行情况协调相关各方进行提交事务或者回滚事务。</p>
<h4 id="成功场景-1"><a href="#成功场景-1" class="headerlink" title="成功场景"></a>成功场景</h4><p>成功场景下， 每个事务都会有开始和对应的结束事件<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qbrxbazj21lo0wydin.jpg" alt=""></p>
<h4 id="异常场景-1"><a href="#异常场景-1" class="headerlink" title="异常场景"></a>异常场景</h4><p>异常场景下，事务发起方会向alpha上报异常事件，然后alpha会向该全局事务的其它已完成的子事务发送补偿指令，确保最终所有的子事务要么都成功，要么都回滚。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qcdd807j21ku0vu76t.jpg" alt=""></p>
<h2 id="omega、alpha的TSL双向证书"><a href="#omega、alpha的TSL双向证书" class="headerlink" title="omega、alpha的TSL双向证书"></a>omega、alpha的TSL双向证书</h2><p>Saga 现在支持在omega和alpha服务之间采用 TLS 通信.同样客户端方面的认证（双向认证）。</p>
<h3 id="准备证书-（Certificates）"><a href="#准备证书-（Certificates）" class="headerlink" title="准备证书 （Certificates）"></a>准备证书 （Certificates）</h3><p>你可以用下面的命令去生成一个用于测试的自签名的证书。 如果你想采用双向认证的方式，只需要客户端证书。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Changes these CN's to match your hosts in your environment if needed.</span></span><br><span class="line"><span class="attribute">SERVER_CN</span>=localhost</span><br><span class="line"><span class="attribute">CLIENT_CN</span>=localhost # Used when doing mutual TLS</span><br><span class="line"></span><br><span class="line">echo Generate CA key:</span><br><span class="line">openssl genrsa -passout pass:1111 -des3 -out ca.key 4096</span><br><span class="line">echo Generate CA certificate:</span><br><span class="line"><span class="comment"># Generates ca.crt which is the trustCertCollectionFile</span></span><br><span class="line">openssl req -passin pass:1111 -new -x509 -days 365 -key ca.key -out ca.crt -subj <span class="string">"/CN=<span class="variable">$&#123;SERVER_CN&#125;</span>"</span></span><br><span class="line">echo Generate<span class="built_in"> server </span>key:</span><br><span class="line">openssl genrsa -passout pass:1111 -des3 -out server.key 4096</span><br><span class="line">echo Generate<span class="built_in"> server </span>signing request:</span><br><span class="line">openssl req -passin pass:1111 -new -key server.key -out server.csr -subj <span class="string">"/CN=<span class="variable">$&#123;SERVER_CN&#125;</span>"</span></span><br><span class="line">echo Self-signed<span class="built_in"> server </span>certificate:</span><br><span class="line"><span class="comment"># Generates server.crt which is the certChainFile for the server</span></span><br><span class="line">openssl x509 -req -passin pass:1111 -days 365 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt </span><br><span class="line">echo <span class="builtin-name">Remove</span> passphrase <span class="keyword">from</span><span class="built_in"> server </span>key:</span><br><span class="line">openssl rsa -passin pass:1111 -in server.key -out server.key</span><br><span class="line">echo Generate<span class="built_in"> client </span>key</span><br><span class="line">openssl genrsa -passout pass:1111 -des3 -out client.key 4096</span><br><span class="line">echo Generate<span class="built_in"> client </span>signing request:</span><br><span class="line">openssl req -passin pass:1111 -new -key client.key -out client.csr -subj <span class="string">"/CN=<span class="variable">$&#123;CLIENT_CN&#125;</span>"</span></span><br><span class="line">echo Self-signed<span class="built_in"> client </span>certificate:</span><br><span class="line"><span class="comment"># Generates client.crt which is the clientCertChainFile for the client (need for mutual TLS only)</span></span><br><span class="line">openssl x509 -passin pass:1111 -req -days 365 -in client.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out client.crt</span><br><span class="line">echo <span class="builtin-name">Remove</span> passphrase <span class="keyword">from</span><span class="built_in"> client </span>key:</span><br><span class="line">openssl rsa -passin pass:1111 -in client.key -out client.key</span><br><span class="line">echo Converting the private keys <span class="keyword">to</span> X.509:</span><br><span class="line"><span class="comment"># Generates client.pem which is the clientPrivateKeyFile for the Client (needed for mutual TLS only)</span></span><br><span class="line">openssl pkcs8 -topk8 -nocrypt -in client.key -out client.pem</span><br><span class="line"><span class="comment"># Generates server.pem which is the privateKeyFile for the Server</span></span><br><span class="line">openssl pkcs8 -topk8 -nocrypt -in server.key -out server.pem</span><br></pre></td></tr></table></figure>
<h3 id="TLS为Alpha服务开启TLS"><a href="#TLS为Alpha服务开启TLS" class="headerlink" title="TLS为Alpha服务开启TLS"></a>TLS为Alpha服务开启TLS</h3><p>1.为alpha-server修改application.yaml文件，在alpha.server部门增加ssl配置。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">alpha:</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    ssl:</span></span><br><span class="line"><span class="attr">      enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      cert:</span> <span class="string">server.crt</span></span><br><span class="line"><span class="attr">      key:</span> <span class="string">server.pem</span></span><br><span class="line"><span class="attr">      mutualAuth:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      clientCert:</span> <span class="string">client.crt</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>将server.crt 和 server.pem 文件放到alpha-server的root 2目录。如果你想双向认证，合并所有client证书到一个client.crt文件,并把client.crt文件放到root目录.</li>
<li>重新启动alpha服务器.</li>
</ol>
<h3 id="为Omega启用TLS"><a href="#为Omega启用TLS" class="headerlink" title="为Omega启用TLS"></a>为Omega启用TLS</h3><ol>
<li>获取CA证书串(chain), 如果你是将alpha服务运行在集群中，你可能需要去合并多个CA证书到一个文件中.</li>
<li>为客户端应用修改application.yaml文件, 在alpha.cluster 部分增加ssl配置.</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">alpha:</span></span><br><span class="line"><span class="attr">  cluster:</span></span><br><span class="line"><span class="attr">    address:</span> <span class="string">alpha-server.servicecomb.io:8080</span></span><br><span class="line"><span class="attr">    ssl:</span></span><br><span class="line"><span class="attr">      enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      certChain:</span> <span class="string">ca.crt</span></span><br><span class="line"><span class="attr">      mutualAuth:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      cert:</span> <span class="string">client.crt</span></span><br><span class="line"><span class="attr">      key:</span> <span class="string">client.pem</span></span><br></pre></td></tr></table></figure>
<ol>
<li>把ca.crt文件放到客户端应用程序的root目录 file under the client application root directory.如果你想用双向认证，仍需要把client.crt和client.pem放到root目录下.</li>
<li>重新启动客户端应用程序.</li>
</ol>
<h2 id="与Spring结合使用"><a href="#与Spring结合使用" class="headerlink" title="与Spring结合使用"></a>与Spring结合使用</h2><h3 id="Saga中的Event简介"><a href="#Saga中的Event简介" class="headerlink" title="Saga中的Event简介"></a>Saga中的Event简介</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">EventType</span> &#123;</span></span><br><span class="line">  SagaStartedEvent,</span><br><span class="line">  TxStartedEvent,</span><br><span class="line">  TxEndedEvent,</span><br><span class="line">  TxAbortedEvent,</span><br><span class="line">  TxCompensatedEvent,</span><br><span class="line">  SagaEndedEvent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SagaStartedEvent: 代表Saga事务的开始，Alpha接受到该事件会保存整个saga事务的执行上下文，其中包括多个本地事务/补偿请求</li>
<li>TxStartedEvent: 本地事务开始事件，其中包含了本地事务执行的上下文（调用方法名，以及相关调用参数）</li>
<li>TXEndedEvent: 本地事务结束事件</li>
<li>TxAbortedEvent: 本地事务执行失败事件，包含了事务执行失败的原因</li>
<li>TxCompensatedEvent: 本地事务补偿事件，Alpha会将本地事务执行的上下文传递给Omega，这样不需要Omega自己维护服务调用的状态。</li>
<li>SagaEndedEvent: 标志着saga事务请求的结束</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qo3gfn4j20x80ibn0v.jpg" alt=""><br>成功场景下，全局事务事件SagaStartedEvent对应SagaEndedEvent ，每个子事务开始的事件TxStartedEvent都会有对应的结束事件TXEndedEvent。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qof1a9kj20zc0j3dk0.jpg" alt=""><br>异常场景下，Omega会向Alpha上报中断事件TxAbortedEvent，然后Alpha会根据全局事务的执行情况， 想其它已成功的子事务(以完成TXEndedEvent)的服务发送补偿指令，以确保最终所有的子事务要么都成功，要么都回滚。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qos3fkjj20ha099abd.jpg" alt=""><br>超时场景下，已超时的事件会被alpha的定期扫描器检测出来，同时该超时事务对应的全局事务也会被中断。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qp1vtvlj20v00f0q4k.jpg" alt=""></p>
<ol>
<li>用户发送Request请求调用业务方法(business logic)</li>
<li>preIntercept向alpha发送TxStartedEvent</li>
<li>被AOP拦截的方法(business logic)被调用</li>
<li>当执行成功时postIntercept发送TxEndedEvent到alpha</li>
<li>最后业务方法向用户发送response</li>
</ol>
<h3 id="与Spring和Mysql结合使用"><a href="#与Spring和Mysql结合使用" class="headerlink" title="与Spring和Mysql结合使用"></a>与Spring和Mysql结合使用</h3><p><a href="https://github.com/dinghuang/servicecomb-test" target="_blank" rel="noopener">项目地址</a></p>
<p>通过源码编译，克隆代码<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/apache/servicecomb-pack.git</span><br></pre></td></tr></table></figure></p>
<p>在<code>alpha/alpha-server/pom.xml</code>文件中加入mysql依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>构建docker镜像<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">./servicecomb-pack</span></span><br><span class="line">mvn clean install -DskipTests -Pdocker</span><br></pre></td></tr></table></figure></p>
<p>成功后如图所示<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[@dinghuangMacPro:~]$ docker images</span><br><span class="line">REPOSITORY               <span class="keyword">TAG</span>                 <span class="title">IMAGE</span> ID            CREATED             SIZE</span><br><span class="line">pack-web                 <span class="number">0.3</span>.<span class="number">0</span>               <span class="number">77</span>dedfe8e865        <span class="number">15</span> seconds ago      <span class="number">131M</span>B</span><br><span class="line">alpha-server             <span class="number">0.3</span>.<span class="number">0</span>               <span class="number">3</span>a34b8cd4224        <span class="number">38</span> seconds ago      <span class="number">144M</span>B</span><br></pre></td></tr></table></figure></p>
<p>启动mysql镜像，如果本地有的话<br>创建库saga，用户saga，密码password，并执行数据库脚本<code>schema-mysql.sql</code></p>
<p>启动alpha-server<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -<span class="selector-tag">p</span> <span class="number">8080</span>:<span class="number">8080</span> -<span class="selector-tag">p</span> <span class="number">8090</span>:<span class="number">8090</span> --link mysql:mysql<span class="selector-class">.servicecomb</span><span class="selector-class">.io</span> -e JAVA_OPTS=-Dspring<span class="selector-class">.profiles</span><span class="selector-class">.active</span>=mysql -e -Dspring<span class="selector-class">.datasource</span><span class="selector-class">.url</span>=jdbc:mysql:<span class="comment">//127.0.0.1:3306/saga?useSSL=false alpha-server:0.3.0</span></span><br></pre></td></tr></table></figure></p>
<p>启动对应的3个应用，分别说shop，order，hotel</p>
<p>访问api<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8081</span><span class="regexp">/shop/u</span>serName<span class="regexp">/orderName/</span>hotelName</span><br></pre></td></tr></table></figure></p>
<h3 id="事务解析"><a href="#事务解析" class="headerlink" title="事务解析"></a>事务解析</h3><p>请求流程示意图：用户发起请求到shop，shop分别调用order和hotel。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fgy1g193ofrsu9j20q00umta3.jpg" alt=""></p>
<p>使用TCC模式，TCC原理图如图所示：<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fgy1g193pjsh7tj20nc0blq9i.jpg" alt=""></p>
<h4 id="情况一：正常事务结束"><a href="#情况一：正常事务结束" class="headerlink" title="情况一：正常事务结束"></a>情况一：正常事务结束</h4><p><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g199o8nyxcj21660e6128.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g199omza6aj21nq044goa.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g199oxaun5j21my03ctb9.jpg" alt=""><br>事务记录成功，订单酒店表都有数据。</p>
<h4 id="情况二：父事件中调用订单成功后，出现异常"><a href="#情况二：父事件中调用订单成功后，出现异常" class="headerlink" title="情况二：父事件中调用订单成功后，出现异常"></a>情况二：父事件中调用订单成功后，出现异常</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父事务</span></span><br><span class="line"><span class="meta">@TccStart</span>(timeout = <span class="number">2</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/shop_tcc/&#123;name&#125;/&#123;order&#125;/&#123;hotel&#125;"</span>)</span><br><span class="line">public <span class="built_in">String</span> shopTcc(<span class="meta">@PathVariable</span> <span class="built_in">String</span> name, <span class="meta">@PathVariable</span> <span class="built_in">String</span> order, <span class="meta">@PathVariable</span> <span class="built_in">String</span> hotel) &#123;</span><br><span class="line">        <span class="comment">//调用订单服务的请求</span></span><br><span class="line">        template.postForEntity(<span class="string">"http://127.0.0.1:8082/order_tcc/&#123;name&#125;/&#123;order&#125;"</span>,<span class="keyword">null</span>, <span class="built_in">String</span>.<span class="keyword">class</span>, name, order);</span><br><span class="line">         <span class="comment">//异常</span></span><br><span class="line">        postBooking();</span><br><span class="line">        <span class="comment">//调用酒店服务的请求</span></span><br><span class="line">        template.postForEntity(<span class="string">"http://127.0.0.1:8083/hotel_tcc/&#123;name&#125;/&#123;hotel&#125;"</span>,<span class="keyword">null</span>, <span class="built_in">String</span>.<span class="keyword">class</span>, name, hotel);</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">" order "</span> + order + <span class="string">"hotel "</span> + hotel + <span class="string">" cars OK"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订单(酒店)中的代码逻辑</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">(OrderDO orderDO)</span> </span>&#123;</span><br><span class="line">        orderRepository.deleteById(orderDO.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">confirm</span><span class="params">(OrderDO orderDO)</span> </span>&#123;</span><br><span class="line">        orderRepository.insert(orderDO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Participate</span>(confirmMethod = <span class="string">"confirm"</span>, cancelMethod = <span class="string">"cancel"</span>)</span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">orderTcc</span><span class="params">(OrderDO orderDO)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据库结果如图所示<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g199hjb9mdj213u0bowkw.jpg" alt=""><br>订单和商店的表都没有生成数据。</p>
<h4 id="情况三：父事件中调用订单和酒店成功后，出现异常"><a href="#情况三：父事件中调用订单和酒店成功后，出现异常" class="headerlink" title="情况三：父事件中调用订单和酒店成功后，出现异常"></a>情况三：父事件中调用订单和酒店成功后，出现异常</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父事务</span></span><br><span class="line"><span class="meta">@TccStart</span>(timeout = <span class="number">2</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/shop_tcc/&#123;name&#125;/&#123;order&#125;/&#123;hotel&#125;"</span>)</span><br><span class="line">public <span class="built_in">String</span> shopTcc(<span class="meta">@PathVariable</span> <span class="built_in">String</span> name, <span class="meta">@PathVariable</span> <span class="built_in">String</span> order, <span class="meta">@PathVariable</span> <span class="built_in">String</span> hotel) &#123;</span><br><span class="line">        <span class="comment">//调用订单服务的请求</span></span><br><span class="line">        template.postForEntity(<span class="string">"http://127.0.0.1:8082/order_tcc/&#123;name&#125;/&#123;order&#125;"</span>,<span class="keyword">null</span>, <span class="built_in">String</span>.<span class="keyword">class</span>, name, order);</span><br><span class="line">        <span class="comment">//调用酒店服务的请求</span></span><br><span class="line">        template.postForEntity(<span class="string">"http://127.0.0.1:8083/hotel_tcc/&#123;name&#125;/&#123;hotel&#125;"</span>,<span class="keyword">null</span>, <span class="built_in">String</span>.<span class="keyword">class</span>, name, hotel);</span><br><span class="line">         <span class="comment">//异常</span></span><br><span class="line">        postBooking();</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">" order "</span> + order + <span class="string">"hotel "</span> + hotel + <span class="string">" cars OK"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据如图所示：<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g199w48vfaj217e0ciajm.jpg" alt=""><br>订单表与酒店表都没有产生数据</p>
<h4 id="情况四：父事件超时"><a href="#情况四：父事件超时" class="headerlink" title="情况四：父事件超时"></a>情况四：父事件超时</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父事务</span></span><br><span class="line"><span class="meta">@TccStart</span>(timeout = <span class="number">2</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/shop_tcc/&#123;name&#125;/&#123;order&#125;/&#123;hotel&#125;"</span>)</span><br><span class="line">public <span class="built_in">String</span> shopTcc(<span class="meta">@PathVariable</span> <span class="built_in">String</span> name, <span class="meta">@PathVariable</span> <span class="built_in">String</span> order, <span class="meta">@PathVariable</span> <span class="built_in">String</span> hotel) throws InterruptedException &#123;</span><br><span class="line">        <span class="comment">//调用订单服务的请求</span></span><br><span class="line">        template.postForEntity(<span class="string">"http://127.0.0.1:8082/order_tcc/&#123;name&#125;/&#123;order&#125;"</span>,<span class="keyword">null</span>, <span class="built_in">String</span>.<span class="keyword">class</span>, name, order);</span><br><span class="line">        <span class="comment">//调用酒店服务的请求</span></span><br><span class="line">        template.postForEntity(<span class="string">"http://127.0.0.1:8083/hotel_tcc/&#123;name&#125;/&#123;hotel&#125;"</span>,<span class="keyword">null</span>, <span class="built_in">String</span>.<span class="keyword">class</span>, name, hotel);</span><br><span class="line">         <span class="comment">//超时</span></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">" order "</span> + order + <span class="string">"hotel "</span> + hotel + <span class="string">" cars OK"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现TCC的timeout选项好像没有作用。。。。看了下源码，的确没有用到，源码如下<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g19adzx8ahj2246138drc.jpg" alt=""><br>ServiceComb在0.3.0加入了TCC的支持，所以有些功能还待完善把。</p>
<h4 id="情况五：订单服务启动，酒店服务未启动"><a href="#情况五：订单服务启动，酒店服务未启动" class="headerlink" title="情况五：订单服务启动，酒店服务未启动"></a>情况五：订单服务启动，酒店服务未启动</h4><p>关闭hotel服务，执行后数据如下：<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g19ajirqhpj215s0aiq99.jpg" alt=""><br>订单和酒店数据库都没有数据</p>
<h4 id="情况六-模拟运行过程中alpha服务挂起，订单、酒店、商店服务正常运行："><a href="#情况六-模拟运行过程中alpha服务挂起，订单、酒店、商店服务正常运行：" class="headerlink" title="情况六: 模拟运行过程中alpha服务挂起，订单、酒店、商店服务正常运行："></a>情况六: 模拟运行过程中alpha服务挂起，订单、酒店、商店服务正常运行：</h4><p>订单、酒店、商店服务后来日志显示心跳连接失效<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fgy1g19aq910axj223k0gstfo.jpg" alt=""><br>请求数据返回错误信息，数据库表均未写入数据。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fgy1g19ap4jromj211602kwjk.jpg" alt=""></p>
<p>重新启动alpha服务，订单、酒店、商店服务重新连接到alpha，业务正常运行。</p>
<h4 id="情况七-模拟运行过程中alpha服务的mysql挂起，订单、酒店、商店服务正常运行："><a href="#情况七-模拟运行过程中alpha服务的mysql挂起，订单、酒店、商店服务正常运行：" class="headerlink" title="情况七: 模拟运行过程中alpha服务的mysql挂起，订单、酒店、商店服务正常运行："></a>情况七: 模拟运行过程中alpha服务的mysql挂起，订单、酒店、商店服务正常运行：</h4><p>请求未进入业务逻辑之前，alpha服务报错，请求未执行。<br>mysql重启成功后，alpha服务正常运行，请求数据正常执行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ServiceComb对于数据最终一致性的解决现阶段0.3.0是满足业务逻辑的，但是对于失败重试、超时等功能这一块还不支持，后期应该会扩展。ServiceComb功能比较简单，但是可以通过对omega的事物id结合调用链追踪实现业务流程与事务的追溯。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/02/22/数据库优化方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/22/数据库优化方案/" itemprop="url">数据库优化方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T11:47:00+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/22/数据库优化方案/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/02/22/数据库优化方案/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SQL优化方案"><a href="#SQL优化方案" class="headerlink" title="SQL优化方案"></a>SQL优化方案</h1><p><a href="https://mp.weixin.qq.com/s/DBeVzJyR9_PXnoAIfJiHfg" target="_blank" rel="noopener">参考博客</a></p>
<h2 id="优化的哲学"><a href="#优化的哲学" class="headerlink" title="优化的哲学"></a>优化的哲学</h2><h3 id="优化可能带来的影响"><a href="#优化可能带来的影响" class="headerlink" title="优化可能带来的影响"></a>优化可能带来的影响</h3><ul>
<li>优化不总是对一个单纯的环境进行，还很可能是一个复杂的已投产的系统；</li>
<li>优化手段本来就有很大的风险，只不过你没能力意识到和预见到；</li>
<li>任何的技术可以解决一个问题，但必然存在带来一个问题的风险；</li>
<li>对于优化来说解决问题而带来的问题，控制在可接受的范围内才是有成果；</li>
<li>保持现状或出现更差的情况都是失败！</li>
</ul>
<h3 id="优化的需求"><a href="#优化的需求" class="headerlink" title="优化的需求"></a>优化的需求</h3><ul>
<li>稳定性和业务可持续性，通常比性能更重要；</li>
<li>优化不可避免涉及到变更，变更就有风险；</li>
<li>优化使性能变好，维持和变差是等概率事件；</li>
<li>切记优化，应该是各部门协同，共同参与的工作，任何单一部门都不能对数据库进行优化！</li>
</ul>
<p>所以优化工作，是由业务需要驱使的！</p>
<h3 id="优化参与"><a href="#优化参与" class="headerlink" title="优化参与"></a>优化参与</h3><p>在进行数据库优化时，应由数据库管理员、业务部门代表、应用程序架构师、应用程序设计人员、应用程序开发人员、硬件及系统管理员、存储管理员等，业务相关人员共同参与。 </p>
<h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><h3 id="优化对象"><a href="#优化对象" class="headerlink" title="优化对象"></a>优化对象</h3><p>在数据库优化上有两个主要方面：即安全与性能。</p>
<ul>
<li>安全-&gt;数据可持续性</li>
<li>性能-&gt;数据的高性能访问</li>
</ul>
<h3 id="优化的范围"><a href="#优化的范围" class="headerlink" title="优化的范围"></a>优化的范围</h3><ul>
<li>存储、主机和操作系统方面：<ul>
<li>主机架构稳定性；</li>
<li>I/O规划及配置；</li>
<li>Swap交换分区；</li>
<li>OS内核参数和网络问题。</li>
</ul>
</li>
<li>应用程序方面：<ul>
<li>应用程序稳定性；</li>
<li>SQL语句性能；</li>
<li>串行访问资源；</li>
<li>能欠佳会话管理；</li>
<li>这个应用适不适合用MySQL。</li>
</ul>
</li>
<li>数据库优化方面：<ul>
<li>内存；</li>
<li>数据库结构（物理&amp;逻辑）；</li>
<li>实例配置。</li>
</ul>
</li>
</ul>
<blockquote>
<p>不管是设计系统、定位问题还是优化，都可以按照这个顺序执行。</p>
</blockquote>
<h3 id="优化维度"><a href="#优化维度" class="headerlink" title="优化维度"></a>优化维度</h3><p>数据库优化维度有四个：</p>
<p>硬件、系统配置、数据库表结构、SQL及索引。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0cvkxgfrpj20iw09yad5.jpg" alt=""></p>
<p>优化选择：</p>
<p>优化成本：硬件&gt;系统配置&gt;数据库表结构&gt;SQL及索引。</p>
<p>优化效果：硬件&lt;系统配置&lt;数据库表结构&lt;SQL及索引。</p>
<h2 id="优化工具"><a href="#优化工具" class="headerlink" title="优化工具"></a>优化工具</h2><h3 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h3><p>检查问题常用工具：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1）MySQL</span><br><span class="line"></span><br><span class="line">2）msyqladmin：MySQL客户端，可进行管理操作</span><br><span class="line"></span><br><span class="line">3）mysqlshow：功能强大的查看shell命令</span><br><span class="line"></span><br><span class="line">4）<span class="keyword">show</span> [<span class="keyword">SESSION</span> | <span class="keyword">GLOBAL</span>] <span class="keyword">variables</span>：查看数据库参数信息</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）<span class="keyword">SHOW</span> [<span class="keyword">SESSION</span> | <span class="keyword">GLOBAL</span>] <span class="keyword">STATUS</span>：查看数据库的状态信息</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）information_schema：获取元数据的方法</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>）<span class="keyword">SHOW</span> <span class="keyword">ENGINE</span> <span class="keyword">INNODB</span> <span class="keyword">STATUS</span>：<span class="keyword">Innodb</span>引擎的所有状态</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>）<span class="keyword">SHOW</span> <span class="keyword">PROCESSLIST</span>：查看当前所有连接<span class="keyword">session</span>状态</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>）<span class="keyword">explain</span>：获取查询语句的执行计划</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>）<span class="keyword">show</span> <span class="keyword">index</span>：查看表的索引信息</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>）slow-<span class="keyword">log</span>：记录慢查询语句</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>）mysqldumpslow：分析slowlog文件的</span><br></pre></td></tr></table></figure>
<p>不常用但好用的工具：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）Zabbix：监控主机、系统、数据库（部署zabbix监控平台）</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）pt-query-digest：分析慢日志</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）MySQL slap：分析慢日志</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）sysbench：压力测试工具</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）MySQL profiling：统计数据库整体状态工具    </span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）Performance Schema：MySQL性能状态统计的数据</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>）workbench：管理、备份、监控、分析、优化工具（比较费资源）</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="http://www.cnblogs.com/clsn/p/7885990.html" target="_blank" rel="noopener">关于Zabbix参考</a></p>
</blockquote>
<h3 id="数据库层面问题解决思路"><a href="#数据库层面问题解决思路" class="headerlink" title="数据库层面问题解决思路"></a>数据库层面问题解决思路</h3><p>一般应急调优的思路：针对突然的业务办理卡顿，无法进行正常的业务处理，需要立马解决的场景。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）show processlist；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）explain  select <span class="built_in">id</span> ,<span class="built_in">name</span> <span class="keyword">from</span> stu <span class="keyword">where</span> <span class="built_in">name</span>='clsn'; <span class="comment"># ALL  id name age  sex；</span></span><br><span class="line"></span><br><span class="line">select <span class="built_in">id</span>,<span class="built_in">name</span> <span class="keyword">from</span> stu  <span class="keyword">where</span> <span class="built_in">id</span>=<span class="number">2</span><span class="number">-1</span> 函数 结果集&gt;<span class="number">30</span>；show index <span class="keyword">from</span> table；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）通过执行计划判断，索引问题（有没有、合不合理）或者语句本身问题；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）show status  like '%lock%';    <span class="comment"># 查询锁状态</span></span><br><span class="line"></span><br><span class="line">kill SESSION_ID;   <span class="comment"># 杀掉有问题的session。</span></span><br></pre></td></tr></table></figure></p>
<p>常规调优思路：针对业务周期性的卡顿，例如在每天10-11点业务特别慢，但是还能够使用，过了这段时间就好了。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）查看slowlog，分析slowlog，分析出查询慢的语句；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）按照一定优先级，一个一个排查所有慢语句；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）分析top SQL，进行explain调试，查看语句执行时间；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）调整索引或语句本身。</span><br></pre></td></tr></table></figure></p>
<h3 id="系统层面"><a href="#系统层面" class="headerlink" title="系统层面"></a>系统层面</h3><p><strong>Cpu方面</strong><br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat、sar <span class="built_in">top</span>、htop、nmon、mpstat；</span><br></pre></td></tr></table></figure></p>
<p><strong>内存</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>、ps-aux；</span><br></pre></td></tr></table></figure></p>
<p>IO设备（磁盘、网络）<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">iostat</span>、ss、netstat、iptraf、iftop、lsof；</span><br></pre></td></tr></table></figure></p>
<p><strong>vmstat命令说明</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）Procs：r显示有多少进程正在等待CPU时间。b显示处于不可中断的休眠的进程数量。在等待I/O。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）Memory：swpd显示被交换到磁盘的数据块的数量。未被使用的数据块，用户缓冲数据块，用于操作系统的数据块的数量。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）Swap：操作系统每秒从磁盘上交换到内存和从内存交换到磁盘的数据块的数量。s1和s0最好是<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）Io：每秒从设备中读入b1的写入到设备b0的数据块的数量。反映了磁盘I/O。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）System：显示了每秒发生中断的数量（in）和上下文交换（cs）的数量。</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）Cpu：显示用于运行用户代码，系统代码，空闲，等待I/O的Cpu时间。</span><br></pre></td></tr></table></figure></p>
<p><strong>iostat命令说明</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">实例命令：iostat -dk <span class="number">1</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">　　　　   iostat -d -k -x <span class="number">5</span> （查看设备使用率（%util）和响应时间（await））</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）tps：该设备每秒的传输次数。“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）iops ：硬件出厂的时候，厂家定义的一个每秒最大的IO次数</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）<span class="string">"一次传输"</span>请求的大小是未知的。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）kB_read/s：每秒从设备（drive expressed）读取的数据量；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）KB_wrtn/s：每秒向设备（drive expressed）写入的数据量；</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）kB_read：读取的总数据量；</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>）kB_wrtn：写入的总数量数据量；这些单位都为Kilobytes。</span><br></pre></td></tr></table></figure></p>
<h3 id="系统层面问题解决办法"><a href="#系统层面问题解决办法" class="headerlink" title="系统层面问题解决办法"></a>系统层面问题解决办法</h3><p>你认为到底负载高好，还是低好呢？在实际的生产中，一般认为Cpu只要不超过90%都没什么问题。</p>
<p>当然不排除下面这些特殊情况：</p>
<p><strong>Cpu负载高，IO负载低</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）内存不够；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）磁盘性能差；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）SQL问题---&gt;去数据库层，进一步排查SQL 问题；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）IO出问题了（磁盘到临界了、raid设计不好、raid降级、锁、在单位时间内tps过高）；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）tps过高：大量的小数据IO、大量的全表扫描。</span><br></pre></td></tr></table></figure></p>
<p><strong>IO负载高，Cpu负载低</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）大量小的IO写操作：</span><br><span class="line"></span><br><span class="line">autocommit，产生大量小IO；IO/PS，磁盘的一个定值，硬件出厂的时候，厂家定义的一个每秒最大的IO次数。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）大量大的IO 写操作：SQL问题的几率比较大</span><br></pre></td></tr></table></figure></p>
<p><strong>IO和cpu负载都很高</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">硬件不够了或SQL存在问题。</span><br></pre></td></tr></table></figure></p>
<h2 id="基础优化"><a href="#基础优化" class="headerlink" title="基础优化"></a>基础优化</h2><h3 id="优化思路-1"><a href="#优化思路-1" class="headerlink" title="优化思路"></a>优化思路</h3><p><strong>定位问题点吮吸</strong>：硬件–&gt;系统–&gt;应用–&gt;数据库–&gt;架构（高可用、读写分离、分库分表）。</p>
<p><strong>处理方向</strong>：明确优化目标、性能和安全的折中、防患未然。</p>
<h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><p><strong>主机方面</strong><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">根据数据库类型，主机CPU选择、内存容量选择、磁盘选择：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）平衡内存和磁盘资源；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）随机的<span class="keyword">I</span>/<span class="keyword">O</span>和顺序的<span class="keyword">I</span>/<span class="keyword">O</span>；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）主机 RAID卡的BBU（Battery Backup Unit）关闭。</span><br></pre></td></tr></table></figure></p>
<p><strong>CPU的选择</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">CPU</span>的两个关键因素：核数、主频</span><br><span class="line"></span><br><span class="line">根据不同的业务类型进行选择：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）<span class="meta">CPU</span>密集型：计算比较多，OLTP - 主频很高的<span class="meta">cpu</span>、核数还要多</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）IO密集型：查询比较，OLAP - 核数要多，主频不一定高的</span><br></pre></td></tr></table></figure></p>
<p><strong>内存的选择</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OLAP类型数据库，需要更多内存，和数据获取量级有关。</span><br><span class="line"></span><br><span class="line">OLTP类型数据一般内存是Cpu核心数量的<span class="number">2</span>倍到<span class="number">4</span>倍，没有最佳实践。</span><br></pre></td></tr></table></figure></p>
<p><strong>存储方面</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）根据存储数据种类的不同，选择不同的存储设备；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）配置合理的RAID级别（raid5、raid10、热备盘）；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）对与操作系统来讲，不需要太特殊的选择，最好做好冗余（raid1）（ssd、sas、sata）。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）raid卡：</span><br><span class="line"></span><br><span class="line">       主机raid卡选择：</span><br><span class="line"></span><br><span class="line">           实现操作系统磁盘的冗余（raid1）；</span><br><span class="line"></span><br><span class="line">           平衡内存和磁盘资源；</span><br><span class="line"></span><br><span class="line">           随机的I/O和顺序的I/O；</span><br><span class="line"></span><br><span class="line">           主机raid卡的BBU（Battery Backup Unit）要关闭。</span><br></pre></td></tr></table></figure></p>
<p>网络设备方面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用流量支持更高的网络设备（交换机、路由器、网线、网卡、HBA卡）</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：以上这些规划应该在初始设计系统时就应该考虑好。</p>
</blockquote>
<h3 id="服务器硬件优化"><a href="#服务器硬件优化" class="headerlink" title="服务器硬件优化"></a>服务器硬件优化</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）物理状态灯</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）自带管理设备：远程控制卡（FENCE设备：ipmi ilo idarc）、开关机、硬件监控。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）第三方的监控软件、设备（snmp、agent）对物理设施进行监控。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）存储设备：自带的监控平台。EMC2（hp收购了）、 日立（hds）、IBM低端OEM hds、高端存储是自己技术，华为存储。</span><br></pre></td></tr></table></figure>
<h3 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h3><p><strong>Cpu</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本不需要调整，在硬件选择方面下功夫即可。</span><br></pre></td></tr></table></figure></p>
<p><strong>内存</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本不需要调整，在硬件选择方面下功夫即可。</span><br></pre></td></tr></table></figure></p>
<p><strong>SWAP</strong><br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MySQL尽量避免使用<span class="keyword">swap</span>。</span><br><span class="line"></span><br><span class="line">阿里云的服务器中默认<span class="keyword">swap</span>为<span class="number">0</span>。</span><br></pre></td></tr></table></figure></p>
<p><strong>IO</strong><br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raid、<span class="literal">no</span> lvm、ext4或xfs、ssd、IO调度策略。</span><br></pre></td></tr></table></figure></p>
<p><strong>Swap调整(不使用swap分区)</strong><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>swappiness的内容改成<span class="number">0</span>（临时），<span class="regexp">/etc/</span>sysctl. conf上添加vm.swappiness=<span class="number">0</span>（永久）</span><br></pre></td></tr></table></figure></p>
<p>这个参数决定了Linux是倾向于使用swap，还是倾向于释放文件系统cache。在内存紧张的情况下，数值越低越倾向于释放文件系统cache。</p>
<p>当然，这个参数只能减少使用swap的概率，并不能避免Linux使用swap。</p>
<p><strong>修改MySQL的配置参数<code>innodb_flush_ method</code>，开启O_DIRECT模式</strong>：</p>
<p>这种情况下，InnoDB的buffer pool会直接绕过文件系统cache来访问磁盘，但是redo log依旧会使用文件系统cache。</p>
<p>值得注意的是，Redo log是覆写模式的，即使使用了文件系统的cache，也不会占用太多。</p>
<p><strong>IO调度策略</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> deadline&gt;/sys/block/sda/queue/scheduler   临时修改为deadline</span></span><br></pre></td></tr></table></figure></p>
<p>永久修改<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /boot/grub/grub.conf</span><br><span class="line"></span><br><span class="line">更改到如下内容:</span><br><span class="line"></span><br><span class="line">kernel /boot/vmlinuz-2.6.18-8.el5 ro <span class="attribute">root</span>=LABEL=/ <span class="attribute">elevator</span>=deadline rhgb quiet</span><br></pre></td></tr></table></figure></p>
<h3 id="系统参数调整"><a href="#系统参数调整" class="headerlink" title="系统参数调整"></a>系统参数调整</h3><p><strong>Linux系统内核参数优化</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim/etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">net.ipv4.ip_local_port_range = <span class="number">1024</span> <span class="number">65535</span>：# 用户端口范围</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = <span class="number">4096</span> </span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_fin_timeout = <span class="number">30</span> </span><br><span class="line"></span><br><span class="line">fs.file-max=<span class="number">65535</span>：# 系统最大文件句柄，控制的是能打开文件最大数量</span><br></pre></td></tr></table></figure></p>
<p><strong>用户限制参数（MySQL可以不设置以下配置）</strong><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim/etc/security/limits.<span class="keyword">conf</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">* soft nproc 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">* hard nproc 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">* soft nofile 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">* hard nofile 65535</span></span><br></pre></td></tr></table></figure></p>
<h3 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h3><p>业务应用和数据库应用独立；</p>
<p><strong>防火墙</strong>：iptables、selinux等其他无用服务（关闭）：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">chkconfig</span> --level <span class="number">23456</span> acpid <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> anacron <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> autofs <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> avahi-daemon <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> bluetooth <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> cups <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> firstboot <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> haldaemon <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> hplip <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> ip6tables <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> iptables  <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> isdn <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> pcscd <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> sendmail  <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> yum-updatesd  <span class="literal">off</span></span><br></pre></td></tr></table></figure></p>
<p>安装图形界面的服务器不要启动图形界面runlevel 3。 </p>
<p>另外，思考将来我们的业务是否真的需要MySQL，还是使用其他种类的数据库。用数据库的最高境界就是不用数据库。</p>
<h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><p>SQL优化方向：执行计划、索引、SQL改写。</p>
<p>架构优化方向：高可用架构、高性能架构、分库分表。</p>
<h3 id="数据库参数优化"><a href="#数据库参数优化" class="headerlink" title="数据库参数优化"></a>数据库参数优化</h3><p><strong>调整</strong></p>
<p>实例整体（高级优化，扩展）：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thread_concurrency：# 并发线程数量个数</span><br><span class="line"></span><br><span class="line">sort_buffer_size：# 排序缓存</span><br><span class="line"></span><br><span class="line">read_buffer_size：# 顺序读取缓存</span><br><span class="line"></span><br><span class="line">read_rnd_buffer_size：# 随机读取缓存</span><br><span class="line"></span><br><span class="line">key_buffer_size：# 索引缓存</span><br><span class="line"></span><br><span class="line">thread_cache_size：# (<span class="number">1</span>G—&gt;<span class="number">8</span>, <span class="number">2</span>G—&gt;<span class="number">16</span>, <span class="number">3</span>G—&gt;<span class="number">32</span>, &gt;<span class="number">3</span>G—&gt;<span class="number">64</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>连接层（基础优化）</strong><br>设置合理的连接客户和连接方式：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">max_connections           <span class="comment"># 最大连接数，看交易笔数设置    </span></span><br><span class="line"></span><br><span class="line">max_<span class="keyword">connect</span>_errors        <span class="comment"># 最大错误连接数，能大则大</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">connect</span>_timeout           <span class="comment"># 连接超时</span></span><br><span class="line"></span><br><span class="line">max_user_connections      <span class="comment"># 最大用户连接数</span></span><br><span class="line"></span><br><span class="line">skip-name-resolve         <span class="comment"># 跳过域名解析</span></span><br><span class="line"></span><br><span class="line">wait_timeout              <span class="comment"># 等待超时</span></span><br><span class="line"></span><br><span class="line">back_log                  <span class="comment"># 可以在堆栈中的连接数量</span></span><br></pre></td></tr></table></figure></p>
<p><strong>SQL层（基础优化）</strong><br>query_cache_size： 查询缓存  &gt;&gt;&gt;  OLAP类型数据库,需要重点加大此内存缓存，但是一般不会超过GB。</p>
<p>对于经常被修改的数据，缓存会立马失效。</p>
<p>我们可以实用内存数据库（redis、memecache），替代他的功能。</p>
<p><strong>存储引擎层（innodb基础优化参数）</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">default</span>-storage-engine</span><br><span class="line"></span><br><span class="line">innodb_buffer_pool_size       # 没有固定大小，<span class="number">50</span>%测试值，看看情况再微调。但是尽量设置不要超过物理内存<span class="number">70</span>%</span><br><span class="line"></span><br><span class="line">innodb_file_per_table=(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">innodb_flush_log_at_trx_commit=(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>) # <span class="number">1</span>是最安全的，<span class="number">0</span>是性能最高，<span class="number">2</span>折中</span><br><span class="line"></span><br><span class="line">binlog_sync</span><br><span class="line"></span><br><span class="line">Innodb_flush_method=(O_DIRECT, fdatasync)</span><br><span class="line"></span><br><span class="line">innodb_log_buffer_size           # <span class="number">100</span>M以下</span><br><span class="line"></span><br><span class="line">innodb_log_file_size               # <span class="number">100</span>M 以下</span><br><span class="line"></span><br><span class="line">innodb_log_files_in_group       # <span class="number">5</span>个成员以下,一般<span class="number">2</span><span class="number">-3</span>个够用（iblogfile0-N）</span><br><span class="line"></span><br><span class="line">innodb_max_dirty_pages_pct   # 达到百分之<span class="number">75</span>的时候刷写 内存脏页到磁盘。</span><br><span class="line"></span><br><span class="line">log_bin</span><br><span class="line"></span><br><span class="line">max_binlog_cache_size                     # 可以不设置</span><br><span class="line"></span><br><span class="line">max_binlog_size                               # 可以不设置</span><br><span class="line"></span><br><span class="line">innodb_additional_mem_pool_size     #小于<span class="number">2</span>G内存的机器，推荐值是<span class="number">20</span>M。<span class="number">32</span>G内存以上<span class="number">100</span>M</span><br></pre></td></tr></table></figure></p>
<h2 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h2><p><a href="https://juejin.im/post/5aa7703c6fb9a028c8128739" target="_blank" rel="noopener">原文博客</a></p>
<ol>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以在 num 上设置默认值 0,确保表中 num 列没有 null 值，然后这样查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li>
<li>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以这样查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span>;</span><br></pre></td></tr></table></figure></p>
<ol start="5">
<li>in 和 not in 也要慎用，否则会导致全表扫描，如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对于连续的数值，能用 between 就不要用 in 了：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<ol start="6">
<li>下面的查询也将导致全表扫描：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%c%'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>若要提高效率，可以考虑<a href="https://www.jianshu.com/p/c48106149b6a" target="_blank" rel="noopener">全文检索</a>。</p>
<ol start="7">
<li>如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优 化程序不能将访问计划的选择推迟到运行时;它必须在编译时进行选择。然 而，如果在编译时建立访问计 划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span> ;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以改为强制查询使用索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">with</span>(<span class="keyword">index</span>(索引名)) <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span> ;</span><br></pre></td></tr></table></figure></p>
<ol start="8">
<li>应尽量避免在 where 子句中对字段进行表达式操作， 这将导致引擎放弃使用索引而进行全表扫描。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以这样查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<ol start="9">
<li>应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="title">substring</span>(<span class="params">name,<span class="number">1</span>,<span class="number">3</span></span>)</span>=<span class="string">'abc'</span>;<span class="meta">#name 以 abc 开头的 id</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>应改为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'abc%'</span>;</span><br></pre></td></tr></table></figure></p>
<ol start="10">
<li>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用 索引。</li>
<li>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件 时才能保证系统使用该索引， 否则该索引将不会 被使用， 并且应尽可能的让字段顺序与索引顺序相一致。</li>
<li>不要写一些没有意义的查询，如需要生成一个空表结构：<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">into</span> #t <span class="keyword">from</span> t <span class="keyword">where</span> <span class="number">1</span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<br><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table <span class="function"><span class="keyword">#</span><span class="title">t</span><span class="params">(…)</span></span>;</span><br></pre></td></tr></table></figure></p>
<ol start="13">
<li>很多时候用 exists 代替 in 是一个好的选择：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> b);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>用下面的语句替换：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> b <span class="keyword">where</span> <span class="keyword">num</span>=a.num);</span><br></pre></td></tr></table></figure></p>
<ol start="14">
<li>并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时， SQL 查询可能不会去利用索引，如一表中有字段 sex,male、female 几乎各一半，那么即使在 sex 上建 了索引也对查询效率起不了作用。</li>
<li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li>
<li>应尽可能的避免更新 clustered 索引数据列， 因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</li>
<li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并 会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言 只需要比较一次就够了。</li>
<li>尽可能的使用 <code>varchar/nvarchar</code> 代替 <code>char/nchar</code> , 因为首先变长字段存储空间小， 可以节省存储空间， 其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</li>
<li>任何地方都不要使用 <code>select * from t</code> ,用具体的字段列表代替“*”,不要返回用不到的任何字段。</li>
<li>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限(只有主键索引)。</li>
<li>避免频繁创建和删除临时表，以减少系统表资源的消耗。</li>
<li>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用。 表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</li>
<li>在新建临时表时，如果一次性插入数据量很大，那么可以使用 <code>select into</code> 代替 <code>create table</code>,避免造成大量 log ,以提高速度;如果数据量不大，为了缓和系统表的资源，应先 <code>create table</code>,然后 <code>insert</code>。</li>
<li>如果使用到了临时表， 在存储过程的最后务必将所有的临时表显式删除， 先 <code>truncate table</code> ,然后 <code>drop table</code> ,这样可以避免系统表的较长时间锁定。</li>
<li>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。</li>
<li>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</li>
<li>与临时表一样，游标并不是不可使用。对小型数据集使用 <code>FAST_FORWARD</code> 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</li>
<li>在所有的存储过程和触发器的开始处设置 <code>SET NOCOUNT ON</code>,在结束时设置 <code>SET NOCOUNT OFF</code> .无需在执行存储过程和触发器的每个语句后向客户端发送<code>DONE_IN_PROC</code>消息。</li>
<li><p>尽量避免大事务操作，提高系统并发能力。 sql 优化方法使用索引来更快地遍历表。 缺省情况下建立的索引是非群集索引，但有时它并不是最佳的。在非群集索引下，数据在物理上随机存放在数据页上。合理的索引设计要建立在对各种查询的分析和预测上。一般来说：</p>
<ul>
<li>有大量重复值、且经常有范围查询( &gt; ,&lt; ,&gt; =,&lt; =)和 order by、group by 发生的列，可考虑建立集群索引;</li>
<li>经常同时存取多列，且每列都含有重复值可考虑建立组合索引;</li>
<li>组合索引要尽量使关键查询形成索引覆盖，其前导列一定是使用最频繁的列。索引虽有助于提高性能但 不是索引越多越好，恰好相反过多的索引会导致系统低效。用户在表中每加进一个索引，维护索引集合就 要做相应的更新工作。</li>
</ul>
</li>
<li>定期分析表和检查表<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分析表的语法：<span class="keyword">ANALYZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> tb1_name[, tbl_name]...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上语句用于分析和存储表的关键字分布，分析的结果将可以使得系统得到准确的统计信息，使得SQL能够生成正确的执行计划。如果用户感觉实际执行计划并不是预期的执行计划，执行一次分析表可能会解决问题。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM，DBD和InnoDB表有作用。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如分析一个数据表：<span class="keyword">analyze</span> <span class="keyword">table</span> table_name</span><br><span class="line"></span><br><span class="line">检查表的语法：<span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tb1_name[,tbl_name]...[<span class="keyword">option</span>]...option = &#123;<span class="keyword">QUICK</span> | <span class="keyword">FAST</span> | <span class="keyword">MEDIUM</span> | <span class="keyword">EXTENDED</span> | <span class="keyword">CHANGED</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>检查表的作用是检查一个或多个表是否有错误，CHECK TABLE 对MyISAM 和 InnoDB表有作用，对于MyISAM表，关键字统计数据被更新</p>
<p>CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表不存在。</p>
<ol start="31">
<li>定期优化表。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">优化表的语法：<span class="keyword">OPTIMIZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> tb1_name [,tbl_name]...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果删除了表的一大部分，或者如果已经对含有可变长度行的表(含有 VARCHAR、BLOB或TEXT列的表)进行更多更改，则应使用OPTIMIZE TABLE命令来进行表优化。这个命令可以将表中的空间碎片进行合并，并且可以消除由于删除或者更新造成的空间浪费，但OPTIMIZE TABLE 命令只对MyISAM、 BDB 和InnoDB表起作用。</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如： optimize <span class="keyword">table</span> table_name</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： analyze、check、optimize执行期间将对表进行锁定，因此一定注意要在MySQL数据库不繁忙的时候执行相关的操作。</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>在海量查询时尽量少用格式转换。</li>
<li>ORDER BY 和 GROPU BY:使用 ORDER BY 和 GROUP BY 短语，任何一种索引都有助于 SELECT 的性能提高。</li>
<li>任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边。</li>
<li>IN、OR 子句常会使用工作表，使索引失效。如果不产生大量重复值，可以考虑把子句拆开。拆开的子 句中应该包含索引。</li>
<li>只要能满足你的需求，应尽可能使用更小的数据类型：例如使用 MEDIUMINT 代替 INT</li>
<li>尽量把所有的列设置为 NOT NULL,如果你要保存 NULL,手动去设置它，而不是把它设为默认值。</li>
<li>尽量少用 VARCHAR、TEXT、BLOB 类型</li>
<li>如果你的数据只有你所知的少量的几个。最好使用 ENUM 类型</li>
<li>正如 graymice 所讲的那样，建立索引。</li>
<li>合理用运分表与分区表提高数据存放和提取速度。</li>
</ol>
<h2 id="亿级数据下的分库分表方案"><a href="#亿级数据下的分库分表方案" class="headerlink" title="亿级数据下的分库分表方案"></a>亿级数据下的分库分表方案</h2><p><a href="https://www.tuicool.com/articles/2EzuQr7" target="_blank" rel="noopener">原文</a></p>
<h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>项目背景是企业级的统一消息处理平台，客户数据在5千万加，每分钟处理消息流水1千万，每天消息流水1亿左右。 虽说Mysql单表可以存储10亿级的数据，但这个时候性能非常差，项目中大量的实验证明，Mysql单表容量在500万左右，性能处于最佳状态，此时，Mysql的BTREE索引树高在3～5之间。既然一张表无法搞定，那么就想办法将数据放到多个地方来解决问题吧，于是，数据库分库分表的方案便产生了，目前比较普遍的方案有三个： 分区，分库分表，NoSql/NewSql 。</p>
<p>在实际的项目中，往往是这三种方案的结合来解决问题，目前绝大部分系统的核心数据都是以RDBMS存储为主，NoSql/NewSql存储为辅。</p>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>首先来了解一下分区方案。</p>
<p>分区表是由多个相关的底层表实现，这些底层表也是由句柄对象表示，所以我们也可以直接访问各个分区，存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），分区表的索引只是在各个底层表上各自加上一个相同的索引，从存储引擎的角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。这个方案也不错，它对用户屏蔽了sharding的细节，即使查询条件没有sharding column，它也能正常工作（只是这时候性能一般）。不过它的缺点很明显：很多的资源都受到单机的限制，例如连接数，网络吞吐等。如何进行分区，在实际应用中是一个非常关键的要素之一。在我们的项目中，以客户信息为例，客户数据量5000万加，项目背景要求保存客户的银行卡绑定关系，客户的证件绑定关系，以及客户绑定的业务信息。此业务背景下，该如何设计数据库呢。项目一期的时候，我们建立了一张客户业务绑定关系表，里面冗余了每一位客户绑定的业务信息。基本结构大致如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1086caaj20fa06m761.jpg" alt=""><br>查询时，对银行卡做索引，业务编号做索引，证件号做索引。随着需求大增多，这张表的索引会达到10个以上。而且客户解约再签约，里面会保存两条数据，只是绑定的状态不同。假设我们有5千万的客户，5个业务类型，每位客户平均2张卡，那么这张表的数据量将会达到惊人的5亿，事实上我们系统用户量还没有过百万时就已经不行了。mysql数据库中的数据是以文件的形势存在磁盘上的，默认放在/mysql/data下面（可以通过my.cnf中的datadir来查看）， 一张表主要对应着三个文件，一个是frm存放表结构的，一个是myd存放表数据的，一个是myi存表索引的。这三个文件都非常的庞大，尤其是.myd文件，快5个G了。 下面进行第一次分区优化 ，Mysql支持的分区方式有四种：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e11m0q1wj20fa066tbt.jpg" alt=""><br>在我们的项目中，range分区和list分区没有使用场景，如果基于绑定编号做range或者list分区，绑定编号没有实际的业务含义，无法通过它进行查询，因此，我们就剩下 HASH 分区和 KEY 分区了， HASH 分区仅支持int类型列的分区，且是其中的一列。看看我们的库表结构，发现没有哪一列是int类型的，如何做分区呢？可以增加一列，绑定时间列，将此列设置为int类型，然后按照绑定时间进行分区，将每一天绑定的用户分到同一个区里面去。这次优化之后，我们的插入快了许多，但是查询依然很慢，为什么，因为在做查询的时候，我们也只是根据银行卡或者证件号进行查询，并没有根据时间查询，相当于每次查询，mysql都会将所有的分区表查询一遍。</p>
<p>然后进行第二次方案优化，既然hash分区和key分区要求其中的一列必须是int类型的，那么创造出一个int类型的列出来分区是否可以。分析发现，银行卡的那串数字有秘密。银行卡一般是16位到19位不等的数字串，我们取其中的某一位拿出来作为表分区是否可行呢，通过分析发现，在这串数字中，其中确实有一位是0到9随机生成的，不同的卡串长度，这一位不同，绝不是最后一位，最后位数字一般都是校验位，不具有随机性。我们新设计的方案，基于银行卡号+随机位进行KEY分区，每次查询的时候，通过计算截取出这位随机位数字，再加上卡号，联合查询，达到了分区查询的目的，需要说明的是，分区后，建立的索引，也必须是分区列，否则的话，Mysql还是会在所有的分区表中查询数据。那么通过银行卡号查询绑定关系的问题解决了，那么证件号呢，如何通过证件号来查询绑定关系。前面已经讲过，做索引一定是要在分区健上进行，否则会引起全表扫描。我们再创建了一张新表，保存客户的证件号绑定关系，每位客户的证件号都是唯一的，新的证件号绑定关系表里，证件号作为了主键，那么如何来计算这个分区健呢，客户的证件信息比较庞杂，有身份证号，港澳台通行证，机动车驾驶证等等，如何在无序的证件号里找到分区健。为了解决这个问题，我们将证件号绑定关系表一分为二，其中的一张表专用于保存身份证类型的证件号，另一张表则保存其他证件类型的证件号，在身份证类型的证件绑定关系表中，我们将身份证号中的月数拆分出来作为了分区健，将同一个月出生的客户证件号保存在同一个区，这样分成了12个区，其他证件类型的证件号，数据量不超过10万，就没有必要进行分区了。这样每次查询时，首先通过证件类型确定要去查询哪张表，再计算分区健进行查询。</p>
<p>作了分区设计之后，保存2000万用户数据的时候，银行卡表的数据保存文件就分成了10个小文件，证件表的数据保存文件分成了12个小文件，解决了这两个查询的问题，还剩下一个问题就是，业务编号呢，怎么办，一个客户有多个签约业务，如何进行保存，这时候，采用分区的方案就不太合适了，它需要用到分表的方案。</p>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>如何进行分库分表，目前互联网上有许多的版本，比较知名的一些方案：</p>
<ul>
<li>阿里的<a href="https://github.com/alibaba/tb_tddl" target="_blank" rel="noopener">TDDL</a>，<a href="https://cn.aliyun.com/product/drds" target="_blank" rel="noopener">DRDS</a>和<a href="https://github.com/alibaba/cobar" target="_blank" rel="noopener">cobar</a></li>
<li><a href="https://yq.aliyun.com/articles/658786" target="_blank" rel="noopener">京东金融的sharding-jdbc</a></li>
<li>民间组织的<a href="https://github.com/MyCATApache/Mycat-Server" target="_blank" rel="noopener">MyCAT</a></li>
<li>360的<a href="https://github.com/Qihoo360/Atlas" target="_blank" rel="noopener">Atlas</a></li>
<li>美团的<a href="https://github.com/Meituan-Dianping/Zebra" target="_blank" rel="noopener">zebra</a></li>
</ul>
<p>其他比如网易，58，京东等公司都有自研的中间件。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0f0ubx3knj20oc0fd45s.jpg" alt=""><br>百花齐放的景象。但是这么多的分库分表中间件方案，归总起来，就两类： client模式和proxy模式 。</p>
<p><strong>client模式</strong><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1osp6e3j20fa0c2ta5.jpg" alt=""></p>
<p><strong>proxy模式</strong><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1v26i8nj20fa0gxmyt.jpg" alt=""></p>
<p>无论是client模式，还是proxy模式，几个核心的步骤是一样的：SQL解析，重写，路由，执行，结果归并。个人比较倾向于采用client模式，它架构简单，性能损耗也比较小，运维成本低。如果在项目中引入mycat或者cobar，他们的单机模式无法保证可靠性，一旦宕机则服务就变得不可用，你又不得不引入HAProxy来实现它的高可用集群部署方案， 为了解决HAProxy的高可用问题，又需要采用Keepalived来实现。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e2eu3bjvj20fa0gy0zk.jpg" alt=""></p>
<p>我们在项目中放弃了这个方案，采用了shardingjdbc的方式。回到刚才的业务问题，如何对业务类型进行分库分表。分库分表第一步也是最重要的一步，即sharding column的选取，sharding column选择的好坏将直接决定整个分库分表方案最终是否成功。而sharding column的选取跟业务强相关。在我们的项目场景中，sharding column无疑最好的选择是业务编号。通过业务编号，将客户不同的绑定签约业务保存到不同的表里面去，查询时，根据业务编号路由到相应的表中进行查询，达到进一步优化sql的目的。</p>
<p>前面我们讲到了基于客户签约绑定业务场景的数据库优化，下面我们再聊一聊，对于海量数据的保存方案。</p>
<h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h4><p>也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。</p>
<h4 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h4><p>垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。如下图：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ezns2ifaj20bf08kgml.jpg" alt=""><br><strong>优点</strong></p>
<p>数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于 Web 和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破 IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。</p>
<p><strong>缺点</strong></p>
<ul>
<li>跨库 join 的问题</li>
<li>跨库事务（分布式事务）的问题</li>
</ul>
<p><strong>解决方式</strong></p>
<ul>
<li>全局表 <ul>
<li>所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库 join 查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。</li>
</ul>
</li>
<li>字段冗余 <ul>
<li>这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免 join 查询。</li>
</ul>
</li>
<li>数据同步<ul>
<li>定时 A 库中的 tab_a 表和 B 库中 tbl_b 有关联，可以定时将指定的表做同步。当然，同步本来会对数据库带来一定的影响，需要性能影响和数据时效性中取得一个平衡。这样来避免复杂的跨库查询。例如ETL工具。</li>
</ul>
</li>
<li>系统层组装<ul>
<li>在系统层面，通过调用不同模块的组件或者服务，获取到数据并进行字段拼装。说起来很容易，但实践起来可真没有这么简单，尤其是数据库设计上存在问题但又无法轻易调整的时候。</li>
</ul>
</li>
</ul>
<p>对于每分钟要处理近1000万的流水，每天流水近1亿的量，如何高效的写入和查询，是一项比较大的挑战。还是老办法，分库分表分区，读写分离，只不过这一次，我们先分表，再分库，最后分区。我们将消息流水按照不同的业务类型进行分表，相同业务的消息流水进入同一张表，分表完成之后，再进行分库。我们将流水相关的数据单独保存到一个库里面去，这些数据，写入要求高，查询和更新到要求低，将它们和那些更新频繁的数据区分开。分库之后，再进行分区。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e30hgeqaj20fa06c75g.jpg" alt=""><br>这是基于业务垂直度进行的分库操作，垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库，以达到系统资源的饱和利用率。这样的分库方案结合应用的微服务治理，每个微服务系统使用独立的一个数据库。将不同模块的数据分库存储，模块间不能进行相互关联查询，如果有，要么通过数据冗余解决，要么通过应用代码进行二次加工进行解决。若不能杜绝跨库关联查询，则将小表到数据冗余到大数据量大库里去。假如，流水大表中查询需要关联获得渠道信息，渠道信息在基础管理库里面，那么，要么在查询时，代码里二次查询基础管理库中的渠道信息表，要么将渠道信息表冗余到流水大表中。</p>
<p>将每天过亿的流水数据分离出去之后，流水库中单表的数据量还是太庞大，我们将单张流水表继续分区，按照一定的业务规则，（一般是查询索引列）将单表进行分区，一个表编程N个表，当然这些变化对应用层是无法感知的。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e5r0z2zoj20fa0lgjw2.jpg" alt=""><br>分区表的设置，一般是以查询索引列进行分区，例如，对于流水表A，查询需要根据手机号和批次号进行查询，所以我们在创建分区的时候，就选择以手机号和批次号进行分区，这样设置后，查询都会走索引，每次查询Mysql都会根据查询条件计算出来，数据会落在那个分区里面，直接到对应的分区表中检索即可，避免了全表扫描。</p>
<p>对于每天流水过亿的数据，当然是要做历史表进行数据迁移的工作了。客户要求流水数据需要保存半年的时间，有的关键流水需要保存一年。删数据是不可能的了，也跑不了路，虽然当时非常有想删数据跑路的冲动。其实即时是删数据也是不太可能的了，delete的拙劣表演先淘汰了，truncate也快不了多少，我们采用了一种比较巧妙方法，具体步骤如下：</p>
<ol>
<li>创建一个原表一模一样的临时表1 <code>create table test_a_serial_1 like test_a_serial</code>;</li>
<li>将原表命名为临时表2 <code>alter table test_a_serial rename test_a_serial_{date}</code>;</li>
<li>将临时表1改为原表 <code>alter table able test_a_serial_1 rename able test_a_serial</code>; 此时，当日流水表就是一张新的空表了，继续保存当日的流水，而临时表2则保存的是昨天的数据和部分今天的数据，临时表2到名字中的date时间是通过计算获得的昨日的日期；每天会产生一张带有昨日日期的临时表2，每个表内的数据大约是有1000万。</li>
<li>将当日表中的历史数据迁移到昨日流水表中去 这样的操作都是用的定时任务进行处理，定时任务触发一般会选择凌晨12点以后，这个操作即时是几秒内完成，也有可能会有几条数据落入到当日表中去。因此我们最后还需要将当日表内的历史流水数据插入到昨日表内； <code>insert into test_a_serial_{date}(cloumn1,cloumn2….) select(cloumn1,cloumn2….) from test_a_serial where LEFT(create_time,8) &gt; CONCAT(date); commit</code>;</li>
</ol>
<p>如此，便完成了流水数据的迁移；</p>
<p>根据业务需要，有些业务数据需要保存半年，超过半年的进行删除,在进行删除的时候，就可以根据表名中的_{date}筛选出大于半年的流水直接删表；</p>
<p>半年的时间，对于一个业务流水表大约就会有180多张表，每张表又有20个分区表，那么如何进实时计算统计行查询呢？由于我们的项目对于流水的查询实时性要求不是特别高，因此我们在做查询时，进行了根据查询时间区间段进行路由查询的做法。大致做法时，根据客户选择的时间区间段，带上查询条件，分别去时间区间段内的每一张表内查询，将查询结果保存到一张临时表内，然后，再去查询临时表获得最终的查询结果。</p>
<p>半年的时间，对于一个业务流水表大约就会有180多张表，每张表又有20个分区表，那么如何进行查询呢？由于我们的项目对于流水的查询实时性要求不是特别高，因此我们在做查询时，进行了根据查询时间区间段进行路由查询的做法。大致做法时，根据客户选择的时间区间段，带上查询条件，分别去时间区间段内的每一张表内查询，将查询结果保存到一张临时表内，然后，再去查询临时表获得最终的查询结果。</p>
<p>以上便是我们面对大数据量的场景下，数据库层面做的相应的优化，一张每天一亿的表，经过拆分后，每个表分区内的数据在500万左右。</p>
<h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><h4 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h4><p>针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ezurxr0cj20bk07hwhl.jpg" alt=""><br>某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破 IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。</p>
<h4 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h4><p>将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。</p>
<p><strong>水平分库分表切分规则</strong></p>
<ul>
<li>RANGE<ul>
<li>从0到10000一个表，10001到20000一个表；</li>
</ul>
</li>
<li><a href="http://www.uml.org.cn/sjjm/201412301.asp?artid=15741" target="_blank" rel="noopener">HASH取模</a><ul>
<li>一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 取用户id，然后hash取模，分配到不同的数据库上。</li>
</ul>
</li>
<li>地理区域<ul>
<li>比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。</li>
</ul>
</li>
<li>时间<ul>
<li>按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。</li>
</ul>
</li>
</ul>
<h2 id="唯一ID方案"><a href="#唯一ID方案" class="headerlink" title="唯一ID方案"></a>唯一ID方案</h2><p>这个方案也很多，主流的有那么几种:</p>
<ul>
<li>利用数据库自增ID<ul>
<li>优点：最简单。 </li>
<li>缺点：单点风险、单机性能瓶颈。</li>
</ul>
</li>
<li>利用数据库集群并设置相应的步长（Flickr方案）<ul>
<li>优点：高可用、ID较简洁。 </li>
<li>缺点：需要单独的数据库集群。</li>
</ul>
</li>
<li>Twitter Snowflake<ul>
<li>优点：高性能高可用、易拓展。</li>
<li>缺点：需要独立的集群以及ZK。</li>
</ul>
</li>
<li>一大波GUID、Random算法<ul>
<li>优点：简单。 </li>
<li>缺点：生成ID较长，有重复几率。</li>
</ul>
</li>
<li>带有业务属性的方案： &gt; 时间戳+用户标识码+随机数<ul>
<li>优点：方便、成本低。基本无重复的可能。自带分库规则，这里的用户标识码即为用户ID的后四位，在查询的场景下，只需要订单号就可以匹配到相应的库表而无需用户ID，只取四位是希望订单号尽可能的短一些，并且评估下来四位已经足够。可排序，因为时间戳在最前面。</li>
<li>缺点：比如长度稍长，性能要比int/bigint的稍差等。</li>
</ul>
</li>
</ul>
<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><p>数据库拆分一般是业务发展到一定规模后的优化和重构，为了支持业务快速上线，很难一开始就分库分表，垂直拆分还好办，改改数据源就搞定了，一旦开始水平拆分，数据清洗就是个大问题，为此，我们经历了以下几个阶段。</p>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0f15jmuu7j20j80ibgmv.jpg" alt=""></p>
<ul>
<li>数据库双写（事务成功以老模型为准），查询走老模型。</li>
<li>每日job数据对账（通过DW），并将差异补平。</li>
<li>通过job导历史数据。</li>
</ul>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0f164jbhbj20j80ewgmg.jpg" alt=""><br>历史数据导入完毕并且数据对账无误。<br>依然是数据库双写，但是事务成功与否以新模型为准，在线查询切新模型。<br>每日job数据对账，将差异补平。</p>
<h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0f16or9y7j20j80ibtam.jpg" alt=""></p>
<ul>
<li>老模型不再同步写入，仅当订单有终态时才会异步补上。</li>
<li>此阶段只有离线数据依然依赖老的模型，并且下游的依赖非常多，待DW改造完就可以完全废除老模型了。</li>
</ul>
<h2 id="报表统计"><a href="#报表统计" class="headerlink" title="报表统计"></a>报表统计</h2><p>待我后续更新。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/02/18/分布式应用监控/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/分布式应用监控/" itemprop="url">分布式应用监控</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T15:47:00+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/18/分布式应用监控/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/02/18/分布式应用监控/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式应用监控"><a href="#分布式应用监控" class="headerlink" title="分布式应用监控"></a>分布式应用监控</h1><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ankzojyuj20my0dqgqa.jpg" alt="image"><br>分布式系统已经诞生了很长时间，现代互联网公司规模都变得异常庞大，系统也变得越来越复杂，给监控工作带来了极大的难度：海量日志数据如何处理，服务如何追踪，如何高效定位故障缩短故障时常，常见的监控手段可以分为集中式日志系统（Logging），集中式度量系统（Metrics）和分布式追踪系统（Tracing）。</p>
<h2 id="集中式日志系统"><a href="#集中式日志系统" class="headerlink" title="集中式日志系统"></a>集中式日志系统</h2><p>集中式日志系统，选取了最具代表性的<a href="https://www.elastic.co/elk-stack" target="_blank" rel="noopener">ELK</a><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anmng640j20t20u0qb9.jpg" alt="image"></p>
<h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><p>Elasticsearch是个开源的分布式搜索引擎，提供搜索、分析、存储数据三大功能。它的特点有：分布式、自动发现、索引自动分片、索引副本机制、RESTful 风格接口、多数据源以及自动搜索负载等。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anngzbwsj20ge06cmxi.jpg" alt="image"></p>
<h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><p>Logstash 是一个开源的动态数据收集处理管道，它可以同时从多个源中提取数据，对其进行转换，并且拥有可扩展的插件生态系统，能够与 Elasticsearch 产生强大的协同作用。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ano9kvhpj20ae0fidh8.jpg" alt="image"></p>
<h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><p>Kibana是一个开源的分析与可视化平台，设计出来用于和Elasticsearch一起使用的。你可以用kibana搜索、查看存放在Elasticsearch中的数据。Kibana与Elasticsearch的交互方式是各种不同的图表、表格、地图等，直观的展示数据，从而达到高级的数据分析与可视化的目的。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anos2ri4j20u00ioaoe.jpg" alt="image"></p>
<h3 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h3><p>Beats 是 ELK Stack 技术栈中负责单一用途数据采集并推送给 Logstash 或 Elasticsearch 的轻量级产品。包括：</p>
<ul>
<li>Filebeats：应用于日志收集场景的实现。</li>
<li>Metricbeat：轻量级的系统级性能指标监控工具。</li>
<li>Packetbeat：轻量级的网络数据包分析工具。</li>
<li>Winlogbeat：轻量级的 Windows 事件日志收集工具。</li>
<li>Heartbeat：心跳检测工具，主要监控服务的可用性。</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anqgzyihj20rs0jkq8b.jpg" alt="image"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>修改虚拟机的内存限制<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vi</span> /etc/sysctl.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure></p>
<p>加入<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="attribute">max_map_count</span>=262144</span><br></pre></td></tr></table></figure></p>
<p><code>sysctl -p</code>查看设置</p>
<p>docker安装ELK<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull sebp/elk</span><br><span class="line">docker <span class="builtin-name">run</span> -p 5601:5601 -p 9200:9200 -p 5044:5044 -e <span class="attribute">ES_MIN_MEM</span>=128m  -e <span class="attribute">ES_MAX_MEM</span>=1024m -it --name elk sebp/elk</span><br></pre></td></tr></table></figure></p>
<p>输入网址<code>http://&lt;your-host&gt;:5601</code>可以看到下面的界面，则说明安装成功<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anujxybgj22la1ac7e1.jpg" alt="image"></p>
<h4 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -<span class="keyword">it</span> &lt;container-<span class="built_in">name</span>&gt; /bin/bash</span><br></pre></td></tr></table></figure>
<p>进入容器，执行命令<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/opt/</span>logstash<span class="regexp">/bin/</span>logstash -e <span class="string">'input &#123; stdin &#123; &#125; &#125; output &#123; elasticsearch &#123; hosts =&gt; ["localhost"] &#125; &#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>如果有错误信息<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service logstash <span class="built_in">stop</span></span><br></pre></td></tr></table></figure></p>
<p>当命令成功被执行后，看到：<code>Successfully started Logstash API endpoint {:port=&gt;9600}</code>信息后，输入：<code>this is a dummy entry</code>然后回车，模拟一条日志进行测试。</p>
<p>打开浏览器<code>http://&lt;your-host&gt;:9200/_search?pretty</code>，如图所示<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anxotbydj22k419y475.jpg" alt="image"></p>
<p>打开浏览器，输入：<code>http://&lt;your-host&gt;:5601</code> 点击创建<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anykdlefj20yn0maacx.jpg" alt="image"></p>
<p>看到如下界面，到此安装结束。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anujxybgj22la1ac7e1%20%281%29.jpg" alt="image"></p>
<p>与java应用结合的日志分析系统可以通过Beats的Filebeats来实现，通过log4j将运行日志输出在文件中，通过Filebeats插件利用Logstash过滤并导入到Elasticsearch中，最后通过Kibana展示。</p>
<h2 id="集中式度量系统"><a href="#集中式度量系统" class="headerlink" title="集中式度量系统"></a>集中式度量系统</h2><h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p><a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a>是一个基于时间序列的数值数据的监控解决方案，这是一个开源项目，由前Google员工在SoundCloud启动，他们希望监控一个高度动态的容器环境，因为对传统的监控工具不甚满意，所以开发出Prometheus，并在上面进行工作。Prometheus解决了Devs如何监控高动态容器环境的问题。</p>
<p>例如我们想要获取所有的服务器上node_exporter暴露出来的数据，就必须有个程序去定时访问这些接口，如果想要增加或者修改这些接口，那么就需要有个配置文件来记录这些服务器的地址，如果想要访问历史的某个时间点的数据，那么就必须按照时间顺序存储获取到的指标和值。而如果想要将值绘制成图，也需要有代码去查询、计算和渲染。最后你可能还希望当服务器的某个指标超过一定的阈值时，向指定的接口发出告警信息。一切的一切其实都可以使用Prometheus来解决。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ao1npp86j20z00kc0wk.jpg" alt="image"></p>
<h3 id="Prometheus检测mysql相关指标"><a href="#Prometheus检测mysql相关指标" class="headerlink" title="Prometheus检测mysql相关指标"></a>Prometheus检测mysql相关指标</h3><p>前提：本地安装了mysql</p>
<h4 id="安装node-exporter"><a href="#安装node-exporter" class="headerlink" title="安装node-exporter"></a>安装node-exporter</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull <span class="keyword">node</span><span class="title">-exporter</span></span><br><span class="line">docker run -d -p <span class="number">9100</span>:<span class="number">9100</span> --cap-add SYS_TIME --<span class="attr">net=</span><span class="string">"host"</span> --<span class="attr">pid=</span><span class="string">"host"</span> -v <span class="string">"/:/host:ro,rslave"</span>quay.io/prometheus/<span class="keyword">node</span><span class="title">-exporter</span> --<span class="attr">cap-add=</span>SYS_TIME --path.rootfs /host</span><br></pre></td></tr></table></figure>
<h4 id="安装mysqld-exporter"><a href="#安装mysqld-exporter" class="headerlink" title="安装mysqld-exporter"></a>安装mysqld-exporter</h4><p>通过mysql命令界面创建相应角色并赋予权限<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'mysql_monitor'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'XXXXXXXX'</span> <span class="keyword">WITH</span> MAX_USER_CONNECTIONS <span class="number">3</span>;</span><br><span class="line"><span class="keyword">GRANT</span> PROCESS, <span class="keyword">REPLICATION</span> <span class="keyword">CLIENT</span>, <span class="keyword">SELECT</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'mysql_monitor'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure></p>
<p>docker安装<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysqld-exporter</span><br><span class="line">docker <span class="builtin-name">run</span> -d -p 9104:9104 -e <span class="attribute">DATA_SOURCE_NAME</span>=<span class="string">"mysql_monitor:root@(127.0.0.1:3306)/"</span> prom/mysqld-exporter</span><br></pre></td></tr></table></figure></p>
<h4 id="安装Prometheus"><a href="#安装Prometheus" class="headerlink" title="安装Prometheus"></a>安装Prometheus</h4><p>创建文件<code>prometheus.yml</code><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">global</span>:</span><br><span class="line">  <span class="attribute">scrape_interval</span>:     <span class="number">60s</span></span><br><span class="line">  <span class="attribute">evaluation_interval</span>: <span class="number">60s</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">scrape_configs</span>:</span><br><span class="line">  - <span class="attribute">job_name</span>: prometheus</span><br><span class="line">    <span class="attribute">static_configs</span>:</span><br><span class="line">      - <span class="attribute">targets</span>: [<span class="string">'106.15.226.184:9090'</span>]</span><br><span class="line">        <span class="attribute">labels</span>:</span><br><span class="line">          <span class="attribute">instance</span>: prometheus</span><br><span class="line"></span><br><span class="line">  - <span class="attribute">job_name</span>: linux</span><br><span class="line">    <span class="attribute">static_configs</span>:</span><br><span class="line">      - <span class="attribute">targets</span>: [<span class="string">'106.15.226.184:9100'</span>]</span><br><span class="line">        <span class="attribute">labels</span>:</span><br><span class="line">          <span class="attribute">instance</span>: db1</span><br><span class="line"></span><br><span class="line">  - <span class="attribute">job_name</span>: mysql</span><br><span class="line">    <span class="attribute">static_configs</span>:</span><br><span class="line">      - <span class="attribute">targets</span>: [<span class="string">'106.15.226.184:9104'</span>]</span><br><span class="line">        <span class="attribute">labels</span>:</span><br><span class="line">          <span class="attribute">instance</span>: db1</span><br></pre></td></tr></table></figure></p>
<p>docker启动<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull prometheus</span><br><span class="line">sudo docker run -d -p <span class="number">9090</span>:<span class="number">9090</span> -v <span class="regexp">/root/</span>conf<span class="regexp">/prometheus.yml:/u</span>sr<span class="regexp">/local/</span>src<span class="regexp">/file/</span>prometheus.yml quay.io<span class="regexp">/prometheus/</span>prometheus --config.<span class="keyword">file</span>=<span class="regexp">/usr/</span>local<span class="regexp">/src/</span><span class="keyword">file</span><span class="regexp">/prometheus.yml</span></span><br></pre></td></tr></table></figure></p>
<h4 id="安装Grafana"><a href="#安装Grafana" class="headerlink" title="安装Grafana"></a>安装Grafana</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull grafana/grafana</span><br><span class="line">docker <span class="builtin-name">run</span> -d <span class="attribute">--name</span>=grafana -p 3000:3000 grafana/grafana</span><br></pre></td></tr></table></figure>
<p>打开<code>http:x.x.x.x:9090</code><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aocmau0ej22l812ogqo.jpg" alt="image"><br>如图所示，说明数据源管道agent启动成功</p>
<p>打开<code>http://x.x.x.x:3000</code>，配置Prometheus数据源<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aoe1u94dj20pp0qv78x.jpg" alt="image"></p>
<p>配置好数据源后，下载<a href="https://codeload.github.com/percona/grafana-dashboards/zip/v1.17.0" target="_blank" rel="noopener">mysql监控模板</a>，<br>解压后，找到mysql开头的模板，导入，最后如图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aog1imivj22jc19e46g.jpg" alt="image"></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aogngitwj22ki19g11f.jpg" alt="image"></p>
<h3 id="Cat"><a href="#Cat" class="headerlink" title="Cat"></a>Cat</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aoibi3egj20qo0eujsb.jpg" alt="image"><br><a href="https://github.com/dianping/cat" target="_blank" rel="noopener">CAT</a>（Central Application Tracking）是一个实时和接近全量的监控系统，它侧重于对Java应用的监控，基本接入了美团上海侧所有核心应用。目前在中间件（MVC、RPC、数据库、缓存等）框架中得到广泛应用，为美团各业务线提供系统的性能指标、健康状况、监控告警等。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aoim0nuwj20zy0lwk41.jpg" alt="image"></p>
<p>监控整体要求就是快速发现故障、快速定位故障以及辅助进行程序性能优化。为了做到这些，我们对监控系统的一些非功能做了如下的要求：</p>
<p>实时处理：信息的价值会随时间锐减，尤其是事故处理过程中。<br>全量数据：最开始的设计目标就是全量采集，全量的好处有很多。<br>高可用：所有应用都倒下了，需要监控还站着，并告诉工程师发生了什么，做到故障还原和问题定位。<br>故障容忍：CAT本身故障不应该影响业务正常运转，CAT挂了，应用不该受影响，只是监控能力暂时减弱。<br>高吞吐：要想还原真相，需要全方位地监控和度量，必须要有超强的处理吞吐能力。<br>可扩展：支持分布式、跨IDC部署，横向扩展的监控系统。<br>不保证可靠：允许消息丢失，这是一个很重要的trade-off，目前CAT服务端可以做到4个9的可靠性，可靠系统和不可靠性系统的设计差别非常大。<br>CAT从开发至今，一直秉承着简单的架构就是最好的架构原则，主要分为三个模块：CAT-client、CAT-consumer、CAT-home。</p>
<p>Cat-client 提供给业务以及中间层埋点的底层SDK。<br>Cat-consumer 用于实时分析从客户端提供的数据。<br>Cat-home 作为用户给用户提供展示的控制端。<br>在实际开发和部署中，Cat-consumer和Cat-home是部署在一个JVM内部，每个CAT服务端都可以作为consumer也可以作为home，这样既能减少整个层级结构，也可以增加系统稳定性。<br>上图是CAT目前多机房的整体结构图，图中可见：</p>
<p>路由中心是根据应用所在机房信息来决定客户端上报的CAT服务端地址，目前美团有广州、北京、上海三地机房。<br>每个机房内部都有独立的原始信息存储集群HDFS。<br>CAT-home可以部署在一个机房也可以部署在多个机房，在最后做展示的时候，home会从consumer中进行跨机房的调用，将所有的数据合并展示给用户。<br>实际过程中，consumer、home以及路由中心都是部署在一起的，每个服务端节点都可以充当任何一个角色。</p>
<h4 id="安装使用Cat"><a href="#安装使用Cat" class="headerlink" title="安装使用Cat"></a>安装使用Cat</h4><p>本文演示单机集群安装部署<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/dianping/<span class="keyword">cat</span>.git</span><br><span class="line"><span class="keyword">cd</span> docker</span><br><span class="line">docker-compose <span class="keyword">up</span></span><br></pre></td></tr></table></figure></p>
<p>第一次运行以后，数据库中没有表结构，需要通过下面的命令创建表：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> exec &lt;container_id&gt; <span class="keyword">bash </span>-c <span class="string">"mysql -uroot -Dcat &lt; /init.sql"</span></span><br></pre></td></tr></table></figure></p>
<p>依赖配置说明</p>
<ul>
<li>datasources.xml<ul>
<li>CAT数据库配置，默认配置是mysql镜像，可以按需替换</li>
</ul>
</li>
<li>docker-compose.yml<ul>
<li>通过docker-compose启动的编排文件，文件中包含cat和mysql。可以屏蔽掉mysql的部分，并且修改cat的环境变量，改为真实的mysql连接信息。</li>
</ul>
</li>
<li>client.xml<ul>
<li>CAT 初始化默认的路由列表，配置此文件可以将客户端数据上报指向到不同环境。</li>
</ul>
</li>
<li>datasources.sh<ul>
<li>辅助脚本，脚本作用时修改datasources.xml，使用环境变量中制定的mysql连接信息。（通过sed命令替换）</li>
</ul>
</li>
</ul>
<h4 id="Java-应用的集成"><a href="#Java-应用的集成" class="headerlink" title="Java 应用的集成"></a>Java 应用的集成</h4><p><a href="https://blog.csdn.net/kefengwang/article/details/81213031" target="_blank" rel="noopener">参考博客</a><br>需要指定 cat 专用的远程仓库<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- %MAVEN_HOME%\conf\settings.xml --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>unidal.nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://unidal.org/nexus/content/repositories/releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>加入依赖(pom.xml)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dianping.cat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cat-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>添加过滤器 CatFilter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatFilterConfigure</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">catFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        registration.setFilter(<span class="keyword">new</span> CatFilter());</span><br><span class="line">        registration.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        registration.setName(<span class="string">"cat-filter"</span>);</span><br><span class="line">        registration.setOrder(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加注解<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CatCacheTransaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="meta">@CatHttpRequestTransaction</span>(type = <span class="string">"URL"</span>, name = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aoqxnurij20qp0d3k4h.jpg" alt="image"></p>
<p>更多集成<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aos0a6q6j20rl0fdwvn.jpg" alt="image"></p>
<h5 id="管理平台的使用"><a href="#管理平台的使用" class="headerlink" title="管理平台的使用"></a>管理平台的使用</h5><p>控制台<br><a href="http://192.168.126.101:8080/cat" target="_blank" rel="noopener">http://192.168.126.101:8080/cat</a><br>帐号/密码: catadmin/catadmin</p>
<p>项目配置<br><a href="http://192.168.126.101:8080/cat/s/config?op=projects" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/s/config?op=projects</a></p>
<p>相关文档<br>部署文档: <a href="http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=deploy" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=deploy</a><br>用户文档：<a href="http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=user" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=user</a><br>告警文档：<a href="http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=alert" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=alert</a><br>集成文档：<a href="http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=integration" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=integration</a><br>开发文档：<a href="http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=develop" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=develop</a><br>设计文档：<a href="http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=design" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=design</a><br>常见问题：<a href="http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=problem" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=problem</a></p>
<p>实时查看<br><a href="http://192.168.126.101:8080/cat/r/t" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/t</a><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aov6vr6mj21gw0o8147.jpg" alt="image"></p>
<h2 id="分布式追踪系统"><a href="#分布式追踪系统" class="headerlink" title="分布式追踪系统"></a>分布式追踪系统</h2><h3 id="Zipkin"><a href="#Zipkin" class="headerlink" title="Zipkin"></a>Zipkin</h3><p><a href="https://zipkin.io/" target="_blank" rel="noopener">Zipkin</a>是一种分布式跟踪系统。它有助于收集解决微服务架构中的延迟问题所需的时序数据。它管理这些数据的收集和查找。Zipkin的设计基于Google Dapper论文。<br>应用程序用于向Zipkin报告时序数据。Zipkin UI还提供了一个依赖关系图，显示了每个应用程序通过的跟踪请求数。如果要解决延迟问题或错误，可以根据应用程序，跟踪长度，注释或时间戳对所有跟踪进行筛选或排序。选择跟踪后，您可以看到每个跨度所需的总跟踪时间百分比，从而可以识别问题应用程序。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aox97889j20u20ewn0o.jpg" alt="image"></p>
<p>共有四个组件构成了 Zipkin：</p>
<ul>
<li>collector</li>
<li>storage</li>
<li>search</li>
<li>web UI</li>
</ul>
<p><strong>Zipkin Collector</strong></p>
<p>一旦追踪数据抵达 Zipkin Collector 守护进程，Zipkin Collector 为了查询，会对其进行校验、存储和索引。</p>
<p><strong>Storage</strong></p>
<p>Zipkin 最初是构建在将数据存储在 Cassandra 中，因为 Cassandra 易跨站，支持灵活的 schema，并且在 Twitter 内部被大规模使用。然而，我们将这个组件做成了可插拔式的。在 Cassandra 之外，我们原生支持 ElasticSearch 和 MySQL。可作为第三方扩展提供给其它后端。</p>
<p><strong>Zipkin 查询服务</strong></p>
<p>一旦数据被存储索引，我们就需要一种方式提取它。查询守护进程提供了一个简单的 JSON API 查询和获取追踪数据。API 的主要消费者就是 Web UI。</p>
<p><strong>Web UI</strong></p>
<p>我们创建了一个用户图形界面为追踪数据提供了一个漂亮的视图。Web UI 提供了基于服务、时间和标记（annotation）查看追中数据的方法。注意：UI 没有内置的身份认证功能。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0bpyewjhlj20id0e0acc.jpg" alt="image"></p>
<h5 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h5><p><a href="https://www.linzepeng.com/2018/06/21/zipkin-node/" target="_blank" rel="noopener">参考</a><br>前提条件：已经安装好ElasticSearch</p>
<p>安装zookeeper和kafka<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> pull wurstmeister/zookeeper  </span><br><span class="line"> </span><br><span class="line">docker pull wurstmeister/kafka</span><br></pre></td></tr></table></figure></p>
<p>启动镜像<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d <span class="params">--name</span> zookeeper <span class="params">--publish</span> 2181<span class="function">:2181</span> <span class="params">--volume</span> <span class="string">/etc/localtime</span>:<span class="string">/etc/localtime</span> zookeeper<span class="function">:latest</span></span><br><span class="line">docker run -d <span class="params">--name</span> kafka <span class="params">--publish</span> 9092<span class="function">:9092</span> <span class="params">--link</span> zookeeper <span class="params">--env</span> KAFKA_ZOOKEEPER_CONNECT=zookeeper<span class="function">:2181</span> </span><br><span class="line"><span class="params">--env</span> KAFKA_ADVERTISED_HOST_NAME=kafka所在宿主机的IP <span class="params">--env</span> KAFKA_ADVERTISED_PORT=9092 <span class="params">--volume</span> <span class="string">/etc/localtime</span>:<span class="string">/etc/localtime</span> </span><br><span class="line">wurstmeister/kafka<span class="function">:latest</span></span><br><span class="line">docker run -d <span class="params">--name</span> zipkin-server -p 9411<span class="function">:9411</span> -e <span class="string">"KAFKA_BOOTSTRAP_SERVERS=your-kafka-address"</span> -e <span class="string">"STORAGE_TYPE=elasticsearch"</span> -e <span class="string">"ES_HOSTS=your-es-host"</span> -e <span class="string">"ES_INDEX=zipkin"</span> -e <span class="string">"ES_INDEX_SHARDS=1"</span> -e <span class="string">"ES_INDEX_REPLICAS=1"</span> zipkin<span class="function">:latest</span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>用maven新建springboot项目<br>引入依赖，包括Spring Cloud Sleuth和Kafka传输的支持依赖Spring Stream Kafak以及web依赖。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>配置<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">service-producer</span> <span class="comment"># 配置应用名称</span></span><br><span class="line"><span class="attr">  kafka:</span></span><br><span class="line"><span class="attr">    bootstrap-servers:</span> <span class="attr">localhost:9092</span> <span class="comment"># 缓冲kafka地址</span></span><br><span class="line"><span class="attr">  sleuth:</span></span><br><span class="line"><span class="attr">    sampler:</span></span><br><span class="line"><span class="attr">      percentage:</span> <span class="number">1</span> <span class="comment"># 设置采样频率，默认为0.1，设置为全采样，便于观测，实际项目中根据具体情况设置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p>
<p>类似的方法再新建一个项目然后写一个接口进行2个服务之间的通讯，触发调用链，可以在<code>http://localhost:9411</code>查看如下效果图：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0bqg7veq9j218o0bu40c.jpg" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0bqgjj4w0j219009a75y.jpg" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0bqgvdbznj218o0jrq7g.jpg" alt="image"><br>需要注意的是，我们使用的存储模块是ES，所以一段时间内的服务调用关系图是无法直接得到的（使用内存存储可以直接得到）。我们需要使用Zipkin官方提供的zipkin-dependencies来生成依赖关系图。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ex to run the job to process yesterday's traces on OS/X</span></span><br><span class="line">$ <span class="attribute">STORAGE_TYPE</span>=elasticsearch <span class="attribute">ES_HOSTS</span>=your-es-host <span class="attribute">ES_INDEX</span>=zipkin <span class="attribute">ES_NODES_WAN_ONLY</span>=<span class="literal">true</span> java -jar zipkin-dependencies.jar `date -uv-1d +%F`</span><br></pre></td></tr></table></figure></p>
<h3 id="Pinpoint"><a href="#Pinpoint" class="headerlink" title="Pinpoint"></a>Pinpoint</h3><p><a href="https://naver.github.io/pinpoint/" target="_blank" rel="noopener">Pinpoint</a>是一个开源的APM监控工具，我们可以通过pinpoint实时跟踪应用之间的调用、程序的响应时间以及服务器资源使用状态，可以在分布式环境中为没个调用生成代码级别的可视图并定位瓶颈点和失败点。Pinpoint的设计也是基于Google Dapper论文<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aoyo8a04j20ru0ietcq.jpg" alt="image"></p>
<h4 id="安装部署-1"><a href="#安装部署-1" class="headerlink" title="安装部署"></a>安装部署</h4><p><a href="https://blog.csdn.net/qq_21816375/article/details/80455681" target="_blank" rel="noopener">参考</a><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/naver/pinpoint-docker.git</span><br><span class="line"><span class="keyword">cd</span> Pinpoint-Docker</span><br><span class="line">docker-compose pull &amp;&amp; docker-compose <span class="keyword">up</span> -d</span><br></pre></td></tr></table></figure></p>
<p>如有问题，请修改相对路径为绝对路径<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> volumes:</span><br><span class="line">      -<span class="ruby"> /home/pinpoint/hbase</span></span><br><span class="line"><span class="ruby">      - <span class="regexp">/home/pinpoint</span><span class="regexp">/zookeeper</span></span></span><br><span class="line"><span class="ruby">...</span></span><br></pre></td></tr></table></figure></p>
<p>启动镜像,访问<code>http://x.x.x.x:8079/</code><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0br3dxdetj21hg0rqtds.jpg" alt="image"><br>hbase页面 <code>http://x.x.x.x:16010/</code><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0br4jwwxyj21h20s2wk3.jpg" alt="image"></p>
<h3 id="Skywalking"><a href="#Skywalking" class="headerlink" title="Skywalking"></a>Skywalking</h3><p><a href="http://skywalking.apache.org/" target="_blank" rel="noopener">Skywalking</a>是一款优秀的国产 APM 工具，包括了分布式追踪、性能指标分析、应用和服务依赖分析等。通过在应用程序中添加 SkyWalking Agent，就可以将接口、服务、数据库、MQ等进行追踪，将追踪结果通过 HTTP 或 gRPC 发送到 SkyWalking Collecter，SkyWalking Collecter 经过分析和聚合，将结果存储到 Elasticsearch 或 H2，SkyWalking 同时提供了一个 SkyWalking UI 的可视化界面，UI 以 GraphQL + HTTP 方式获取存储数据进行展示。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aozn4exyj20uk0f6wif.jpg" alt="image"></p>
<h4 id="安装部署-2"><a href="#安装部署-2" class="headerlink" title="安装部署"></a>安装部署</h4><p><a href="https://www.jianshu.com/p/6fc29924f495" target="_blank" rel="noopener">参考博客</a></p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>拷贝apache-skywalking-apm-incubating目录下的agent目录到应用程序位置，探针包含整个目录，请不要改变目录结构</p>
<p>java程序启动时，增加JVM启动参数，<code>-javaagent:/path/to/agent/skywalking-agent.jar</code>。参数值为<code>skywalking-agent.jar</code>的绝对路径</p>
<p>agent探针配置，简单修改下<code>agent.application_code</code>即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前的应用编码，最终会显示在webui上。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建议一个应用的多个实例，使用有相同的application_code。请使用英文</span></span><br><span class="line">agent.application_code=Your_ApplicationName</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每三秒采样的Trace数量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认为负数，代表在保证不超过内存Buffer区的前提下，采集所有的Trace</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> agent.sample_n_per_3_secs=-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置需要忽略的请求地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认配置如下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> agent.ignore_suffix=.jpg,.jpeg,.js,.css,.png,.bmp,.gif,.ico,.mp3,.mp4,.html,.svg</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 探针调试开关，如果设置为<span class="literal">true</span>，探针会将所有操作字节码的类输出到/debugging目录下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> skywalking团队可能在调试，需要此文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> agent.is_open_debugging_class = <span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对应Collector的config/application.yml配置文件中 agent_server/jetty/port 配置内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单节点配置：SERVERS=<span class="string">"127.0.0.1:8080"</span> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群配置：SERVERS=<span class="string">"10.2.45.126:8080,10.2.45.127:7600"</span> </span></span><br><span class="line">collector.servers=127.0.0.1:10800</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件名称前缀</span></span><br><span class="line">logging.file_name=skywalking-agent.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件最大大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果超过此大小，则会生成新文件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认为300M</span></span><br><span class="line">logging.max_file_size=314572800</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志级别，默认为DEBUG。</span></span><br><span class="line">logging.level=DEBUG</span><br></pre></td></tr></table></figure></p>
<p>一切正常的话，稍后就可以在skywalking ui看到了。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0bs6hyznoj21gg0pldjo.jpg" alt="image"></p>
<h3 id="Jaeger"><a href="#Jaeger" class="headerlink" title="Jaeger"></a>Jaeger</h3><p>Uber开源的<a href="https://www.jaegertracing.io/" target="_blank" rel="noopener">Jaeger</a>用于监控和排除基于微服务的分布式系统，包括：</p>
<ul>
<li>分布式上下文传播</li>
<li>分布式事务监控</li>
<li>根本原因分析</li>
<li>服务依赖性分析</li>
<li>性能/延迟优化</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ap1ca1x2j20um0gi78o.jpg" alt="image"></p>
<h4 id="安装部署-3"><a href="#安装部署-3" class="headerlink" title="安装部署"></a>安装部署</h4><p>all-in-one 是Uber官方打包好的镜像，可以直接部署使用，但是只能用于测试环境，不能用于线上，因为它把数据放入了内存。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -e COLLECTOR_ZIPKIN_HTTP_PORT=<span class="number">9411</span> -<span class="string">p5775:</span><span class="number">5775</span><span class="regexp">/udp -p6831:6831/</span>udp -<span class="string">p6832:</span><span class="number">6832</span>/udp \</span><br><span class="line">  -<span class="string">p5778:</span><span class="number">5778</span> -<span class="string">p16686:</span><span class="number">16686</span> -<span class="string">p14268:</span><span class="number">14268</span> -<span class="string">p9411:</span><span class="number">9411</span> jaegertracing/all-<span class="keyword">in</span>-<span class="string">one:</span>latest</span><br></pre></td></tr></table></figure>
<p>通过 <a href="http://localhost:16686" target="_blank" rel="noopener">http://localhost:16686</a> 可以在浏览器查看 Jaeger的后台</p>
<p>正常安装<a href="https://blog.yeeef.com/post/uber_jaeger/" target="_blank" rel="noopener">参考</a></p>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p><a href="https://medium.com/opentracing/take-opentracing-for-a-hotrod-ride-f6e3141f7941" target="_blank" rel="noopener">参考</a></p>
<h3 id="分布式链路追踪技术对比"><a href="#分布式链路追踪技术对比" class="headerlink" title="分布式链路追踪技术对比"></a>分布式链路追踪技术对比</h3><p><a href="https://blog.csdn.net/u012394095/article/details/79700200" target="_blank" rel="noopener">来自博文</a></p>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>由大众点评开源，基于Java开发的实时应用监控平台，包括实时应用监控，业务监控 。 集成方案是通过</p>
<p>代码埋点的方式来实现监控，比如： 拦截器，注解，过滤器等。   对代码的侵入性很大，集成成本较高。<br>支持技术栈： </p>
<ul>
<li>dubbo</li>
<li>spring mvc ,spring aop ,springmvc-url</li>
<li>spring boot</li>
<li>mybatis</li>
<li>log4j , logback</li>
<li>playframework</li>
<li>http请求</li>
</ul>
<p>风险较大。 </p>
<h4 id="zipkin"><a href="#zipkin" class="headerlink" title="zipkin"></a>zipkin</h4><p>由Twitter团队开源， Zipkin是一个分布式的跟踪系统。它有助于收集数据需要解决潜在的问题在市微服架构的时机。它管理数据的收集和查找 .</p>
<p>该产品结合spring-cloud-sleuth使用较为简单， 集成很方便。 但是功能较简单。</p>
<p>支持技术栈：</p>
<ul>
<li>spring cloud</li>
</ul>
<p>以上是结合spring-cloud-sleuth支持的技术栈</p>
<h4 id="pinpoint"><a href="#pinpoint" class="headerlink" title="pinpoint"></a>pinpoint</h4><p>由韩国团队naver团队开源，针对大规模分布式系统用链路监控，使用java写的工具。灵感来自短小精悍，帮助分析系统的总</p>
<p>体结构和内部组件如何被调用在分布式应用提供了一个很好的解决方案。</p>
<p>使用java探针字节码增加技术，实现对整个应用的监控 。 对应用零侵入</p>
<p>支持技术栈： </p>
<ul>
<li>Tomcat 6+,Jetty 8/9,JBoss 6,Resin 4,Websphere 6+,Vertx 3.3+</li>
<li>Spring, Spring Boot (Embedded Tomcat, Jetty)</li>
<li>HTTP Client 3.x/4.x, HttpConnector, GoogleHttpClient, OkHttpClient, NingAsyncHttpClient</li>
<li>Thrift, Dubbo</li>
<li>mysql, oracle, mssql, cubrid,PostgreSQL, maria</li>
<li>arcus, memcached, redis, cassandra</li>
<li>MyBatis</li>
<li>DBCP, DBCP2, HIKARICP</li>
<li>gson, Jackson, Json Lib</li>
<li>log4j, Logback</li>
</ul>
<h4 id="skywalking"><a href="#skywalking" class="headerlink" title="skywalking"></a>skywalking</h4><p>2015年由个人吴晟（华为开发者）开源 ， 2017年加入Apache孵化器。</p>
<p>针对分布式系统的应用性能监控系统，特别针对微服务、cloud native和容器化(Docker, Kubernetes, Mesos)架构， 其核心是个分布式追踪系统。</p>
<p>使用java探针字节码增加技术，实现对整个应用的监控 。对应用零侵入</p>
<p>支持技术栈</p>
<ul>
<li>Tomcat7+ , resin3+, jetty</li>
<li>spring boot ,spring mvc</li>
<li>strtuts2</li>
<li>spring RestTemplete ,spring-cloud-feign</li>
<li>okhttp , httpClient</li>
<li>msyql ,oracle , H2 , sharding-jdbc,PostgreSQL</li>
<li>dubbo,dubbox ,motan, gRpc ,</li>
<li>rocketMq , kafla</li>
<li>redis, mongoDB,memcached ,</li>
<li>elastic-job , Netflix Eureka , Hystric</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>模拟了三种并发用户：500，750，1000。使用jmeter测试，每个线程发送30个请求，设置思考时间为10ms。使用的采样率为1，即100%，这边与生产可能有差别。</p>
<p>pinpoint默认的采样率为20，即50%，通过设置agent的配置文件改为100%。zipkin默认也是1。组合起来，一共有12种。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/01/24/TestNG测试框架与rest-assured结合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/24/TestNG测试框架与rest-assured结合/" itemprop="url">TestNG测试框架与rest-assured结合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-24T09:47:00+08:00">
                2019-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/24/TestNG测试框架与rest-assured结合/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/01/24/TestNG测试框架与rest-assured结合/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://testng.org/doc/index.html" target="_blank" rel="noopener">TestNG官网</a></p>
<h1 id="TestNG简介"><a href="#TestNG简介" class="headerlink" title="TestNG简介"></a>TestNG简介</h1><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0apgqmzy2j206o06odhi.jpg" alt="image"></p>
<p>TestNG是一个受JUnit和NUnit启发的测试框架，但引入了一些新功能，使其功能更强大，相对于JUnit来说，xml的配置使的testNG对于不同测试之间的依赖程度有更好的把控性。</p>
<h1 id="rest-assured简介"><a href="#rest-assured简介" class="headerlink" title="rest-assured简介"></a>rest-assured简介</h1><p>在Java中测试和验证REST服务比在Ruby和Groovy等动态语言中更难。REST <a href="http://rest-assured.io/" target="_blank" rel="noopener">Assured</a>将使用这些语言的简单性带入了Java域。</p>
<h1 id="TestNG测试框架与rest-assured结合"><a href="#TestNG测试框架与rest-assured结合" class="headerlink" title="TestNG测试框架与rest-assured结合"></a>TestNG测试框架与rest-assured结合</h1><p>项目地址：<br><a href="https://github.com/dinghuang/testNGExample" target="_blank" rel="noopener">https://github.com/dinghuang/testNGExample</a></p>
<p>上面实现了模拟用户登录以及rest-assured的高级用法，同时可以通过命令行直接生成报告，报告中对http请求增加了过滤，会在报告中展示请求信息，可以通过xml解析直接获取，还实现了多个suit通过mvn命令直接运行。目前在Choerodon中已经增加了TestNG的支持，用户可以直接推到gitlab，gitlab中的runner会在ci中打包并运行测试jar包，把报告解析并提取请求信息生成测试用例。</p>
<p>项目的关键代码就不一一说了，项目中有注释，不懂的+我VX:742041978</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/01/12/Kubernetes学习（一）之认识Kubernetes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/12/Kubernetes学习（一）之认识Kubernetes/" itemprop="url">Kubernetes学习（一）之认识Kubernetes</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-12T15:47:00+08:00">
                2019-01-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/12/Kubernetes学习（一）之认识Kubernetes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/01/12/Kubernetes学习（一）之认识Kubernetes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Kubernetes学习（一）之认识Kubernetes"><a href="#Kubernetes学习（一）之认识Kubernetes" class="headerlink" title="Kubernetes学习（一）之认识Kubernetes"></a>Kubernetes学习（一）之认识Kubernetes</h1><h2 id="Kubernetes概念"><a href="#Kubernetes概念" class="headerlink" title="Kubernetes概念"></a>Kubernetes概念</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://kubernetes.io" target="_blank" rel="noopener">Kubernetes</a>是一个跨主机集群的 开源的容器调度平台，它可以自动化应用容器的部署、扩展和操作 , 提供以容器为中心的基础架构。结合<code>docker</code>可以提供持续开发，持续部署的功能，我现在所从事开发的<a href="https://choerodon.io/zh/" target="_blank" rel="noopener">Choerodon</a>就是基于这一套架构开发的企业级数字服务平台，具有敏捷化的应用交付和自动化的运营管理的特点。这里介绍的版本是<code>v1.13</code></p>
<p><img src="https://d33wubrfki0l68.cloudfront.net/e7b766e0175f30ae37f7e0e349b87cfe2034a1ae/3e391/images/docs/why_containers.svg" alt="image"></p>
<p>新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能快速部署，由于容器与底层设施、机器文件系统解耦的，所以它能在不同云、不同版本操作系统间进行迁移。</p>
<p>容器占用资源少、部署快，每个应用可以被打包成一个容器镜像，每个应用与容器间成一对一关系也使容器有更大优势，使用容器可以在build或release 的阶段，为应用创建容器镜像，因为每个应用不需要与其余的应用堆栈组合，也不依赖于生产环境基础结构，这使得从研发到测试、生产能提供一致环境。类似地，容器比虚机轻量、更“透明”，这更便于监控和管理。</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LDAOok5ngY4pc1lEDes%2F-LM_rqip-tinVoiFZE0I%2F-LM_sFnwCik1PPfAm7xB%2Farchitecture.png?generation=1537160056980734&amp;alt=media" alt="image"></p>
<h4 id="Master组件"><a href="#Master组件" class="headerlink" title="Master组件"></a>Master组件</h4><p>Kubernetes 主要由以下几个核心（Master）组件组成，Master组件提供集群的管理控制中心。Master组件可以在集群中任何节点上运行。但是为了简单起见，通常在一台VM/机器上启动所有Master组件，并且不会在此VM/机器上运行用户容器。请参考<a href="https://kubernetes.io/docs/admin/high-availability/" target="_blank" rel="noopener">构建高可用群集以来构建multi-master-VM</a>。</p>
<h5 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h5><p><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/用于暴露Kubernetes API。任何的资源请求/调用操作都是通过kube-apiserver提供的接口进行，并提供认证、授权、访问控制、API 注册和发现等机制。例如kubectl CLI命令行就是与kube-apiserver通讯查询节点信息的。请参阅[构建高可用群集](https://kubernetes.io/docs/admin/high-availability/" target="_blank" rel="noopener">kube-apiserver</a>。</p>
<h5 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h5><p><a href="https://github.com/coreos/etcd/blob/master/Documentation/docs.md" target="_blank" rel="noopener">etcd</a>是Kubernetes提供默认的存储系统，保存所有集群数据，使用时需要为etcd数据提供备份计划。</p>
<h5 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h5><p>主服务器上的组件，用于监视未创建节点的新创建的pod，并选择一个节点供其运行。 调度决策所考虑的因素包括个人和集体资源需求，硬件/软件/策略约束，亲和力和反亲和性规范，数据位置，工作负载间干扰和最后期限。</p>
<h5 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h5><p><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/" target="_blank" rel="noopener">kube-controller-manager</a>运行管理控制器，它们是集群中处理常规任务的后台线程。逻辑上，每个控制器是一个单独的进程，但为了降低复杂性，它们都被编译成单个二进制文件，并在单个进程中运行。负责维护集群的状态，比如故障检测、自动扩展、滚动更新等。</p>
<p>这些控制器包括：</p>
<ul>
<li><a href="http://docs.kubernetes.org.cn/304.html" target="_blank" rel="noopener">节点（Node</a>）控制器。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" target="_blank" rel="noopener">副本（Replication）控制器</a>：负责维护系统中每个副本中的pod。</li>
<li>端点（Endpoints）控制器：填充Endpoints对象（即连接Services＆Pods）。<br>-<a href="http://docs.kubernetes.org.cn/84.html" target="_blank" rel="noopener"> Service Account</a>和Token控制器：为新的<a href="http://docs.kubernetes.org.cn/242.html" target="_blank" rel="noopener">Namespace</a> 创建默认帐户访问API Token。</li>
</ul>
<h5 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud-controller-manager"></a>cloud-controller-manager</h5><p><a href="https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/" target="_blank" rel="noopener">云控制器管理器</a>负责与底层云提供商的平台交互。云控制器管理器是Kubernetes版本1.6中引入的，目前还是Alpha的功能。</p>
<p>云控制器管理器仅运行云提供商特定的（controller loops）控制器循环。可以通过将<code>--cloud-provider</code> flag设置为<code>external</code>启动kube-controller-manager ，来禁用控制器循环。</p>
<p>cloud-controller-manager 具体功能：</p>
<ul>
<li>节点（Node）控制器</li>
<li>路由（Route）控制器</li>
<li>Service控制器</li>
<li>卷（Volume）控制器</li>
</ul>
<h4 id="节点（Node）组件"><a href="#节点（Node）组件" class="headerlink" title="节点（Node）组件"></a>节点（Node）组件</h4><p>节点组件运行在<a href="http://docs.kubernetes.org.cn/304.html" target="_blank" rel="noopener">Node</a>，提供Kubernetes运行时环境，以及维护Pod。</p>
<h5 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h5><p>kubelet是主要的节点代理，它会监视已分配给节点的pod，负责维护容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理，具体功能：</p>
<ul>
<li>安装Pod所需的volume。</li>
<li>下载Pod的Secrets。</li>
<li>Pod中运行的 docker（或experimentally，rkt）容器。</li>
<li>定期执行容器健康检查。</li>
<li>通过在必要时创建镜像pod，将pod状态报告回系统的其余部分。</li>
<li>将节点的状态返回到系统的其余部分。</li>
</ul>
<h5 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h5><p><a href="https://kubernetes.io/docs/admin/kube-proxy/" target="_blank" rel="noopener">kube-proxy</a>通过在主机上维护网络规则并执行连接转发来实现Kubernetes服务抽象。负责为 Service 提供 cluster 内部的服务发现和负载均衡。</p>
<h5 id="Container-Runtime"><a href="#Container-Runtime" class="headerlink" title="Container Runtime"></a>Container Runtime</h5><p>容器运行时是负责运行容器的软件。 Kubernetes支持多种运行时：<a href="http://www.docker.com/" target="_blank" rel="noopener">Docker</a>，<a href="https://coreos.com/rkt/" target="_blank" rel="noopener">rkt</a>，<a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runc</a>和任何OCI运行时规范实现。</p>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>插件（addon）是实现集群pod和Services功能的 。PodDeployments，ReplicationController等进行管理。Namespace 插件对象是在<code>kube-system</code> Namespace中创建。有关可用插件的扩展列表，请参阅<a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">插件</a>。</p>
<h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p>虽然不严格要求使用插件，但Kubernetes集群都应该具有<a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noopener">DNS集群</a>。<br>群集 DNS是一个DNS服务器，能够为 Kubernetes services提供 DNS记录。<br>由Kubernetes启动的容器自动将这个DNS服务器包含在他们的DNS searches中。</p>
<h5 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h5><p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="noopener">仪表板</a>是Kubernetes集群的基于Web的通用UI。它允许用户管理和解决群集中运行的应用程序以及群集本身。</p>
<h5 id="容器资源监测"><a href="#容器资源监测" class="headerlink" title="容器资源监测"></a>容器资源监测</h5><p><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/" target="_blank" rel="noopener">容器资源监控</a>提供一个UI浏览监控数据。</p>
<h5 id="Cluster-level-Logging"><a href="#Cluster-level-Logging" class="headerlink" title="Cluster-level Logging"></a>Cluster-level Logging</h5><p><a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/" target="_blank" rel="noopener">Cluster-level logging</a>，负责保存容器日志，搜索/查看日志。</p>
<h5 id="supervisord"><a href="#supervisord" class="headerlink" title="supervisord"></a>supervisord</h5><p>supervisord是一个轻量级的监控系统，用于保障kubelet和docker运行。</p>
<h5 id="fluentd"><a href="#fluentd" class="headerlink" title="fluentd"></a>fluentd</h5><p>fluentd是一个守护进程，可提供<a href="https://kubernetes.io/docs/concepts/overview/components/#cluster-level-logging" target="_blank" rel="noopener">cluster-level logging</a>。</p>
<h3 id="The-Kubernetes-API"><a href="#The-Kubernetes-API" class="headerlink" title="The Kubernetes API"></a>The Kubernetes API</h3><p><a href="https://git.k8s.io/community/contributors/devel/api-conventions.md" target="_blank" rel="noopener">API约定文档</a>中描述了总体API约定</p>
<p><a href="https://kubernetes.io/docs/reference" target="_blank" rel="noopener">API参考</a>中描述了API端点，资源类型和示例。</p>
<p><a href="https://kubernetes.io/docs/reference/access-authn-authz/controlling-access/" target="_blank" rel="noopener">Controlling API Access</a>文档中讨论了对API的远程访问。</p>
<p>Kubernetes API还可用作系统声明性配置架构的基础。 kubectl命令行工具可用于创建，更新，删除和获取API对象。</p>
<p>Kubernetes还根据API资源存储其序列化状态（当前在<a href="https://coreos.com/docs/distributed-configuration/getting-started-with-etcd/" target="_blank" rel="noopener">etcd</a>中）。</p>
<p>Kubernetes本身被分解为多个组件，通过其API进行交互。</p>
<ul>
<li>API更改 </li>
<li>OpenAPI和Swagger定义 </li>
<li>API版本控制</li>
<li>API组 </li>
<li>启用API组 </li>
<li>启用组中的资源</li>
</ul>
<h4 id="API更改"><a href="#API更改" class="headerlink" title="API更改"></a>API更改</h4><p>根据我们的经验，任何成功的系统都需要随着新用例的出现或现有用例的变化而增长和变化。因此，我们希望Kubernetes API能够不断变化和发展。但是，我们打算在很长一段时间内不破坏与现有客户端的兼容性。通常，可以预期频繁添加新的API资源和新的资源字段。消除资源或字段将需要遵循<a href="https://kubernetes.io/docs/reference/using-api/deprecation-policy/" target="_blank" rel="noopener">API弃用策略</a>。</p>
<h4 id="OpenAPI和Swagger定义"><a href="#OpenAPI和Swagger定义" class="headerlink" title="OpenAPI和Swagger定义"></a>OpenAPI和Swagger定义</h4><p>使用<a href="https://www.openapis.org/" target="_blank" rel="noopener">OpenAPI</a>记录完整的API详细信息。 从Kubernetes 1.10开始，Kubernetes API服务器通过<code>/openapi/ v2</code>端点提供OpenAPI规范。通过设置HTTP标头指定请求的格式：</p>
<table>
<thead>
<tr>
<th>Header</th>
<th>Possible Values</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>application/json, <a href="mailto:application/com.github.proto-openapi.spec.v2@v1.0" target="_blank" rel="noopener">application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf (the default content-type is application/json for <em>/</em> or not passing this header)</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>gzip (not passing this header is acceptable)</td>
</tr>
</tbody>
</table>
<p>在1.14之前，格式分离的端点（<code>/swagger.json</code>,<code>/swagger-2.0.0.json</code>,<code>/swagger-2.0.0.pb-v1</code>,<code>/swagger-2.0.0.pb-v1.gz</code>）为OpenAPI提供服务不同格式的规范。这些端点已弃用，将在Kubernetes 1.14中删除。</p>
<p>获取OpenAPI规范的示例：</p>
<table>
<thead>
<tr>
<th>Before 1.10</th>
<th>Starting with Kubernetes 1.10</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET /swagger.json</td>
<td>GET /openapi/v2 Accept: application/json</td>
</tr>
<tr>
<td>GET /swagger-2.0.0.pb-v1</td>
<td>GET /openapi/v2 Accept: <a href="mailto:application/com.github.proto-openapi.spec.v2@v1.0" target="_blank" rel="noopener">application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf</td>
</tr>
<tr>
<td>GET /swagger-2.0.0.pb-v1.gz</td>
<td>GET /openapi/v2 Accept: <a href="mailto:application/com.github.proto-openapi.spec.v2@v1.0" target="_blank" rel="noopener">application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf Accept-Encoding: gzip</td>
</tr>
</tbody>
</table>
<p>Kubernetes为API实现了另一种基于Protobuf的序列化格式，主要用于集群内通信，在<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md" target="_blank" rel="noopener">设计提案</a>中有记录，每个模式的IDL文件都位于定义API对象的Go包中。</p>
<p>在1.14之前，Kubernetes apiserver还公开了一个API，可用于检索/ swaggerapi上的<a href="http://swagger.io/" target="_blank" rel="noopener">Swagger v1.2</a> Kubernetes API规范。该端点已弃用，将在Kubernetes 1.14中删除。</p>
<h4 id="API版本控制"><a href="#API版本控制" class="headerlink" title="API版本控制"></a>API版本控制</h4><p>为了更容易消除字段或重构资源表示，Kubernetes支持多个API版本，每个API版本位于不同的API路径，例如<code>/api/v1</code>或<code>/apis/extensions/v1beta1</code>。</p>
<p>我们选择在API级别而不是在资源或字段级别进行版本化，以确保API提供清晰，一致的系统资源和行为视图，并允许控制对生命末端和/或实验API的访问。 JSON和Protobuf序列化模式遵循相同的模式更改指南 - 以下所有描述都涵盖两种格式。</p>
<p>请注意，API版本控制和软件版本控制仅间接相关。 <a href="https://git.k8s.io/community/contributors/design-proposals/release/versioning.md" target="_blank" rel="noopener">API和发布版本控制提议</a>描述了API版本控制和软件版本控制之间的关系。</p>
<p>不同的API版本意味着不同级别的稳定性和支持。 <a href="https://git.k8s.io/community/contributors/devel/api_changes.md#alpha-beta-and-stable-versions" target="_blank" rel="noopener">API更改文档</a>中更详细地描述了每个级别的标准。他们总结在这里：</p>
<h5 id="Alpha-level"><a href="#Alpha-level" class="headerlink" title="Alpha level:"></a>Alpha level:</h5><ul>
<li>版本名称包含alpha（例如v1alpha1）。</li>
<li>可能是马车。启用该功能可能会暴露错误。默认情况下禁用。</li>
<li>可随时删除对功能的支持，恕不另行通知。</li>
<li>API可能会在以后的软件版本中以不兼容的方式更改，恕不另行通知。</li>
<li>由于错误风险增加和缺乏长期支持，建议仅在短期测试集群中使用。</li>
</ul>
<h5 id="Beta-level"><a href="#Beta-level" class="headerlink" title="Beta level::"></a>Beta level::</h5><ul>
<li>版本名称包含beta（例如v2beta3）。</li>
<li>代码经过了充分测试。启用该功能被认为是安全的。默认情况下启用。</li>
<li>虽然细节可能会有所变化，但不会删除对整体功能的支持。</li>
<li>在随后的beta版或稳定版中，对象的模式和/或语义可能以不兼容的方式发生变化。发生这种情况时，我们将提供迁移到下一版本的说明。这可能需要删除，编辑和重新创建API对象。编辑过程可能需要一些思考。对于依赖该功能的应用程序，这可能需要停机时间。</li>
<li>建议仅用于非关键业务用途，因为后续版本中可能存在不兼容的更改。如果您有多个可以独立升级的群集，您可以放宽此限制。</li>
<li>请尝试我们的测试版功能并提供反馈！一旦他们退出测试版，我们可能无法进行更多更改。</li>
</ul>
<h5 id="Stable-level"><a href="#Stable-level" class="headerlink" title="Stable level:"></a>Stable level:</h5><ul>
<li>该版本名称是vX这里X是一个整数。</li>
<li>许多后续版本的已发布软件中将出现稳定版本的功能。</li>
</ul>
<h4 id="API组"><a href="#API组" class="headerlink" title="API组"></a>API组</h4><p>为了更容易扩展Kubernetes API，我们实现了<a href="https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md" target="_blank" rel="noopener">API组</a>。API组在REST路径和<code>apiVersion</code>序列化对象的字段中指定。</p>
<p>目前有几个API组正在使用中：</p>
<ol>
<li>核心组，常常被称为遗留组，是在REST路径<code>/api/v1</code>和用途<code>apiVersion: v1</code>。</li>
<li>命名组处于REST路径<code>/apis/$GROUP_NAME/$VERSION</code>，并使用<code>apiVersion: $GROUP_NAME/$VERSION</code> （例如<code>apiVersion: batch/v1</code>）。在<a href="https://kubernetes.io/docs/reference/" target="_blank" rel="noopener">Kubernetes API参考</a>中可以看到支持的API组的完整列表。</li>
</ol>
<p>使用<a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/" target="_blank" rel="noopener">自定义资源</a>扩展API有两种受支持的路径：</p>
<ol>
<li><a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/" target="_blank" rel="noopener">CustomResourceDefinition</a> 适用于具有非常基本CRUD需求的用户。</li>
<li>需要完整Kubernetes API语义的用户可以实现自己的apiserver并使用<a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/configure-aggregation-layer/" target="_blank" rel="noopener">聚合器</a> 使其无缝地为客户端。</li>
</ol>
<h4 id="启用API组"><a href="#启用API组" class="headerlink" title="启用API组"></a>启用API组</h4><p>默认情况下启用某些资源和API组。可以通过设置<code>--runtime-config apiserver</code> 来启用或禁用它们。<code>--runtime-config</code>接受逗号分隔值。例如：要禁用批处理/ v1，请设置 <code>--runtime-config=batch/v1=false</code>，以启用批处理/ v2alpha1，设置<code>--runtime-config=batch/v2alpha1</code>。该标志接受逗号分隔的一组key = value对，描述了apiserver的运行时配置。</p>
<p>重要信息：启用或禁用组或资源需要重新启动apiserver和controller-manager以获取<code>--runtime-config</code>更改。</p>
<h4 id="启用组中的资源"><a href="#启用组中的资源" class="headerlink" title="启用组中的资源"></a>启用组中的资源</h4><p>默认情况下启用DaemonSet，Deployments，HorizontalPodAutoscalers，Ingresses，Jobs和ReplicaSet。可以通过设置<code>--runtime-configapiserver</code> 来启用其他扩展资源。<code>--runtime-config</code>接受逗号分隔值。例如：要禁用部署和入口，请设置 <code>--runtime-config=extensions/v1beta1/deployments=false,extensions/v1beta1/ingresses=false</code></p>
<h3 id="与Kubernetes对象一起工作"><a href="#与Kubernetes对象一起工作" class="headerlink" title="与Kubernetes对象一起工作"></a>与Kubernetes对象一起工作</h3><h4 id="了解Kubernetes对象"><a href="#了解Kubernetes对象" class="headerlink" title="了解Kubernetes对象"></a><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/" target="_blank" rel="noopener">了解Kubernetes对象</a></h4><h5 id="了解Kubernetes对象-1"><a href="#了解Kubernetes对象-1" class="headerlink" title="了解Kubernetes对象"></a>了解Kubernetes对象</h5><p>Kubernetes对象是Kubernetes系统中的持久实体。Kubernetes使用这些实体来表示集群的状态。具体来说，他们可以描述：</p>
<ul>
<li>容器化应用正在运行(以及在哪些节点上)</li>
<li>这些应用可用的资源</li>
<li>关于这些应用如何运行的策略，如重新策略，升级和容错<br>Kubernetes对象是“record of intent”，一旦创建了对象，Kubernetes系统会确保对象存在。通过创建对象，可以有效地告诉Kubernetes系统你希望集群的工作负载是什么样的。</li>
</ul>
<p>要使用Kubernetes对象（无论是创建，修改还是删除），都需要使用<a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" target="_blank" rel="noopener">Kubernetes API</a>。例如，当使用<a href="http://docs.kubernetes.org.cn/61.html" target="_blank" rel="noopener">kubectl命令管理工具</a>时，CLI会为提供Kubernetes API调用。你也可以直接在自己的程序中使用Kubernetes API，您还可以使用其中一个<a href="https://kubernetes.io/docs/reference/using-api/client-libraries/" target="_blank" rel="noopener">客户端库</a>在您自己的程序中直接使用Kubernetes API。</p>
<h5 id="对象（Object）规范和状态"><a href="#对象（Object）规范和状态" class="headerlink" title="对象（Object）规范和状态"></a>对象（Object）规范和状态</h5><p>每个Kubernetes对象都包含两个嵌套对象字段，用于管理Object的配置：Object Spec和Object Status。Spec描述了对象所需的状态 - 希望Object具有的特性，Status描述了对象的实际状态，并由Kubernetes系统提供和更新。</p>
<p>例如，通过Kubernetes Deployment 来表示在集群上运行的应用的对象。创建Deployment时，可以设置Deployment Spec，来指定要运行应用的三个副本。Kubernetes系统将读取Deployment Spec，并启动你想要的三个应用实例 - 来更新状态以符合之前设置的Spec。如果这些实例中有任何一个失败（状态更改），Kuberentes系统将响应Spec和当前状态之间差异来调整，这种情况下，将会开始替代实例。</p>
<p>有关object spec、status和metadata更多信息，请参考<a href="https://git.k8s.io/community/contributors/devel/api-conventions.md" target="_blank" rel="noopener">“Kubernetes API Conventions”</a>。</p>
<h5 id="描述Kubernetes对象"><a href="#描述Kubernetes对象" class="headerlink" title="描述Kubernetes对象"></a>描述Kubernetes对象</h5><p>在Kubernetes中创建对象时，必须提供描述其所需Status的对象Spec，以及关于对象（如name）的一些基本信息。当使用Kubernetes API创建对象（直接或通过kubectl）时，该API请求必须将该信息作为JSON包含在请求body中。通常，可以将信息提供给kubectl .yaml文件，在进行API请求时，kubectl将信息转换为JSON。</p>
<p>以下示例是一个.yaml文件，显示Kubernetes Deployment所需的字段和对象Spec：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application/deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># for versions before 1.9.0 use apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span> <span class="comment"># tells deployment to run 2 pods matching the template</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>使用上述.yaml文件创建Deployment，是通过在kubectl中使用<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create" target="_blank" rel="noopener">kubectl create</a>命令来实现。将该.yaml文件作为参数传递。如下例子：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>kubectl create -f <span class="symbol">https:</span>/<span class="regexp">/k8s.io/examples</span><span class="regexp">/application/deployment</span>.yaml --record</span><br><span class="line">deployment.apps/nginx-deployment created</span><br></pre></td></tr></table></figure></p>
<h5 id="必填字段"><a href="#必填字段" class="headerlink" title="必填字段"></a>必填字段</h5><p>对于要创建的Kubernetes对象的yaml文件，需要为以下字段设置值：</p>
<ul>
<li>apiVersion - 创建对象的Kubernetes API 版本</li>
<li>kind - 要创建什么样的对象？</li>
<li>metadata- 具有唯一标示对象的数据，包括 name（字符串）、UID和Namespace（可选项）<br>您还需要提供对象规范字段。对象规范的精确格式对于每个Kubernetes对象都是不同的，并且包含特定于该对象的嵌套字段。 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/" target="_blank" rel="noopener">Kubernetes API Reference</a>可以帮助您找到可以使用Kubernetes创建的所有对象的规范格式。例如，可以在<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#podspec-v1-core" target="_blank" rel="noopener">此处</a>找到Pod对象的spec格式，可以在<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#deploymentspec-v1-apps" target="_blank" rel="noopener">此处</a>找到Deployment对象的spec格式。</li>
</ul>
<h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>Kubernetes REST API中的所有对象都由Name和UID明确标识。</p>
<p>对于非唯一的用户提供的属性，Kubernetes提供<a href="https://kubernetes.io/docs/user-guide/labels" target="_blank" rel="noopener">标签</a>和<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/" target="_blank" rel="noopener">注释</a>。</p>
<p>有关名称和UID的精确语法规则，请参阅<a href="https://git.k8s.io/community/contributors/design-proposals/architecture/identifiers.md" target="_blank" rel="noopener">标识符设计文档</a>。</p>
<ul>
<li>Names</li>
<li>UIDs</li>
</ul>
<h5 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h5><p>客户端提供的字符串，用于引用资源URL中的对象，例如<code>/api/v1/pods/some-name</code>。</p>
<p>只有给定类型的一个对象一次可以有一个给定的名称。但是，如果删除该对象，则可以创建具有相同名称的新对象。</p>
<p>按照惯例，Kubernetes资源的名称应最多为253个字符，并且由小写字母数字字符组成-，并且.，但某些资源具有更具体的限制。</p>
<h5 id="UIDs"><a href="#UIDs" class="headerlink" title="UIDs"></a>UIDs</h5><p>Kubernetes系统生成的字符串，用于唯一标识对象。</p>
<p>在Kubernetes集群的整个生命周期中创建的每个对象都具有不同的UID。它旨在区分类似实体的历史事件。</p>
<h4 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h4><p>Kubernetes支持由同一物理集群支持的多个虚拟集群。这些虚拟集群称为名称空间。</p>
<ul>
<li>何时使用多个命名空间</li>
<li>使用命名空间</li>
<li>命名空间和DNS</li>
<li>并非所有对象都在命名空间中</li>
</ul>
<h5 id="何时使用多个命名空间"><a href="#何时使用多个命名空间" class="headerlink" title="何时使用多个命名空间"></a>何时使用多个命名空间</h5><p>命名空间旨在用于多个用户分布在多个团队或项目中的环境中。对于具有几个到几十个用户的集群，您根本不需要创建或考虑名称空间。当您需要它们提供的功能时，请开始使用命名空间。</p>
<p>命名空间提供名称范围。资源名称在名称空间中必须是唯一的，而不是跨名称空间。</p>
<p>命名空间是一种在多个用户之间划分群集资源的方法（通过<a href="https://kubernetes.io/docs/concepts/policy/resource-quotas/" target="_blank" rel="noopener">资源配额</a>）。</p>
<p>在Kubernetes的未来版本中，默认情况下，同一名称空间中的对象将具有相同的访问控制策略。</p>
<p>没有必要使用多个名称空间来分隔略有不同的资源，例如同一软件的不同版本：使用<a href="https://kubernetes.io/docs/user-guide/labels" target="_blank" rel="noopener">标签</a>来区分同一名称空间中的资源。</p>
<h5 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h5><p>名称空间的<a href="https://kubernetes.io/docs/admin/namespaces" target="_blank" rel="noopener">管理指南文档</a>中描述了名称空间的创建和删除。</p>
<h6 id="查看名称空间"><a href="#查看名称空间" class="headerlink" title="查看名称空间"></a>查看名称空间</h6><p>您可以使用以下命令列出集群中的当前名称空间：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">get</span> namespaces</span><br><span class="line">NAME          STATUS    AGE</span><br><span class="line">default       Active    1d</span><br><span class="line">kube-system   Active    1d</span><br><span class="line">kube-public   Active    1d</span><br></pre></td></tr></table></figure></p>
<p>Kubernetes以三个初始名称空间开头：</p>
<ul>
<li><code>default</code> 没有其他命名空间的对象的默认命名空间</li>
<li><code>kube-system</code> Kubernetes系统创建的对象的命名空间</li>
<li><code>kube-public</code>此命名空间是自动创建的，并且所有用户（包括未经过身份验证的用户）都可以读取。此命名空间主要用于群集使用，以防某些资源在整个群集中可见且可公开读取。此命名空间的公共方面只是一个约定，而不是一个要求。</li>
</ul>
<h6 id="设置请求的命名空间"><a href="#设置请求的命名空间" class="headerlink" title="设置请求的命名空间"></a>设置请求的命名空间</h6><p>要临时设置请求的命名空间，请使用该<code>--namespace</code>标志。</p>
<p>例如：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="attribute">--namespace</span>=&lt;insert-namespace-name-here&gt; <span class="builtin-name">run</span> nginx <span class="attribute">--image</span>=nginx</span><br><span class="line">$ kubectl <span class="attribute">--namespace</span>=&lt;insert-namespace-name-here&gt; <span class="builtin-name">get</span> pods</span><br></pre></td></tr></table></figure></p>
<h6 id="设置命名空间首选项"><a href="#设置命名空间首选项" class="headerlink" title="设置命名空间首选项"></a>设置命名空间首选项</h6><p>您可以在该上下文中为所有后续kubectl命令永久保存命名空间。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl<span class="built_in"> config </span>set-context $(kubectl<span class="built_in"> config </span>current-context) <span class="attribute">--namespace</span>=&lt;insert-namespace-name-here&gt;</span><br><span class="line"><span class="comment"># Validate it</span></span><br><span class="line">$ kubectl<span class="built_in"> config </span>view | grep namespace:</span><br></pre></td></tr></table></figure>
<h5 id="命名空间和DNS"><a href="#命名空间和DNS" class="headerlink" title="命名空间和DNS"></a>命名空间和DNS</h5><p>创建<a href="https://kubernetes.io/docs/user-guide/services" target="_blank" rel="noopener">服务</a>时，它会创建相应的<a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noopener">DNS条目</a>。此条目是表单<code>&lt;service-name&gt;.&lt;namespace-name&gt;.svc.cluster.local</code>，这意味着如果容器只是使用<code>&lt;service-name&gt;</code>，它将解析为命名空间本地的服务。这对于在多个名称空间（如开发，分段和生产）中使用相同的配置非常有用。如果要跨命名空间访问，则需要使用完全限定的域名（FQDN）。</p>
<h5 id="并非所有对象都在命名空间中"><a href="#并非所有对象都在命名空间中" class="headerlink" title="并非所有对象都在命名空间中"></a>并非所有对象都在命名空间中</h5><p>大多数Kubernetes资源（例如pod，服务，复制控制器等）都在某些名称空间中。但是，命名空间资源本身并不在命名空间中。并且低级资源（例如节点和persistentVolumes）不在任何名称空间中。</p>
<p>要查看哪些Kubernetes资源在命名空间中，哪些不在：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> In a namespace</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl api-resources --namespaced=<span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Not <span class="keyword">in</span> a namespace</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl api-resources --namespaced=<span class="literal">false</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="Labels-and-Selectors"><a href="#Labels-and-Selectors" class="headerlink" title="Labels and Selectors"></a>Labels and Selectors</h4><p>标签是附加到对象（例如pod）的键/值对。标签旨在用于指定对用户有意义且相关的对象的标识属性，但不直接暗示核心系统的语义。标签可用于组织和选择对象的子集。标签可以在创建时附加到对象，随后可以随时添加和修改。每个对象都可以定义一组键/值标签。每个Key对于给定对象必须是唯一的。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"metadata"</span>: &#123;</span><br><span class="line">  <span class="string">"labels"</span>: &#123;</span><br><span class="line">    <span class="string">"key1"</span> : <span class="string">"value1"</span>,</span><br><span class="line">    <span class="string">"key2"</span> : <span class="string">"value2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>标签允许高效的查询和监视，非常适合在UI和CLI中使用。应使用<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/" target="_blank" rel="noopener">注释</a>记录非识别信息。</p>
<ul>
<li>动机</li>
<li>语法和字符集</li>
<li>标签选择器</li>
<li>API</li>
</ul>
<h5 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h5><p>标签使用户能够以松散耦合的方式将他们自己的组织结构映射到系统对象，而无需客户端存储这些映射。</p>
<p>服务部署和批处理流水线通常是多维实体（例如，多个分区或部署，多个释放轨道，多个层，每层多个微服务）。管理通常需要交叉操作，这打破了严格的层次表示的封装，特别是由基础设施而不是用户确定的严格的层次结构。</p>
<p>示例标签：</p>
<ul>
<li><code>&quot;release&quot; : &quot;stable&quot;</code>，<code>&quot;release&quot; : &quot;canary&quot;</code></li>
<li><code>&quot;environment&quot; : &quot;dev&quot;</code>，<code>&quot;environment&quot; : &quot;qa&quot;</code>，<code>&quot;environment&quot; : &quot;production&quot;</code></li>
<li><code>&quot;tier&quot; : &quot;frontend&quot;</code>，<code>&quot;tier&quot; : &quot;backend&quot;</code>，<code>&quot;tier&quot; : &quot;cache&quot;</code></li>
<li><code>&quot;partition&quot; : &quot;customerA&quot;</code>， <code>&quot;partition&quot; : &quot;customerB&quot;</code></li>
<li><code>&quot;track&quot; : &quot;daily&quot;</code>， <code>&quot;track&quot; : &quot;weekly&quot;</code><br>这些只是常用标签的例子; 你可以自由地制定自己的约定。请记住，标签Key对于给定对象必须是唯一的。</li>
</ul>
<h5 id="语法和字符集"><a href="#语法和字符集" class="headerlink" title="语法和字符集"></a>语法和字符集</h5><p>标签是键/值对。有效标签键有两个段：可选前缀和名称，用斜杠（<code>/</code>）分隔。名称段是必需的，必须是63个字符或更少，以字母数字字符（<code>[a-z0-9A-Z]</code>）开头和结尾，带有破折号（<code>-</code>），下划线（<code>_</code>），点（<code>.</code>）和字母数字之间。前缀是可选的。如果指定，前缀必须是DNS子域：由点（<code>.</code>）分隔的一系列DNS标签，总共不超过253个字符，后跟斜杠（<code>/</code>）。</p>
<p>如果省略前缀，则假定标签Key对用户是私有的。自动化系统组件（例如<code>kube-scheduler</code>，<code>kube-controller-manager</code>，<code>kube-apiserver</code>，<code>kubectl</code>，或其他第三方自动化），它添加标签终端用户对象都必须指定一个前缀。</p>
<p>在<code>kubernetes.io/</code>和<code>k8s.io/</code>前缀保留给Kubernetes核心组件。</p>
<p>有效标签值必须为63个字符或更少，并且必须为空或以字母数字字符（<code>[a-z0-9A-Z]</code>）开头和结尾，并带有短划线（<code>-</code>），下划线（<code>_</code>），点（<code>.</code>）和字母数字。</p>
<h5 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h5><p>与名称和UID不同，标签不提供唯一性。通常，我们希望许多对象携带相同的标签。</p>
<p>通过标签选择器，客户端/用户可以识别一组对象。标签选择器是Kubernetes中的核心分组原语。</p>
<p>目前，API支持两种类型的选择：基于平等，和基于集的。标签选择器可以由逗号分隔的多个要求组成。在多个要求的情况下，必须满足所有要求，因此逗号分隔符充当逻辑AND（<code>&amp;&amp;</code>）运算符。</p>
<p>空或非指定选择器的语义取决于上下文，使用选择器的API类型应记录它们的有效性和含义。</p>
<blockquote>
<p>注意：对于某些API类型（例如ReplicaSet），两个实例的标签选择器不得在命名空间内重叠，或者控制器可以将其视为冲突的指令，并且无法确定应存在多少副本。</p>
</blockquote>
<h6 id="基于平等的要求"><a href="#基于平等的要求" class="headerlink" title="基于平等的要求"></a>基于平等的要求</h6><p>基于平等或不平等的要求允许按标签键和值进行过滤。匹配对象必须满足所有指定的标签约束，尽管它们也可能有其他标签。三种操作都承认<code>=</code>，<code>==</code>，<code>!=</code>。前两个代表平等（简单地说是同义词），而后者代表不平等。例如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">environment = production</span><br><span class="line">tier != frontend</span><br></pre></td></tr></table></figure></p>
<p>前者选择密钥等于<code>environment</code>和值等于的所有资源<code>production</code>。后者选择密钥等于<code>tier</code>和值不同的<code>frontend</code>所有资源，以及没有带<code>tier</code>密钥标签的所有资源。可以过滤使用逗号运算符<code>production</code>排除的资源<code>frontend</code>：<code>environment=production,tier!=frontend</code></p>
<p>基于等同的标签要求的一种使用场景是Pods指定节点选择标准。例如，下面的示例Pod选择标签为“ <code>accelerator=nvidia-tesla-p100</code>”的节点。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: v1</span><br><span class="line"><span class="attribute">kind</span>: Pod</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">name</span>: cuda-test</span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">containers</span>:</span><br><span class="line">    - <span class="attribute">name</span>: cuda-test</span><br><span class="line">      <span class="attribute">image</span>: <span class="string">"k8s.gcr.io/cuda-vector-add:v0.1"</span></span><br><span class="line">      <span class="attribute">resources</span>:</span><br><span class="line">        <span class="attribute">limits</span>:</span><br><span class="line">          nvidia.com/<span class="attribute">gpu</span>: <span class="number">1</span></span><br><span class="line">  <span class="attribute">nodeSelector</span>:</span><br><span class="line">    <span class="attribute">accelerator</span>: nvidia-tesla-p100</span><br></pre></td></tr></table></figure></p>
<h6 id="基于集合的要求"><a href="#基于集合的要求" class="headerlink" title="基于集合的要求"></a>基于集合的要求</h6><p>基于集合的标签要求允许根据一组值过滤密钥。三种操作的支持：<code>in</code>，<code>notin</code>和<code>exists</code>（仅密钥标识符）。例如：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">environment <span class="keyword">in</span> (production, qa)</span><br><span class="line">tier notin (frontend, backend)</span><br><span class="line"><span class="built_in">partition</span></span><br><span class="line">!<span class="built_in">partition</span></span><br></pre></td></tr></table></figure></p>
<p>第一个示例选择键等于<code>environment</code>和值等于<code>production</code>或的所有资源<code>qa</code>。第二个示例选择密钥等于<code>tier</code>和除了<code>frontend</code>和之外的值的<code>backend</code>所有资源，以及没有带<code>tier</code>密钥标签的所有资源。第三个例子选择所有资源，包括带密钥的标签<code>partition</code>; 没有检查值。第四个示例选择没有带键的标签的所有资源<code>partition</code>; 没有检查值。类似地，逗号分隔符充当AND运算符。因此，使用<code>partition</code>密钥（无论值）和<code>environment</code>不同的  过滤资源<code>qa</code>都可以实现<code>partition</code>,<code>environment notin (qa)</code>。基于集合标签选择器是一种平等的一般形式，因为<code>environment=production</code>它等同于<code>environment in (production)</code>; 同样的<code>!=</code>和<code>notin</code>。</p>
<p>基于集合的需求可以与基于相等的需求相结合。例如：<code>partition in (customerA, customerB),environment!=qa</code>。</p>
<h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><h6 id="LIST和WATCH过滤"><a href="#LIST和WATCH过滤" class="headerlink" title="LIST和WATCH过滤"></a>LIST和WATCH过滤</h6><p>LIST和WATCH操作可以指定标签选择器来过滤使用查询参数返回的对象集。这两个要求都是允许的（在此处显示为出现在URL查询字符串中）：</p>
<ul>
<li>基于平等的要求：<code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li>
<li>基于集合的要求：<code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li>
</ul>
<p>两种标签选择器样式都可用于通过REST客户端列出或查看资源。例如，靶向<code>apiserver</code>与<code>kubectl</code>和使用基于平等-一个可写：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">get</span> pods -l <span class="attribute">environment</span>=production,tier=frontend</span><br></pre></td></tr></table></figure></p>
<p>或使用基于集合的要求：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -l <span class="symbol">'environment</span> <span class="keyword">in</span> (production),tier <span class="keyword">in</span> (frontend)'</span><br></pre></td></tr></table></figure></p>
<p>如前所述，基于集合的要求更具表现力。例如，他们可以在值上实现OR运算符：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l <span class="string">'environment in (production, qa)'</span></span></span><br></pre></td></tr></table></figure></p>
<p>或限制负匹配通过存在操作者：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l <span class="string">'environment,environment notin (frontend)'</span></span></span><br></pre></td></tr></table></figure></p>
<p>在API对象中设置引用</p>
<p>某些Kubernetes对象（例如<a href="https://kubernetes.io/docs/user-guide/services" target="_blank" rel="noopener">services</a>和<a href="https://kubernetes.io/docs/user-guide/replication-controller" target="_blank" rel="noopener">replicationcontrollers</a>）也使用标签选择器来指定其他资源集，例如<a href="https://kubernetes.io/docs/user-guide/pods" target="_blank" rel="noopener">pod</a>。</p>
<h5 id="服务和ReplicationController"><a href="#服务和ReplicationController" class="headerlink" title="服务和ReplicationController"></a>服务和ReplicationController</h5><p><code>service</code>使用标签选择器定义目标的一组pod 。类似地<code>，replicationcontroller</code>应该管理的pod的数量也用标签选择器定义。</p>
<p>两个对象的标签选择器在使用映射定义<code>json</code>或<code>yaml</code>文件中定义，并且仅支持基于等同的需求选择器：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"selector"</span>: &#123;</span><br><span class="line">    <span class="string">"component"</span> : <span class="string">"redis"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要么<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">selector:</span></span><br><span class="line"><span class="symbol">    component:</span> redis</span><br></pre></td></tr></table></figure></p>
<p>这个选择器（分别以<code>json</code>或<code>yaml</code>格式）相当于<code>component=redis</code>或<code>component in (redis)</code>。</p>
<h5 id="支持基于集合的需求的资源"><a href="#支持基于集合的需求的资源" class="headerlink" title="支持基于集合的需求的资源"></a>支持基于集合的需求的资源</h5><p>较新的资源，如<a href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/" target="_blank" rel="noopener">Job</a>，<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployment</a>，<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">Replica Set</a>，和<a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">Daemon Set</a>，支持基于集合的要求也是如此。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">selector</span>:</span><br><span class="line">  <span class="attribute">matchLabels</span>:</span><br><span class="line">    <span class="attribute">component</span>: redis</span><br><span class="line">  <span class="attribute">matchExpressions</span>:</span><br><span class="line">    - &#123;<span class="attribute">key</span>: tier, <span class="attribute">operator</span>: In, <span class="attribute">values</span>: [cache]&#125;</span><br><span class="line">    <span class="selector-tag">-</span> &#123;<span class="attribute">key</span>: environment, <span class="attribute">operator</span>: NotIn, <span class="attribute">values</span>: [dev]&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>matchLabels</code>是对的地图<code>{key,value}</code>。一个单一的<code>{key,value}</code>在<code>matchLabels</code>地图相当于一个元件<code>matchExpressions</code>，其key字段是“key”，则<code>operator</code>是“In”和values阵列仅包含“value”。<code>matchExpressions</code>是一个pod选择器要求列表。有效的运算符包括In，NotIn，Exists和DoesNotExist。在In和NotIn的情况下，设置的值必须是非空的。所有的要求，从两者<code>matchLabels</code>和<code>matchExpressionsAND</code>一起 - 他们必须满足，以匹配。</p>
<h5 id="选择节点集"><a href="#选择节点集" class="headerlink" title="选择节点集"></a>选择节点集</h5><p>用于选择标签的一个用例是约束pod可以调度的节点集。有关更多信息，请参阅有关节点选择的文档。</p>
<h4 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h4><p>您可以使用Kubernetes注释将任意非标识元数据附加到对象。工具和库等客户端可以检索此元数据。</p>
<ul>
<li>将元数据附加到对象</li>
<li>语法和字符集</li>
</ul>
<h5 id="将元数据附加到对象"><a href="#将元数据附加到对象" class="headerlink" title="将元数据附加到对象"></a>将元数据附加到对象</h5><p>您可以使用标签或注释将元数据附加到Kubernetes对象。标签可用于选择对象和查找满足特定条件的对象集合。相反，注释不用于识别和选择对象。注释中的元数据可以是小的或大的，结构化的或非结构化的，并且可以包括标签不允许的字符。</p>
<p>注释（如标签）是键/值映射<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"metadata"</span>: &#123;</span><br><span class="line">  <span class="string">"annotations"</span>: &#123;</span><br><span class="line">    <span class="string">"key1"</span> : <span class="string">"value1"</span>,</span><br><span class="line">    <span class="string">"key2"</span> : <span class="string">"value2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是可以在注释中记录的一些信息示例：</p>
<ul>
<li>由声明性配置层管理的字段。将这些字段作为注释附加，可以将它们与客户端或服务器设置的默认值以及自动生成的字段和自动调整大小或自动调整系统设置的字段区分开来。</li>
<li>构建，发布或映像信息，如时间戳，版本ID，git分支，PR编号，镜像哈希和仓库地址。</li>
<li>指向日志记录，监视，分析或审计存储库的指针。</li>
<li>可用于调试目的的客户端库或工具信息：例如，名称，版本和构建信息。</li>
<li>用户或工具/系统出处信息，例如来自其他生态系统组件的相关对象的URL。</li>
<li>轻量推出工具元数据：例如，配置或检查点。</li>
<li>负责人的电话或寻呼机号码，或指定可在何处找到该信息的目录条目，例如团队网站。</li>
<li>从最终用户到实现的指令，用于修改行为或使用非标准功能。</li>
</ul>
<p>您可以将此类信息存储在外部数据库或目录中，而不是使用注释，但这会使生成用于部署，管理，内省等的共享客户端库和工具变得更加困难。</p>
<h5 id="语法和字符集-1"><a href="#语法和字符集-1" class="headerlink" title="语法和字符集"></a>语法和字符集</h5><p>注释是键/值对。有效的注释键有两个段：可选的前缀和名称，用斜杠（<code>/</code>）分隔。名称段是必需的，必须是63个字符或更少，以字母数字字符（<code>[a-z0-9A-Z]</code>）开头和结尾，带有破折号（<code>-</code>），下划线（<code>_</code>），点（<code>.</code>）和字母数字之间。前缀是可选的。如果指定，前缀必须是DNS子域：由点（<code>.</code>）分隔的一系列DNS标签，总共不超过253个字符，后跟斜杠（<code>/</code>）。</p>
<p>如果省略前缀，则假定注释密钥对用户是私有的。自动化系统组件（例如<code>kube-scheduler</code>，<code>kube-controller-manager</code>，<code>kube-apiserver</code>，<code>kubectl</code>，或其他第三方自动化）的添加注释到最终用户的对象都必须指定一个前缀。</p>
<p>在<code>kubernetes.io/</code>和<code>k8s.io/</code>前缀保留给Kubernetes核心组件。</p>
<h4 id="Field-Selectors"><a href="#Field-Selectors" class="headerlink" title="Field Selectors"></a>Field Selectors</h4><ul>
<li>支持的字段</li>
<li>支持操作</li>
<li>链式选择器</li>
<li>多种资源类型</li>
</ul>
<p>字段选择器允许您根据一个或多个资源字段的值<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects" target="_blank" rel="noopener">选择Kubernetes资源</a>。以下是一些示例字段选择器查询：</p>
<ul>
<li><code>metadata.name=my-service</code></li>
<li><code>metadata.namespace!=default</code></li>
<li><code>status.phase=Pending</code>  </li>
</ul>
<p>此<code>kubectl</code>命令选择<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase" target="_blank" rel="noopener">status.phase</a>字段值为的所有Pod <code>Running</code>：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">get</span> pods --field-selector status.<span class="attribute">phase</span>=Running</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：<br>字段选择器本质上是资源过滤器。默认情况下，不应用选择器/过滤器，这意味着将选择指定类型的所有资源。这使以下kubectl查询等效：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="meta">get</span> pods</span><br><span class="line">$ kubectl <span class="meta">get</span> pods --<span class="meta">field</span>-<span class="keyword">selector </span><span class="string">""</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="支持的字段"><a href="#支持的字段" class="headerlink" title="支持的字段"></a>支持的字段</h5><p>支持的字段选择器因Kubernetes资源类型而异。所有资源类型都支持<code>metadata.name</code>和<code>metadata.namespace</code>字段。使用不受支持的字段选择器会产生错误。例如：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">get</span> ingress --field-selector foo.<span class="attribute">bar</span>=baz</span><br><span class="line"><span class="builtin-name">Error</span> <span class="keyword">from</span><span class="built_in"> server </span>(BadRequest): Unable <span class="keyword">to</span> <span class="builtin-name">find</span> <span class="string">"ingresses"</span> that match label selector <span class="string">""</span>, field selector <span class="string">"foo.bar=baz"</span>: <span class="string">"foo.bar"</span> is <span class="keyword">not</span> a known field selector: only <span class="string">"metadata.name"</span>, <span class="string">"metadata.namespace"</span></span><br></pre></td></tr></table></figure></p>
<h5 id="支持操作"><a href="#支持操作" class="headerlink" title="支持操作"></a>支持操作</h5><p>您可以使用<code>=</code>，<code>==</code>以及<code>!=</code>与现场选择操作（<code>=</code>和<code>==</code>意思是一样的）。<code>kubectl</code>例如，此命令选择不在<code>default</code>命名空间中的所有Kubernetes服务：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">get</span> services --field-selector metadata.<span class="keyword">namespace</span>!=<span class="built_in">default</span></span><br></pre></td></tr></table></figure></p>
<h5 id="链式选择器"><a href="#链式选择器" class="headerlink" title="链式选择器"></a>链式选择器</h5><p>与<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels" target="_blank" rel="noopener">标签</a>和其他选择器一样，字段选择器可以作为逗号分隔列表链接在一起。此<code>kubectl</code>命令选择<code>status.phase</code>不相等<code>Running</code>且<code>spec.restartPolicy</code>字段等于的所有Pod <code>Always</code>：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">get</span> pods <span class="attribute">--field-selector</span>=status.phase!=Running,spec.restartPolicy=Always</span><br></pre></td></tr></table></figure></p>
<h5 id="多种资源类型"><a href="#多种资源类型" class="headerlink" title="多种资源类型"></a>多种资源类型</h5><p>您可以跨多种资源类型使用字段选择器。此<code>kubectl</code>命令选择不在<code>default</code>命名空间中的所有Statefulsets和Services ：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">get</span> statefulsets,services --field-selector metadata.<span class="keyword">namespace</span>!=<span class="built_in">default</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Recommended-Labels"><a href="#Recommended-Labels" class="headerlink" title="Recommended Labels"></a>Recommended Labels</h4><p>您可以使用比kubectl和仪表板更多的工具来可视化和管理Kubernetes对象。一组通用的标签允许工具以互操作的方式工作，以所有工具都能理解的通用方式描述对象。</p>
<p>除支持工具外，推荐标签还以可查询的方式描述应用程序。</p>
<ul>
<li>标签</li>
<li>应用程序和应用程序实例</li>
<li>例子<br>元数据围绕应用程序的概念进行组织。Kubernetes不是一个服务平台（PaaS），也没有或强制执行正式的应用程序概念。相反，应用程序是非正式的，并使用元数据进 应用程序包含的内容的定义是松散的。</li>
</ul>
<blockquote>
<p>注意：这些是推荐标签。它们使管理应用程序变得更容易，但对于任何核心工具都不是必需的。</p>
</blockquote>
<p>共享标签和注释共享一个共同的前缀：<code>app.kubernetes.io</code>。没有前缀的标签对用户是私有的。共享前缀可确保共享标签不会干扰自定义用户标签。</p>
<h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><p>为了充分利用这些标签，应将它们应用于每个资源对象。</p>
<table>
<thead>
<tr>
<th>键</th>
<th>描述</th>
<th>例</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>app.kubernetes.io/name</td>
<td>应用程序的名称</td>
<td>string</td>
<td>mysql</td>
</tr>
<tr>
<td>app.kubernetes.io/instance</td>
<td>标识应用程序实例的唯一名称</td>
<td>string</td>
<td>wordpress-abcxzy</td>
</tr>
<tr>
<td>app.kubernetes.io/version</td>
<td>应用程序的当前版本（例如，语义版本，修订版哈希等）</td>
<td>string</td>
<td>5.7.21</td>
</tr>
<tr>
<td>app.kubernetes.io/component</td>
<td>架构中的组件</td>
<td>string</td>
<td>database</td>
</tr>
<tr>
<td>app.kubernetes.io/part-of</td>
<td>此级别的更高级别应用程序的名称</td>
<td>string</td>
<td>wordpress</td>
</tr>
<tr>
<td>app.kubernetes.io/managed-by</td>
<td>该工具用于管理应用程序的操作</td>
<td>string</td>
<td>helm</td>
</tr>
</tbody>
</table>
<p>要说明这些标签的运行情况，请考虑以下StatefulSet对象：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/name: mysql</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/instance: wordpress-abcxzy</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/version: <span class="string">"5.7.21"</span></span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/component: database</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/part-of: wordpress</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/managed-by: helm</span><br></pre></td></tr></table></figure></p>
<h5 id="应用程序和应用程序实例"><a href="#应用程序和应用程序实例" class="headerlink" title="应用程序和应用程序实例"></a>应用程序和应用程序实例</h5><p>应用程序可以一次或多次安装到Kubernetes集群中，在某些情况下，可以安装在同一名称空间中。例如，<code>wordpress</code>可以不止一次安装，其中不同的网站是<code>wordpress</code>的不同安装。</p>
<p>应用程序的名称和实例名称分别记录。例如，在WordPress具有<code>app.kubernetes.io/name</code>的<code>wordpress</code>，同时它有一个实例名，被表示为<code>app.kubernetes.io/instance</code>具有值 <code>wordpress-abcxzy</code>。这使得应用程序的应用程序和实例可以识别。应用程序的每个实例都必须具有唯一的名称。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>为了说明使用这些标签的不同方式，以下示例具有不同的复杂性。</p>
<h6 id="一种简单的无状态服务"><a href="#一种简单的无状态服务" class="headerlink" title="一种简单的无状态服务"></a>一种简单的无状态服务</h6><p>考虑使用<code>Deployment</code>和<code>Service</code>对象部署的简单无状态服务的情况。以下两个代码段表示如何以最简单的形式使用标签。</p>
<p>本<code>Deployment</code>是用来监督运行应用程序本身的豆荚。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: apps/v1</span><br><span class="line"><span class="attribute">kind</span>: Deployment</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">labels</span>:</span><br><span class="line">    app.kubernetes.io/<span class="attribute">name</span>: myservice</span><br><span class="line">    app.kubernetes.io/<span class="attribute">instance</span>: myservice-abcxzy</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>将<code>Service</code>用于公开应用程序。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: myservice</span><br><span class="line">    app.kubernetes.io/instance: myservice-abcxzy</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure></p>
<h6 id="使用数据库的Web应用程序"><a href="#使用数据库的Web应用程序" class="headerlink" title="使用数据库的Web应用程序"></a>使用数据库的Web应用程序</h6><p>考虑一个稍微复杂的应用程序：使用Helm安装的使用数据库（MySQL）的Web应用程序（WordPress）。以下代码段说明了用于部署此应用程序的对象的开始。</p>
<p>以下<code>Deployment</code>内容用于WordPress：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/name: wordpress</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/instance: wordpress-abcxzy</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/version: <span class="string">"4.9.4"</span></span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/managed-by: helm</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/component: server</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/part-of: wordpress</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>将<code>Service</code>用于公开WordPress的：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: wordpress</span><br><span class="line">    app.kubernetes.io/instance: wordpress-abcxzy</span><br><span class="line">    app.kubernetes.io/version: <span class="string">"4.9.4"</span></span><br><span class="line">    app.kubernetes.io/managed-by: helm</span><br><span class="line">    app.kubernetes.io/component: server</span><br><span class="line">    app.kubernetes.io/part-of: wordpress</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure></p>
<p>MySQL作为一个<code>StatefulSet</code>包含它的元数据和它所属的更大的应用程序公开：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/name: mysql</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/instance: wordpress-abcxzy</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/managed-by: helm</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/component: database</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/part-of: wordpress</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/version: <span class="string">"5.7.21"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>将<code>Service</code>用于公开MySQL作为WordPress的部分：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/name: mysql</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/instance: wordpress-abcxzy</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/managed-by: helm</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/component: database</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/part-of: wordpress</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/version: <span class="string">"5.7.21"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>使用MySQL <code>StatefulSet</code>，<code>Service</code>您会注意到有关MySQL和Wordpress的信息，包括更广泛的应用程序。</p>
<h3 id="对象管理使用kubectl"><a href="#对象管理使用kubectl" class="headerlink" title="对象管理使用kubectl"></a>对象管理使用kubectl</h3><h4 id="Kubernetes对象管理"><a href="#Kubernetes对象管理" class="headerlink" title="Kubernetes对象管理"></a>Kubernetes对象管理</h4><p>该<code>kubectl</code>命令行工具支持多种不同的方法来创建和管理Kubernetes对象。本文档概述了不同的方法。</p>
<ul>
<li>管理技巧</li>
<li>命令式命令</li>
<li>势在必行的对象配置</li>
<li>声明性对象配置</li>
</ul>
<h5 id="管理技巧"><a href="#管理技巧" class="headerlink" title="管理技巧"></a>管理技巧</h5><blockquote>
<p>警告：应仅使用一种技术管理Kubernetes对象。对同一对象的混合和匹配技术会导致未定义的行为。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Management technique</th>
<th>操作</th>
<th>推荐环境</th>
<th>Supported writers</th>
<th>Learning curve</th>
</tr>
</thead>
<tbody>
<tr>
<td>Imperative commands</td>
<td>Live objects</td>
<td>Development projects</td>
<td>1+</td>
<td>Lowest</td>
</tr>
<tr>
<td>Imperative object configuration</td>
<td>Individual files</td>
<td>Production projects</td>
<td>1</td>
<td>Moderate</td>
</tr>
<tr>
<td>Declarative object configuration</td>
<td>Directories of files</td>
<td>Production projects</td>
<td>1+</td>
<td>Highest</td>
</tr>
</tbody>
</table>
<h5 id="命令式命令"><a href="#命令式命令" class="headerlink" title="命令式命令"></a>命令式命令</h5><p>使用命令性命令时，用户直接在群集中的活动对象上操作。用户将<code>kubectl</code>命令的操作作为参数或标志提供。</p>
<p>这是在集群中启动或运行一次性任务的最简单方法。由于此技术直接在活动对象上运行，因此它不提供先前配置的历史记录。</p>
<h6 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h6><p>通过创建Deployment对象来运行nginx容器的实例：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">run</span> nginx <span class="comment">--image nginx</span></span><br></pre></td></tr></table></figure></p>
<p>使用不同的语法执行相同的操作：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">create</span> deployment nginx <span class="comment">--image nginx</span></span><br></pre></td></tr></table></figure></p>
<h6 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h6><p>与对象配置相比的优点：</p>
<ul>
<li>命令简单易学，易记。</li>
<li>命令只需要一个步骤即可对集群进行更改。</li>
</ul>
<p>与对象配置相比的缺点：</p>
<ul>
<li>命令不与更改审核过程集成。</li>
<li>命令不提供与更改关联的审计跟踪。</li>
<li>除了活动之外，命令不提供记录源。</li>
<li>命令不提供用于创建新对象的模板。</li>
</ul>
<h5 id="势在必行的对象配置"><a href="#势在必行的对象配置" class="headerlink" title="势在必行的对象配置"></a>势在必行的对象配置</h5><p>在命令式对象配置中，kubectl命令指定操作（创建，替换等），可选标志和至少一个文件名。指定的文件必须包含YAML或JSON格式的对象的完整定义。</p>
<p>有关 对象定义的更多详细信息，请参阅<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/" target="_blank" rel="noopener">API参考</a>。</p>
<blockquote>
<p>警告：<code>replace</code>命令式命令将现有规范替换为新提供的规范，删除对配置文件中缺少的对象的所有更改。此方法不应与其配置文件独立更新的资源类型一起使用。<code>LoadBalancer</code>例如，类型的服务使其<code>externalIPs</code>字段独立于群集的配置而更新。</p>
</blockquote>
<h6 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h6><p>创建配置文件中定义的对象：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">kubectl</span> <span class="selector-tag">create</span> <span class="selector-tag">-f</span> <span class="selector-tag">nginx</span><span class="selector-class">.yaml</span></span><br></pre></td></tr></table></figure></p>
<p>删除两个配置文件中定义的对象：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">kubectl</span> <span class="selector-tag">delete</span> <span class="selector-tag">-f</span> <span class="selector-tag">nginx</span><span class="selector-class">.yaml</span> <span class="selector-tag">-f</span> <span class="selector-tag">redis</span><span class="selector-class">.yaml</span></span><br></pre></td></tr></table></figure></p>
<p>通过覆盖实时配置来更新配置文件中定义的对象：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">replace</span> -f nginx.yaml</span><br></pre></td></tr></table></figure></p>
<h6 id="权衡-1"><a href="#权衡-1" class="headerlink" title="权衡"></a>权衡</h6><p>与命令式命令相比的优点：</p>
<ul>
<li>对象配置可以存储在诸如Git的源控制系统中。</li>
<li>对象配置可以与进程集成，例如在推送和审计跟踪之前查看更改。</li>
<li>对象配置提供了用于创建新对象的模板。</li>
</ul>
<p>与命令式命令相比的缺点：</p>
<ul>
<li>对象配置需要对对象模式有基本的了解。</li>
<li>对象配置需要编写YAML文件的附加步骤。</li>
</ul>
<p>与声明对象配置相比的优点：</p>
<ul>
<li>命令式对象配置行为更简单，更易于理解。</li>
<li>从Kubernetes 1.5版开始，命令式对象配置更加成熟。</li>
</ul>
<p>与声明对象配置相比的缺点：</p>
<ul>
<li>命令对象配置最适合文件，而不是目录。</li>
<li>活动对象的更新必须反映在配置文件中，否则在下次更换时会丢失。</li>
</ul>
<h5 id="声明性对象配置"><a href="#声明性对象配置" class="headerlink" title="声明性对象配置"></a>声明性对象配置</h5><p>使用声明性对象配置时，用户对本地存储的对象配置文件进行操作，但是用户不定义要对文件执行的操作。每个对象自动检测创建，更新和删除操作<code>kubectl</code>。这使得能够处理目录，其中可能需要不同对象的不同操作。</p>
<blockquote>
<p>注意：声明性对象配置保留其他编写者所做的更改，即使更改未合并回对象配置文件也是如此。这可以通过使用<code>patch</code>API操作来仅写入观察到的差异，而不是使用<code>replace</code> API操作来替换整个对象配置。</p>
</blockquote>
<h6 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h6><p>处理目录中的所有对象配置文件<code>configs</code>，并创建或修补活动对象。您可以先<code>diff</code>查看要进行的更改，然后应用：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">diff</span> -f configs/</span><br><span class="line">kubectl <span class="built_in">apply</span> -f configs/</span><br></pre></td></tr></table></figure>
<p>递归处理目录：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">diff</span> -R -f configs/</span><br><span class="line">kubectl <span class="built_in">apply</span> -R -f configs/</span><br></pre></td></tr></table></figure></p>
<h6 id="权衡-2"><a href="#权衡-2" class="headerlink" title="权衡"></a>权衡</h6><p>与命令式对象配置相比的优点：</p>
<ul>
<li>即使它们未合并回配置文件，也会保留直接对活动对象所做的更改。</li>
<li>声明性对象配置更好地支持对目录进行操作并自动检测每个对象的操作类型（创建，修补，删除）。</li>
</ul>
<p>与命令式对象配置相比的缺点：</p>
<ul>
<li>声明性对象配置更难以调试，并在意外时理解结果。</li>
<li>使用diff的部分更新会创建复杂的合并和修补操作。</li>
</ul>
<h4 id="使用命令式命令管理Kubernetes对象"><a href="#使用命令式命令管理Kubernetes对象" class="headerlink" title="使用命令式命令管理Kubernetes对象"></a>使用命令式命令管理Kubernetes对象</h4><p>可以使用命令<code>kubectl</code>行工具中内置的命令性命令直接创建，更新和删除Kubernetes对象。本文档说明了如何组织这些命令以及如何使用它们来管理实时对象。</p>
<ul>
<li>权衡</li>
<li>如何创建对象</li>
<li>如何更新对象</li>
<li>如何删除对象</li>
<li>如何查看对象</li>
<li>使用set命令在创建之前修改对象</li>
<li>使用–edit修改之前创建的对象</li>
</ul>
<h5 id="权衡-3"><a href="#权衡-3" class="headerlink" title="权衡"></a>权衡</h5><p>该<code>kubectl</code>工具支持三种对象管理：</p>
<ul>
<li>命令式命令</li>
<li>势在必行的对象配置</li>
<li>声明性对象配置</li>
</ul>
<p>有关<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">每种对象管理</a> 的优缺点的讨论，请参阅<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">Kubernetes</a>对象管理。</p>
<h5 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h5><p>该<code>kubectl</code>工具支持动词驱动的命令，用于创建一些最常见的对象类型。这些命令被命名为不熟悉Kubernetes对象类型的用户可识别。</p>
<ul>
<li><code>run</code>：创建一个新的Deployment对象以在一个或多个Pod中运行Container。</li>
<li><code>expose</code>：创建一个新的服务对象，以跨Pod调整流量负载。</li>
<li><code>autoscale</code>：创建新的Autoscaler对象以自动水平扩展控制器，例如部署。</li>
</ul>
<p>该<code>kubectl</code>工具还支持由对象类型驱动的创建命令。这些命令支持更多对象类型，并且更明确地表达了它们的意图，但要求用户知道他们打算创建的对象的类型。</p>
<ul>
<li><code>create &lt;objecttype&gt; [&lt;subtype&gt;] &lt;instancename&gt;</code></li>
</ul>
<p>某些对象类型具有您可以在<code>create</code>命令中指定的子类型。例如，Service对象有几个子类型，包括ClusterIP，LoadBalancer和NodePort。这是一个使用子类型NodePort创建服务的示例：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create<span class="built_in"> service </span>nodeport &lt;myservicename&gt;</span><br></pre></td></tr></table></figure></p>
<p>在前面的示例中，该<code>create service nodeport</code>命令称为命令的子<code>create service</code>命令。</p>
<p>您可以使用该<code>-h</code>标志来查找子命令支持的参数和标志：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create<span class="built_in"> service </span>nodeport -h</span><br></pre></td></tr></table></figure></p>
<h5 id="如何更新对象"><a href="#如何更新对象" class="headerlink" title="如何更新对象"></a>如何更新对象</h5><p>该<code>kubectl</code>命令支持一些常见更新操作的动词驱动命令。命名这些命令是为了使不熟悉Kubernetes对象的用户能够在不知道必须设置的特定字段的情况下执行更新：</p>
<ul>
<li><code>scale</code>：通过更新控制器的副本计数，水平缩放控制器以添加或删除Pod。</li>
<li><code>annotate</code>：在对象中添加或删除注释。</li>
<li><code>label</code>：在对象中添加或删除标签。</li>
</ul>
<p>该<code>kubectl</code>命令还支持由对象的一个方面驱动的更新命令。设置此方面可以为不同的对象类型设置不同的字段：</p>
<ul>
<li>set ：设置对象的一个方面。</li>
</ul>
<blockquote>
<p>注意：在Kubernetes 1.5版中，并非每个动词驱动的命令都有一个关联的方面驱动命令。</p>
</blockquote>
<p>该<code>kubectl</code>工具支持这些直接更新实时对象的其他方法，但是它们需要更好地理解Kubernetes对象模式。</p>
<ul>
<li><code>edit</code>：通过在编辑器中打开其配置，直接编辑活动对象的原始配置。</li>
<li><code>patch</code>：使用补丁字符串直接修改活动对象的特定字段。有关修补程序字符串的更多详细信息，请参阅API约定中的修补程序部分 。</li>
</ul>
<h5 id="如何删除对象"><a href="#如何删除对象" class="headerlink" title="如何删除对象"></a>如何删除对象</h5><p>您可以使用该<code>delete</code>命令从群集中删除对象：</p>
<ul>
<li><code>delete &lt;type&gt;/&lt;name&gt;</code></li>
</ul>
<blockquote>
<p>注意：您可以使用<code>kubectl delete</code>命令式命令和命令式对象配置。不同之处在于传递给命令的参数。要 <code>kubectl delete</code>用作命令性命令，请将要删除的对象作为参数传递。这是一个传递名为nginx的Deployment对象的示例：</p>
</blockquote>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">delete</span> deployment/nginx</span><br></pre></td></tr></table></figure>
<h5 id="如何查看对象"><a href="#如何查看对象" class="headerlink" title="如何查看对象"></a>如何查看对象</h5><p>有几个命令用于打印有关对象的信息：</p>
<ul>
<li><code>get</code>：打印有关匹配对象的基本信息。使用<code>get -h</code>查看选项列表。</li>
<li><code>describe</code>：打印有关匹配对象的聚合详细信息。</li>
<li><code>logs</code>：为在Pod中运行的容器打印stdout和stderr。</li>
</ul>
<h5 id="使用set命令在创建之前修改对象"><a href="#使用set命令在创建之前修改对象" class="headerlink" title="使用set命令在创建之前修改对象"></a>使用set命令在创建之前修改对象</h5><p>有些对象字段没有可在<code>create</code>命令中使用的标志。在一些案件中，可以使用的组合 <code>set</code>并<code>create</code>指定对象创建前场的值。这是通过将<code>create</code>命令的输出传递给 <code>set</code>命令，然后返回到<code>create</code>命令来完成的。这是一个例子：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create service clusterip my-svc --clusterip=<span class="string">"None"</span> -o yaml --dry-<span class="keyword">run</span><span class="bash"> | kubectl <span class="built_in">set</span> selector --<span class="built_in">local</span> -f - <span class="string">'environment=qa'</span> -o yaml | kubectl create -f -</span></span><br></pre></td></tr></table></figure>
<ol>
<li>该<code>kubectl create service -o yaml --dry-run</code>命令为服务创建配置，但将其作为YAML打印到stdout，而不是将其发送到Kubernetes API服务器。</li>
<li>该<code>kubectl set selector --local -f - -o yaml</code>命令从stdin读取配置，并将更新的配置作为YAML写入stdout。</li>
<li>该<code>kubectl create -f -</code>命令使用stdin提供的配置创建对象。</li>
</ol>
<h5 id="使用–edit修改之前创建的对象"><a href="#使用–edit修改之前创建的对象" class="headerlink" title="使用–edit修改之前创建的对象"></a>使用–edit修改之前创建的对象</h5><p>您可以<code>kubectl create --edit</code>在创建对象之前对其进行任意更改。这是一个例子：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create<span class="built_in"> service </span>clusterip my-svc <span class="attribute">--clusterip</span>=<span class="string">"None"</span> -o yaml --dry-<span class="builtin-name">run</span> &gt; /tmp/srv.yaml</span><br><span class="line">kubectl create --<span class="builtin-name">edit</span> -f /tmp/srv.yaml</span><br></pre></td></tr></table></figure></p>
<p>该<code>kubectl create service</code>命令为服务创建配置并将其保存到<code>/tmp/srv.yaml</code>。<br>该<code>kubectl create --edit</code>命令在创建对象之前打开配置文件以进行编辑。</p>
<h4 id="使用配置文件管理Kubernetes对象"><a href="#使用配置文件管理Kubernetes对象" class="headerlink" title="使用配置文件管理Kubernetes对象"></a>使用配置文件管理Kubernetes对象</h4><p>可以使用<code>kubectl</code> 命令行工具以及使用YAML或JSON编写的对象配置文件来创建，更新和删除Kubernetes对象。本文档介绍了如何使用配置文件定义和管理对象。</p>
<ul>
<li>权衡</li>
<li>如何创建对象</li>
<li>如何更新对象</li>
<li>如何删除对象</li>
<li>如何查看对象</li>
<li>限制</li>
<li>在不保存配置的情况下从URL创建和编辑对象</li>
<li>从命令式命令迁移到命令式对象配置</li>
<li>定义控制器选择器和PodTemplate标签</li>
</ul>
<h5 id="权衡-4"><a href="#权衡-4" class="headerlink" title="权衡"></a>权衡</h5><p>该<code>kubectl</code>工具支持三种对象管理：</p>
<ul>
<li>命令式命令</li>
<li>势在必行的对象配置</li>
<li>声明性对象配置</li>
</ul>
<p>有关<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">每种对象管理</a> 的优缺点的讨论，请参阅<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">Kubernetes</a>对象管理。</p>
<h5 id="如何创建对象-1"><a href="#如何创建对象-1" class="headerlink" title="如何创建对象"></a>如何创建对象</h5><p>您可以使用<code>kubectl create -f</code>从配置文件创建对象。 有关详细信息，请参阅<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/" target="_blank" rel="noopener">kubernetes API参考</a>。</p>
<ul>
<li><code>kubectl create -f &lt;filename|url&gt;</code></li>
</ul>
<h5 id="如何更新对象-1"><a href="#如何更新对象-1" class="headerlink" title="如何更新对象"></a>如何更新对象</h5><blockquote>
<p>警告：使用该<code>replace</code>命令更新对象会删除配置文件中未指定的规范的所有部分。这不应该与规范部分由集群管理的对象一起使用，例如类型服务<code>LoadBalancer</code>，其中<code>externalIPs</code>字段独立于配置文件进行管理。必须将独立管理的字段复制到配置文件中以防止<code>replace</code>丢弃它们。</p>
</blockquote>
<p>您可以使用<code>kubectl replace -f</code>根据配置文件更新活动对象。</p>
<ul>
<li><code>kubectl replace -f &lt;filename|url&gt;</code></li>
</ul>
<h5 id="如何删除对象-1"><a href="#如何删除对象-1" class="headerlink" title="如何删除对象"></a>如何删除对象</h5><p>您可以使用<code>kubectl delete -f</code>删除配置文件中描述的对象。</p>
<ul>
<li><code>kubectl delete -f &lt;filename|url&gt;</code></li>
</ul>
<h5 id="如何查看对象-1"><a href="#如何查看对象-1" class="headerlink" title="如何查看对象"></a>如何查看对象</h5><p>您可以使用它<code>kubectl get -f</code>来查看有关配置文件中描述的对象的信息。</p>
<ul>
<li><code>kubectl get -f &lt;filename|url&gt; -o yaml</code></li>
</ul>
<p>该<code>-o yaml</code>标志指定打印完整对象配置。使用<code>kubectl get -h</code>查看选项列表。</p>
<h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><p><code>create</code>，<code>replace</code>和<code>delete</code>命令工作得很好，当每个对象的配置完全确定并记录在它的配置文件。但是，当更新活动对象并且更新未合并到其配置文件中时，更新将在下次<code>replace</code> 执行时丢失。如果控制器（例如HorizontalPodAutoscaler）直接对活动对象进行更新，则会发生这种情况。这是一个例子：</p>
<ol>
<li>您可以从配置文件创建对象。</li>
<li>另一个源通过更改某个字段来更新对象。</li>
<li>您从配置文件中替换该对象。步骤2中其他来源所做的更改将丢失。</li>
</ol>
<p>如果需要支持同一对象的多个编写器，则可以使用它<code>kubectl apply</code>来管理对象。</p>
<h5 id="在不保存配置的情况下从URL创建和编辑对象"><a href="#在不保存配置的情况下从URL创建和编辑对象" class="headerlink" title="在不保存配置的情况下从URL创建和编辑对象"></a>在不保存配置的情况下从URL创建和编辑对象</h5><p>假设您具有对象配置文件的URL。您可以 <code>kubectl create --edit</code>在创建对象之前用于更改配置。这对于指向可由读者修改的配置文件的教程和任务特别有用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">create</span> -f &lt;<span class="keyword">url</span>&gt; <span class="comment">--edit</span></span><br></pre></td></tr></table></figure>
<h5 id="从命令式命令迁移到命令式对象配置"><a href="#从命令式命令迁移到命令式对象配置" class="headerlink" title="从命令式命令迁移到命令式对象配置"></a>从命令式命令迁移到命令式对象配置</h5><ol>
<li>从命令式命令迁移到命令式对象配置涉及几个手动步骤。<br>将活动对象导出到本地对象配置文件：</li>
</ol>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">get</span> <span class="symbol">&lt;kind&gt;</span>/<span class="symbol">&lt;name&gt;</span> -<span class="keyword">o</span> yaml --export &gt; <span class="symbol">&lt;kind&gt;</span>_<span class="symbol">&lt;name&gt;</span>.yaml</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>从对象配置文件中手动删除状态字段。</p>
</li>
<li><p>对于后续对象管理，请<code>replace</code>专门使用。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl replace -f <span class="tag">&lt;<span class="name">kind</span>&gt;</span>_<span class="tag">&lt;<span class="name">name</span>&gt;</span>.yaml</span><br></pre></td></tr></table></figure>
<h5 id="定义控制器选择器和PodTemplate标签"><a href="#定义控制器选择器和PodTemplate标签" class="headerlink" title="定义控制器选择器和PodTemplate标签"></a>定义控制器选择器和PodTemplate标签</h5><blockquote>
<p>警告：强烈建议不要更新控制器上的选择器。</p>
</blockquote>
<p>推荐的方法是定义一个仅由控制器选择器使用的单个不可变PodTemplate标签，没有其他语义含义。</p>
<p>示例标签：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">selector</span>:</span><br><span class="line">  <span class="attribute">matchLabels</span>:</span><br><span class="line">      <span class="attribute">controller-selector</span>: <span class="string">"extensions/v1beta1/deployment/nginx"</span></span><br><span class="line"><span class="attribute">template</span>:</span><br><span class="line">  <span class="attribute">metadata</span>:</span><br><span class="line">    <span class="attribute">labels</span>:</span><br><span class="line">      <span class="attribute">controller-selector</span>: <span class="string">"extensions/v1beta1/deployment/nginx"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用配置文件声明管理Kubernetes对象"><a href="#使用配置文件声明管理Kubernetes对象" class="headerlink" title="使用配置文件声明管理Kubernetes对象"></a>使用配置文件声明管理Kubernetes对象</h4><p>可以通过在目录中存储多个对象配置文件并使用<code>kubectl apply</code>根据需要递归创建和更新这些对象来创建，更新和删除Kubernetes对象。此方法保留对活动对象的写入，而不将更改合并回对象配置文件。<code>kubectl diff</code>还可以预览<code>apply</code>将要进行的更改。</p>
<ul>
<li>权衡</li>
<li>在你开始之前</li>
<li>如何创建对象</li>
<li>如何更新对象</li>
<li>如何删除对象</li>
<li>如何查看对象</li>
<li>如何应用计算差异并合并更改</li>
<li>默认字段值</li>
<li>如何更改配置文件和直接命令式编写器之间字段的所有权</li>
<li>改变管理方法</li>
<li>定义控制器选择器和PodTemplate标签</li>
</ul>
<h5 id="权衡-5"><a href="#权衡-5" class="headerlink" title="权衡"></a>权衡</h5><p>该<code>kubectl</code>工具支持三种对象管理：</p>
<ul>
<li>命令式命令</li>
<li>势在必行的对象配置</li>
<li>声明性对象配置</li>
</ul>
<p>有关<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">每种对象管理</a> 的优缺点的讨论，请参阅<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">Kubernetes</a>对象管理。</p>
<h5 id="在你开始之前"><a href="#在你开始之前" class="headerlink" title="在你开始之前"></a>在你开始之前</h5><p>声明性对象配置需要牢固地理解Kubernetes对象定义和配置。如果您还没有阅读并填写以下文件：</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/imperative-command/" target="_blank" rel="noopener">使用命令式命令管理Kubernetes对象</a></li>
<li><a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/imperative-config/" target="_blank" rel="noopener">使用配置文件管理Kubernetes对象</a></li>
</ul>
<p>以下是本文档中使用的术语的定义：</p>
<ul>
<li>对象配置文件/配置文件：定义Kubernetes对象配置的文件。本主题说明如何将配置文件传递给<code>kubectl apply</code>。配置文件通常存储在源代码管理中，例如Git。</li>
<li>实时对象配置/实时配置：Kubernetes集群观察到的对象的实时配置值。这些保存在Kubernetes集群存储中，通常是etcd。</li>
<li>声明性配置writer / declarative writer：对活动对象进行更新的人员或软件组件。本主题中提到的实时编写器会更改对象配置文件并运行<code>kubectl apply</code>以编写更改。</li>
</ul>
<h5 id="如何创建对象-2"><a href="#如何创建对象-2" class="headerlink" title="如何创建对象"></a>如何创建对象</h5><p>使用<code>kubectl apply</code>创建的所有对象，除了那些已经存在，通过配置文件在指定的目录中定义：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f &lt;<span class="built_in">directory</span>&gt;/</span><br></pre></td></tr></table></figure></p>
<p>这将<code>kubectl.kubernetes.io/last-applied-configuration: &#39;{...}&#39;</code>在每个对象上设置注释。注释包含用于创建对象的对象配置文件的内容。</p>
<blockquote>
<p>注意：添加-R标志以递归处理目录。</p>
</blockquote>
<p>以下是对象配置文件的示例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application/simple_deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>运行<code>kubectl diff</code>以打印将要创建的对象：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl diff -f https:<span class="regexp">//</span>k8s.io<span class="regexp">/examples/</span>application<span class="regexp">/simple_deployment.yaml</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：<code>diff</code>使用服务器端干运行，需要启用<code>kube-apiserver</code>。</p>
</blockquote>
<p>使用<code>kubectl apply</code>以下方法创建对象<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https:<span class="regexp">//</span>k8s.io<span class="regexp">/examples/</span>application<span class="regexp">/simple_deployment.yaml</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>kubectl get</code>以下方式打印实时配置<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> -f https:<span class="comment">//k8s.io/examples/application/simple_deployment.yaml -o yaml</span></span><br></pre></td></tr></table></figure></p>
<p>输出显示<code>kubectl.kubernetes.io/last-applied-configuration</code>注释已写入实时配置，并且与配置文件匹配：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">kind:</span> Deployment</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  annotations:</span></span><br><span class="line">    <span class="meta"># ...</span></span><br><span class="line">    <span class="meta"># This is the json representation of simple_deployment.yaml</span></span><br><span class="line">    <span class="meta"># It was written by kubectl apply when the object was created</span></span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;<span class="string">"apiVersion"</span>:<span class="string">"apps/v1"</span>,<span class="string">"kind"</span>:<span class="string">"Deployment"</span>,</span><br><span class="line">      <span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"nginx-deployment"</span>,<span class="string">"namespace"</span>:<span class="string">"default"</span>&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"minReadySeconds"</span>:<span class="number">5</span>,<span class="string">"selector"</span>:&#123;<span class="string">"matchLabels"</span>:&#123;<span class="string">"app"</span>:nginx&#125;&#125;,<span class="string">"template"</span>:&#123;<span class="string">"metadata"</span>:&#123;<span class="string">"labels"</span>:&#123;<span class="string">"app"</span>:<span class="string">"nginx"</span>&#125;&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"containers"</span>:[&#123;<span class="string">"image"</span>:<span class="string">"nginx:1.7.9"</span>,<span class="string">"name"</span>:<span class="string">"nginx"</span>,</span><br><span class="line">      <span class="string">"ports"</span>:[&#123;<span class="string">"containerPort"</span>:<span class="number">80</span>&#125;]&#125;]&#125;&#125;&#125;&#125;</span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">  selector:</span></span><br><span class="line"><span class="symbol">    matchLabels:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      app:</span> nginx</span><br><span class="line"><span class="symbol">  template:</span></span><br><span class="line"><span class="symbol">    metadata:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      labels:</span></span><br><span class="line"><span class="symbol">        app:</span> nginx</span><br><span class="line"><span class="symbol">    spec:</span></span><br><span class="line"><span class="symbol">      containers:</span></span><br><span class="line">      - image: nginx:<span class="number">1.7</span><span class="number">.9</span></span><br><span class="line">        <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">        name:</span> nginx</span><br><span class="line"><span class="symbol">        ports:</span></span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">        <span class="meta"># ...</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line">    <span class="meta"># ...</span></span><br><span class="line">  <span class="meta"># ...</span></span><br></pre></td></tr></table></figure></p>
<h5 id="如何更新对象-2"><a href="#如何更新对象-2" class="headerlink" title="如何更新对象"></a>如何更新对象</h5><p>您还可以使用<code>kubectl apply</code>更新目录中定义的所有对象，即使这些对象已存在。此方法可实现以下目标：</p>
<ol>
<li>设置实时配置中配置文件中显示的字段。</li>
<li>清除实时配置中从配置文件中删除的字段。</li>
</ol>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">diff</span> -f &lt;<span class="built_in">directory</span>&gt;/</span><br><span class="line">kubectl <span class="built_in">apply</span> -f &lt;<span class="built_in">directory</span>&gt;/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：添加-R标志以递归处理目录。</p>
</blockquote>
<p>这是一个示例配置文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application/simple_deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>kubectl apply</code>以下方法创建对象<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https:<span class="regexp">//</span>k8s.io<span class="regexp">/examples/</span>application<span class="regexp">/simple_deployment.yaml</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：出于说明的目的，上述命令引用单个配置文件而不是目录。</p>
</blockquote>
<p>使用<code>kubectl get</code>以下方式打印实时配置<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> -f https:<span class="comment">//k8s.io/examples/application/simple_deployment.yaml -o yaml</span></span><br></pre></td></tr></table></figure></p>
<p>输出显示<code>kubectl.kubernetes.io/last-applied-configuration</code>注释已写入实时配置，并且与配置文件匹配：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">kind:</span> Deployment</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  annotations:</span></span><br><span class="line">    <span class="meta"># ...</span></span><br><span class="line">    <span class="meta"># This is the json representation of simple_deployment.yaml</span></span><br><span class="line">    <span class="meta"># It was written by kubectl apply when the object was created</span></span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;<span class="string">"apiVersion"</span>:<span class="string">"apps/v1"</span>,<span class="string">"kind"</span>:<span class="string">"Deployment"</span>,</span><br><span class="line">      <span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"nginx-deployment"</span>,<span class="string">"namespace"</span>:<span class="string">"default"</span>&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"minReadySeconds"</span>:<span class="number">5</span>,<span class="string">"selector"</span>:&#123;<span class="string">"matchLabels"</span>:&#123;<span class="string">"app"</span>:nginx&#125;&#125;,<span class="string">"template"</span>:&#123;<span class="string">"metadata"</span>:&#123;<span class="string">"labels"</span>:&#123;<span class="string">"app"</span>:<span class="string">"nginx"</span>&#125;&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"containers"</span>:[&#123;<span class="string">"image"</span>:<span class="string">"nginx:1.7.9"</span>,<span class="string">"name"</span>:<span class="string">"nginx"</span>,</span><br><span class="line">      <span class="string">"ports"</span>:[&#123;<span class="string">"containerPort"</span>:<span class="number">80</span>&#125;]&#125;]&#125;&#125;&#125;&#125;</span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">  selector:</span></span><br><span class="line"><span class="symbol">    matchLabels:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      app:</span> nginx</span><br><span class="line"><span class="symbol">  template:</span></span><br><span class="line"><span class="symbol">    metadata:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      labels:</span></span><br><span class="line"><span class="symbol">        app:</span> nginx</span><br><span class="line"><span class="symbol">    spec:</span></span><br><span class="line"><span class="symbol">      containers:</span></span><br><span class="line">      - image: nginx:<span class="number">1.7</span><span class="number">.9</span></span><br><span class="line">        <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">        name:</span> nginx</span><br><span class="line"><span class="symbol">        ports:</span></span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">        <span class="meta"># ...</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line">    <span class="meta"># ...</span></span><br><span class="line">  <span class="meta"># ...</span></span><br></pre></td></tr></table></figure></p>
<p>使用，直接更新<code>replicas</code>实时配置中的字段<code>kubectl scale</code>。这不使用<code>kubectl apply</code>：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployment/nginx-deployment <span class="attribute">--replicas</span>=2</span><br></pre></td></tr></table></figure></p>
<p>使用<code>kubectl get</code>以下方式打印实时配置<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> -f https:<span class="comment">//k8s.io/examples/application/simple_deployment.yaml -o yaml</span></span><br></pre></td></tr></table></figure></p>
<p>输出显示该<code>replicas</code>字段已设置为2，并且<code>last-applied-configuration</code>注释不包含<code>replicas</code>字段：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">apiVersion:</span> apps/v1</span><br><span class="line"><span class="symbol">kind:</span> Deployment</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  annotations:</span></span><br><span class="line">    <span class="meta"># ...</span></span><br><span class="line">    <span class="meta"># note that the annotation does not contain replicas</span></span><br><span class="line">    <span class="meta"># because it was not updated through apply</span></span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;<span class="string">"apiVersion"</span>:<span class="string">"apps/v1"</span>,<span class="string">"kind"</span>:<span class="string">"Deployment"</span>,</span><br><span class="line">      <span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"nginx-deployment"</span>,<span class="string">"namespace"</span>:<span class="string">"default"</span>&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"minReadySeconds"</span>:<span class="number">5</span>,<span class="string">"selector"</span>:&#123;<span class="string">"matchLabels"</span>:&#123;<span class="string">"app"</span>:nginx&#125;&#125;,<span class="string">"template"</span>:&#123;<span class="string">"metadata"</span>:&#123;<span class="string">"labels"</span>:&#123;<span class="string">"app"</span>:<span class="string">"nginx"</span>&#125;&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"containers"</span>:[&#123;<span class="string">"image"</span>:<span class="string">"nginx:1.7.9"</span>,<span class="string">"name"</span>:<span class="string">"nginx"</span>,</span><br><span class="line">      <span class="string">"ports"</span>:[&#123;<span class="string">"containerPort"</span>:<span class="number">80</span>&#125;]&#125;]&#125;&#125;&#125;&#125;</span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  replicas:</span> <span class="number">2</span> <span class="meta"># written by scale</span></span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">  selector:</span></span><br><span class="line"><span class="symbol">    matchLabels:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      app:</span> nginx</span><br><span class="line"><span class="symbol">  template:</span></span><br><span class="line"><span class="symbol">    metadata:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      labels:</span></span><br><span class="line"><span class="symbol">        app:</span> nginx</span><br><span class="line"><span class="symbol">    spec:</span></span><br><span class="line"><span class="symbol">      containers:</span></span><br><span class="line">      - image: nginx:<span class="number">1.7</span><span class="number">.9</span></span><br><span class="line">        <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">        name:</span> nginx</span><br><span class="line"><span class="symbol">        ports:</span></span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">      <span class="meta"># ...</span></span><br></pre></td></tr></table></figure></p>
<p>更新<code>simple_deployment.yaml</code>配置文件以将映像更改 <code>nginx:1.7.9</code>为<code>nginx:1.11.9</code>，并删除该<code>minReadySeconds</code>字段：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application/update_deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.11.9</span> <span class="comment"># update the image</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>应用对配置文件所做的更改：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl diff -f <span class="symbol">https:</span>/<span class="regexp">/k8s.io/examples</span><span class="regexp">/application/update</span>_deployment.yaml</span><br><span class="line">kubectl apply -f <span class="symbol">https:</span>/<span class="regexp">/k8s.io/examples</span><span class="regexp">/application/update</span>_deployment.yaml</span><br></pre></td></tr></table></figure></p>
<p>使用<code>kubectl get</code>以下方式打印实时配置<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> -f https:<span class="comment">//k8s.io/examples/application/simple_deployment.yaml -o yaml</span></span><br></pre></td></tr></table></figure></p>
<p>输出显示实时配置的以下更改：</p>
<p>该<code>replicas</code>字段保留2的值<code>kubectl scale</code>。这是可能的，因为它从配置文件中省略。<br>该<code>image</code>场已被更新，以<code>nginx:1.11.9</code>从<code>nginx:1.7.9</code>。<br>该<code>last-applied-configuration</code>批注已经更新了新的形象。<br>该<code>minReadySeconds</code>领域已被清除。<br>该<code>last-applied-configuration</code>注释不再包含<code>minReadySeconds</code>字段。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    # ...</span><br><span class="line">    # The annotation contains the updated image to nginx <span class="number">1.11</span><span class="number">.9</span>,</span><br><span class="line">    # but does not contain the updated replicas to <span class="number">2</span></span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;<span class="string">"apiVersion"</span>:<span class="string">"apps/v1"</span>,<span class="string">"kind"</span>:<span class="string">"Deployment"</span>,</span><br><span class="line">      <span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"nginx-deployment"</span>,<span class="string">"namespace"</span>:<span class="string">"default"</span>&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"selector"</span>:&#123;<span class="string">"matchLabels"</span>:&#123;<span class="string">"app"</span>:nginx&#125;&#125;,<span class="string">"template"</span>:&#123;<span class="string">"metadata"</span>:&#123;<span class="string">"labels"</span>:&#123;<span class="string">"app"</span>:<span class="string">"nginx"</span>&#125;&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"containers"</span>:[&#123;<span class="string">"image"</span>:<span class="string">"nginx:1.11.9"</span>,<span class="string">"name"</span>:<span class="string">"nginx"</span>,</span><br><span class="line">      <span class="string">"ports"</span>:[&#123;<span class="string">"containerPort"</span>:<span class="number">80</span>&#125;]&#125;]&#125;&#125;&#125;&#125;</span><br><span class="line">    # ...</span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">2</span> # Set by `kubectl scale`.  Ignored by `kubectl apply`.</span><br><span class="line">  # minReadySeconds cleared by `kubectl apply`</span><br><span class="line">  # ...</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      # ...</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      # ...</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx:<span class="number">1.11</span><span class="number">.9</span> # Set by `kubectl apply`</span><br><span class="line">        # ...</span><br><span class="line">        name: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">        # ...</span><br><span class="line">      # ...</span><br><span class="line">    # ...</span><br><span class="line">  # ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告：混合<code>kubectl apply</code>与势在必行对象配置命令 <code>create</code>和<code>replace</code>不支持。这是因为<code>create</code> 并<code>replace</code>没有保留<code>kubectl.kubernetes.io/last-applied-configuration</code> 的是<code>kubectl apply</code>用来计算更新。</p>
</blockquote>
<h5 id="如何删除对象-2"><a href="#如何删除对象-2" class="headerlink" title="如何删除对象"></a>如何删除对象</h5><p>删除管理对象有两种方法<code>kubectl apply</code>。</p>
<h6 id="推荐的：-kubectl-delete-f-lt-filename-gt"><a href="#推荐的：-kubectl-delete-f-lt-filename-gt" class="headerlink" title="推荐的： kubectl delete -f &lt;filename&gt;"></a>推荐的： <code>kubectl delete -f &lt;filename&gt;</code></h6><p>建议的方法是使用命令式命令手动删除对象，因为它更明确地删除了什么，并且不太可能导致用户无意中删除了某些内容<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">delete</span> -<span class="keyword">f</span> <span class="symbol">&lt;filename&gt;</span></span><br></pre></td></tr></table></figure></p>
<h6 id="替代方案：-kubectl-apply-f-lt-directory-gt-prune-l-your-label"><a href="#替代方案：-kubectl-apply-f-lt-directory-gt-prune-l-your-label" class="headerlink" title="替代方案： kubectl apply -f &lt;directory/&gt; --prune -l your=label"></a>替代方案： <code>kubectl apply -f &lt;directory/&gt; --prune -l your=label</code></h6><p>只有在你知道自己在做什么的情况下才能使用它。</p>
<blockquote>
<p>警告： <code>kubectl apply --prune</code>处于alpha状态，后续版本中可能会引入向后不兼容的更改。</p>
</blockquote>
<blockquote>
<p>警告：使用此命令时必须小心，以免意外删除对象。</p>
</blockquote>
<p>作为替代方法<code>kubectl delete</code>，您可以使用它<code>kubectl apply</code>来识别从目录中删除配置文件后要删除的对象。<code>--prune</code> 对API服务器应用查询以匹配一组标签的所有对象，并尝试将返回的活动对象配置与对象配置文件进行匹配。如果对象与查询匹配，并且目录中没有配置文件，并且它具有<code>last-applied-configuration</code>注释，则会将其删除。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f &lt;<span class="built_in">directory</span>/&gt; --prune -l &lt;<span class="built_in">labels</span>&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>警告：只应对包含对象配置文件的根目录运行prune。如果对象被指定的标签选择器查询返回-l <labels>并且未出现在子目录中，则对子目录运行会导致无意中删除对象。</labels></p>
</blockquote>
<h5 id="如何查看对象-2"><a href="#如何查看对象-2" class="headerlink" title="如何查看对象"></a>如何查看对象</h5><p>您可以使用<code>kubectl getwith -o yaml</code>来查看活动对象的配置：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="builtin-name">get</span> -f &lt;filename|url&gt; -o yaml</span><br></pre></td></tr></table></figure>
<h5 id="如何应用计算差异并合并更改"><a href="#如何应用计算差异并合并更改" class="headerlink" title="如何应用计算差异并合并更改"></a>如何应用计算差异并合并更改</h5><blockquote>
<p>注意：补丁是一种更新操作，其范围限定为对象的特定字段而不是整个对象。这样可以仅更新对象上的特定字段集，而无需先读取对象。</p>
</blockquote>
<p>当<code>kubectl apply</code>一个对象更新实时配置，它通过发送补丁请求API服务器这样做。该补丁定义了作用于活动对象配置的特定字段的更新。该<code>kubectl apply</code>命令使用配置文件，实时配置和实时配置中<code>last-applied-configuration</code>存储的注释来计算此修补程序请求 。</p>
<h6 id="合并补丁计算"><a href="#合并补丁计算" class="headerlink" title="合并补丁计算"></a>合并补丁计算</h6><p>该<code>kubectl apply</code>命令将配置文件的内容写入 <code>kubectl.kubernetes.io/last-applied-configuration</code>注释。这用于标识已从配置文件中删除的字段，需要从实时配置中清除。以下是用于计算应删除或设置哪些字段的步骤：</p>
<ol>
<li>计算要删除的字段。这些是<code>last-applied-configuration</code>配置文件中存在和丢失的字段。</li>
<li>计算要添加或设置的字段。这些是配置文件中存在的字段，其值与实时配置不匹配。</li>
</ol>
<p>这是一个例子。假设这是Deployment对象的配置文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application/update_deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.11.9</span> <span class="comment"># update the image</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>另外，假设这是同一Deployment对象的实时配置：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">apiVersion:</span> apps/v1</span><br><span class="line"><span class="symbol">kind:</span> Deployment</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  annotations:</span></span><br><span class="line">    <span class="meta"># ...</span></span><br><span class="line">    <span class="meta"># note that the annotation does not contain replicas</span></span><br><span class="line">    <span class="meta"># because it was not updated through apply</span></span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;<span class="string">"apiVersion"</span>:<span class="string">"apps/v1"</span>,<span class="string">"kind"</span>:<span class="string">"Deployment"</span>,</span><br><span class="line">      <span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"nginx-deployment"</span>,<span class="string">"namespace"</span>:<span class="string">"default"</span>&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"minReadySeconds"</span>:<span class="number">5</span>,<span class="string">"selector"</span>:&#123;<span class="string">"matchLabels"</span>:&#123;<span class="string">"app"</span>:nginx&#125;&#125;,<span class="string">"template"</span>:&#123;<span class="string">"metadata"</span>:&#123;<span class="string">"labels"</span>:&#123;<span class="string">"app"</span>:<span class="string">"nginx"</span>&#125;&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"containers"</span>:[&#123;<span class="string">"image"</span>:<span class="string">"nginx:1.7.9"</span>,<span class="string">"name"</span>:<span class="string">"nginx"</span>,</span><br><span class="line">      <span class="string">"ports"</span>:[&#123;<span class="string">"containerPort"</span>:<span class="number">80</span>&#125;]&#125;]&#125;&#125;&#125;&#125;</span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  replicas:</span> <span class="number">2</span> <span class="meta"># written by scale</span></span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">  selector:</span></span><br><span class="line"><span class="symbol">    matchLabels:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      app:</span> nginx</span><br><span class="line"><span class="symbol">  template:</span></span><br><span class="line"><span class="symbol">    metadata:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      labels:</span></span><br><span class="line"><span class="symbol">        app:</span> nginx</span><br><span class="line"><span class="symbol">    spec:</span></span><br><span class="line"><span class="symbol">      containers:</span></span><br><span class="line">      - image: nginx:<span class="number">1.7</span><span class="number">.9</span></span><br><span class="line">        <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">        name:</span> nginx</span><br><span class="line"><span class="symbol">        ports:</span></span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">      <span class="meta"># ...</span></span><br></pre></td></tr></table></figure></p>
<p>以下是将通过以下方式执行的合并计算<code>kubectl apply</code>：</p>
<ol>
<li>通过读取值<code>last-applied-configuration</code>并将它们与配置文件中的值进行比较来计算要删除的字段 。清除字段在本地对象配置文件中显式设置为null，无论它们是否出现在<code>last-applied-configuration</code>。在此示例中，<code>minReadySeconds</code>出现在 <code>last-applied-configuration</code>注释中，但未出现在配置文件中。 <strong>Action</strong>：<code>minReadySeconds`</code>从实时配置中清除。</li>
<li>通过从配置文件中读取值并将它们与实时配置中的值进行比较来计算要设置的字段。在此示例中，<code>image</code>配置文件中的值与实时配置中的值不匹配。<strong>Action</strong>：设置image实时配置中的值。</li>
<li>设置<code>last-applied-configuration</code>注释以匹配配置文件的值。</li>
<li>将来自1,2,3的结果合并到API服务器的单个补丁请求中。</li>
</ol>
<p>以下是合并的实时配置：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    # ...</span><br><span class="line">    # The annotation contains the updated image to nginx <span class="number">1.11</span><span class="number">.9</span>,</span><br><span class="line">    # but does not contain the updated replicas to <span class="number">2</span></span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;<span class="string">"apiVersion"</span>:<span class="string">"apps/v1"</span>,<span class="string">"kind"</span>:<span class="string">"Deployment"</span>,</span><br><span class="line">      <span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"nginx-deployment"</span>,<span class="string">"namespace"</span>:<span class="string">"default"</span>&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"selector"</span>:&#123;<span class="string">"matchLabels"</span>:&#123;<span class="string">"app"</span>:nginx&#125;&#125;,<span class="string">"template"</span>:&#123;<span class="string">"metadata"</span>:&#123;<span class="string">"labels"</span>:&#123;<span class="string">"app"</span>:<span class="string">"nginx"</span>&#125;&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"containers"</span>:[&#123;<span class="string">"image"</span>:<span class="string">"nginx:1.11.9"</span>,<span class="string">"name"</span>:<span class="string">"nginx"</span>,</span><br><span class="line">      <span class="string">"ports"</span>:[&#123;<span class="string">"containerPort"</span>:<span class="number">80</span>&#125;]&#125;]&#125;&#125;&#125;&#125;</span><br><span class="line">    # ...</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      # ...</span><br><span class="line">      app: nginx</span><br><span class="line">  replicas: <span class="number">2</span> # Set by `kubectl scale`.  Ignored by `kubectl apply`.</span><br><span class="line">  # minReadySeconds cleared by `kubectl apply`</span><br><span class="line">  # ...</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      # ...</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx:<span class="number">1.11</span><span class="number">.9</span> # Set by `kubectl apply`</span><br><span class="line">        # ...</span><br><span class="line">        name: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">        # ...</span><br><span class="line">      # ...</span><br><span class="line">    # ...</span><br><span class="line">  # ...</span><br></pre></td></tr></table></figure></p>
<h6 id="如何合并不同类型的字段"><a href="#如何合并不同类型的字段" class="headerlink" title="如何合并不同类型的字段"></a>如何合并不同类型的字段</h6><p>配置文件中的特定字段如何与实时配置合并取决于字段的类型。有几种类型的字段：</p>
<ul>
<li>primitive：字符串，整数或布尔类型的字段。例如，<code>image</code>和<code>replicas</code>是原始字段。行动：替换。</li>
<li>map，也称为object：类型为map的字段或包含子字段的复杂类型。例如<code>labels</code>， <code>annotations</code>，<code>spec</code>并且<code>metadata</code>是所有map。<strong>Action</strong>：合并元素或子字段。</li>
<li>list：包含可以是基本类型或映射的项列表的字段。例如<code>containers</code>，<code>ports</code>和<code>args</code>是列表。行动：变化。</li>
</ul>
<p>当<code>kubectl apply</code>更新map或列表字段，它通常不更换整个领域，而是更新各个子元素。例如，在合并<code>spec</code>部署时，<code>spec</code>不会替换整个部署。相反，比较和合并<code>spec</code>诸如的子字段<code>replicas</code>。</p>
<h6 id="将更改合并到基本字段"><a href="#将更改合并到基本字段" class="headerlink" title="将更改合并到基本字段"></a>将更改合并到基本字段</h6><p>将更改合并到基本字段</p>
<blockquote>
<p>注意： -用于“不适用”，因为未使用该值。</p>
</blockquote>
<table>
<thead>
<tr>
<th>对象配置文件中的字段</th>
<th>实时对象配置中的字段</th>
<th>最后应用配置中的字段</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td>是</td>
<td>是</td>
<td>-</td>
<td>设置为配置文件值。</td>
</tr>
<tr>
<td>是</td>
<td>没有</td>
<td>-</td>
<td>将实时设置为本地配置。</td>
</tr>
<tr>
<td>没有</td>
<td>-</td>
<td>-</td>
<td>从实时配置中清除。</td>
</tr>
<tr>
<td>没有</td>
<td>-</td>
<td>没有</td>
<td>没做什么。保持实时价值。</td>
</tr>
</tbody>
</table>
<h6 id="合并对地图字段的更改"><a href="#合并对地图字段的更改" class="headerlink" title="合并对地图字段的更改"></a>合并对地图字段的更改</h6><p>通过比较地图的每个子字段或元素来合并表示地图的字段：</p>
<blockquote>
<p>注意： -用于“不适用”，因为未使用该值。</p>
</blockquote>
<table>
<thead>
<tr>
<th>键入对象配置文件</th>
<th>键入实时对象配置</th>
<th>最后应用配置中的字段</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td>是</td>
<td>是</td>
<td>-</td>
<td>比较子字段值。</td>
</tr>
<tr>
<td>是</td>
<td>没有</td>
<td>-</td>
<td>将实时设置为本地配置。</td>
</tr>
<tr>
<td>没有</td>
<td>-</td>
<td>是</td>
<td>从实时配置中删除。</td>
</tr>
<tr>
<td>没有</td>
<td>-</td>
<td>没有</td>
<td>没做什么。保持实时价值。</td>
</tr>
</tbody>
</table>
<h6 id="合并类型列表字段的更改"><a href="#合并类型列表字段的更改" class="headerlink" title="合并类型列表字段的更改"></a>合并类型列表字段的更改</h6><p>将更改合并到列表使用以下三种策略之一：</p>
<ul>
<li>替换列表。</li>
<li>合并复杂元素列表中的各个元素。</li>
<li>合并原始元素列表。</li>
</ul>
<p>战略的选择是基于每个领域。</p>
<h5 id="替换列表"><a href="#替换列表" class="headerlink" title="替换列表"></a>替换列表</h5><p>将列表视为与原始字段相同。替换或删除整个列表。这保留了订购。</p>
<p><strong>例如</strong>：使用<code>kubectl apply</code>更新<code>args</code>一个pod里的一个Container的field。这会将<code>args</code>实时配置中的值设置为配置文件中的值。<code>args</code>之前已添加到实时配置的任何元素都将丢失。<code>args</code>配置文件中定义的元素的顺序将保留在实时配置中。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># last-applied-configuration value</span></span><br><span class="line"><span class="symbol">    args:</span> [<span class="string">"a"</span>, <span class="string">"b"</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta"># configuration file value</span></span><br><span class="line"><span class="symbol">    args:</span> [<span class="string">"a"</span>, <span class="string">"c"</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta"># live configuration</span></span><br><span class="line"><span class="symbol">    args:</span> [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta"># result after merge</span></span><br><span class="line"><span class="symbol">    args:</span> [<span class="string">"a"</span>, <span class="string">"c"</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>说明</strong>：合并使用配置文件值作为新列表值。</p>
<h5 id="合并复杂元素列表中的各个元素："><a href="#合并复杂元素列表中的各个元素：" class="headerlink" title="合并复杂元素列表中的各个元素："></a>合并复杂元素列表中的各个元素：</h5><p>将列表视为映射，并将每个元素的特定字段视为键。添加，删除或更新单个元素。这不会保留排序。</p>
<p>此合并策略在每个字段上使用一个名为a的特殊标记<code>patchMergeKey</code>。<code>patchMergeKey</code>是在Kubernetes源代码中的每个字段中定义： <a href="https://github.com/kubernetes/api/blob/d04500c8c3dda9c980b668c57abc2ca61efcf5c4/core/v1/types.go#L2747" target="_blank" rel="noopener">types.go</a> 当合并映射的列表，指定的字段作为<code>patchMergeKey</code>对于给定的元素被用于像该元素的映射键。</p>
<p><strong>例如</strong>：使用<code>kubectl apply</code>更新<code>containers一PodSpec</code>的field。这将列表合并为好像是每个元素都被键入的映射<code>name</code>。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># last-applied-configuration value</span></span><br><span class="line"><span class="attr">    containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">nginx:1.10</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-a</span> <span class="comment"># key: nginx-helper-a; will be deleted in result</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-b</span> <span class="comment"># key: nginx-helper-b; will be retained</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># configuration file value</span></span><br><span class="line"><span class="attr">    containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">nginx:1.10</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-b</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-c</span> <span class="comment"># key: nginx-helper-c; will be added in result</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># live configuration</span></span><br><span class="line"><span class="attr">    containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">nginx:1.10</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-a</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-b</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"><span class="attr">      args:</span> <span class="string">["run"]</span> <span class="comment"># Field will be retained</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-d</span> <span class="comment"># key: nginx-helper-d; will be retained</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># result after merge</span></span><br><span class="line"><span class="attr">    containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">nginx:1.10</span></span><br><span class="line">      <span class="comment"># Element nginx-helper-a was deleted</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-b</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"><span class="attr">      args:</span> <span class="string">["run"]</span> <span class="comment"># Field was retained</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-c</span> <span class="comment"># Element was added</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-d</span> <span class="comment"># Element was ignored</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ul>
<li>名为“nginx-helper-a”的容器已删除，因为配置文件中没有出现名为“nginx-helper-a”的容器。</li>
<li>名为“nginx-helper-b”的容器保留<code>args</code> 了实时配置中的更改。<code>kubectl apply</code>能够识别实时配置中的“nginx-helper-b”与配置文件中的“nginx-helper-b”相同，即使它们的字段具有不同的值（<code>args</code>配置文件中没有）。这是因为<code>patchMergeKey</code>字段值（名称）在两者中都是相同的。</li>
<li>添加了名为“nginx-helper-c”的容器，因为实时配置中没有出现具有该名称的容器，但配置文件中出现了具有该名称的容器。</li>
<li>保留名为“nginx-helper-d”的容器，因为在最后应用的配置中没有出现具有该名称的元素。</li>
</ul>
<h5 id="合并原始元素列表"><a href="#合并原始元素列表" class="headerlink" title="合并原始元素列表"></a>合并原始元素列表</h5><p>从Kubernetes 1.5开始，不支持合并原始元素列表。</p>
<blockquote>
<p>注意：为给定字段选择的上述策略中的哪一个由<a href="https://github.com/kubernetes/api/blob/d04500c8c3dda9c980b668c57abc2ca61efcf5c4/core/v1/types.go#L2748" target="_blank" rel="noopener">types.go</a>中的<code>patchStrategy</code>标记控制。如果没有为类型列表的字段指<code>定patchStrategy</code>，则替换列表。</p>
</blockquote>
<h5 id="默认字段值"><a href="#默认字段值" class="headerlink" title="默认字段值"></a>默认字段值</h5><p>如果在创建对象时未指定某些字段，则API服务器会将某些字段设置为实时配置中的默认值。</p>
<p>这是部署的配置文件。该文件未指定<code>strategy</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application/simple_deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>kubectl apply</code>以下方法创建对象<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https:<span class="regexp">//</span>k8s.io<span class="regexp">/examples/</span>application<span class="regexp">/simple_deployment.yaml</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>kubectl get</code>以下方式打印实时配置<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> -f https:<span class="comment">//k8s.io/examples/application/simple_deployment.yaml -o yaml</span></span><br></pre></td></tr></table></figure></p>
<p>输出显示API服务器在实时配置中将多个字段设置为默认值。配置文件中未指定这些字段。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    rollingUpdate:</span> <span class="comment"># defaulted by apiserver - derived from strategy.type</span></span><br><span class="line"><span class="attr">      maxSurge:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      maxUnavailable:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">RollingUpdate</span> <span class="comment"># defaulted apiserver</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">        resources:</span> <span class="string">&#123;&#125;</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">        terminationMessagePath:</span> <span class="string">/dev/termination-log</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">      dnsPolicy:</span> <span class="string">ClusterFirst</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">Always</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">      securityContext:</span> <span class="string">&#123;&#125;</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">      terminationGracePeriodSeconds:</span> <span class="number">30</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p>
<p>在修补程序请求中，默认字段不会被重新默认，除非它们作为修补程序请求的一部分被明确清除。这可能会导致基于其他字段的值默认的字段出现意外行为。稍后更改其他字段时，除非明确清除，否则不会更新默认值。</p>
<p>因此，建议在配置文件中显式定义服务器默认的某些字段，即使所需的值与服务器默认值匹配也是如此。这样可以更轻松地识别不会被服务器重新默认的冲突值。</p>
<p>例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># last-applied-configuration</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># configuration file</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Recreate</span> <span class="comment"># updated value</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># live configuration</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">RollingUpdate</span> <span class="comment"># defaulted value</span></span><br><span class="line"><span class="attr">    rollingUpdate:</span> <span class="comment"># defaulted value derived from type</span></span><br><span class="line">      <span class="string">maxSurge</span> <span class="string">:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      maxUnavailable:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># result after merge - ERROR!</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Recreate</span> <span class="comment"># updated value: incompatible with rollingUpdate</span></span><br><span class="line"><span class="attr">    rollingUpdate:</span> <span class="comment"># defaulted value: incompatible with "type: Recreate"</span></span><br><span class="line">      <span class="string">maxSurge</span> <span class="string">:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      maxUnavailable:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ol>
<li>用户无需定义即可创建部署<code>strategy.type</code>。</li>
<li>服务器默认<code>strategy.type</code>为<code>RollingUpdate</code>默认 <code>strategy.rollingUpdate</code>值。</li>
<li>用户更改<code>strategy.type</code>为<code>Recreate</code>。该<code>strategy.rollingUpdate</code>值保持在其默认的值，但服务器期望他们被清除。如果<code>strategy.rollingUpdate</code>最初在配置文件中定义了值，则更清楚的是它们需要被删除。</li>
<li>应用失败，因为<code>strategy.rollingUpdate</code>未清除。该<code>strategy.rollingupdate</code> 字段不能与被定义<code>strategy.type的Recreate</code>。</li>
</ol>
<p>建议：应在对象配置文件中明确定义这些字段：</p>
<ul>
<li>工作负载上的选择器和PodTemplate标签，例如Deployment，StatefulSet，Job，DaemonSet，ReplicaSet和ReplicationController</li>
<li>部署部署策略</li>
</ul>
<h6 id="如何清除其他编写者设置的服务器默认字段或字段"><a href="#如何清除其他编写者设置的服务器默认字段或字段" class="headerlink" title="如何清除其他编写者设置的服务器默认字段或字段"></a>如何清除其他编写者设置的服务器默认字段或字段</h6><p>可以通过将其值设置为<code>null</code>然后应用配置文件来清除未出现在配置文件中的字段。对于服务器默认的字段，这会触发重新默认值。</p>
<h5 id="如何更改配置文件和直接命令式编写器之间字段的所有权"><a href="#如何更改配置文件和直接命令式编写器之间字段的所有权" class="headerlink" title="如何更改配置文件和直接命令式编写器之间字段的所有权"></a>如何更改配置文件和直接命令式编写器之间字段的所有权</h5><p>这些是您应该用来更改单个对象字段的唯一方法：</p>
<ul>
<li>使用<code>kubectl apply</code>。</li>
<li>直接写入实时配置而不修改配置文件：例如，使用<code>kubectl scale</code>。</li>
</ul>
<h6 id="将所有者从直接命令式编写器更改为配置文件"><a href="#将所有者从直接命令式编写器更改为配置文件" class="headerlink" title="将所有者从直接命令式编写器更改为配置文件"></a>将所有者从直接命令式编写器更改为配置文件</h6><p>将该字段添加到配置文件中。对于现场，停止对未经过的实时配置的直接更新<code>kubectl apply</code>。</p>
<h6 id="将所有者从配置文件更改为直接命令式编写器"><a href="#将所有者从配置文件更改为直接命令式编写器" class="headerlink" title="将所有者从配置文件更改为直接命令式编写器"></a>将所有者从配置文件更改为直接命令式编写器</h6><p>从Kubernetes 1.5开始，将字段的所有权从配置文件更改为命令式编写器需要手动步骤：</p>
<ul>
<li>从配置文件中删除该字段。</li>
<li>从<code>kubectl.kubernetes.io/last-applied-configuration</code>活动对象上的注释中删除该字段。</li>
</ul>
<h5 id="改变管理方法"><a href="#改变管理方法" class="headerlink" title="改变管理方法"></a>改变管理方法</h5><p>应该一次只使用一种方法管理Kubernetes对象。可以从一种方法切换到另一种方法，但这是一种手动过程。</p>
<blockquote>
<p>注意：使用命令式删除和声明式管理是可以的。</p>
</blockquote>
<h6 id="从命令式命令管理迁移到声明性对象配置"><a href="#从命令式命令管理迁移到声明性对象配置" class="headerlink" title="从命令式命令管理迁移到声明性对象配置"></a>从命令式命令管理迁移到声明性对象配置</h6><p>从命令式命令管理迁移到声明性对象配置涉及几个手动步骤：</p>
<ol>
<li><p>将活动对象导出到本地配置文件：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">get</span> <span class="symbol">&lt;kind&gt;</span>/<span class="symbol">&lt;name&gt;</span> -<span class="keyword">o</span> yaml --export &gt; <span class="symbol">&lt;kind&gt;</span>_<span class="symbol">&lt;name&gt;</span>.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>status</code>从配置文件中手动删除该字段。</p>
</li>
</ol>
<blockquote>
<p>注意：此步骤是可选的，因为<code>kubectl apply</code>不会更新状态字段 即使它存在于配置文件中。</p>
</blockquote>
<ol start="3">
<li><p><code>kubectl.kubernetes.io/last-applied-configuration</code>在对象上设置注释：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl replace --<span class="keyword">save</span>-config -f &lt;<span class="keyword">kind</span>&gt;_&lt;<span class="keyword">name</span>&gt;.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改<code>kubectl apply</code>用于专门管理对象的进程。</p>
</li>
</ol>
<h6 id="从命令式对象配置迁移到声明性对象配置"><a href="#从命令式对象配置迁移到声明性对象配置" class="headerlink" title="从命令式对象配置迁移到声明性对象配置"></a>从命令式对象配置迁移到声明性对象配置</h6><ol>
<li><p><code>kubectl.kubernetes.io/last-applied-configuration</code>在对象上设置注释：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl replace --<span class="keyword">save</span>-config -f &lt;<span class="keyword">kind</span>&gt;_&lt;<span class="keyword">name</span>&gt;.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改<code>kubectl apply</code>用于专门管理对象的进程。</p>
</li>
</ol>
<h5 id="定义控制器选择器和PodTemplate标签-1"><a href="#定义控制器选择器和PodTemplate标签-1" class="headerlink" title="定义控制器选择器和PodTemplate标签"></a>定义控制器选择器和PodTemplate标签</h5><blockquote>
<p>警告：强烈建议不要更新控制器上的选择器。</p>
</blockquote>
<p>推荐的方法是定义一个仅由控制器选择器使用的单个不可变PodTemplate标签，没有其他语义含义。</p>
<p>例：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">selector</span>:</span><br><span class="line">  <span class="attribute">matchLabels</span>:</span><br><span class="line">      <span class="attribute">controller-selector</span>: <span class="string">"extensions/v1beta1/deployment/nginx"</span></span><br><span class="line"><span class="attribute">template</span>:</span><br><span class="line">  <span class="attribute">metadata</span>:</span><br><span class="line">    <span class="attribute">labels</span>:</span><br><span class="line">      <span class="attribute">controller-selector</span>: <span class="string">"extensions/v1beta1/deployment/nginx"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Kubernetes-Architecture"><a href="#Kubernetes-Architecture" class="headerlink" title="Kubernetes Architecture"></a>Kubernetes Architecture</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>节点是Kubernetes中的工作机器，以前称为一个 <code>minion</code>。节点可以是VM或物理机，具体取决于集群。每个节点都包含运行<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="noopener">pods</a>所需的服务，并由主组件管理。节点上的服务包括<a href="https://kubernetes.io/docs/concepts/overview/components/#node-components" target="_blank" rel="noopener">container runtime</a>，kubelet和kube-proxy。有关更多详细信息，请参阅 体系结构设计文档中的<a href="https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node" target="_blank" rel="noopener">Kubernetes节点部分</a>。</p>
<ul>
<li>节点状态</li>
<li>管理</li>
<li>API对象</li>
</ul>
<h4 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h4><p>节点的状态包含以下信息：</p>
<ul>
<li>地址</li>
<li>条件</li>
<li>容量</li>
<li>信息</li>
</ul>
<p>下面详细描述每个部分。</p>
<h5 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h5><p>这些字段的使用取决于您的云提供商或裸机配置。</p>
<ul>
<li>HostName：节点内核报告的主机名。可以通过kubelet<code>--hostname-override</code>参数覆盖。</li>
<li>ExternalIP：通常是可从外部路由的节点的IP地址（可从群集外部获得）。</li>
<li>InternalIP：通常仅在群集内可路由的节点的IP地址。</li>
</ul>
<h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><p>该<code>conditions</code>字段描述了所有<code>Running</code>节点的状态。</p>
<table>
<thead>
<tr>
<th>节点条件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OutOfDisk</code></td>
<td><code>True</code> 如果节点上的可用空间不足以添加新的pod，否则 <code>False</code></td>
</tr>
<tr>
<td><code>Ready</code></td>
<td><code>True</code>如果节点是健康的并准备好接受pod，<code>False</code>如果节点不健康且不接受pod，并且<code>Unknown</code>节点控制器在最后一次没有从节点听到<code>node-monitor-grace-period</code>（默认为40秒）</td>
</tr>
<tr>
<td><code>MemoryPressure</code></td>
<td><code>True</code>如果节点存储器上存在压力 - 即节点存储器是否为低; 除此以外<code>False</code></td>
</tr>
<tr>
<td><code>PIDPressure</code></td>
<td><code>True</code>如果进程存在压力 - 也就是说，如果节点上有太多进程; 除此以外<code>False</code></td>
</tr>
<tr>
<td><code>DiskPressure</code></td>
<td><code>True</code>如果磁盘大小存在压力 - 即磁盘容量低; 除此以外<code>False</code></td>
</tr>
<tr>
<td><code>NetworkUnavailable</code></td>
<td><code>True</code> 如果没有正确配置节点的网络，否则 <code>False</code></td>
</tr>
</tbody>
</table>
<p>节点条件表示为JSON对象。例如，以下响应描述了健康节点。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"conditions"</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"Ready"</span>,</span><br><span class="line">    <span class="string">"status"</span>: <span class="string">"True"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>如果就绪状态的状态保持<code>Unknown</code>或<code>False</code>超过<code>pod-eviction-timeout</code>，则会将参数传递给<a href="https://kubernetes.io/docs/admin/kube-controller-manager/" target="_blank" rel="noopener">kube-controller-manager</a>，并且节点控制器会调度节点上的所有Pod以进行删除。默认逐出超时持续时间为<strong>五分钟</strong>。在某些情况下，当节点无法访问时，apiserver无法与节点上的kubelet通信。在重新建立与apiserver的通信之前，不能将删除pod的决定传送到kubelet。同时，计划删除的pod可以继续在分区节点上运行。</p>
<p>在1.5之前的Kubernetes版本中，节点控制器会从apiserver中<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/#force-deletion-of-pods" target="_blank" rel="noopener">强制删除</a>这些无法访问的pod。但是，在1.5及更高版本中，节点控制器不会强制删除容器，直到确认它们已停止在群集中运行。您可以看到可能在无法访问的节点上运行的Pod处于<code>Terminating</code>或<code>Unknown</code>状态。如果节点永久离开群集，如果Kubernetes无法从底层基础架构推断出，则群集管理员可能需要手动删除节点对象。从Kubernetes中删除节点对象会导致节点上运行的所有Pod对象从apiserver中删除，并释放它们的名称。</p>
<p>在版本1.12中，<code>TaintNodesByCondition</code>功能被提升为beta版，因此节点生命周期控制器会自动创建表示条件的<a href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/" target="_blank" rel="noopener"> taints</a> 。类似地，调度程序在考虑节点时忽略条件;相反，它会查看Node的污点和Pod的容忍度。 现在，用户可以在旧的调度模型和更灵活的新调度模型之间进行选择。根据旧型号，可以安排没有任何容忍度的Pod。但是可以在该节点上安排容忍特定节点的污点的Pod。</p>
<blockquote>
<p>警告：启用此功能会在观察到条件和创建污点之间产生一个小延迟。此延迟通常小于一秒，但它可以增加成功安排但被kubelet拒绝的Pod的数量。</p>
</blockquote>
<h5 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h5><p>描述节点上可用的资源：CPU，内存以及可以在节点上调度的最大pod数。</p>
<h5 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h5><p>有关节点的一般信息，例如内核版本，Kubernetes版本（kubelet和kube-proxy版本），Docker版本（如果使用），操作系统名称。信息由Kubelet从节点收集。</p>
<h4 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h4><p>与<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="noopener">pod</a>和<a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">服务</a>不同，Kubernetes本身并不创建节点：它由Google Compute Engine等云提供商在外部创建，或者存在于物理或虚拟机池中。因此，当Kubernetes创建节点时，它会创建一个表示节点的对象。创建后，Kubernetes会检查节点是否有效。例如，如果您尝试从以下内容创建节点：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"kind"</span>: <span class="string">"Node"</span>,</span><br><span class="line">  <span class="attr">"apiVersion"</span>: <span class="string">"v1"</span>,</span><br><span class="line">  <span class="attr">"metadata"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"10.240.79.157"</span>,</span><br><span class="line">    <span class="attr">"labels"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"my-first-k8s-node"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Kubernetes在内部创建节点对象（表示），并通过基于<code>metadata.name</code>字段的运行状况检查来验证节点。如果节点有效 - 即，如果所有必需的服务都在运行 - 它有资格运行pod。否则，对于任何群集活动，它将被忽略，直到它变为有效。</p>
<blockquote>
<p>注意： Kubernetes保留无效节点的对象，并不断检查它是否有效。您必须显式删除Node对象才能停止此过程。</p>
</blockquote>
<p>目前，有三个组件与Kubernetes节点接口交互：节点控制器，kubelet和kubectl。</p>
<h5 id="节点控制器"><a href="#节点控制器" class="headerlink" title="节点控制器"></a>节点控制器</h5><p>节点控制器是Kubernetes主组件，它管理节点的各个方面。</p>
<p>节点控制器在节点的生命周期中具有多个角色。第一种是在注册时为节点分配CIDR块（如果打开了CIDR分配）。</p>
<p>第二个是使节点控制器的内部节点列表与云提供商的可用计算机列表保持同步。在云环境中运行时，只要节点不健康，节点控制器就会询问云提供商该节点的VM是否仍然可用。如果不是，则节点控制器从其节点列表中删除该节点。</p>
<p>第三是监测节点的健康状况。节点控制器负责在节点变得无法访问时将NodeStatus的NodeReady条件更新为ConditionUnknown（即节点控制器由于某种原因停止接收心跳，例如由于节点关闭），然后从节点中驱逐所有pod （如果节点仍然无法访问，则使用正常终止）。（默认超时为40 <code>--node-monitor-period</code>秒，开始报告ConditionUnknown，之后5米开始驱逐pod。）节点控制器每秒检查每个节点的状态。</p>
<p>在1.13之前的Kubernetes版本中，NodeStatus是节点的心跳。从Kubernetes 1.13开始，节点租用功能作为alpha功能引入（功能门<code>NodeLease</code>， <a href="https://github.com/kubernetes/community/blob/master/keps/sig-node/0009-node-heartbeat.md" target="_blank" rel="noopener">KEP-0009</a>）。启用节点租用功能时，每个节点都有一个关联的<code>Lease</code>对象 <code>kube-node-lease</code>由节点定期更新的命名空间，NodeStatus和节点租约都被视为来自节点的心跳。节点租约经常更新，而NodeStatus仅在有一些更改或经过足够时间时从节点报告为主节点（默认值为1分钟，这比不可达节点的默认超时40秒）。由于节点租约比NodeStatus轻得多，因此从可伸缩性和性能角度来看，此功能使节点心跳显着降低。</p>
<p>在Kubernetes 1.4中，我们更新了节点控制器的逻辑，以便在大量节点到达主站时遇到问题时更好地处理案例（例如，因为主站有网络问题）。从1.4开始，节点控制器在决定pod驱逐时查看集群中所有节点的状态。</p>
<p>在大多数情况下，节点控制器将驱逐率限制为每秒 <code>--node-eviction-rate</code>（默认值0.1），这意味着它不会每10秒从多个节点驱逐pod。</p>
<p>当给定可用区中的节点变得不健康时，节点逐出行为会发生变化。节点控制器同时检查区域中节点的百分比是否不健康（NodeReady条件是ConditionUnknown或ConditionFalse）。如果不健康节点的比例至少为 <code>--unhealthy-zone-threshold</code>（默认为0.55），则驱逐率降低：如果群集较小（即小于或等于<code>--large-cluster-size-threshold</code>节点 - 默认为50）则停止驱逐，否则驱逐率降低为 <code>--secondary-node-eviction-rate</code>（默认0.01）每秒。每个可用区域实施这些策略的原因是因为一个可用区域可能从主服务器分区而其他可用区域保持连接。如果您的群集未跨越多个云提供商可用区域，则只有一个可用区域（整个群集）。</p>
<p>在可用区域之间传播节点的一个关键原因是，当整个区域出现故障时，工作负载可以转移到健康区域。因此，如果区域中的所有节点都不健康，则节点控制器以正常速率驱逐<code>--node-eviction-rate</code>。角落情况是所有区域完全不健康（即群集中没有健康的节点）。在这种情况下，节点控制器假定主连接存在一些问题，并在某些连接恢复之前停止所有驱逐。</p>
<p>从Kubernetes 1.6开始，NodeController还负责驱逐在具有<code>NoExecute</code>污点的节点上运行的pod，当pod不能容忍taints时。此外，作为默认禁用的alpha功能，NodeController负责添加与节点无法访问或未就绪等节点问题相对应的污点。 有关污点和alpha功能的详细信息，请参阅<a href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/" target="_blank" rel="noopener">此文档</a><code>NoExecute</code>。</p>
<p>从版本1.8开始，节点控制器可以负责创建表示节点条件的污点。这是1.8版的alpha功能。</p>
<h5 id="节点自注册"><a href="#节点自注册" class="headerlink" title="节点自注册"></a>节点自注册</h5><p>当kubelet标志<code>--register-node</code>为true（默认值）时，kubelet将尝试向API服务器注册自己。这是大多数发行版使用的首选模式。</p>
<p>对于自行注册，可以使用以下选项启动kubelet：</p>
<ul>
<li><code>--kubeconfig</code> - 凭证路径，以向apiserver验证自身。</li>
<li><code>--cloud-provider</code> - 如何与云提供商交谈以阅读有关自身的元数据。</li>
<li><code>--register-node</code> - 自动注册API服务器。</li>
<li><code>--register-with-taints</code>- 使用给定的taints列表注册节点（以逗号分隔<code>&lt;key&gt;=&lt;value&gt;:&lt;effect&gt;</code>）。No-op如果<code>register-node</code>是假的。</li>
<li><code>--node-ip</code> - 节点的IP地址。</li>
<li><code>--node-labels</code>- 在群集中注册节点时添加的标签（请参阅<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction" target="_blank" rel="noopener">1.13+中NodeRestriction准入插件</a>强制执行的标签限制）。</li>
<li><code>--node-status-update-frequency</code> - 指定kubelet将节点状态发布到master的频率。</li>
</ul>
<p>当<a href="https://kubernetes.io/docs/reference/access-authn-authz/node/" target="_blank" rel="noopener">节点授权模式</a>和 <a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction/" target="_blank" rel="noopener">NodeRestriction</a>录取插件的启用，kubelets仅被授权创建/修改自己的节点资源。</p>
<h4 id="手动节点管理"><a href="#手动节点管理" class="headerlink" title="手动节点管理"></a>手动节点管理</h4><p>集群管理员可以创建和修改节点对象。</p>
<p>如果管理员希望手动创建节点对象，请设置kubelet标志 <code>--register-node=false</code>。</p>
<p>管理员可以修改节点资源（无论设置如何<code>--register-node</code>）。修改包括在节点上设置标签并将其标记为不可调度。</p>
<p>节点上的标签可以与pod上的节点选择器结合使用以控制调度，例如，将pod限制为仅有资格在节点的子集上运行。</p>
<p>将节点标记为不可调度可防止将新pod调度到该节点，但不会影响节点上的任何现有pod。这在节点重启等之前作为准备步骤很有用。例如，要标记节点不可调度，请运行以下命令：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">kubectl</span> cordon <span class="variable">$NODENAME</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：由DaemonSet控制器创建的Pod绕过Kubernetes调度程序，不遵守节点上的不可调度属性。这假设守护进程属于机器，即使它在准备重新启动时正在耗尽应用程序。</p>
</blockquote>
<h5 id="节点容量"><a href="#节点容量" class="headerlink" title="节点容量"></a>节点容量</h5><p>节点的容量（cpus的数量和内存量）是节点对象的一部分。通常，节点在创建节点对象时注册自己并报告其容量。如果您正在进行<a href="https://kubernetes.io/docs/concepts/architecture/nodes/#manual-node-administration" target="_blank" rel="noopener">手动节点管理</a>，则需要在添加节点时设置节点容量。</p>
<p>Kubernetes调度程序确保节点上的所有pod都有足够的资源。它检查节点上容器请求的总和不大于节点容量。它包括由kubelet启动的所有容器，但不包括由<a href="https://kubernetes.io/docs/concepts/overview/components/#node-components" target="_blank" rel="noopener">容器运行时</a>直接启动的<a href="https://kubernetes.io/docs/concepts/overview/components/#node-components" target="_blank" rel="noopener">容器</a>，也不包括在容器外部运行的任何进程。</p>
<p>如果要为非Pod进程显式保留资源，请按照<a href="https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved" target="_blank" rel="noopener">本教程</a> 为系统守护程序保留资源。</p>
<h4 id="API对象"><a href="#API对象" class="headerlink" title="API对象"></a>API对象</h4><p>Node是Kubernetes REST API中的顶级资源。有关API对象的更多详细信息，请参见： <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#node-v1-core" target="_blank" rel="noopener">Node API对象</a>。</p>
<h3 id="主节点通信"><a href="#主节点通信" class="headerlink" title="主节点通信"></a>主节点通信</h3><p>本文档对master（实际上是apiserver）和Kubernetes集群之间的通信路径进行了编目。目的是允许用户自定义其安装以强化网络配置，以便群集可以在不受信任的网络（或云提供商上的完全公共IP）上运行。</p>
<ul>
<li>群集到Master</li>
<li>掌握群集</li>
</ul>
<h4 id="群集到Master"><a href="#群集到Master" class="headerlink" title="群集到Master"></a>群集到Master</h4><p>从集群到主服务器的所有通信路径都在apiserver处终止（其他主服务器组件均未设计为公开远程服务）。在典型部署中，apiserver被配置为在安全HTTPS端口（443）上侦听远程连接，其中启用了一种或多种形式的客户端<a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/" target="_blank" rel="noopener">认证</a>。 应启用一种或多种<a href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/" target="_blank" rel="noopener">授权</a>形式，尤其是 在允许<a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#anonymous-requests" target="_blank" rel="noopener">匿名请求</a> 或<a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#service-account-tokens" target="_blank" rel="noopener">服务帐户令牌</a>的情况下。</p>
<p>应为节点配置群集的公共根证书，以便它们可以安全地连接到apiserver以及有效的客户端凭据。例如，在默认GKE部署中，提供给kubelet的客户端凭证采用客户端证书的形式。请参阅 <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/" target="_blank" rel="noopener">kubelet TLS bootstrapping</a> 以自动配置kubelet客户端证书。</p>
<p>希望连接到apiserver的Pod可以通过利用服务帐户安全地执行此操作，以便Kubernetes在实例化时自动将公共根证书和有效的承载令牌注入到pod中。该<code>kubernetes</code>服务（在所有名称空间中）配置有虚拟IP地址，该地址被重定向（通过kube-proxy）到apiserver上的HTTPS端点。</p>
<p>主组件还通过安全端口与群集服务器通信。</p>
<p>因此，默认情况下，从群集（节点和节点上运行的节点）到主节点的连接的默认操作模式是安全的，可以在不受信任和/或公共网络上运行。</p>
<h4 id="掌握群集"><a href="#掌握群集" class="headerlink" title="掌握群集"></a>掌握群集</h4><p>从主服务器（apiserver）到集群有两条主要通信路径。第一个是从apiserver到kubelet进程，它在集群中的每个节点上运行。第二种是通过apiserver的代理功能从apiserver到任何节点，pod或服务。</p>
<h5 id="kubelet的保护者"><a href="#kubelet的保护者" class="headerlink" title="kubelet的保护者"></a>kubelet的保护者</h5><p>从apiserver到kubelet的连接用于：</p>
<ul>
<li>获取pod的日志。</li>
<li>附加（通过kubectl）到运行的pod。</li>
<li>提供kubelet的端口转发功能。</li>
</ul>
<p>这些连接终止于kubelet的HTTPS端点。默认情况下，apiserver不会验证kubelet的服务证书，这会使连接受到中间人攻击，并且 <strong>不安全</strong>地运行在不受信任的和/或公共网络上。</p>
<p>要验证此连接，请使用该<code>--kubelet-certificate-authority</code>标志为apiserver提供根证书包，以用于验证kubelet的服务证书。</p>
<p>如果无法做到这一点，请 在apiserver和kubelet之间使用<a href="https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/" target="_blank" rel="noopener">SSH隧道</a>，以避免连接不受信任或公共网络。</p>
<p>最后， 应启用<a href="https://kubernetes.io/docs/admin/kubelet-authentication-authorization/" target="_blank" rel="noopener">Kubelet身份验证和/或授权</a>以保护kubelet API。</p>
<h5 id="节点，pod和服务的apiserver"><a href="#节点，pod和服务的apiserver" class="headerlink" title="节点，pod和服务的apiserver"></a>节点，pod和服务的apiserver</h5><p>从apiserver到节点，pod或服务的连接默认为纯HTTP连接，因此既未经过身份验证也未加密。它们可以通过前缀https:到API URL中的节点，pod或服务名称在安全HTTPS连接上运行，但它们不会验证HTTPS端点提供的证书，也不会提供客户端凭据，因此在连接将被加密时，它不会提供任何诚信保证。这些连接<strong>目前</strong>在不受信任和/或公共网络上运行<strong>是不安全的</strong>。</p>
<h3 id="云控制器管理器的基础概念"><a href="#云控制器管理器的基础概念" class="headerlink" title="云控制器管理器的基础概念"></a>云控制器管理器的基础概念</h3><p>最初创建云控制器管理器（CCM）概念（不要与二进制混淆），以允许特定于云的供应商代码和Kubernetes核心彼此独立地发展。云控制器管理器与其他主组件（如Kubernetes控制器管理器，API服务器和调度程序）一起运行。它也可以作为Kubernetes插件启动，在这种情况下它运行在Kubernetes之上。</p>
<p>云控制器管理器的设计基于一种插件机制，允许新的云提供商通过使用插件轻松地与Kubernetes集成。有计划在Kubernetes上加入新的云提供商，以及将云提供商从旧模型迁移到新的CCM模型。</p>
<p>本文档讨论了云控制器管理器背后的概念，并提供了有关其相关功能的详细信息。</p>
<p>这是没有云控制器管理器的Kubernetes集群的架构：</p>
<p><img src="https://d33wubrfki0l68.cloudfront.net/e298a92e2454520dddefc3b4df28ad68f9b91c6f/70d52/images/docs/pre-ccm-arch.png" alt="image"></p>
<ul>
<li>设计</li>
<li>CCM的组成部分</li>
<li>CCM的功能</li>
<li>插件机制</li>
<li>授权</li>
<li>供应商实施</li>
<li>群集管理</li>
</ul>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>在上图中，Kubernetes和云提供商通过几个不同的组件集成：</p>
<ul>
<li>Kubelet</li>
<li>Kubernetes控制器经理</li>
<li>Kubernetes API服务器</li>
</ul>
<p>CCM整合了前三个组件中的所有依赖于云的逻辑，以创建与云的单一集成点。CCM的新架构如下所示：<br><img src="https://d33wubrfki0l68.cloudfront.net/518e18713c865fe67a5f23fc64260806d72b38f5/61d75/images/docs/post-ccm-arch.png" alt="image"></p>
<h4 id="CCM的组成部分"><a href="#CCM的组成部分" class="headerlink" title="CCM的组成部分"></a>CCM的组成部分</h4><p>CCM打破了Kubernetes控制器管理器（KCM）的一些功能，并将其作为一个单独的进程运行。具体来说，它打破了KCM中依赖于云的控制器。KCM具有以下依赖于云的控制器循环：</p>
<ul>
<li>节点控制器</li>
<li>音量控制器</li>
<li>路线控制器</li>
<li>服务控制器</li>
</ul>
<p>在1.9版中，CCM运行前面列表中的以下控制器：</p>
<ul>
<li>节点控制器</li>
<li>路线控制器</li>
<li>服务控制器</li>
</ul>
<p>此外，它还运行另一个名为PersistentVolumeLabels控制器的控制器。此控制器负责在GCP和AWS云中创建的PersistentVolumes上设置区域和区域标签。</p>
<blockquote>
<p>注意：故意选择音量控制器不属于CCM。由于涉及复杂性并且由于现有的努力抽象出供应商特定的卷逻辑，因此决定不将卷控制器移动到CCM。</p>
</blockquote>
<p>使用CCM支持卷的最初计划是使用Flex卷来支持可插拔卷。然而，正在计划一项名为CSI的竞争性工作来取代Flex。</p>
<p>考虑到这些动态，我们决定在CSI准备好之前进行中间止差测量。</p>
<h4 id="CCM的功能"><a href="#CCM的功能" class="headerlink" title="CCM的功能"></a>CCM的功能</h4><p>CCM从依赖于云提供商的Kubernetes组件继承其功能。本节基于这些组件构建。</p>
<h5 id="1-Kubernetes控制器经理"><a href="#1-Kubernetes控制器经理" class="headerlink" title="1. Kubernetes控制器经理"></a>1. Kubernetes控制器经理</h5><p>CCM的大部分功能来自KCM。如上一节所述，CCM运行以下控制循环：</p>
<ul>
<li>节点控制器</li>
<li>路线控制器</li>
<li>服务控制器</li>
<li>PersistentVolumeLabels控制器</li>
</ul>
<h6 id="节点控制器-1"><a href="#节点控制器-1" class="headerlink" title="节点控制器"></a>节点控制器</h6><p>节点控制器负责通过从云提供商获取有关在集群中运行的节点的信息来初始化节点。节点控制器执行以下功能：</p>
<ol>
<li>使用特定于云的区域/区域标签初始化节点。</li>
<li>使用特定于云的实例详细信息初始化节点，例如，类型和大小。</li>
<li>获取节点的网络地址和主机名。</li>
<li>如果节点无响应，请检查云以查看该节点是否已从云中删除。如果已从云中删除该节点，请删除Kubernetes Node对象。</li>
</ol>
<h6 id="路线控制器"><a href="#路线控制器" class="headerlink" title="路线控制器"></a>路线控制器</h6><p>Route控制器负责适当地配置云中的路由，以便Kubernetes集群中不同节点上的容器可以相互通信。路径控制器仅适用于Google Compute Engine群集。</p>
<h6 id="服务控制器"><a href="#服务控制器" class="headerlink" title="服务控制器"></a>服务控制器</h6><p>服务控制器负责监听服务创建，更新和删除事件。根据Kubernetes中当前的服务状态，它配置云负载均衡器（如ELB或Google LB）以反映Kubernetes中的服务状态。此外，它还确保云负载平衡器的服务后端是最新的。</p>
<h6 id="PersistentVolumeLabels控制器"><a href="#PersistentVolumeLabels控制器" class="headerlink" title="PersistentVolumeLabels控制器"></a>PersistentVolumeLabels控制器</h6><p>PersistentVolumeLabels控制器在创建AWS EBS / GCE PD卷时应用标签。这消除了用户手动设置这些卷上的标签的需要。</p>
<p>这些标签对于pod的计划至关重要，因为这些卷仅限于在它们所在的区域/区域内工作。使用这些卷的任何Pod都需要在同一区域/区域中进行调度。</p>
<p>PersistentVolumeLabels控制器专门为CCM创建; 也就是说，在创建CCM之前它不存在。这样做是为了将Kubernetes API服务器（它是一个许可控制器）中的PV标记逻辑移动到CCM。它不在KCM上运行。</p>
<h5 id="2-Kubelet"><a href="#2-Kubelet" class="headerlink" title="2. Kubelet"></a>2. Kubelet</h5><p>节点控制器包含kubelet的依赖于云的功能。在引入CCM之前，kubelet负责使用特定于云的详细信息（如IP地址，区域/区域标签和实例类型信息）初始化节点。CCM的引入已将此初始化操作从kubelet转移到CCM。</p>
<p>在这个新模型中，kubelet初始化一个没有特定于云的信息的节点。但是，它会为新创建的节点添加污点，使节点不可调度，直到CCM使用特定于云的信息初始化节点。然后它消除了这种污点。</p>
<h5 id="3-Kubernetes-API服务器"><a href="#3-Kubernetes-API服务器" class="headerlink" title="3. Kubernetes API服务器"></a>3. Kubernetes API服务器</h5><p>PersistentVolumeLabels控制器将Kubernetes API服务器的依赖于云的功能移动到CCM，如前面部分所述。</p>
<h4 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h4><p>云控制器管理器使用Go接口允许插入任何云的实现。具体来说，它使用<a href="https://github.com/kubernetes/cloud-provider/blob/9b77dc1c384685cb732b3025ed5689dd597a5971/cloud.go#L42-L62" target="_blank" rel="noopener">此处</a>定义的CloudProvider接口。</p>
<p>上面突出显示的四个共享控制器的实现，以及一些脚手架以及共享的cloudprovider接口，将保留在Kubernetes核心中。特定于云提供商的实现将在核心之外构建，并实现核心中定义的接口。</p>
<p>有关开发插件的更多信息，请参阅<a href="https://kubernetes.io/docs/tasks/administer-cluster/developing-cloud-controller-manager/" target="_blank" rel="noopener">开发Cloud Controller Manager</a>。</p>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>本节分解了CCM执行其操作时各种API对象所需的访问权限。</p>
<h5 id="节点控制器-2"><a href="#节点控制器-2" class="headerlink" title="节点控制器"></a>节点控制器</h5><p>Node控制器仅适用于Node对象。它需要完全访问get，list，create，update，patch，watch和delete Node对象。</p>
<p>V1 /节点：</p>
<ul>
<li>Get</li>
<li>List</li>
<li>Create</li>
<li>Update</li>
<li>Patch</li>
<li>Watch</li>
<li>Delete</li>
</ul>
<h5 id="路线控制器-1"><a href="#路线控制器-1" class="headerlink" title="路线控制器"></a>路线控制器</h5><p>路由控制器侦听Node对象创建并适当地配置路由。它需要访问Node对象。</p>
<p>V1 /节点：</p>
<ul>
<li>Get</li>
</ul>
<h5 id="服务控制器-1"><a href="#服务控制器-1" class="headerlink" title="服务控制器"></a>服务控制器</h5><p>服务控制器侦听Service对象创建，更新和删除事件，然后适当地为这些服务配置端点。</p>
<p>要访问服务，它需要列表和监视访问权限。要更新服务，它需要修补和更新访问权限。</p>
<p>要为服务设置端点，需要访问create，list，get，watch和update。</p>
<p>V1 /服务：</p>
<ul>
<li>List</li>
<li>Get</li>
<li>Watch</li>
<li>Patch</li>
<li>Update</li>
</ul>
<h5 id="PersistentVolumeLabels控制器-1"><a href="#PersistentVolumeLabels控制器-1" class="headerlink" title="PersistentVolumeLabels控制器"></a>PersistentVolumeLabels控制器</h5><p>PersistentVolumeLabels控制器侦听PersistentVolume（PV）创建事件，然后更新它们。该控制器需要访问以获取和更新PV。</p>
<p>V1 / PersistentVolume：</p>
<ul>
<li>Get</li>
<li>List</li>
<li>Watch</li>
<li>Update</li>
</ul>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>CCM核心的实现需要访问以创建事件，并且为了确保安全操作，它需要访问以创建ServiceAccounts。</p>
<p>V1 /事件：</p>
<ul>
<li>Create</li>
<li>Patch</li>
<li>Update</li>
</ul>
<p>V1 / ServiceAccount：</p>
<ul>
<li>Create</li>
</ul>
<p>CCM的RBAC ClusterRole如下所示：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: cloud-controller-manager</span><br><span class="line">rules:</span><br><span class="line">-<span class="ruby"> <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - events</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - create</span></span><br><span class="line"><span class="ruby">  - patch</span></span><br><span class="line"><span class="ruby">  - update</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - nodes</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">'*'</span></span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - nodes/status</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - patch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - services</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - patch</span></span><br><span class="line"><span class="ruby">  - update</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - serviceaccounts</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - create</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - persistentvolumes</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - update</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - endpoints</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - create</span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">  - update</span></span><br></pre></td></tr></table></figure></p>
<h4 id="供应商实施"><a href="#供应商实施" class="headerlink" title="供应商实施"></a>供应商实施</h4><p>以下云提供商已实施CCM：</p>
<ul>
<li><a href="https://github.com/digitalocean/digitalocean-cloud-controller-manager" target="_blank" rel="noopener">Digital Ocean</a></li>
<li><a href="https://github.com/oracle/oci-cloud-controller-manager" target="_blank" rel="noopener">Oracle</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/tree/master/pkg/cloudprovider/providers/azure" target="_blank" rel="noopener">Azure</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/tree/master/pkg/cloudprovider/providers/gce" target="_blank" rel="noopener">GCE</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/tree/master/pkg/cloudprovider/providers/aws" target="_blank" rel="noopener">AWS</a></li>
</ul>
<h4 id="群集管理"><a href="#群集管理" class="headerlink" title="群集管理"></a>群集管理</h4><p><a href="https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager" target="_blank" rel="noopener">此处</a>提供了有关配置和运行CCM的完整说明 </p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>您创建Docker镜像并将其推送到仓库，然后在Kubernetes的pod中引用它。</p>
<p><code>image</code>容器的属性支持与<code>docker</code>命令相同的语法，包括私有仓库和标记。</p>
<ul>
<li>更新镜像</li>
<li>用清单构建多架构镜像</li>
<li>使用私人仓库</li>
</ul>
<h4 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h4><p>默认拉取策略<code>IfNotPresent</code>会导致Kubelet跳过拉动镜像（如果已存在）。如果您想总是强制Docker拉动，可以执行以下操作之一：</p>
<ul>
<li>将<code>imagePullPolicy</code>容器设置为Always。</li>
<li>省略<code>imagePullPolicy</code>并使用它<code>:latest</code>作为要使用的镜像的标记。</li>
<li>省略<code>imagePullPolicy</code>要使用的镜像和标记。</li>
<li>启用<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages" target="_blank" rel="noopener">AlwaysPullImages</a>准入控制器。</li>
</ul>
<p>请注意，您应该避免使用<code>:latest</code>标记，有关详细信息，请<a href="https://kubernetes.io/docs/concepts/configuration/overview/#container-images" target="_blank" rel="noopener">参阅配置的最佳实践</a>。</p>
<h4 id="用清单构建多架构图像"><a href="#用清单构建多架构图像" class="headerlink" title="用清单构建多架构图像"></a>用清单构建多架构图像</h4><p>Docker CLI现在支持以下命令<code>docker manifest</code>中包含的子命令<code>create</code>，<code>annotate</code>并<code>push</code>。这些命令可用于构建和推送清单。您可以使用<code>docker manifest inspect</code>查看清单。</p>
<p>请在此处查看<a href="https://docs.docker.com/edge/engine/reference/commandline/manifest/" target="_blank" rel="noopener">docker文档</a>，<br>请参阅我们在构建工具中如何使用它的<a href="https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate" target="_blank" rel="noopener">示例</a>&amp;i=nope&amp;files=&amp;repos=)。</p>
<p>这些命令完全依赖于Docker CLI，并且完全在Docker CLI上实现。您需要编辑<code>$HOME/.docker/config.json</code>和设置<code>experimental</code>密钥，<code>enabled</code>或者只需在调用CLI命令时将<code>DOCKER_CLI_EXPERIMENTAL</code>环境变量设置为<code>enabled</code>。</p>
<blockquote>
<p>注意：请使用Docker 18.06或更高版本，以下版本有错误或不支持实验命令行选项。<a href="https://github.com/docker/cli/issues/1135" target="_blank" rel="noopener">示例</a>会在containerd下导致问题。</p>
</blockquote>
<p>如果您在上传陈旧的清单时遇到问题，只需清理旧的清单<code>$HOME/.docker/manifests</code>即可重新开始。</p>
<p>对于Kubernetes，我们通常使用带后缀的镜像<code>-$(ARCH)</code>。为了向后兼容，请生成带有后缀的旧镜像。我们的想法是生成<code>pause</code>具有所有拱形清单的说明镜像，并说出<code>pause-amd64</code>哪些向后兼容旧配置或YAML文件，这些文件可能硬编码带有后缀的镜像。</p>
<h4 id="使用私人仓库"><a href="#使用私人仓库" class="headerlink" title="使用私人仓库"></a>使用私人仓库</h4><p>私人仓库管理可能需要密钥才能从中读取图像。凭证可以通过多种方式提供：</p>
<ul>
<li>使用Google Container Registry<ul>
<li>Per-cluster</li>
<li>在Google Compute Engine或Google Kubernetes Engine上自动配置</li>
<li>所有pod都可以读取项目的私有仓库</li>
</ul>
</li>
<li>使用AWS EC2容器仓库（ECR）<ul>
<li>使用IAM角色和策略来控制对ECR存储库的访问</li>
<li>自动刷新ECR登录凭据</li>
</ul>
</li>
<li>使用Azure容器仓库（ACR）</li>
<li>使用IBM Cloud Container Registry</li>
<li>配置节点以验证私有仓库<ul>
<li>所有pod都可以读取任何已配置的私有仓库</li>
<li>需要集群管理员进行节点配置</li>
</ul>
</li>
<li>预拉镜像<ul>
<li>所有pod都可以使用节点上缓存的任何镜像</li>
<li>需要root权限才能设置所有节点</li>
</ul>
</li>
<li>在Pod上指定ImagePullSecrets<ul>
<li>只有提供自己密钥的pod才能访问私有仓库</li>
</ul>
</li>
</ul>
<p>下面更详细地描述每个选项。</p>
<h5 id="使用Google-Container-Registry"><a href="#使用Google-Container-Registry" class="headerlink" title="使用Google Container Registry"></a>使用Google Container Registry</h5><p>在Google Compute Engine（GCE）上运行时，Kubernetes对<a href="https://cloud.google.com/tools/container-registry/" target="_blank" rel="noopener">Google Container Registry（GCR）</a>提供原生支持。如果您在GCE或Google Kubernetes Engine上运行群集，只需使用完整的镜像名称（例如gcr.io/my_project/image：tag）。</p>
<p>群集中的所有pod都具有此仓库中镜像的读取权限。</p>
<p>kubelet将使用实例的Google服务帐户向GCR进行身份验证。实例上的服务帐户将具有一个 <code>https://www.googleapis.com/auth/devstorage.read_only</code>，因此它可以从项目的GCR中提取，但不能推送。</p>
<h5 id="使用AWS-EC2-Container-Registry"><a href="#使用AWS-EC2-Container-Registry" class="headerlink" title="使用AWS EC2 Container Registry"></a>使用AWS EC2 Container Registry</h5><p>当节点是AWS EC2实例时，Kubernetes对<a href="https://aws.amazon.com/ecr/" target="_blank" rel="noopener">AWS EC2 Container Registry</a>具有本机支持。</p>
<p>只需<code>ACCOUNT.dkr.ecr.REGION.amazonaws.com/imagename:tag</code>在Pod定义中使用完整的图像名称（例如）。</p>
<p>可以创建pod的群集的所有用户都可以运行使用ECR仓库中任何镜像的pod。</p>
<p>kubelet将获取并定期刷新ECR凭据。它需要以下权限才能执行此操作：</p>
<ul>
<li>ecr:GetAuthorizationToken</li>
<li>ecr:BatchCheckLayerAvailability</li>
<li>ecr:GetDownloadUrlForLayer</li>
<li>ecr:GetRepositoryPolicy</li>
<li>ecr:DescribeRepositories</li>
<li>ecr:ListImages</li>
<li>ecr:BatchGetImage</li>
</ul>
<p>要求：</p>
<ul>
<li>您必须使用kubelet版本<code>v1.2.0</code>或更新版本。（例如run <code>/usr/bin/kubelet --version=true</code>）。</li>
<li>如果您的节点位于区域A中且您的注册表位于不同的区域B中，则需要<code>v1.3.0</code>更新版本或更新版本。</li>
<li>ECR必须在您所在的地区提供</li>
</ul>
<p>故障排除：</p>
<ul>
<li>验证上述所有要求。</li>
<li><code>us-west-2</code>在工作站上获取$ REGION（例如）凭据。SSH进入主机并使用这些信用卡手动运行Docker。它有用吗？</li>
<li>验证kubelet是否正在运行<code>--cloud-provider=aws</code>。</li>
<li>检查kubelet日志（例如<code>journalctl -u kubelet</code>）以获取日志行，例如：<ul>
<li><code>plugins.go:56] Registering credential provider: aws-ecr-key</code></li>
<li><code>provider.go:91] Refreshing cache for provider: *aws_credentials.ecrProvider</code></li>
</ul>
</li>
</ul>
<h5 id="使用Azure容器仓库（ACR）"><a href="#使用Azure容器仓库（ACR）" class="headerlink" title="使用Azure容器仓库（ACR）"></a>使用Azure容器仓库（ACR）</h5><p>使用<a href="https://azure.microsoft.com/en-us/services/container-registry/" target="_blank" rel="noopener">Azure容器仓库</a>时， 您可以使用管理员用户或服务主体进行身份验证。在任何一种情况下，身份验证都通过标准Docker身份验证完成 这些说明假定使用 <a href="https://github.com/azure/azure-cli" target="_blank" rel="noopener">azure-cli</a>命令行工具。</p>
<p>您首先需要创建一个仓库并生成凭据，完整的文档可以在<a href="https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-azure-cli" target="_blank" rel="noopener">Azure容器仓库文档</a>中找到。</p>
<p>创建容器仓库后，您将使用以下凭据登录：</p>
<ul>
<li><code>DOCKER_USER</code> ：服务主体或管理员用户名</li>
<li><code>DOCKER_PASSWORD</code>：服务主体密码或管理员用户密码</li>
<li><code>DOCKER_REGISTRY_SERVER</code>： <code>${some-registry-name}.azurecr.io</code></li>
<li><code>DOCKER_EMAIL</code>：<code>${some-email-address}</code></li>
</ul>
<p>填好这些变量后，您可以<a href="https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod" target="_blank" rel="noopener">配置Kubernetes Secret并使用它来部署Pod</a>。</p>
<h5 id="使用IBM-Cloud-Container-Registry"><a href="#使用IBM-Cloud-Container-Registry" class="headerlink" title="使用IBM Cloud Container Registry"></a>使用IBM Cloud Container Registry</h5><p>IBM Cloud Container Registry提供了一个多租户私有镜像仓库，您可以使用它来安全地存储和共享Docker镜像。默认情况下，集成的漏洞顾问会扫描私有仓库中的镜像，以检测安全问题和潜在漏洞。IBM Cloud帐户中的用户可以访问您的镜像，也可以创建令牌以授予对仓库命名空间的访问权限。</p>
<p>要安装IBM Cloud Container Registry CLI插件并为镜像创建命名空间，请参阅<a href="https://console.bluemix.net/docs/services/Registry/index.html#index" target="_blank" rel="noopener">IBM Cloud Container Registry入门</a>。</p>
<p>您可以使用IBM Cloud Container Registry将容器从<a href="https://console.bluemix.net/docs/services/RegistryImages/index.html#ibm_images" target="_blank" rel="noopener">IBM Cloud公共镜像</a>和私有镜像部署到<code>default</code>IBM Cloud Kubernetes Service集群的命名空间中。要将容器部署到其他名称空间，或使用来自其他IBM Cloud Container Registry区域或IBM Cloud帐户的镜像，请创建Kubernetes <code>imagePullSecret</code>。有关更多信息，请参阅<a href="https://console.bluemix.net/docs/containers/cs_images.html#images" target="_blank" rel="noopener">从镜像构建容器</a>。</p>
<h5 id="配置节点以验证私有仓库"><a href="#配置节点以验证私有仓库" class="headerlink" title="配置节点以验证私有仓库"></a>配置节点以验证私有仓库</h5><blockquote>
<p>注意：如果您在Google Kubernetes Engine上运行，则<code>.dockercfg</code>每个节点上都会有一个包含Google Container Registry凭据的节点。你不能使用这种方法。</p>
</blockquote>
<blockquote>
<p>注意：如果您在AWS EC2上运行并且正在使用EC2容器仓库（ECR），则每个节点上的kubelet将管理和更新ECR登录凭据。你不能使用这种方法</p>
</blockquote>
<blockquote>
<p>注意：如果您可以控制节点配置，则此方法是合适的。它不能可靠地在GCE和任何其他进行自动节点替换的云提供商上运行。</p>
</blockquote>
<p>Docker将私有仓库的密钥存储在<code>$HOME/.dockercfg</code>或<code>$HOME/.docker/config.json</code>文件中。如果您将相同的文件放在下面的搜索路径列表中，则kubelet会在拉取镜像时将其用作凭据提供程序。</p>
<ul>
<li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li>
<li><code>{cwd of kubelet}/config.json</code></li>
<li><code>${HOME}/.docker/config.json</code></li>
<li><code>/.docker/config.json</code></li>
<li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li>
<li><code>{cwd of kubelet}/.dockercfg</code></li>
<li><code>${HOME}/.dockercfg</code></li>
<li><code>/.dockercfg</code></li>
</ul>
<blockquote>
<p>注意：您可能必须<code>HOME=/root</code>在环境文件中明确设置kubelet。</p>
</blockquote>
<p>以下是配置节点以使用私有仓库的建议步骤。在此示例中，在桌面/笔记本电脑上运行这些：</p>
<ol>
<li><code>docker login [server]</code>针对要使用的每组凭据运行。这更新<code>$HOME/.docker/config.json</code>。</li>
<li><code>$HOME/.docker/config.json</code>在编辑器中查看以确保它仅包含您要使用的凭据。</li>
<li>获取节点列表，例如：</li>
</ol>
<ul>
<li>如果你想要这些名字： <code>nodes=$(kubectl get nodes -o jsonpath=&#39;{range.items[*].metadata}{.name} {end}&#39;)</code></li>
<li>如果你想获得IP： <code>nodes=$(kubectl get nodes -o jsonpath=&#39;{range .items[*].status.addresses[?(@.type==&quot;ExternalIP&quot;)]}{.address} {end}&#39;)</code></li>
</ul>
<ol start="4">
<li>将本地复制<code>.docker/config.json</code>到上面的搜索路径列表之一。</li>
</ol>
<ul>
<li>例如： <code>for n in $nodes; do scp ~/.docker/config.json root@$n:/var/lib/kubelet/config.json; done</code></li>
</ul>
<p>通过创建使用私有镜像的pod进行验证，例如：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f - &lt;&lt;EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  <span class="built_in">name</span>: <span class="built_in">private</span>-<span class="built_in">image</span>-test-<span class="number">1</span></span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - <span class="built_in">name</span>: uses-<span class="built_in">private</span>-<span class="built_in">image</span></span><br><span class="line">      <span class="built_in">image</span>: $PRIVATE_IMAGE_NAME</span><br><span class="line">      imagePullPolicy: Always</span><br><span class="line">      command: [ <span class="string">"echo"</span>, <span class="string">"SUCCESS"</span> ]</span><br><span class="line">EOF</span><br><span class="line">pod/<span class="built_in">private</span>-<span class="built_in">image</span>-test-<span class="number">1</span> created</span><br></pre></td></tr></table></figure></p>
<p>如果一切正常，那么过了一会儿，你应该看到：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs <span class="keyword">private</span>-<span class="built_in">image</span>-test<span class="number">-1</span></span><br><span class="line">SUCCESS</span><br></pre></td></tr></table></figure></p>
<p>如果失败了，那么你会看到：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">describe</span> pods/<span class="keyword">private</span>-image-<span class="keyword">test</span><span class="number">-1</span> | grep <span class="string">"Failed"</span></span><br><span class="line">  Fri, <span class="number">26</span> Jun <span class="number">2015</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">13</span> <span class="number">-0700</span>    Fri, <span class="number">26</span> Jun <span class="number">2015</span> <span class="number">15</span>:<span class="number">39</span>:<span class="number">13</span> <span class="number">-0700</span>    <span class="number">19</span>    &#123;kubelet node-i2hq&#125;    spec.containers&#123;uses-<span class="keyword">private</span>-image&#125;    <span class="keyword">failed</span>        <span class="keyword">Failed</span> <span class="keyword">to</span> pull image <span class="string">"user/privaterepo:v1"</span>: <span class="keyword">Error</span>: image <span class="keyword">user</span>/privaterepo:v1 <span class="keyword">not</span> <span class="keyword">found</span></span><br></pre></td></tr></table></figure></p>
<p>您必须确保群集中的所有节点都具有相同的节点<code>.docker/config.json</code>。否则，pod将在某些节点上运行，而无法在其他节点上运行。例如，如果使用节点自动缩放，则每个实例模板都需要包含<code>.docker/config.json</code>或装载包含它的驱动器。</p>
<p>将私有仓库项添加到任何私有仓库中后，所有pod都将具有对镜像的读访问权限<code>.docker/config.json</code>。</p>
<h5 id="预拉图像"><a href="#预拉图像" class="headerlink" title="预拉图像"></a>预拉图像</h5><blockquote>
<p>注意：如果您在Google Kubernetes Engine上运行，则.dockercfg每个节点上都会有一个包含Google Container Registry凭据的节点。你不能使用这种方法。</p>
</blockquote>
<blockquote>
<p>注意：如果您可以控制节点配置，则此方法是合适的。它不能可靠地在GCE和任何其他进行自动节点替换的云提供商上运行。</p>
</blockquote>
<p>默认情况下，kubelet将尝试从指定的仓库中提取每个镜像。但是，如果<code>imagePullPolicy</code>容器的属性设置为<code>IfNotPresent</code>或<code>Never</code>，则使用本地镜像（分别优先或排他）。</p>
<p>如果您希望依赖预先提取的镜像作为仓库身份验证的替代，则必须确保群集中的所有节点都具有相同的预拉镜像。</p>
<p>这可以用于预加载某些镜像以提高速度，或者作为对私有仓库进行身份验证的替代方法。</p>
<p>所有pod都可以读取任何预拉镜像。</p>
<h5 id="在Pod上指定ImagePullSecrets"><a href="#在Pod上指定ImagePullSecrets" class="headerlink" title="在Pod上指定ImagePullSecrets"></a>在Pod上指定ImagePullSecrets</h5><blockquote>
<p>注意：此方法目前是Google Kubernetes Engine，GCE以及自动创建节点的任何云提供商的推荐方法。</p>
</blockquote>
<p>Kubernetes支持在pod上指定仓库项。</p>
<h5 id="使用Docker配置创建机密"><a href="#使用Docker配置创建机密" class="headerlink" title="使用Docker配置创建机密"></a>使用Docker配置创建机密</h5><p>运行以下命令，替换相应的大写值：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create<span class="built_in"> secret </span>docker-registry myregistrykey <span class="attribute">--docker-server</span>=DOCKER_REGISTRY_SERVER <span class="attribute">--docker-username</span>=DOCKER_USER <span class="attribute">--docker-password</span>=DOCKER_PASSWORD <span class="attribute">--docker-email</span>=DOCKER_EMAIL</span><br><span class="line">secret/myregistrykey created.</span><br></pre></td></tr></table></figure></p>
<p>如果需要访问多个仓库，则可以为每个仓库创建一个秘密。 在为Pods提取镜像时，Kubelet会将任何内容合并<code>imagePullSecrets</code>为一个虚拟内容<code>.docker/config.json</code>。</p>
<p>Pod只能在自己的命名空间中引用镜像拉取秘密，因此每个命名空间需要执行一次此过程。</p>
<h6 id="绕过kubectl会产生秘密"><a href="#绕过kubectl会产生秘密" class="headerlink" title="绕过kubectl会产生秘密"></a>绕过kubectl会产生秘密</h6><p>如果由于某种原因，您需要单个项目中的多个项目<code>.docker/config.json</code>或需要上述命令未给出的控制，那么您可以<a href="https://kubernetes.io/docs/user-guide/secrets/#creating-a-secret-manually" target="_blank" rel="noopener">使用json或yaml创建一个秘密</a>。</p>
<p>务必：</p>
<ul>
<li>设置数据项的名称 <code>.dockerconfigjson</code></li>
<li>base64编码docker文件并粘贴该字符串，不间断作为字段的值 <code>data[&quot;.dockerconfigjson&quot;]</code></li>
<li>设置<code>type</code>为<code>kubernetes.io/dockerconfigjson</code></li>
</ul>
<p>例：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: myregistrykey</span><br><span class="line">  namespace: awesomeapps</span><br><span class="line">data:</span><br><span class="line">  .dockerconfigjson: <span class="attribute">UmVhbGx5IHJlYWxseSByZWVlZWVlZWVlZWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGx5eXl5eXl5eXl5eXl5eXl5eXl5eSBsbGxsbGxsbGxsbGxsbG9vb29vb29vb29vb29vb29vb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg</span>==</span><br><span class="line">type: kubernetes.io/dockerconfigjson</span><br></pre></td></tr></table></figure></p>
<p>如果收到错误消息<code>error: no objects passed to create</code>，则可能表示base64编码的字符串无效。如果收到类似的错误消息<code>Secret &quot;myregistrykey&quot; is invalid: data[.dockerconfigjson]: invalid value ...</code>，则表示数据已成功取消base64编码，但无法解析为<code>.docker/config.json</code>文件。</p>
<h5 id="参考Pod上的imagePullSecrets"><a href="#参考Pod上的imagePullSecrets" class="headerlink" title="参考Pod上的imagePullSecrets"></a>参考Pod上的imagePullSecrets</h5><p>现在，您可以通过向<code>imagePullSecrets</code> pod定义添加一个部分来创建引用该秘密的pod。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: v1</span><br><span class="line"><span class="attribute">kind</span>: Pod</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">name</span>: foo</span><br><span class="line">  <span class="attribute">namespace</span>: awesomeapps</span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">containers</span>:</span><br><span class="line">    - <span class="attribute">name</span>: foo</span><br><span class="line">      <span class="attribute">image</span>: janedoe/<span class="attribute">awesomeapp</span>:v1</span><br><span class="line">  <span class="attribute">imagePullSecrets</span>:</span><br><span class="line">    - <span class="attribute">name</span>: myregistrykey</span><br></pre></td></tr></table></figure></p>
<p>需要对使用私有仓库的每个pod执行此操作。</p>
<p>但是，可以通过在<a href="https://kubernetes.io/docs/user-guide/service-accounts" target="_blank" rel="noopener">serviceAccount</a>资源中设置imagePullSecrets来自动设置此字段。检查将<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account" target="_blank" rel="noopener">ImagePullSecrets添加到服务帐户</a>以获取详细说明。</p>
<p>您可以将其与每个节点结合使用<code>.docker/config.json</code>。凭证将被合并。这种方法适用于Google Kubernetes Engine。</p>
<h6 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h6><p>有许多配置私有仓库的解决方案。以下是一些常见用例和建议的解决方案。</p>
<ol>
<li>群集仅运行非专有（例如开源）镜像。无需隐藏镜像。</li>
</ol>
<ul>
<li>在Docker hub上使用公共镜像。<ul>
<li>无需配置。</li>
<li>在GCE / Google Kubernetes Engine上，自动使用本地镜像来提高速度和可用性。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>群集运行一些专有镜像，这些镜像像应隐藏给公司外部的人员，但对所有群集用户可见。</li>
</ol>
<ul>
<li>使用托管的私有<a href="https://docs.docker.com/registry/" target="_blank" rel="noopener">Docker仓库</a>。<ul>
<li>它可能托管在<a href="https://hub.docker.com/signup" target="_blank" rel="noopener">Docker Hub</a>或其他地方。</li>
<li>如上所述，在每个节点上手动配置<code>.docker / config.json</code>。</li>
</ul>
</li>
<li>或者，使用开放读取访问权限在防火墙后面运行内部私有仓库。<ul>
<li>不需要Kubernetes配置。</li>
</ul>
</li>
<li>或者，在使用GCE / Google Kubernetes Engine时，请使用该项目的Google Container Registry。<ul>
<li>与集群自动调节相比，它可以比手动节点配置更好地工作。</li>
</ul>
</li>
<li>或者，在更改节点配置不方便的群集上，请使用<code>imagePullSecrets</code>。</li>
</ul>
<ol start="3">
<li>具有专有镜像的集群，其中一些需要更严格的访问控制。</li>
</ol>
<ul>
<li>确保<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages" target="_blank" rel="noopener">AlwaysPullImages准入控制器</a>处于活动状态。否则，所有Pod都可能访问所有镜像。</li>
<li>将敏感数据移动到“秘密”资源中，而不是将其打包在镜像中。</li>
</ul>
<ol start="4">
<li>一个多租户群集，每个租户都需要拥有私有仓库。</li>
</ol>
<ul>
<li>确<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages" target="_blank" rel="noopener">保AlwaysPullImages准入控制器</a>处于活动状态。否则，所有租户的所有Pod都可能访问所有图像。</li>
<li>运行需要授权的私有仓库。</li>
<li>为每个租户生成仓库凭据，保密，并为每个租户命名空间填充机密。</li>
<li>租户将这个秘密添加到每个命名空间的imagePullSecrets。</li>
</ul>
<h3 id="容器环境变量"><a href="#容器环境变量" class="headerlink" title="容器环境变量"></a>容器环境变量</h3><p>此页面描述Container环境中Container可用的资源。</p>
<h4 id="容器环境"><a href="#容器环境" class="headerlink" title="容器环境"></a>容器环境</h4><p>Kubernetes Container环境为容器提供了几个重要资源：</p>
<ul>
<li>文件系统，是镜像和一个或多个卷的组合。</li>
<li>有关Container本身的信息。</li>
<li>有关群集中其他对象的信息。</li>
</ul>
<h5 id="容器信息"><a href="#容器信息" class="headerlink" title="容器信息"></a>容器信息</h5><p>Container 的主机名是运行Container的Pod的名称。它可以通过 libc中的<code>hostname</code>命令或 <a href="http://man7.org/linux/man-pages/man2/gethostname.2.html" target="_blank" rel="noopener"><code>gethostname</code></a>函数调用获得。</p>
<p>Pod名称和命名空间可通过<a href="https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/" target="_blank" rel="noopener">向下API</a>作为环境变量使用 。</p>
<p>Pod定义中的用户定义环境变量也可用于Container，Docker镜像中静态指定的任何环境变量也是如此。</p>
<h5 id="群集信息"><a href="#群集信息" class="headerlink" title="群集信息"></a>群集信息</h5><p>创建Container时运行的所有服务的列表可作为环境变量用于该Container。这些环境变量与Docker链接的语法相匹配。</p>
<p>对于名为foo的映射到名为bar的Container 的服务，定义了以下变量：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">FOO_SERVICE_HOST</span>=&lt;the host the<span class="built_in"> service </span>is running on&gt;</span><br><span class="line"><span class="attribute">FOO_SERVICE_PORT</span>=&lt;the<span class="built_in"> port </span>the<span class="built_in"> service </span>is running on&gt;</span><br></pre></td></tr></table></figure></p>
<p>服务具有专用IP地址，如果启用了<a href="http://releases.k8s.io/master/cluster/addons/dns/" target="_blank" rel="noopener">DNS插件</a>，则可通过DNS使用Container 。 </p>
<h3 id="运行时类"><a href="#运行时类" class="headerlink" title="运行时类"></a>运行时类</h3><p>特征状态： Kubernetes v1.12<br>该页面描述了RuntimeClass资源和运行时选择机制。</p>
<blockquote>
<p>此功能目前处于alpha状态，意思是：<br>版本名称包含alpha（例如v1alpha1）。<br>可能是马车。启用该功能可能会暴露错误。默认情况下禁用。<br>可随时删除对功能的支持，恕不另行通知。<br>API可能会在以后的软件版本中以不兼容的方式更改，恕不另行通知。<br>由于错误风险增加和缺乏长期支持，建议仅在短期测试集群中使用。</p>
</blockquote>
<h4 id="运行时类-1"><a href="#运行时类-1" class="headerlink" title="运行时类"></a>运行时类</h4><p>RuntimeClass是一个alpha功能，用于选择用于运行pod容器的容器运行时配置。</p>
<h5 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h5><p>作为早期的alpha功能，必须采取一些额外的设置步骤才能使用RuntimeClass功能：</p>
<ol>
<li>启用RuntimeClass功能门（在apiservers＆kubelets上，需要1.12+版本）</li>
<li>安装RuntimeClass CRD</li>
<li>在节点上配置CRI实现（取决于运行时）</li>
<li>创建相应的RuntimeClass资源</li>
</ol>
<h5 id="1-启用RuntimeClass-feature-gate"><a href="#1-启用RuntimeClass-feature-gate" class="headerlink" title="1.启用RuntimeClass feature gate"></a>1.启用RuntimeClass feature gate</h5><p>有关启用feature gates的说明，请参见<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/" target="_blank" rel="noopener">feature gates</a>。必须在apiservers和kubelet上启用<code>RuntimeClass</code>功能门。</p>
<h5 id="2-安装RuntimeClass-CRD"><a href="#2-安装RuntimeClass-CRD" class="headerlink" title="2.安装RuntimeClass CRD"></a>2.安装RuntimeClass CRD</h5><p>RuntimeClass <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/" target="_blank" rel="noopener">CustomResourceDefinition</a>（CRD）可以在Kubernetes git repo的addons目录中找到：<code>kubernetes / cluster / addons / runtimeclass / runtimeclass_crd.yaml</code></p>
<p>安装CRD <code>kubectl apply -f runtimeclass_crd.yaml</code>。</p>
<h5 id="3-在节点上配置CRI实现"><a href="#3-在节点上配置CRI实现" class="headerlink" title="3.在节点上配置CRI实现"></a>3.在节点上配置CRI实现</h5><p>使用RuntimeClass进行选择的配置取决于CRI实现。有关如何配置的信息，请参阅CRI实现的相应文档。由于这是一个alpha功能，并非所有CRI都支持多个RuntimeClasses。</p>
<blockquote>
<p>注意： RuntimeClass当前假定整个集群中的同类节点配置（这意味着所有节点的配置方式与容器运行时相同）。任何异构性（变化的配置）必须通过调度功能独立于RuntimeClass进行管理（请参阅<a href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/" target="_blank" rel="noopener">将Pod分配给节点</a>）。</p>
</blockquote>
<p>配置具有相应的<code>RuntimeHandler</code>名称，由RuntimeClass引用。RuntimeHandler必须是有效的DNS 1123子域（字母数字<code>+</code> <code>-</code>和<code>.</code>字符）。</p>
<h5 id="4-创建相应的RuntimeClass资源"><a href="#4-创建相应的RuntimeClass资源" class="headerlink" title="4.创建相应的RuntimeClass资源"></a>4.创建相应的RuntimeClass资源</h5><p>步骤3中的配置设置应各自具有关联的<code>RuntimeHandler</code>名称，用于标识配置。对于每个RuntimeHandler（以及可选的空””处理程序），创建相应的RuntimeClass对象。</p>
<p>RuntimeClass资源当前只有2个重要字段：RuntimeClass name（<code>metadata.name</code>）和RuntimeHandler（<code>spec.runtimeHandler</code>）。对象定义如下所示：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: node.k8s.io/v1alpha1  # RuntimeClass is defined <span class="keyword">in</span> the node.k8s.io API group</span><br><span class="line">kind: RuntimeClass</span><br><span class="line">metadata:</span><br><span class="line">  name: myclass  # The name the RuntimeClass will be referenced by</span><br><span class="line">  # RuntimeClass is a non-namespaced resource</span><br><span class="line">spec:</span><br><span class="line">  runtimeHandler: myconfiguration  # The name of the corresponding CRI configuration</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：建议将RuntimeClass写入操作（create / update / patch / delete）限制为群集管理员。这通常是默认值。有关详细信息，请参阅<a href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/" target="_blank" rel="noopener">授权概述</a>。</p>
</blockquote>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p>为集群配置RuntimeClasses后，使用它们非常简单。runtimeClassName在Pod规范中指定a 。例如：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">apiVersion:</span> v1</span><br><span class="line"><span class="symbol">kind:</span> Pod</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  name:</span> mypod</span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  runtimeClassName:</span> myclass</span><br><span class="line">  <span class="meta"># ...</span></span><br></pre></td></tr></table></figure></p>
<p>这将指示Kubelet使用命名的RuntimeClass来运行此pod。如果命名的RuntimeClass不存在，或者CRI无法运行相应的处理程序，则pod将进入 <code>Failed</code>终端<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase" target="_blank" rel="noopener">阶段</a>。查找错误消息的相应<a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-application-introspection/" target="_blank" rel="noopener">事件</a>。</p>
<p>如果未<code>runtimeClassName</code>指定，则将使用默认的RuntimeHandler，这相当于禁用RuntimeClass功能时的行为。</p>
<h3 id="容器生命周期钩子"><a href="#容器生命周期钩子" class="headerlink" title="容器生命周期钩子"></a>容器生命周期钩子</h3><p>此页面描述了kubelet管理的容器如何使用Container生命周期钩子框架来运行在管理生命周期中由事件触发的代码。</p>
<ul>
<li>概观</li>
<li>集装箱挂钩</li>
</ul>
<h4 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h4><p>类似于许多具有组件生命周期钩子的编程语言框架，例如Angular，Kubernetes为Containers提供了生命周期钩子。钩子使Container能够了解其管理生命周期中的事件，并在执行相应的生命周期钩子时运行在处理程序中实现的代码。</p>
<h4 id="容器钩子"><a href="#容器钩子" class="headerlink" title="容器钩子"></a>容器钩子</h4><p>有两个暴露给容器的钩子：</p>
<p><code>PostStart</code></p>
<p>在创建容器后立即执行此挂钩。但是，无法保证挂钩将在容器ENTRYPOINT之前执行。没有参数传递给处理程序。</p>
<p><code>PreStop</code></p>
<p>在容器终止之前立即调用此挂钩。它是阻塞的，意味着它是同步的，所以它必须在删除容器的调用之前完成。没有参数传递给处理程序。</p>
<p>终止行为的更详细描述可以在<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods" target="_blank" rel="noopener">终端中</a>找到 。</p>
<h5 id="钩子处理程序实现"><a href="#钩子处理程序实现" class="headerlink" title="钩子处理程序实现"></a>钩子处理程序实现</h5><p>容器可以通过实现和注册该钩子的处理程序来访问钩子。可以为Container实现两种类型的钩子处理程序：</p>
<ul>
<li>Exec - 执行特定命令，例如<code>pre-stop.sh</code>，在Container的cgroups和名称空间内。命令消耗的资源将根据Container计算。</li>
<li>HTTP - 对Container上的特定端点执行HTTP请求。</li>
</ul>
<h5 id="钩子处理程序执行"><a href="#钩子处理程序执行" class="headerlink" title="钩子处理程序执行"></a>钩子处理程序执行</h5><p>调用Container生命周期管理挂钩时，Kubernetes管理系统会在为该挂钩注册的Container中执行处理程序。 </p>
<p>钩子处理程序调用在包含Container的Pod的上下文中是同步的。这意味着对于一个<code>PostStart</code>钩子，Container ENTRYPOINT和钩子异步发射。但是，如果挂钩运行或挂起太长时间，则Container无法达到某种<code>running</code>状态。</p>
<p><code>PreStop</code>钩子的行为类似。如果钩子在执行期间挂起，则Pod阶段将保持<code>Terminating</code>状态并在<code>terminationGracePeriodSecondspod</code>结束后被杀死。如果一个 <code>PostStart</code>或<code>PreStophook</code>失败，则会终止Container。</p>
<p>用户应使其钩子处理程序尽可能轻量级。但是，有些情况下，长时间运行的命令是有意义的，例如在停止Container之前保存状态。</p>
<h5 id="挂钩送货保证"><a href="#挂钩送货保证" class="headerlink" title="挂钩送货保证"></a>挂钩送货保证</h5><p>钩子传递至少是一次，这意味着可以为任何给定事件多次调用钩子，例如for <code>PostStart</code>或<code>PreStop</code>。由钩子实现来正确处理这个问题。</p>
<p>通常，只进行单次交付。例如，如果HTTP挂钩接收器关闭且无法获取流量，则不会尝试重新发送。然而，在一些罕见的情况下，可能会发生双重递送。例如，如果一个kubelet在发送一个钩子的过程中重新启动，那么在该kubelet重新启动后可能会重新发送一个钩子。</p>
<h5 id="调试Hook处理程序"><a href="#调试Hook处理程序" class="headerlink" title="调试Hook处理程序"></a>调试Hook处理程序</h5><p>在Pod事件中不公开Hook处理程序的日志。如果处理程序由于某种原因失败，它会广播一个事件。因为<code>PostStart</code>，这是<code>FailedPostStartHook</code>事件，因为<code>PreStop</code>这是<code>FailedPreStopHook</code>事件。您可以通过运行来查看这些事件<code>kubectl describe pod &lt;pod_name&gt;</code>。以下是运行此命令的一些事件输出示例：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Events:</span><br><span class="line">  FirstSeen    LastSeen    Count    From                            SubobjectPath        Type        Reason        Message</span><br><span class="line">  ---------    --------    -----    ----                            -------------        --------    ------        -------</span><br><span class="line">  <span class="number">1</span>m        <span class="number">1</span>m        <span class="number">1</span>    &#123;<span class="keyword">default</span>-scheduler &#125;                                Normal        Scheduled    Successfully assigned test<span class="number">-1730497541</span>-cq1d2 to gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd</span><br><span class="line">  <span class="number">1</span>m        <span class="number">1</span>m        <span class="number">1</span>    &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;    spec.containers&#123;main&#125;    Normal        Pulling        pulling <span class="keyword">image</span> <span class="string">"test:1.0"</span></span><br><span class="line">  <span class="number">1</span>m        <span class="number">1</span>m        <span class="number">1</span>    &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;    spec.containers&#123;main&#125;    Normal        Created        Created <span class="keyword">container</span> with docker id <span class="number">5</span>c6a256a2567; Security:[seccomp=unconfined]</span><br><span class="line">  <span class="number">1</span>m        <span class="number">1</span>m        <span class="number">1</span>    &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;    spec.containers&#123;main&#125;    Normal        Pulled        Successfully pulled <span class="keyword">image</span> <span class="string">"test:1.0"</span></span><br><span class="line">  <span class="number">1</span>m        <span class="number">1</span>m        <span class="number">1</span>    &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;    spec.containers&#123;main&#125;    Normal        Started        Started <span class="keyword">container</span> with docker id <span class="number">5</span>c6a256a2567</span><br><span class="line">  <span class="number">38</span>s        <span class="number">38</span>s        <span class="number">1</span>    &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;    spec.containers&#123;main&#125;    Normal        Killing        Killing <span class="keyword">container</span> with docker id <span class="number">5</span>c6a256a2567: PostStart handler: Error executing <span class="keyword">in</span> Docker Container: <span class="number">1</span></span><br><span class="line">  <span class="number">37</span>s        <span class="number">37</span>s        <span class="number">1</span>    &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;    spec.containers&#123;main&#125;    Normal        Killing        Killing <span class="keyword">container</span> with docker id <span class="number">8</span>df9fdfd7054: PostStart handler: Error executing <span class="keyword">in</span> Docker Container: <span class="number">1</span></span><br><span class="line">  <span class="number">38</span>s        <span class="number">37</span>s        <span class="number">2</span>    &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;                Warning        FailedSync    Error syncing pod, skipping: failed to <span class="string">"StartContainer"</span> <span class="keyword">for</span> <span class="string">"main"</span> with RunContainerError: <span class="string">"PostStart handler: Error executing in Docker Container: 1"</span></span><br><span class="line">  <span class="number">1</span>m         <span class="number">22</span>s         <span class="number">2</span>     &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;    spec.containers&#123;main&#125;    Warning        FailedPostStartHook</span><br></pre></td></tr></table></figure></p>
<h2 id="Workloads"><a href="#Workloads" class="headerlink" title="Workloads"></a>Workloads</h2><h3 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h3><h4 id="Pod概述"><a href="#Pod概述" class="headerlink" title="Pod概述"></a>Pod概述</h4><p>此页面概述Pod了Kubernetes对象模型中最小的可部署对象。</p>
<ul>
<li>了解Pods</li>
<li>使用Pods</li>
<li>Pod模板</li>
</ul>
<h5 id="了解Pods"><a href="#了解Pods" class="headerlink" title="了解Pods"></a>了解Pods</h5><p>一个pod是在创建或部署Kubernetes对象模型Kubernetes-最小最简单的单元的基本构建块。Pod表示群集上正在运行的进程。</p>
<p>Pod封装了一个应用程序容器（或者，在某些情况下，多个容器），存储资源，一个唯一的网络IP以及控制容器应该如何运行的选项。Pod表示部署单元：Kubernetes中的单个应用程序实例，可能包含单个容器或少量紧密耦合且共享资源的容器。</p>
<p><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a>是Kubernetes Pod中最常用的容器运行时，但Pods也支持其他容器运行时。</p>
<p>Kubernetes集群中的Pod可以以两种主要方式使用：</p>
<ul>
<li><strong>运行单个容器的Pod</strong>。“one-container-per-Pod”模型是最常见的Kubernetes用例; 在这种情况下，您可以将Pod视为单个容器的包装，而Kubernetes直接管理Pod而不是容器。</li>
<li><strong>运行多个需要协同工作的容器的Pod</strong>。Pod可以封装由多个共址容器组成的应用程序，这些容器紧密耦合并需要共享资源。这些共处一地的容器可能形成一个统一的服务单元 - 一个容器从共享卷向公众提供文件，而一个单独的“sidecar”容器刷新或更新这些文件。Pod将这些容器和存储资源作为单个可管理实体包装在一起。</li>
</ul>
<p>该<a href="http://kubernetes.io/blog" target="_blank" rel="noopener">Kubernetes博客</a>对pod用例一些额外的信息。有关更多信息，请参阅：</p>
<ul>
<li><a href="https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns" target="_blank" rel="noopener">分布式系统工具包：复合容器的模式</a></li>
<li><a href="https://kubernetes.io/blog/2016/06/container-design-patterns" target="_blank" rel="noopener">容器设计模式</a></li>
</ul>
<p>每个Pod都用于运行给定应用程序的单个实例。如果要水平扩展应用程序（例如，运行多个实例），则应使用多个Pod，每个实例一个。在Kubernetes中，这通常被称为复制。复制Pod通常由称为Controller的抽象创建和管理。有关更多信息，请参阅<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#pods-and-controllers" target="_blank" rel="noopener">Pod和控制器</a>。</p>
<h6 id="Pod如何管理多个容器"><a href="#Pod如何管理多个容器" class="headerlink" title="Pod如何管理多个容器"></a>Pod如何管理多个容器</h6><p>Pod旨在支持多个协作流程（作为容器），形成一个有凝聚力的服务单元。Pod中的容器自动位于群集中的同一物理或虚拟机上，并共同调度。容器可以共享资源和依赖关系，彼此通信，并协调它们何时以及如何终止。</p>
<p>请注意，在单个Pod中对多个共存和共同管理的容器进行分组是一个相对高级的用例。您应该仅在容器紧密耦合的特定实例中使用此模式。例如，您可能有一个容器充当共享卷中文件的Web服务器，以及一个单独的“sidecar”容器，用于从远程源更新这些文件，如下图所示：<br><img src="https://d33wubrfki0l68.cloudfront.net/aecab1f649bc640ebef1f05581bfcc91a48038c4/728d6/images/docs/pod.svg" alt="image"></p>
<p><strong>pod diagram</strong></p>
<p>Pod为其组成容器提供两种共享资源：网络和存储。</p>
<p><strong>联网</strong></p>
<p>每个Pod都分配有唯一的IP地址。Pod中的每个容器都共享网络命名空间，包括IP地址和网络端口。Pod内的容器可以使用相互通信<code>localhost</code>。当Pod中的容器与Pod 外部的实体通信时，它们必须协调它们如何使用共享网络资源（例如端口）。</p>
<p><strong>存储</strong></p>
<p>Pod可以指定一组共享存储卷。Pod中的所有容器都可以访问共享卷，允许这些容器共享数据。如果需要重新启动其中一个容器，则卷还允许Pod中的持久数据存活。见卷上Kubernetes如何实现一个pod里的共享存储更多的信息。</p>
<h5 id="使用Pods"><a href="#使用Pods" class="headerlink" title="使用Pods"></a>使用Pods</h5><p>你很少直接在Kubernetes - 甚至是单身Pod中创建单独的Pod。这是因为Pods被设计为相对短暂的一次性实体。当创建Pod（由您直接创建或由Controller间接创建）时，它将被安排在群集中的节点上运行。Pod保留在该节点上，直到进程终止，pod对象被删除，pod 因资源不足而被驱逐，或者Node失败。</p>
<blockquote>
<p>注意：不应将重新启动Pod重新启动Pod中的容器。Pod本身不会运行，但是容器运行的环境会持续存在，直到删除为止。</p>
</blockquote>
<p>pod本身不能自我修复。如果将Pod调度到失败的节点，或者调度操作本身失败，则删除Pod; 同样，由于缺乏资源或节点维护，Pod将无法在驱逐中存活。Kubernetes使用更高级别的抽象，称为Controller，它处理管理相对可处理的Pod实例的工作。因此，虽然可以直接使用Pod，但在Kubernetes中使用Controller管理pod更为常见。见<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#pods-and-controllers" target="_blank" rel="noopener">pod和控制器</a>上Kubernetes如何使用控制器来实现pod缩放和愈合的更多信息。</p>
<h6 id="pod和控制器"><a href="#pod和控制器" class="headerlink" title="pod和控制器"></a>pod和控制器</h6><p>Controller可以为您创建和管理多个Pod，处理复制和部署，并在集群范围内提供自我修复功能。例如，如果节点发生故障，Controller可能会通过在不同节点上安排相同的替换来自动替换Pod。</p>
<p>包含一个或多个pod的控制器的一些示例包括：</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">部署</a></li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">StatefulSet</a></li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">DaemonSet</a></li>
</ul>
<p>通常，控制器使用您提供的Pod模板来创建它负责的Pod。</p>
<h5 id="Pod模板"><a href="#Pod模板" class="headerlink" title="Pod模板"></a>Pod模板</h5><p>Pod模板是pod规范，包含在其他对象中，例如 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" target="_blank" rel="noopener">Replication Controllers</a>，<a href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/" target="_blank" rel="noopener">Jobs</a>和 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">DaemonSets</a>。控制器使用Pod模板制作实际的pod。下面的示例是Pod的简单清单，其中包含一个打印消息的容器。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: v1</span><br><span class="line"><span class="attribute">kind</span>: Pod</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">name</span>: myapp-pod</span><br><span class="line">  <span class="attribute">labels</span>:</span><br><span class="line">    <span class="attribute">app</span>: myapp</span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">containers</span>:</span><br><span class="line">  - <span class="attribute">name</span>: myapp-container</span><br><span class="line">    <span class="attribute">image</span>: busybox</span><br><span class="line">    <span class="attribute">command</span>: [<span class="string">'sh'</span>, <span class="string">'-c'</span>, <span class="string">'echo Hello Kubernetes! &amp;&amp; sleep 3600'</span>]</span><br></pre></td></tr></table></figure></p>
<p>pod模板不是指定所有副本的当前所需状态，而是像cookie 切割机。切割 cookie后，cookie与切割机无关。没有“量子纠缠”。对模板的后续更改甚至切换到新模板对已创建的pod没有直接影响。类似地，随后可以直接更新由复制控制器创建的pod。这与pod有意对比，pod确实指定了属于pod的所有容器的当前所需状态。这种方法从根本上简化了系统语义并增加了原语的灵活性。</p>
<h4 id="Pods-1"><a href="#Pods-1" class="headerlink" title="Pods"></a>Pods</h4><p>pods是可以创建和管理Kubernetes计算的最小可部署单元。</p>
<ul>
<li>什么是Pod？</li>
<li>pod的动机</li>
<li>pod的使用</li>
<li>考虑的替代方案</li>
<li>pod的耐久性（或缺乏）</li>
<li>终止pod</li>
<li>pod容器的特权模式</li>
<li>API对象</li>
</ul>
<h5 id="什么是Pod？"><a href="#什么是Pod？" class="headerlink" title="什么是Pod？"></a>什么是Pod？</h5><p>一个pod（如在whales或pea pod中）是一组一个或多个容器（如Docker容器），具有共享存储/网络，以及如何运行容器的规范。pod的内容始终位于同一位置并共同调度，并在共享上下文中运行。pod模拟特定于应用程序的“逻辑主机” - 它包含一个或多个相对紧密耦合的应用程序容器 - 在预容器世界中，在同一物理或虚拟机上执行意味着在同一逻辑主机上执行。</p>
<p>虽然Kubernetes支持的容器运行时间多于Docker，但Docker是最常见的运行时，它有助于用Docker术语描述pod。</p>
<p>pod的共享上下文是一组Linux命名空间，cgroup，以及可能的隔离方面 - 与隔离Docker容器相同的东西。在pod的上下文中，各个应用程序可能会应用进一步的子隔离。</p>
<p>Pod中的容器共享IP地址和端口空间，并且可以通过它们找到彼此localhost。他们还可以使用标准的进程间通信（如SystemV信号量或POSIX共享内存）相互通信。不同pod中的容器具有不同的IP地址，并且在没有<a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/" target="_blank" rel="noopener">特殊配置</a>的情况下无法通过IPC进行通信 。这些容器通常通过Pod IP地址相互通信。</p>
<p>pod中的应用程序还可以访问共享卷，共享卷被定义为pod的一部分，可以安装到每个应用程序的文件系统中。</p>
<p>就<a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a>构造而言，pod被建模为一组具有共享命名空间和共享<a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="noopener">卷</a>的Docker容器 。</p>
<p>与单个应用程序容器一样，pod被认为是相对短暂的（而不是持久的）实体。正如在pod的生命周期中所讨论的，创建pod，分配唯一ID（UID），并调度到它们保留的节点，直到终止（根据重启策略）或删除。如果节点终止，则在超时期限之后，将调度计划到该节点的Pod进行删除。给定的pod（由UID定义）不会“重新安排”到新节点; 相反，它可以被相同的pod替换，如果需要，甚至可以使用相同的名称，但是使用新的UID（有关更多详细信息，请参阅<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" target="_blank" rel="noopener">复制控制器</a>）。</p>
<p>当某些东西被认为具有与容量相同的生命周期时，例如卷，这意味着只要该容器（具有该UID）存在就存在。如果由于任何原因删除了该pod，即使创建了相同的替换，相关的东西（例如卷）也会被销毁并重新创建。<br><img src="https://d33wubrfki0l68.cloudfront.net/aecab1f649bc640ebef1f05581bfcc91a48038c4/728d6/images/docs/pod.svg" alt="image"></p>
<h6 id="pod图"><a href="#pod图" class="headerlink" title="pod图"></a>pod图</h6><p>一个多容器窗格，包含文件提取程序和Web服务器，该服务器使用持久卷在容器之间共享存储。</p>
<h5 id="pod的动机"><a href="#pod的动机" class="headerlink" title="pod的动机"></a>pod的动机</h5><h6 id="管理-1"><a href="#管理-1" class="headerlink" title="管理"></a>管理</h6><p>Pod是多个合作过程模式的模型，形成了一个有凝聚力的服务单元。它们通过提供比其组成应用程序集更高级别的抽象来简化应用程序部署和管理。Pod用作部署，水平扩展和复制的单元。对容器中的容器自动处理共置（共同调度），共享命运（例如终止），协调复制，资源共享和依赖关系管理。</p>
<h6 id="资源共享和沟通"><a href="#资源共享和沟通" class="headerlink" title="资源共享和沟通"></a>资源共享和沟通</h6><p>Pod可以实现其成员之间的数据共享和通信。</p>
<p>pod中的应用程序都使用相同的网络命名空间（相同的IP和端口空间），因此可以相互“找到”并使用它们进行通信<code>localhost</code>。因此，pod中的应用程序必须协调它们对端口的使用。每个pod在平面共享网络空间中具有IP地址，该网络空间与网络上的其他物理计算机和pod完全通信。</p>
<p>主机名设置为pod中应用程序容器的pod名称。<a href="https://kubernetes.io/docs/concepts/cluster-administration/networking/" target="_blank" rel="noopener">关于网络的更多细节</a>。</p>
<p>除了定义在pod中运行的应用程序容器之外，pod还指定了一组共享存储卷。卷使数据能够在容器重新启动后继续存在，并在容器内的应用程序之间共享。</p>
<h5 id="pod的使用"><a href="#pod的使用" class="headerlink" title="pod的使用"></a>pod的使用</h5><p>Pod可用于托管垂直集成的应用程序堆栈（例如LAMP），但其主要动机是支持共址，共同管理的帮助程序，例如：</p>
<ul>
<li>内容管理系统，文件和数据加载器，本地缓存管理器等。</li>
<li>日志和检查点备份，压缩，旋转，快照等</li>
<li>数据变更观察者，日志零售商，日志和监控适配器，活动发布者等。</li>
<li>代理，网桥和适配器</li>
<li>控制器，管理器，配置器和更新器</li>
</ul>
<p>通常，单个pod不用于运行同一应用程序的多个实例。</p>
<p>有关更长的说明，请参阅<a href="https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns" target="_blank" rel="noopener">分布式系统工具包：复合容器的模式</a>。</p>
<h5 id="考虑的替代方案"><a href="#考虑的替代方案" class="headerlink" title="考虑的替代方案"></a>考虑的替代方案</h5><p>为什么不在一个（Docker）容器中运行多个程序？</p>
<ol>
<li>透明度。使基础架构内的容器对基础架构可见，使基础架构能够为这些容器提供服务，例如进程管理和资源监视。这为用户提供了许多便利。</li>
<li>解耦软件依赖关系。各个容器可以独立地进行版本化，重建和重新部署。Kubernetes甚至有一天可能会支持单个容器的实时更新。</li>
<li>便于使用。用户无需运行自己的流程管理器，担心信号和退出代码传播等。</li>
<li>效率。由于基础设施承担更多责任，因此集装箱的重量可以更轻。</li>
</ol>
<p>为什么不支持基于亲和力的容器协同调度？</p>
<p>这种方法可以提供协同定位，但不会提供pod的大部分好处，例如资源共享，IPC，保证命运共享和简化管理。</p>
<h5 id="pod的耐久性（或缺乏）"><a href="#pod的耐久性（或缺乏）" class="headerlink" title="pod的耐久性（或缺乏）"></a>pod的耐久性（或缺乏）</h5><p>pod不应被视为耐用实体。它们将无法在调度故障，节点故障或其他驱逐（例如由于缺乏资源）或节点维护的情况下存活。</p>
<p>通常，用户不需要直接创建pod。他们应该几乎总是使用控制器，即使是singletons，例如， <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">部署</a>。控制器提供集群范围的自我修复，以及复制和部署管理。像<a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset.md" target="_blank" rel="noopener">StatefulSet</a>这样的控制器 也可以为有状态的pod提供支持。</p>
<p>使用集合API作为主要的面向用户的原语在集群调度系统中相对常见，包括<a href="https://research.google.com/pubs/pub43438.html" target="_blank" rel="noopener">Borg</a>，<a href="https://mesosphere.github.io/marathon/docs/rest-api.html" target="_blank" rel="noopener">Marathon</a>，<a href="http://aurora.apache.org/documentation/latest/reference/configuration/#job-schema" target="_blank" rel="noopener">Aurora</a>和<a href="http://www.slideshare.net/Docker/aravindnarayanan-facebook140613153626phpapp02-37588997" target="_blank" rel="noopener">Tupperware</a>。</p>
<p>Pod作为基元公开，以便于：</p>
<ul>
<li>调度程序和控制器可插拔性</li>
<li>支持pod级操作，无需通过控制器API“代理”它们</li>
<li>pod生命周期与控制器生命周期的解耦，例如引导</li>
<li>控制器和服务的分离 - 端点控制器只是监视pod</li>
<li>具有集群级功能的Kubelet级功能的清晰组合 - Kubelet实际上是“pod控制器”</li>
<li>高可用性应用程序，它们将期望在终止之前更换pod，并且肯定在删除之前，例如在计划驱逐或图像预取的情况下。</li>
</ul>
<h5 id="终止pod"><a href="#终止pod" class="headerlink" title="终止pod"></a>终止pod</h5><p>因为pod表示集群中节点上的正在运行的进程，所以允许这些进程在不再需要时优雅地终止（与使用KILL信号猛烈杀死并且没有机会清理）非常重要。用户应该能够请求删除并知道进程何时终止，但也能够确保删除最终完成。当用户请求删除pod时，系统会在允许pod强制终止之前记录预期的宽限期，并将TERM信号发送到每个容器中的主进程。宽限期到期后，KILL信号将发送到这些进程，然后从API服务器中删除该pod。如果在等待进程终止时重新启动Kubelet或容器管理器，</p>
<p>一个示例流程：</p>
<ol>
<li>用户发送删除Pod的命令，默认宽限期（30秒）</li>
<li>API服务器中的Pod随着时间的推移而更新，其中Pod被视为“死”以及宽限期。</li>
<li>在客户端命令中列出时，Pod显示为“终止”</li>
<li>（与3同时）当Kubelet看到Pod已被标记为终止，因为已经设置了2中的时间，它开始了pod关闭过程。<ol>
<li>如果其中一个Pod的容器定义了一个<a href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#hook-details" target="_blank" rel="noopener">preStop挂钩</a>，则会在容器内部调用它。如果在<code>preStop</code>宽限期到期后钩子仍在运行，则以小（2秒）延长的宽限期调用步骤2。</li>
<li>容器被发送TERM信号。请注意，并非Pod中的所有容器都会同时收到TERM信号，并且<code>preStop</code>如果它们关闭的顺序很重要，则每个容器都需要一个钩子。</li>
</ol>
</li>
<li>（与3同时）Pod从端点列表中删除以进行维护，并且不再被视为复制控制器的运行pod集的一部分。缓慢关闭的窗格无法继续提供流量，因为负载平衡器（如服务代理）会将其从旋转中移除。</li>
<li>当宽限期到期时，仍然在Pod中运行的任何进程都将被SIGKILL杀死。</li>
<li>Kubelet将通过设置宽限期0（立即删除）完成删除API服务器上的Pod。Pod从API中消失，不再从客户端可见。</li>
</ol>
<p>默认情况下，所有删除在30秒内都是正常的。该<code>kubectl delete</code>命令支持<code>--grace-period=&lt;seconds&gt;</code>允许用户覆盖默认值并指定其自己的值的选项。值<code>0</code><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/#force-deletion-of-pods" target="_blank" rel="noopener">force删除</a> pod。在kubectl版本&gt; = 1.5时，必须指定一个额外的标志<code>--force</code>一起<code>--grace-period=0</code>，以执行力的缺失。</p>
<h6 id="强制删除pod"><a href="#强制删除pod" class="headerlink" title="强制删除pod"></a>强制删除pod</h6><p>强制删除pod被定义为立即从群集状态和etcd删除pod。当执行强制删除时，许可证持有者不会等待来自kubelet的确认该pod已在其运行的节点上终止。它会立即删除API中的pod，以便可以使用相同的名称创建新的pod。在节点上，设置为立即终止的pod在被强制终止之前仍将被给予一个小的宽限期。</p>
<p>强制删除可能对某些pod有潜在危险，应谨慎执行。如果是StatefulSet pod，请参阅任务文档以<a href="https://kubernetes.io/docs/tasks/run-application/force-delete-stateful-set-pod/" target="_blank" rel="noopener">从StatefulSet中删除</a> Pod 。</p>
<h5 id="pod容器的特权模式"><a href="#pod容器的特权模式" class="headerlink" title="pod容器的特权模式"></a>pod容器的特权模式</h5><p>从Kubernetes v1.1开始，pod中的任何容器都可以使用容器规范中的<code>privileged</code>标志启用特权模式<code>SecurityContext</code>。这对于想要使用Linux功能（如操作网络堆栈和访问设备）的容器非常有用。容器内的进程获得与容器外部进程可用的几乎相同的权限。使用特权模式，将网络和卷插件编写为不需要编译到kubelet的独立窗格应该更容易。</p>
<p>如果主服务器正在运行Kubernetes v1.1或更高版本，并且节点运行的版本低于v1.1，那么api-server将接受新的特权pod，但不会启动。他们将处于待决状态。如果用户呼叫<code>kubectl describe pod FooPodName</code>，用户可以查看pod处于暂挂状态的原因。describe命令输出中的events表将说：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error </span>validating pod "FooPodName"."FooPodNamespace" from api, ignoring: spec.containers[0].securityContext.privileged: forbidden '&lt;*&gt;(0xc2089d3248)true'</span><br></pre></td></tr></table></figure></p>
<p>如果主服务器运行的版本低于v1.1，则无法创建特权pod。如果用户尝试创建具有特权容器的pod，则用户将收到以下错误：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Pod <span class="string">"FooPodName"</span> is invalid. spec<span class="selector-class">.containers</span>[<span class="number">0</span>]<span class="selector-class">.securityContext</span><span class="selector-class">.privileged</span>: forbidden <span class="string">'&lt;*&gt;(0xc20b222db0)true'</span></span><br></pre></td></tr></table></figure></p>
<h5 id="API对象-1"><a href="#API对象-1" class="headerlink" title="API对象"></a>API对象</h5><p>Pod是Kubernetes REST API中的顶级资源。有关API对象的更多详细信息，请参阅： <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#pod-v1-core" target="_blank" rel="noopener">Pod API对象</a>。</p>
<h4 id="Pod生命周期"><a href="#Pod生命周期" class="headerlink" title="Pod生命周期"></a>Pod生命周期</h4><p>该页面描述了Pod的生命周期。</p>
<ul>
<li>Pod阶段</li>
<li>Pod条件</li>
<li>容器探针</li>
<li>Pod和Container状态</li>
<li>Pod准备gate</li>
<li>重启政策</li>
<li>Pod寿命</li>
<li>例子</li>
</ul>
<h5 id="Pod阶段"><a href="#Pod阶段" class="headerlink" title="Pod阶段"></a>Pod阶段</h5><p>Pod的<code>status</code>字段是 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#podstatus-v1-core" target="_blank" rel="noopener">PodStatus</a> 对象，它有一个<code>phase</code>字段。</p>
<p>Pod的阶段是Pod在其生命周期中的简单，高级摘要。该阶段不是对Container或Pod状态的全面观察汇总，也不是一个综合状态机。</p>
<p>Pod阶段值的数量和含义受到严密保护。除了这里记录的内容之外，没有任何关于具有给定<code>phase</code>值的Pod的假设。</p>
<p>以下是可能的值<code>phase</code>：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Pending</code></td>
<td>Pod已被Kubernetes系统接受，但尚未创建一个或多个Container图像。这包括计划之前的时间以及通过网络下载图像所花费的时间，这可能需要一段时间。</td>
</tr>
<tr>
<td><code>Running</code></td>
<td>Pod已绑定到节点，并且已创建所有Container。至少有一个Container仍在运行，或者正在启动或重新启动。</td>
</tr>
<tr>
<td><code>Succeeded</code></td>
<td>Pod中的所有容器都已成功终止，并且不会重新启动。</td>
</tr>
<tr>
<td><code>Failed</code></td>
<td>Pod中的所有容器都已终止，并且至少有一个Container已终止失败。也就是说，Container要么退出非零状态，要么被系统终止。</td>
</tr>
<tr>
<td><code>Unknown</code></td>
<td>由于某种原因，无法获得Pod的状态，这通常是由于与Pod的主机通信时出错。</td>
</tr>
</tbody>
</table>
<h5 id="Pod条件"><a href="#Pod条件" class="headerlink" title="Pod条件"></a>Pod条件</h5><p>Pod有一个PodStatus，它有一个<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#podcondition-v1-core" target="_blank" rel="noopener">PodConditions</a>数组， Pod已经或没有通过它。PodCondition数组的每个元素都有六个可能的字段：</p>
<ul>
<li>该<code>lastProbeTime</code>字段提供上次探测Pod条件的时间戳。</li>
<li>该<code>lastTransitionTime</code>字段提供Pod最后从一个状态转换到另一个状态的时间戳。</li>
<li>该<code>message</code>字段是人类可读的消息，指示有关转换的详细信息。</li>
<li>该<code>reason</code>字段是该条件最后一次转换的唯一，单字，CamelCase原因。</li>
<li>该<code>status</code>字段是一个字符串，可能的值为“ <code>True</code>”，“ <code>False</code>”和“ <code>Unknown</code>”。</li>
<li>该<code>type</code>字段是一个包含以下可能值的字符串：<ul>
<li><code>PodScheduled</code>：Pod已被安排到一个节点;</li>
<li><code>Ready</code>：Pod可以提供请求，应该添加到所有匹配服务的负载平衡池中;</li>
<li><code>Initialized</code>：所有<a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers" target="_blank" rel="noopener">init容器</a> 都已成功启动;</li>
<li><code>Unschedulable</code>：调度程序现在无法调度Pod，例如由于缺少资源或其他限制;</li>
<li><code>ContainersReady</code>：Pod中的所有容器都已准备就绪。</li>
</ul>
</li>
</ul>
<h5 id="容器探针"><a href="#容器探针" class="headerlink" title="容器探针"></a>容器探针</h5><p>一个<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#probe-v1-core" target="_blank" rel="noopener">探头</a>是通过周期性地执行的诊断<a href="https://kubernetes.io/docs/admin/kubelet/" target="_blank" rel="noopener">kubelet </a>上的容器。为了执行诊断，kubelet调用Container实现的 <a href="https://godoc.org/k8s.io/kubernetes/pkg/api/v1#Handler" target="_blank" rel="noopener">Handler</a>。有三种类型的处理程序：</p>
<ul>
<li><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#execaction-v1-core" target="_blank" rel="noopener">ExecAction</a>：在Container内执行指定的命令。如果命令以状态代码0退出，则认为诊断成功。</li>
<li><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#tcpsocketaction-v1-core" target="_blank" rel="noopener">TCPSocketAction</a>：对指定端口上的Container的IP地址执行TCP检查。如果端口打开，则诊断被认为是成功的。</li>
<li><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#httpgetaction-v1-core" target="_blank" rel="noopener">HTTPGetAction</a>：对指定端口和路径上的Container的IP地址执行HTTP Get请求。如果响应的状态代码大于或等于200且小于400，则认为诊断成功。</li>
</ul>
<p>每个探针都有三个结果之一：</p>
<ul>
<li>成功：Container通过了诊断。</li>
<li>失败：容器未通过诊断。</li>
<li>未知：诊断失败，因此不应采取任何措施。</li>
</ul>
<p>在运行容器时，kubelet可以选择性地执行和响应两种探测器：</p>
<ul>
<li><code>livenessProbe</code>：指示Container是否正在运行。如果活动探测失败，则kubelet会杀死Container，并且Container将受其重启策略的约束。如果Container未提供活动探测，则默认状态为<code>Success</code>。</li>
<li><code>readinessProbe</code>：指示Container是否已准备好为请求提供服务。如果准备就绪探测失败，则端点控制器会从与Pod匹配的所有服务的端点中删除Pod的IP地址。初始延迟之前的默认准备状态是<code>Failure</code>。如果Container未提供就绪探测，则默认状态为<code>Success</code>。</li>
</ul>
<h5 id="什么时候应该使用活力或准备探针？"><a href="#什么时候应该使用活力或准备探针？" class="headerlink" title="什么时候应该使用活力或准备探针？"></a>什么时候应该使用活力或准备探针？</h5><p>如果您的Container中的进程在遇到问题或变得不健康时能够自行崩溃，则您不一定需要活动探测器; kubelet将根据Pod的内容自动执行正确的操作<code>restartPolicy</code>。</p>
<p>如果您希望在探测失败时杀死并重新启动Container，则指定活动探测，并指定<code>restartPolicy</code>Always或OnFailure。</p>
<p>如果您只想在探测成功时开始向Pod发送流量，请指定准备探测。在这种情况下，准备情况探测可能与活动探测相同，但规范中存在准备探测意味着Pod将在不接收任何流量的情况下启动，并且仅在探测开始成功后才开始接收流量。</p>
<p>如果Container需要在启动期间处理大型数据，配置文件或迁移，请指定就绪性探针。</p>
<p>如果您希望Container能够自行维护，您可以指定一个就绪探针，用于检查特定于就绪状态的端点，该端点与活动探针不同。</p>
<p>请注意，如果您只想在删除Pod时排除请求，则不一定需要准备探测; 在删除时，无论准备情况探测是否存在，Pod都会自动将其置于未准备状态。Pod在等待Pod中的容器停止时仍处于未准备状态。</p>
<p>有关如何设置活动或准备情况探测的详细信息，请参阅 <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" target="_blank" rel="noopener">配置活动和准备探测</a>。</p>
<h5 id="Pod和Container状态"><a href="#Pod和Container状态" class="headerlink" title="Pod和Container状态"></a>Pod和Container状态</h5><p>有关Pod容器状态的详细信息，请参阅 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#podstatus-v1-core" target="_blank" rel="noopener">PodStatus </a>和 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#containerstatus-v1-core" target="_blank" rel="noopener">ContainerStatus</a>。请注意，报告为Pod状态的信息取决于当前的 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#containerstatus-v1-core" target="_blank" rel="noopener">ContainerState</a>。</p>
<h5 id="Pod准备gate"><a href="#Pod准备gate" class="headerlink" title="Pod准备gate"></a>Pod准备gate</h5><p>特征状态： <code>Kubernetes v1.12</code></p>
<blockquote>
<p>此功能目前处于测试状态</p>
</blockquote>
<p>为了通过注入额外的反馈或信号来增加Pod准备的可扩展性<code>PodStatus</code>，Kubernetes 1.11引入了一个名为<a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/0007-pod-ready%2B%2B.md" target="_blank" rel="noopener">Pod ready ++</a>的功能。您可以使用新的字段<code>ReadinessGate</code>中<code>PodSpec</code>指定波德准备进行评估附加条件。如果Kubernetes在<code>status.conditionsPod</code> 的字段中找不到这样的条件，则条件的状态默认为“ <code>False</code>”。以下是一个例子：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  readinessGates:</span></span><br><span class="line"><span class="attr">    - conditionType:</span> <span class="string">"www.example.com/feature-1"</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line"><span class="attr">  conditions:</span></span><br><span class="line"><span class="attr">    - type:</span> <span class="string">Ready</span>  <span class="comment"># this is a builtin PodCondition</span></span><br><span class="line"><span class="attr">      status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">      lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">      lastTransitionTime:</span> <span class="number">2018</span><span class="bullet">-01</span><span class="bullet">-01</span><span class="attr">T00:00:00Z</span></span><br><span class="line"><span class="attr">    - type:</span> <span class="string">"www.example.com/feature-1"</span>   <span class="comment"># an extra PodCondition</span></span><br><span class="line"><span class="attr">      status:</span> <span class="string">"False"</span></span><br><span class="line"><span class="attr">      lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">      lastTransitionTime:</span> <span class="number">2018</span><span class="bullet">-01</span><span class="bullet">-01</span><span class="attr">T00:00:00Z</span></span><br><span class="line"><span class="attr">  containerStatuses:</span></span><br><span class="line"><span class="attr">    - containerID:</span> <span class="attr">docker://abcd...</span></span><br><span class="line"><span class="attr">      ready:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure></p>
<p>新Pod条件必须符合Kubernetes <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set" target="_blank" rel="noopener">标签密钥格式</a>。由于该<code>kubectl patch</code>命令仍然不支持修补对象状态，因此必须<code>PATCH</code>使用其中一个<a href="https://kubernetes.io/docs/reference/using-api/client-libraries/" target="_blank" rel="noopener">KubeClient库</a>通过操作注入新的Pod条件。</p>
<p>随着新Pod条件的引入，<strong>只有</strong> 当以下两个语句都成立时，<strong>才会</strong>评估Pod是否就绪：</p>
<ul>
<li>Pod中的所有容器都已准备就绪。</li>
<li>指定的所有条件<code>ReadinessGates</code>均为“ <code>True</code>”。</li>
</ul>
<p>为了便于对Pod准备评估进行此更改，<code>ContainersReady</code>引入了一个新的Pod条件 来捕获旧的Pod <code>Ready</code>条件。</p>
<p>在K8s 1.11中，作为alpha功能，必须通过将<code>PodReadinessGates</code> 功能门设置 为true 来明确启用“Pod Ready ++”功能。</p>
<p>在K8s 1.12中，默认情况下启用该功能。</p>
<h5 id="重启政策"><a href="#重启政策" class="headerlink" title="重启政策"></a>重启政策</h5><p>PodSpec的<code>restartPolicy</code>字段可能包含Always，OnFailure和Never。默认值为Always。 <code>restartPolicy</code>适用于Pod中的所有容器。<code>restartPolicy</code>仅指由同一节点上的kubelet重新启动Container。由kubelet重新启动的已退出容器将以指数退避延迟（10秒，20秒，40秒……）重新启动，上限为五分钟，并在成功执行十分钟后重置。正如<a href="https://kubernetes.io/docs/user-guide/pods/#durability-of-pods-or-lack-thereof" target="_blank" rel="noopener">Pods文档</a>中所讨论的 ，一旦绑定到节点，Pod将永远不会被反弹到另一个节点。</p>
<h5 id="Pod寿命"><a href="#Pod寿命" class="headerlink" title="Pod寿命"></a>Pod寿命</h5><p>一般来说，pod不会消失，直到有人摧毁它们。这可能是人或控制者。此规则的唯一例外是具有<code>phase</code>成功或失败超过一定持续时间（由<code>terminated-pod-gc-threshold</code>master确定）的Pod将过期并自动销毁。</p>
<p>有三种控制器可供选择：</p>
<ul>
<li>使用<a href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/" target="_blank" rel="noopener">Job</a> for Pods预期终止，例如批量计算。作业仅适用于 <code>restartPolicy</code>等于OnFailure或Never的Pod。</li>
<li>对不希望终止的<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">Pod</a>（例如，Web服务器）使用<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" target="_blank" rel="noopener">ReplicationController</a>， <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">ReplicaSet</a>或 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployment</a>。ReplicationControllers仅适用于具有<code>restartPolicy</code>Always的Pod。</li>
<li>使用需要为每台计算机运行一个的<a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">Pod的DaemonSet</a>，因为它们提供特定于计算机的系统服务。</li>
</ul>
<p>所有三种类型的控制器都包含PodTemplate。建议创建适当的控制器并让它创建Pod，而不是自己直接创建Pod。这是因为Pods单独对机器故障没有弹性，但是控制器是。</p>
<p>如果节点死亡或与群集的其余部分断开连接，Kubernetes会应用策略<code>phase</code>将丢失节点上的所有Pod设置为Failed。</p>
<h5 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h5><h6 id="高级活动探测示例"><a href="#高级活动探测示例" class="headerlink" title="高级活动探测示例"></a>高级活动探测示例</h6><p>活动探测由kubelet执行，因此所有请求都在kubelet网络名称空间中进行。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">apiVersion:</span> v1</span><br><span class="line"><span class="symbol">kind:</span> Pod</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  labels:</span></span><br><span class="line"><span class="symbol">    test:</span> liveness</span><br><span class="line"><span class="symbol">  name:</span> liveness-http</span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  containers:</span></span><br><span class="line">  - args:</span><br><span class="line">    - /server</span><br><span class="line"><span class="symbol">    image:</span> k8s.gcr.io/liveness</span><br><span class="line"><span class="symbol">    livenessProbe:</span></span><br><span class="line"><span class="symbol">      httpGet:</span></span><br><span class="line">        <span class="meta"># when <span class="string">"host"</span> is not defined, <span class="string">"PodIP"</span> will be used</span></span><br><span class="line">        <span class="meta"># host: my-host</span></span><br><span class="line">        <span class="meta"># when <span class="string">"scheme"</span> is not defined, <span class="string">"HTTP"</span> scheme will be used. Only <span class="string">"HTTP"</span> and <span class="string">"HTTPS"</span> are allowed</span></span><br><span class="line">        <span class="meta"># scheme: HTTPS</span></span><br><span class="line"><span class="symbol">        path:</span> /healthz</span><br><span class="line"><span class="symbol">        port:</span> <span class="number">8080</span></span><br><span class="line"><span class="symbol">        httpHeaders:</span></span><br><span class="line">        - name: X-Custom-Header</span><br><span class="line"><span class="symbol">          value:</span> Awesome</span><br><span class="line"><span class="symbol">      initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line"><span class="symbol">      timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">    name:</span> liveness</span><br></pre></td></tr></table></figure></p>
<h6 id="示例状态"><a href="#示例状态" class="headerlink" title="示例状态"></a>示例状态</h6><ul>
<li>Pod正在运行并有一个Container。集装箱出口成功。<ul>
<li>记录完成事件。</li>
<li>如果<code>restartPolicy</code>是：<ul>
<li>始终：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>OnFailure：Pod <code>phase</code>成功。</li>
<li>从不：Pod <code>phase</code>成功。</li>
</ul>
</li>
</ul>
</li>
<li>Pod正在运行并有一个Container。容器退出失败。<ul>
<li>记录失败事件。</li>
<li>如果<code>restartPolicy</code>是：<ul>
<li>始终：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>OnFailure：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>从不：Pod <code>phase</code>变得失败。</li>
</ul>
</li>
</ul>
</li>
<li>Pod正在运行并有两个容器。容器1出现故障。<ul>
<li>记录失败事件。</li>
<li>如果<code>restartPolicy</code>是：<ul>
<li>始终：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>OnFailure：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>从不：不要重启容器; Pod <code>phase</code>保持运行状态。</li>
</ul>
</li>
<li>如果Container 1未运行，并且Container 2退出：<ul>
<li>记录失败事件。</li>
<li>如果<code>restartPolicy</code>是：<ul>
<li>始终：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>OnFailure：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>从不：Pod <code>phase</code>变得失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Pod正在运行并有一个Container。容器耗尽内存。<ul>
<li>记录失败事件。</li>
<li>记录OOM事件。</li>
<li>如果<code>restartPolicy</code>是：<ul>
<li>始终：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>OnFailure：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>从不：记录失败事件; Pod <code>phase</code>保持运行状态。</li>
</ul>
</li>
</ul>
</li>
<li>Pod正在运行，磁盘已经死亡。<ul>
<li>杀死所有容器。</li>
<li>记录适当的事件。</li>
<li>Pod <code>phase</code>变得失败。</li>
<li>如果在控制器下运行，Pod将在其他位置重新创建。</li>
</ul>
</li>
<li>Pod正在运行，其节点已分段。<ul>
<li>杀死所有容器。</li>
<li>记录适当的事件。</li>
<li>Pod <code>phase</code>变得失败。</li>
<li>如果在控制器下运行，Pod将在其他位置重新创建。</li>
</ul>
</li>
</ul>
<h4 id="初始容器"><a href="#初始容器" class="headerlink" title="初始容器"></a>初始容器</h4><p>此页面提供了Init Containers的概述，它是在应用程序容器之前运行的专用容器，可以包含应用程序映像中不存在的实用程序或设置脚本。</p>
<ul>
<li>了解Init容器</li>
<li>Init容器可以用于什么？</li>
<li>详细的行为</li>
<li>支持和兼容性</li>
</ul>
<h5 id="了解Init容器"><a href="#了解Init容器" class="headerlink" title="了解Init容器"></a>了解Init容器</h5><p>一个<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener">pod</a>能够在其内运行的应用程序的多个容器，但它也可以有一个或多个初始化容器，该容器的应用容器启动之前运行。</p>
<p>Init容器与常规容器完全相同，除了：</p>
<ul>
<li>他们总是跑完成。</li>
<li>每个人必须在下一个启动之前成功完成。</li>
</ul>
<p>如果Init容器的Init容器失败，Kubernetes会重复重启Pod，直到Init容器成功。但是，如果Pod具有<code>restartPolicy</code>Never，则不会重新启动。</p>
<p>要将Container指定为Init容器，请将<code>initContainers</code>PodSpec上的字段添加 为应用程序数组旁边的<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#container-v1-core" target="_blank" rel="noopener">Container</a>类型的JSON containers数组。init容器的状态在<code>.status.initContainerStatuses</code>字段中作为容器状态的数组返回（类似于<code>.status.containerStatuses</code>字段）。</p>
<h6 id="与常规容器的差异"><a href="#与常规容器的差异" class="headerlink" title="与常规容器的差异"></a>与常规容器的差异</h6><p>Init Containers支持应用容器的所有字段和功能，包括资源限制，卷和安全设置。但是，Init容器的资源请求和限制的处理方式略有不同，这些内容在下面的<a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#resources" target="_blank" rel="noopener">参考资料</a>中有说明。此外，Init Containers不支持就绪探针，因为它们必须在Pod准备好之前运行完成。</p>
<p>如果为Pod指定了多个Init容器，则按顺序一次运行一个Container。每一个都必须在下一次运行之前成功。当所有Init容器都运行完成后，Kubernetes会初始化Pod并像往常一样运行应用程序容器。</p>
<h5 id="Init容器可以用于什么？"><a href="#Init容器可以用于什么？" class="headerlink" title="Init容器可以用于什么？"></a>Init容器可以用于什么？</h5><p>由于Init Containers具有来自应用容器的单独镜像，因此它们对于启动相关代码具有一些优势：</p>
<ul>
<li>出于安全原因，它们可以包含并运行不希望包含在应用容器镜像中的实用程序。</li>
<li>它们可以包含应用程序镜像中不存在的用于设置的实用程序或自定义代码。例如，没有必要使镜像<code>FROM</code>的另一个镜像只使用像工具 <code>sed</code>，<code>awk</code>，<code>python</code>，或<code>dig</code>在安装过程中。</li>
<li>应用程序映像构建器和部署者角色可以独立工作，而无需共同构建单个应用程序镜像。</li>
<li>他们使用Linux命名空间，以便他们从应用程序容器中获得不同的文件系统视图。因此，他们可以访问应用容器无法访问的秘密。</li>
<li>它们在任何应用程序容器启动之前运行完成，而应用程序容器并行运行，因此Init容器提供了一种简单的方法来阻止或延迟应用容器的启动，直到满足一组前置条件。</li>
</ul>
<h6 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h6><p>以下是有关如何使用Init Containers的一些想法：</p>
<ul>
<li>等待使用shell命令创建服务，例如：</li>
<li>我在{1..100}; 做睡觉1; 如果挖我的服务; 然后退出0; 网络连接; 完成; 退出1</li>
<li><p>使用以下命令从向下API向远程服务器注册此Pod：</p>
<p>  curl -X POST http：// $ MANAGEMENT_SERVICE_HOST：$ MANAGEMENT_SERVICE_PORT / register -d’instal = $（）IP = $（）”</p>
</li>
<li>等待一段时间，然后使用类似命令启动app Container <code>sleep 60</code>。</li>
<li>将git存储库克隆到卷中。</li>
<li>将值放入配置文件并运行模板工具以动态生成主应用程序Container的配置文件。例如，将POD_IP值放在配置中，并使用Jinja生成主应用程序配置文件。</li>
</ul>
<p>可以在<a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">StatefulSets</a>文档 和<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-initialization/" target="_blank" rel="noopener">Production Pods指南</a>中找到更详细的用法示例。</p>
<h6 id="初始容器正在使用中"><a href="#初始容器正在使用中" class="headerlink" title="初始容器正在使用中"></a>初始容器正在使用中</h6><p>以下针对Kubernetes 1.5的yaml文件概述了一个具有两个Init容器的简单Pod。第一个等待，<code>myservice</code>第二个等待<code>mydb</code>。一旦两个容器完成，Pod就会开始。<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-pod</span><br><span class="line">  labels:</span><br><span class="line">    app: myapp</span><br><span class="line">  annotations:</span><br><span class="line">    pod.beta.kubernetes.io/init-containers: <span class="string">'[</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            "</span>name<span class="string">": "</span>init-myservice<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>image<span class="string">": "</span>busybox<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>command<span class="string">": ["</span>sh<span class="string">", "</span>-c<span class="string">", "</span>until nslookup myservice; <span class="keyword">do</span> echo waiting <span class="keyword">for</span> myservice; sleep <span class="number">2</span>; done;<span class="string">"]</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            "</span>name<span class="string">": "</span>init-mydb<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>image<span class="string">": "</span>busybox<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>command<span class="string">": ["</span>sh<span class="string">", "</span>-c<span class="string">", "</span>until nslookup mydb; <span class="keyword">do</span> echo waiting <span class="keyword">for</span> mydb; sleep <span class="number">2</span>; done;<span class="string">"]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]'</span></span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp-container</span><br><span class="line">    image: busybox</span><br><span class="line">    command: [<span class="string">'sh'</span>, <span class="string">'-c'</span>, <span class="string">'echo The app is running! &amp;&amp; sleep 3600'</span>]</span><br></pre></td></tr></table></figure></p>
<p>Kubernetes 1.6中有一种新语法，尽管旧的注释语法仍适用于1.6和1.7。新语法必须用于1.8或更高版本。我们已将Init Containers的声明移至<code>spec</code>：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: v1</span><br><span class="line"><span class="attribute">kind</span>: Pod</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">name</span>: myapp-pod</span><br><span class="line">  <span class="attribute">labels</span>:</span><br><span class="line">    <span class="attribute">app</span>: myapp</span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">containers</span>:</span><br><span class="line">  - <span class="attribute">name</span>: myapp-container</span><br><span class="line">    <span class="attribute">image</span>: busybox</span><br><span class="line">    <span class="attribute">command</span>: [<span class="string">'sh'</span>, <span class="string">'-c'</span>, <span class="string">'echo The app is running! &amp;&amp; sleep 3600'</span>]</span><br><span class="line">  <span class="attribute">initContainers</span>:</span><br><span class="line">  - <span class="attribute">name</span>: init-myservice</span><br><span class="line">    <span class="attribute">image</span>: busybox</span><br><span class="line">    <span class="attribute">command</span>: [<span class="string">'sh'</span>, <span class="string">'-c'</span>, <span class="string">'until nslookup myservice; do echo waiting for myservice; sleep 2; done;'</span>]</span><br><span class="line">  - <span class="attribute">name</span>: init-mydb</span><br><span class="line">    <span class="attribute">image</span>: busybox</span><br><span class="line">    <span class="attribute">command</span>: [<span class="string">'sh'</span>, <span class="string">'-c'</span>, <span class="string">'until nslookup mydb; do echo waiting for mydb; sleep 2; done;'</span>]</span><br></pre></td></tr></table></figure></p>
<p>1.5语法仍适用于1.6，但我们建议使用1.6语法。在Kubernetes 1.6中，Init Containers在API中成为了一个领域。beta注释在1.6和1.7中仍然受到尊重，但在1.8或更高版本中不受支持。</p>
<p>下面YAML文件概述了<code>mydb</code>与<code>myservice</code>服务：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myservice</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">9376</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mydb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">9377</span></span><br></pre></td></tr></table></figure></p>
<p>可以使用以下命令启动和调试此Pod：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f myapp.yaml</span><br><span class="line">pod/myapp-pod created</span><br><span class="line">$ kubectl <span class="builtin-name">get</span> -f myapp.yaml</span><br><span class="line">NAME        READY     STATUS     RESTARTS   AGE</span><br><span class="line">myapp-pod   0/1       Init:0/2   0          6m</span><br><span class="line">$ kubectl describe -f myapp.yaml</span><br><span class="line">Name:          myapp-pod</span><br><span class="line">Namespace:     default</span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">Labels:        <span class="attribute">app</span>=myapp</span><br><span class="line">Status:        Pending</span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">Init Containers:</span><br><span class="line">  init-myservice:</span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">    State:         Running</span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">  init-mydb:</span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">    State:         Waiting</span><br><span class="line">      Reason:      PodInitializing</span><br><span class="line">    Ready:         <span class="literal">False</span></span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">Containers:</span><br><span class="line">  myapp-container:</span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">    State:         Waiting</span><br><span class="line">      Reason:      PodInitializing</span><br><span class="line">    Ready:         <span class="literal">False</span></span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">Events:</span><br><span class="line">  FirstSeen    LastSeen    Count    <span class="keyword">From</span>                      SubObjectPath                          <span class="built_in"> Type </span>         Reason        Message</span><br><span class="line">  ---------    --------    -----    ----                      -------------                           --------      ------        -------</span><br><span class="line">  16s          16s         1        &#123;default-scheduler &#125;                                              Normal        Scheduled     Successfully assigned myapp-pod <span class="keyword">to</span> 172.17.4.201</span><br><span class="line">  16s          16s         1        &#123;kubelet 172.17.4.201&#125;    spec.initContainers&#123;init-myservice&#125;     Normal        Pulling       pulling image <span class="string">"busybox"</span></span><br><span class="line">  13s          13s         1        &#123;kubelet 172.17.4.201&#125;    spec.initContainers&#123;init-myservice&#125;     Normal        Pulled        Successfully pulled image <span class="string">"busybox"</span></span><br><span class="line">  13s          13s         1        &#123;kubelet 172.17.4.201&#125;    spec.initContainers&#123;init-myservice&#125;     Normal        Created       Created container with docker id 5ced34a04634; Security:[<span class="attribute">seccomp</span>=unconfined]</span><br><span class="line">  13s          13s         1        &#123;kubelet 172.17.4.201&#125;    spec.initContainers&#123;init-myservice&#125;     Normal        Started       Started container with docker id 5ced34a04634</span><br><span class="line">$ kubectl logs myapp-pod -c init-myservice # Inspect the first init container</span><br><span class="line">$ kubectl logs myapp-pod -c init-mydb      # Inspect the second init container</span><br></pre></td></tr></table></figure></p>
<p>一旦我们启动mydb和myservice服务，我们就可以看到Init Containers完成并myapp-pod创建了：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f services.yaml</span><br><span class="line">service/myservice created</span><br><span class="line">service/mydb created</span><br><span class="line">$ kubectl get -f myapp.yaml</span><br><span class="line">NAME        READY     STATUS    RESTARTS   AGE</span><br><span class="line">myapp-pod   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">9</span>m</span><br></pre></td></tr></table></figure></p>
<p>这个例子非常简单，但应该为您创建自己的Init容器提供一些灵感。</p>
<h5 id="详细的行为"><a href="#详细的行为" class="headerlink" title="详细的行为"></a>详细的行为</h5><p>在Pod启动期间，初始化网络和卷后，初始容器将按顺序启动。每个Container必须在下一个Container启动之前成功退出。如果Container由于运行时未能启动或因故障退出，则根据Pod重试<code>restartPolicy</code>。但是，如果将Pod <code>restartPolicy</code>设置为Always，则Init Containers将使用 <code>RestartPolicy</code>OnFailure。</p>
<p>在<code>Ready</code>所有Init容器都成功之前，Pod不能。Init容器上的端口不在服务下聚合。正在初始化的Pod处于<code>Pending</code>状态，但应将条件<code>Initializing</code>设置为true。</p>
<p>如果<a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#pod-restart-reasons" target="_blank" rel="noopener">重新启动</a> Pod，则必须再次执行所有Init Containers。</p>
<p>Init容器规范的更改仅限于容器镜像字段。更改Init Container镜像字段相当于重新启动Pod。</p>
<p>由于Init Containers可以重新启动，重试或重新执行，因此Init Container代码应该是幂等的。特别是，<code>EmptyDirs</code> 应该为输出文件已经存在的可能性准备写入文件的代码。</p>
<p>Init Containers具有应用Container的所有字段。但是，Kubernetes禁止<code>readinessProbe</code>使用，因为Init Containers无法定义与完成不同的准备情况。这在验证期间强制执行。</p>
<p>使用<code>activeDeadlineSeconds</code>上pod<code>livenessProbe</code>的容器，以防止初始化容器从永远失败。活动截止日期包括Init Containers。</p>
<p>Pod中每个应用程序和Init容器的名称必须是唯一的; 任何与另一个名称共享名称的Container都会引发验证错误。</p>
<h6 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h6><p>给定Init Containers的排序和执行，适用以下资源使用规则：</p>
<ul>
<li>在所有Init Containers上定义的任何特定资源请求或限制的最高值是有效的init请求/限制</li>
<li>Pod 对资源的有效请求/限制是以下值中的较高者：</li>
<li>资源的所有应用容器请求/限制的总和</li>
<li>资源的有效init请求/限制</li>
<li>调度是基于有效的请求/限制完成的，这意味着Init Containers可以预留在Pod生命周期内未使用的初始化资源。</li>
<li>Pod的有效QoS层的QoS层是Init Containers和app容器的QoS层。</li>
</ul>
<p>根据有效的Pod请求和限制应用配额和限制。</p>
<p>Pod级别cgroup基于有效的Pod请求和限制，与调度程序相同。</p>
<h6 id="Pod重启原因"><a href="#Pod重启原因" class="headerlink" title="Pod重启原因"></a>Pod重启原因</h6><p>Pod可以重新启动，导致重新执行Init Containers，原因如下：</p>
<ul>
<li>用户更新PodSpec，导致Init容器映像发生更改。App Container图像更改仅重新启动应用程序Container。</li>
<li>Pod基础架构容器重新启动。这种情况并不常见，必须由对节点具有root访问权限的人员来完成。</li>
<li>Pod中的所有容器都被终止，同时<code>restartPolicy</code>设置为Always，强制重新启动，并且Init Container完成记录由于垃圾回收而丢失。</li>
</ul>
<h5 id="支持和兼容性"><a href="#支持和兼容性" class="headerlink" title="支持和兼容性"></a>支持和兼容性</h5><p>具有Apiserver 1.6.0或更高版本的群集支持使用该<code>.spec.initContainers</code>字段的Init Containers 。以前的版本使用alpha或beta注释支持Init Containers。该<code>.spec.initContainers</code>字段还镜像为alpha和beta注释，以便Kubelet 1.3.0或更高版本可以执行Init Containers，因此版本1.6 apiserver可以安全地回滚到1.5.x版，而不会丢失现有创建的pod的Init Container功能。</p>
<p>在Apiserver和Kubelet 1.8.0或更高版本中，删除了对alpha和beta注释的支持，需要从不推荐的注释转换到 <code>.spec.initContainers</code>字段。</p>
<p>此功能已在1.6中退出测试版。可以在应用程序<code>containers</code>阵列旁边的PodSpec中指定Init容器。beta注释值仍将受到尊重并覆盖PodSpec字段值，但是，它们在1.6和1.7中已弃用。在1.8中，不再支持注释，必须将其转换为PodSpec字段。</p>
<h4 id="Pod-Preset"><a href="#Pod-Preset" class="headerlink" title="Pod Preset"></a>Pod Preset</h4><p>此页面提供PodPresets的概述，PodPresets是在创建时将特定信息注入pod的对象。信息可以包括秘密，卷，卷安装和环境变量。</p>
<ul>
<li>了解Pod预设</li>
<li>这个怎么运作</li>
<li>启用Pod预设</li>
</ul>
<h5 id="了解Pod预设"><a href="#了解Pod预设" class="headerlink" title="了解Pod预设"></a>了解Pod预设</h5><p><code>Pod Preset</code>是一种API资源，用于在创建时将其他运行时需求注入Pod。您可以使用<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors" target="_blank" rel="noopener">标签选择器</a> 指定应用给定Pod预设的Pod。</p>
<p>使用Pod预设允许pod模板作者不必显式提供每个pod的所有信息。这样，使用特定服务的pod模板的作者不需要知道有关该服务的所有详细信息。</p>
<p>有关背景的更多信息，请参阅<a href="https://git.k8s.io/community/contributors/design-proposals/service-catalog/pod-preset.md" target="_blank" rel="noopener">PodPreset</a>的<a href="https://git.k8s.io/community/contributors/design-proposals/service-catalog/pod-preset.md" target="_blank" rel="noopener">设计方案</a>。</p>
<h5 id="这个怎么运作"><a href="#这个怎么运作" class="headerlink" title="这个怎么运作"></a>这个怎么运作</h5><p>Kubernetes提供了一个准入控制器（<code>PodPreset</code>），当启用时，它将Pod Presets应用于传入的pod创建请求。发生pod创建请求时，系统会执行以下操作：</p>
<ol>
<li>检索所有<code>PodPresets</code>可用的。</li>
<li>检查任何标签选择器是否<code>PodPreset</code>与正在创建的pod上的标签匹配。</li>
<li>尝试将所定义的各种资源合并<code>PodPreset</code>到正在创建的Pod中。</li>
<li>出错时，抛出一个记录pod上合并错误的事件，并创建pod 而不从中注入任何资源<code>PodPreset</code>。</li>
<li>注释生成的修改后的Pod规范，以指示它已被修改<code>PodPreset</code>。注释是形式的 <code>podpreset.admission.kubernetes.io/podpreset-&lt;pod-preset name&gt;: &quot;&lt;resource version&gt;&quot;</code>。</li>
</ol>
<p>每个Pod可以匹配零个或多个Pod Presets; 并且每个<code>PodPreset</code>都可以应用于零个或多个pod。当 <code>PodPreset</code>应用于一个或多个Pod时，Kubernetes会修改Pod规范。对于更改<code>Env</code>，<code>EnvFrom</code>和 <code>VolumeMounts</code>，Kubernetes修改在波德所有容器容器规范; 对于更改<code>Volume</code>，Kubernetes修改Pod规范。</p>
<blockquote>
<p>注意： Pod Preset能够<code>.spec.containers</code>在适当的时候修改Pod规范中的字段。没有从POD预置资源定义将被应用到initContainers外地。</p>
</blockquote>
<h6 id="禁用特定Pod的Pod预设"><a href="#禁用特定Pod的Pod预设" class="headerlink" title="禁用特定Pod的Pod预设"></a>禁用特定Pod的Pod预设</h6><p>在某些情况下，您希望Pod不会被任何Pod Preset突变改变。在这些情况下，您可以在表单的Pod Spec中添加注释：<code>podpreset.admission.kubernetes.io/exclude: &quot;true&quot;</code>。</p>
<h5 id="启用Pod预设"><a href="#启用Pod预设" class="headerlink" title="启用Pod预设"></a>启用Pod预设</h5><p>要在群集中使用Pod Presets，您必须确保以下内容：</p>
<ol>
<li>您已启用API类型<code>settings.k8s.io/v1alpha1/podpreset</code>。例如，这可以通过包含<code>settings.k8s.io/v1alpha1=true</code>在<code>--runtime-config</code>API服务器的选项中来完成。在minikube中，<code>--extra-config=apiserver.runtime-config=settings.k8s.io/v1alpha1=true</code>在启动集群时添加此标志 。</li>
<li>您已启用准入控制器<code>PodPreset</code>。执行此操作的一种方法是包含<code>PodPreset</code>在<code>--enable-admission-plugins</code>为API服务器指定的选项值中。在minikube中，<code>--extra-config=apiserver.enable-admission-plugins=Initializers,NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodPreset</code> 在启动集群时添加此标志 。</li>
<li>您已通过<code>PodPreset</code>在将使用的命名空间中创建对象来定义Pod预设。</li>
</ol>
<h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>本指南适用于想要构建高可用性应用程序的应用程序所有者，因此需要了解Pod可能发生的中断类型。</p>
<p>它也适用于希望执行自动群集操作的群集管理员，例如升级和自动缩放群集。</p>
<ul>
<li>自愿和非自愿中断</li>
<li>处理中断</li>
<li>中断预算如何运作</li>
<li>PDB示例</li>
<li>分离群集所有者和应用程序所有者角色</li>
<li>如何在群集上执行破坏性操作</li>
</ul>
<h5 id="自愿和非自愿中断"><a href="#自愿和非自愿中断" class="headerlink" title="自愿和非自愿中断"></a>自愿和非自愿中断</h5><p>在有人（一个人或一个控制器）摧毁它们，或者存在不可避免的硬件或系统软件错误之前，Pod不会消失。</p>
<p>我们将这些不可避免的案例称为对应用程序的非自愿中断。例如：</p>
<ul>
<li>支持节点的物理机的硬件故障</li>
<li>集群管理员错误地删除了VM（实例）</li>
<li>云提供商或虚拟机管理程序故障使虚拟机消失</li>
<li>内核恐慌</li>
<li>由于群集网络分区，节点从群集中消失</li>
<li>由于节点<a href="https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/" target="_blank" rel="noopener">资源不足</a>而导致pod被驱逐。</li>
</ul>
<p>除资源不足外，大多数用户都应熟悉所有这些条件; 它们不是Kubernetes特有的。</p>
<p>我们将其他案件称为自愿中断。其中包括应用程序所有者启动的操作和群集管理员启动的操作。典型应用程序所有者操作包</p>
<ul>
<li>删除管理pod的部署或其他控制器</li>
<li>更新部署的pod模板导致重新启动</li>
<li>直接删除pod（例如意外）</li>
</ul>
<p>群集管理员操作包括：<br>-<a href="https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/" target="_blank" rel="noopener"> 耗尽节点</a>进行修复或升级。</p>
<ul>
<li>从群集中排出节点以缩小群集（了解<a href="https://kubernetes.io/docs/tasks/administer-cluster/cluster-management/#cluster-autoscaler" target="_blank" rel="noopener">群集自动缩放</a> ）。</li>
<li>从节点中删除pod以允许其他内容适合该节点。</li>
</ul>
<p>这些操作可以由集群管理员直接执行，也可以由集群管理员或集群主机提供商自动运行。</p>
<p>请咨询您的集群管理员或咨询您的云提供商或分发文档，以确定是否为您的集群启用了任何自愿中断源。如果未启用，则可以跳过创建Pod中断预算。</p>
<h5 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h5><p>以下是一些缓解非自愿中断的方法：</p>
<ul>
<li>确保您的pod <a href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-ram-container" target="_blank" rel="noopener">请求所需的资源</a>。</li>
<li>如果需要更高的可用性，请复制应用程序。（了解运行复制的 <a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/" target="_blank" rel="noopener">无状态</a> 和<a href="https://kubernetes.io/docs/tasks/run-application/run-replicated-stateful-application/" target="_blank" rel="noopener">有状态</a>应用程序。）</li>
<li>为了在运行复制的应用程序时获得更高的可用性，可以跨机架（使用<a href="https://kubernetes.io/docs/user-guide/node-selection/#inter-pod-affinity-and-anti-affinity-beta-feature" target="_blank" rel="noopener">反关联</a>）或跨区域（如果使用 <a href="https://kubernetes.io/docs/setup/multiple-zones" target="_blank" rel="noopener">多区域群集</a>）分布应用程序 。</li>
</ul>
<p>自愿中断的频率各不相同。在基本的Kubernetes集群上，根本没有自愿中断。但是，您的群集管理员或托管服务提供商可能会运行一些导致自愿中断的其他服务。例如，推出节点软件更新可能会导致自愿中断。此外，群集（节点）自动缩放的某些实现可能会导致自动中断以进行碎片整理和压缩节点。您的集群管理员或托管服务提供商应记录预期的自愿中断级别（如果有）。</p>
<p>Kubernetes提供的功能可以帮助您在频繁的自愿中断的同时运行高可用性应用程序。我们将这组功能称为 中断预算。</p>
<h5 id="中断预算如何运作"><a href="#中断预算如何运作" class="headerlink" title="中断预算如何运作"></a>中断预算如何运作</h5><p>应用程序所有者可以<code>PodDisruptionBudget</code>为每个应用程序创建一个对象（PDB）。PDB限制复制应用程序的pod的数量，这些pod与自愿中断同时发生故障。例如，基于仲裁的应用程序希望确保运行的副本数量永远不会低于仲裁所需的数量。Web前端可能希望确保服务负载的副本数量永远不会低于总数的某个百分比。</p>
<p>集群管理器和托管提供商应使用通过调用<a href="https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/#the-eviction-api" target="_blank" rel="noopener">Eviction API</a> 而不是直接删除pod来遵守Pod Disruption Budgets的工具。示例是<code>kubectl drain</code>命令和Kubernetes-on-GCE集群升级脚本（<code>cluster/gce/upgrade.sh</code>）。</p>
<p>当集群管理员想要耗尽节点时，他们使用<code>该kubectl drain</code>命令。该工具试图驱逐机器上的所有pod。可以暂时拒绝逐出请求，并且该工具定期重试所有失败的请求，直到所有pod终止，或者直到达到可配置的超时。</p>
<p>PDB指定应用程序可以容忍的副本数量，相对于预期的副本数量。例如，具有部署<code>.spec.replicas: 5</code>应该在任何给定时间具有5个pod。如果其PDB允许一次有4个，则Eviction API将允许一次自动中断一个而不是两个pod。</p>
<p>组成应用程序的pod组使用标签选择器指定，与应用程序控制器使用的标签选择器相同（部署，有状态集等）。</p>
<p>“预期”数量的pod是根据<code>.spec.replicaspods</code>控制器计算出来的。使用<code>.metadata.ownerReferences</code>对象的pod从pod中发现控制器。</p>
<p>PDB不能防止<a href="https://kubernetes.io/docs/concepts/workloads/pods/disruptions/#voluntary-and-involuntary-disruptions" target="_blank" rel="noopener">非自愿中断</a>发生，但它们确实违背了预算。</p>
<p>由于滚动升级到应用程序而被删除或不可用的Pod确实会计入中断预算，但是在执行滚动升级时，控制器（如部署和有状态集）不受PDB限制 - 在应用程序更新期间处理故障在控制器规范中。（了解有关<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#updating-a-deployment" target="_blank" rel="noopener">更新部署的信息</a>。）</p>
<p>当吊舱使用驱逐API逐出，它是正常终止（见 <code>terminationGracePeriodSeconds</code>在<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#podspec-v1-core" target="_blank" rel="noopener">PodSpec</a>。）</p>
<p>PDB示例<br>考虑具有3个节点的群集中，<code>node-1</code>通过<code>node-3</code>。群集正在运行多个应用程序。其中一人有3个副本最初称 <code>pod-a</code>，<code>pod-b</code>和<code>pod-c</code>。<code>pod-x</code>还示出了另一个没有PDB的不相关的pod。最初，pod的布局如下：</p>
<table>
<thead>
<tr>
<th>节点-1</th>
<th>节点-2-</th>
<th>节点-3-</th>
</tr>
</thead>
<tbody>
<tr>
<td>pod-a 可用</td>
<td>pod-b 可用</td>
<td>pod-c 可用</td>
</tr>
<tr>
<td>pod-x 可用</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>所有3个pod都是部署的一部分，它们共同拥有一个PDB，要求所有3个pod中至少有2个可用。</p>
<p>例如，假设集群管理员想要重新启动到新的内核版本来修复内核中的错误。群集管理员首先尝试<code>node-1</code>使用该<code>kubectl drain</code>命令消耗。该工具试图驱逐<code>pod-a</code>和<code>pod-x</code>。这立即成功。两个pod同时进入该<code>terminating</code>。这使集群处于以下状态</p>
<table>
<thead>
<tr>
<th>节点-1 耗尽</th>
<th>节点-2-</th>
<th>节点-3-</th>
</tr>
</thead>
<tbody>
<tr>
<td>pod-a  终止</td>
<td>pod-b 可用</td>
<td>pod-c 可用</td>
</tr>
<tr>
<td>pod-x  终止</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>部署注意到其中一个pod正在终止，因此它会创建一个名为的替换<code>pod-d</code>。由于<code>node-1</code>是封锁的，它落在另一个节点上。还创造<code>pod-y</code>了一些替代品<code>pod-x</code>。</p>
<p>（注意：对于一个StatefulSet，<code>pod-a</code>它将被称为类似的东西<code>pod-1</code>，需要在它被替换之前完全终止，也可以被调用，<code>pod-1</code>但是可以创建不同的UID。否则，该示例也适用于StatefulSet。）</p>
<p>现在集群处于以下状态：</p>
<table>
<thead>
<tr>
<th>节点-1 耗尽</th>
<th>节点-2-</th>
<th>节点-3-</th>
</tr>
</thead>
<tbody>
<tr>
<td>pod-a  终止</td>
<td>pod-b 可用</td>
<td>pod-c 可用</td>
</tr>
<tr>
<td>pod-x  终止</td>
<td>pod-b 开始</td>
<td>POD-Y</td>
</tr>
</tbody>
</table>
<p>在某些时候，pod终止，集群看起来像这样：</p>
<table>
<thead>
<tr>
<th>节点-1 耗尽</th>
<th>节点-2-</th>
<th>节点-3-</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>pod-b 可用</td>
<td>pod-c 可用</td>
</tr>
<tr>
<td></td>
<td>pod-b 开始</td>
<td>POD-Y</td>
</tr>
</tbody>
</table>
<p> 此时，如果一个不耐烦的集群管理员试图耗尽，<code>node-2</code>或者 <code>node-3</code>排除命令将阻塞，因为部署只有2个可用的pod，并且其PDB至少需要2.经过一段时间后，<code>pod-d</code>变为可用。</p>
<p>群集状态现在看起来像这样：</p>
<table>
<thead>
<tr>
<th>节点-1 耗尽</th>
<th>节点-2-</th>
<th>节点-3-</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>pod-b 可用</td>
<td>pod-c 可用</td>
</tr>
<tr>
<td></td>
<td>pod-b 可用</td>
<td>POD-Y</td>
</tr>
</tbody>
</table>
<p> 现在，集群管理员试图耗尽<code>node-2</code>。drain命令将尝试以某种顺序驱逐两个pod，<code>pod-b</code>先说然后再说 <code>pod-d</code>。它将成功驱逐<code>pod-b</code>。但是，当它试图逐出时<code>pod-d</code>，它将被拒绝，因为这将只留下一个可用于部署的pod。</p>
<p>部署创建了<code>pod-b</code>被叫的替代品<code>pod-e</code>。因为集群中没有足够的资源来安排 <code>pod-e</code>排水将再次阻塞。群集可能最终处于此状态：</p>
<table>
<thead>
<tr>
<th>节点-1 耗尽</th>
<th>节点-2-</th>
<th>节点-3-</th>
<th>没有节点</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>pod-b 可用</td>
<td>pod-c 可用</td>
<td>pod-e 待定</td>
</tr>
<tr>
<td></td>
<td>pod-b 可用</td>
<td>POD-Y</td>
<td></td>
</tr>
</tbody>
</table>
<p> 此时，集群管理员需要将节点添加回集群以继续升级。</p>
<p>你可以看到Kubernetes如何改变发生中断的速度，根据：</p>
<ul>
<li>应用程序需要多少个副本</li>
<li>优雅地关闭实例需要多长时间</li>
<li>启动新实例需要多长时间</li>
<li>控制器的类型</li>
<li>集群的资源容量</li>
</ul>
<h5 id="分离群集所有者和应用程序所有者角色"><a href="#分离群集所有者和应用程序所有者角色" class="headerlink" title="分离群集所有者和应用程序所有者角色"></a>分离群集所有者和应用程序所有者角色</h5><p>通常，将群集管理器和应用程序所有者视为彼此知之甚少的单独角色很有用。在这些情况下，这种职责分离可能有意义：</p>
<ul>
<li>当有许多应用程序团队共享Kubernetes集群时，角色有自然的专业化</li>
<li>当第三方工具或服务用于自动化集群管理时</li>
</ul>
<p>Pod Disruption Budgets通过在角色之间提供接口来支持这种角色分离。</p>
<p>如果您的组织中没有这样的责任分离，则可能不需要使用Pod Disruption Budgets。</p>
<h5 id="如何在群集上执行破坏性操作"><a href="#如何在群集上执行破坏性操作" class="headerlink" title="如何在群集上执行破坏性操作"></a>如何在群集上执行破坏性操作</h5><p>如果您是群集管理员，并且需要对群集中的所有节点执行中断操作，例如节点或系统软件升级，则可以使用以下选项：</p>
<ul>
<li>在升级期间接受停机时间。</li>
<li>故障转移到另一个完整的副本群集。<ul>
<li>没有停机时间，但对于重复的节点以及人类协调切换的努力可能都是昂贵的。</li>
</ul>
</li>
<li>编写容错中断应用程序并使用PDB。<ul>
<li>没有停机时间。</li>
<li>最小的资源重复。</li>
<li>允许更多自动化群集管理。</li>
<li>编写容忍破坏性的应用程序很棘手，但容忍自愿中断的工作很大程度上与支持自动缩放和容忍非自愿中断的工作重叠。</li>
</ul>
</li>
</ul>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h4><p>ReplicaSet是下一代复制控制器。现在ReplicaSet和 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" target="_blank" rel="noopener">Replication Controller</a>之间的唯一区别是选择器支持。ReplicaSet支持新的基于集合的选择器要求，如<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors" target="_blank" rel="noopener">标签用户指南</a>中所述， 而Replication Controller仅支持基于等同的选择器要求。</p>
<ul>
<li>如何使用ReplicaSet</li>
<li>何时使用ReplicaSet</li>
<li>例</li>
<li>编写副本集规范</li>
<li>使用ReplicaSet</li>
<li>ReplicaSet的替代品</li>
</ul>
<h5 id="如何使用ReplicaSet"><a href="#如何使用ReplicaSet" class="headerlink" title="如何使用ReplicaSet"></a>如何使用ReplicaSet</h5><p>大多数<a href="https://kubernetes.io/docs/user-guide/kubectl/" target="_blank" rel="noopener">kubectl</a>支持复制控制器的命令也支持ReplicaSet。<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rolling-update" target="_blank" rel="noopener">rolling-update</a>命令是一个例外 。如果您想要滚动更新功能，请考虑使用部署。此外， <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rolling-update" target="_blank" rel="noopener">rolling-update</a>命令是必需的，而Deployments是声明性的，因此我们建议通过<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rollout" target="_blank" rel="noopener">rollout</a>命令使用Deployments 。</p>
<p>虽然ReplicaSet可以独立使用，但今天它主要被 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployments</a>用作协调pod创建，删除和更新的机制。使用“部署”时，您不必担心管理它们创建的副本集。部署拥有并管理其ReplicaSet。</p>
<h5 id="何时使用ReplicaSet"><a href="#何时使用ReplicaSet" class="headerlink" title="何时使用ReplicaSet"></a>何时使用ReplicaSet</h5><p>ReplicaSet确保在任何给定时间运行指定数量的pod副本。但是，Deployment是一个更高级别的概念，它管理ReplicaSet并为pod提供声明性更新以及许多其他有用的功能。因此，除非您需要自定义更新编排或根本不需要更新，否则我们建议使用部署而不是直接使用ReplicaSet。</p>
<p>这实际上意味着您可能永远不需要操作ReplicaSet对象：改为使用Deployment，并在spec部分中定义您的应用程序。</p>
<p>例<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#controllers/frontend.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">guestbook</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># modify replicas according to your case</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">    matchExpressions:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">&#123;key:</span> <span class="string">tier,</span> <span class="attr">operator:</span> <span class="string">In,</span> <span class="attr">values:</span> <span class="string">[frontend]&#125;</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">guestbook</span></span><br><span class="line"><span class="attr">        tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">php-redis</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">gcr.io/google_samples/gb-frontend:v3</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">100</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">GET_HOSTS_FROM</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">dns</span></span><br><span class="line">          <span class="comment"># If your cluster config does not include a dns service, then to</span></span><br><span class="line">          <span class="comment"># instead access environment variables to find service host</span></span><br><span class="line">          <span class="comment"># info, comment out the 'value: dns' line above, and uncomment the</span></span><br><span class="line">          <span class="comment"># line below.</span></span><br><span class="line">          <span class="comment"># value: env</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>将此清单保存<code>frontend.yaml</code>到Kubernetes集群并将其提交到Kubernetes集群应该创建已定义的ReplicaSet及其管理的pod。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="keyword">create</span> -f <span class="keyword">http</span>://k8s.io/examples/controllers/frontend.yaml</span><br><span class="line">replicaset.apps/frontend created</span><br><span class="line">$ kubectl <span class="keyword">describe</span> rs/frontend</span><br><span class="line"><span class="keyword">Name</span>:		frontend</span><br><span class="line">Namespace:	<span class="keyword">default</span></span><br><span class="line">Selector:	<span class="keyword">tier</span>=frontend,<span class="keyword">tier</span> <span class="keyword">in</span> (frontend)</span><br><span class="line">Labels:		app=guestbook</span><br><span class="line">		<span class="keyword">tier</span>=frontend</span><br><span class="line">Annotations:	&lt;<span class="keyword">none</span>&gt;</span><br><span class="line">Replicas:	<span class="number">3</span> <span class="keyword">current</span> / <span class="number">3</span> desired</span><br><span class="line">Pods <span class="keyword">Status</span>:	<span class="number">3</span> Running / <span class="number">0</span> Waiting / <span class="number">0</span> Succeeded / <span class="number">0</span> <span class="keyword">Failed</span></span><br><span class="line">Pod <span class="keyword">Template</span>:</span><br><span class="line">  Labels:       app=guestbook</span><br><span class="line">                <span class="keyword">tier</span>=frontend</span><br><span class="line">  Containers:</span><br><span class="line">   php-redis:</span><br><span class="line">    Image:      gcr.io/google_samples/gb-frontend:v3</span><br><span class="line">    Port:       <span class="number">80</span>/TCP</span><br><span class="line">    Requests:</span><br><span class="line">      cpu:      <span class="number">100</span>m</span><br><span class="line">      <span class="keyword">memory</span>:   <span class="number">100</span>Mi</span><br><span class="line">    Environment:</span><br><span class="line">      GET_HOSTS_FROM:   dns</span><br><span class="line">    Mounts:             &lt;<span class="keyword">none</span>&gt;</span><br><span class="line">  Volumes:              &lt;<span class="keyword">none</span>&gt;</span><br><span class="line"><span class="keyword">Events</span>:</span><br><span class="line">  FirstSeen    LastSeen    <span class="keyword">Count</span>    <span class="keyword">From</span>                SubobjectPath    <span class="keyword">Type</span>        Reason            Message</span><br><span class="line">  <span class="comment">---------    --------    -----    ----                -------------    --------    ------            -------</span></span><br><span class="line">  <span class="number">1</span>m           <span class="number">1</span>m          <span class="number">1</span>        &#123;replicaset-controller &#125;             <span class="keyword">Normal</span>      SuccessfulCreate  Created pod: frontend-qhloh</span><br><span class="line">  <span class="number">1</span>m           <span class="number">1</span>m          <span class="number">1</span>        &#123;replicaset-controller &#125;             <span class="keyword">Normal</span>      SuccessfulCreate  Created pod: frontend-dnjpy</span><br><span class="line">  <span class="number">1</span>m           <span class="number">1</span>m          <span class="number">1</span>        &#123;replicaset-controller &#125;             <span class="keyword">Normal</span>      SuccessfulCreate  Created pod: frontend<span class="number">-9</span>si5l</span><br><span class="line">$ kubectl <span class="keyword">get</span> pods</span><br><span class="line"><span class="keyword">NAME</span>             READY     <span class="keyword">STATUS</span>    RESTARTS   AGE</span><br><span class="line">frontend<span class="number">-9</span>si5l   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>m</span><br><span class="line">frontend-dnjpy   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>m</span><br><span class="line">frontend-qhloh   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>m</span><br></pre></td></tr></table></figure></p>
<h5 id="编写副本集规范"><a href="#编写副本集规范" class="headerlink" title="编写副本集规范"></a>编写副本集规范</h5><p>与所有其他Kubernetes API对象，一个ReplicaSet需要<code>apiVersion</code>，<code>kind</code>和<code>metadata</code>领域。有关使用清单的一般信息，请参阅<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">使用kubectl进行对象管理</a>。</p>
<p>ReplicaSet还需要一个<a href="https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status" target="_blank" rel="noopener"><code>.spec</code>部分</a>。</p>
<h6 id="Pod模板-1"><a href="#Pod模板-1" class="headerlink" title="Pod模板"></a>Pod模板</h6><p>这<code>.spec.template</code>是唯一必需的领域<code>.spec</code>。这<code>.spec.template</code>是一个 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#pod-templates" target="_blank" rel="noopener">pod模板</a>。它与pod具有完全相同的架构 ，除了它是嵌套的并且没有<code>apiVersion</code>或<code>kind</code>。</p>
<p>除了pod的必填字段外，ReplicaSet中的pod模板还必须指定适当的标签和适当的重新启动策略。</p>
<p>对于标签，请确保不与其他控制器重叠。有关更多信息，请参阅<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/#pod-selector" target="_blank" rel="noopener">pod选择器</a>。</p>
<p>对于<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy" target="_blank" rel="noopener">重新启动策略</a>，唯一允许的值<code>.spec.template.spec.restartPolicy</code>是<code>Always</code>，这是默认值。</p>
<p>对于本地容器重新启动，ReplicaSet委托给节点上的代理程序，例如<a href="https://kubernetes.io/docs/admin/kubelet/" target="_blank" rel="noopener">Kubelet</a>或Docker。</p>
<h6 id="Pod选择器"><a href="#Pod选择器" class="headerlink" title="Pod选择器"></a>Pod选择器</h6><p>该<code>.spec.selector</code>字段是<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" target="_blank" rel="noopener">标签选择器</a>。ReplicaSet使用与选择器匹配的标签管理所有pod。它不区分它创建或删除的pod以及另一个人或进程创建或删除的pod。这允许替换ReplicaSet而不影响正在运行的pod。</p>
<p>在<code>.spec.template.metadata.labels</code>必须匹配<code>.spec.selector</code>，否则会被API被拒绝。</p>
<p>在Kubernetes 1.9中，<code>apps/v1</code>ReplicaSet类型的API版本是当前版本，默认情况下已启用。<code>apps/v1beta2</code>不推荐使用API版本。</p>
<p>此外，您通常不应创建任何标签与此选择器匹配的pod，可以直接与另一个ReplicaSet一起创建，也可以与其他控制器（如Deployment）一起创建。如果这样做，ReplicaSet会认为它创建了其他pod。Kubernetes并没有阻止你这样做。</p>
<p>如果最终有多个具有重叠选择器的控制器，则必须自己管理删除。</p>
<h6 id="副本集上的标签"><a href="#副本集上的标签" class="headerlink" title="副本集上的标签"></a>副本集上的标签</h6><p>ReplicaSet本身可以有标签（<code>.metadata.labels</code>）。通常，您可以将它们设置为相同<code>.spec.template.metadata.labels</code>。但是，允许它们不同，并且<code>.metadata.labels</code>不会影响ReplicaSet的行为。</p>
<h6 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h6><p>您可以通过设置指定应同时运行的pod数量<code>.spec.replicas</code>。在任何时间运行的数字可能更高或更低，例如，如果副本只是增加或减少，或者如果正常关闭吊舱，并且提前开始更换。</p>
<p>如果未指定<code>.spec.replicas</code>，则默认为1。</p>
<h5 id="使用ReplicaSet"><a href="#使用ReplicaSet" class="headerlink" title="使用ReplicaSet"></a>使用ReplicaSet</h5><h6 id="删除ReplicaSet及其Pod"><a href="#删除ReplicaSet及其Pod" class="headerlink" title="删除ReplicaSet及其Pod"></a>删除ReplicaSet及其Pod</h6><p>要删除ReplicaSet及其所有Pod，请使用<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#delete" target="_blank" rel="noopener"><code>kubectl delete</code></a>。该<a href="https://kubernetes.io/docs/concepts/workloads/controllers/garbage-collection/" target="_blank" rel="noopener">垃圾收集器</a>在默认情况下会自动删除所有相关的荚。</p>
<p>使用REST API或<code>client-go</code>库时，必须设置<code>propagationPolicy</code>为<code>Background</code>或<code>Foreground</code>删除选项。例如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">kubectl</span> proxy <span class="comment">--port=8080</span></span><br><span class="line"><span class="title">curl</span> -<span class="type">X</span> <span class="type">DELETE</span>  'localhost:<span class="number">8080</span>/apis/extensions/v1beta1/namespaces/<span class="keyword">default</span>/replicasets/frontend' \</span><br><span class="line">&gt; -d '&#123;<span class="string">"kind"</span>:<span class="string">"DeleteOptions"</span>,<span class="string">"apiVersion"</span>:<span class="string">"v1"</span>,<span class="string">"propagationPolicy"</span>:<span class="string">"Foreground"</span>&#125;' \</span><br><span class="line">&gt; -<span class="type">H</span> <span class="string">"Content-Type: application/json"</span></span><br></pre></td></tr></table></figure></p>
<h6 id="仅删除副本集"><a href="#仅删除副本集" class="headerlink" title="仅删除副本集"></a>仅删除副本集</h6><p>您可以删除副本集，而不会影响使用<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#delete" target="_blank" rel="noopener"><code>kubectl delete</code></a>该<code>--cascade=false</code>选项的任何pod 。使用REST API或<code>client-go</code>库时，必须设置<code>propagationPolicy</code>为<code>Orphan</code>，例如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">kubectl</span> proxy <span class="comment">--port=8080</span></span><br><span class="line"><span class="title">curl</span> -<span class="type">X</span> <span class="type">DELETE</span>  'localhost:<span class="number">8080</span>/apis/extensions/v1beta1/namespaces/<span class="keyword">default</span>/replicasets/frontend' \</span><br><span class="line">&gt; -d '&#123;<span class="string">"kind"</span>:<span class="string">"DeleteOptions"</span>,<span class="string">"apiVersion"</span>:<span class="string">"v1"</span>,<span class="string">"propagationPolicy"</span>:<span class="string">"Orphan"</span>&#125;' \</span><br><span class="line">&gt; -<span class="type">H</span> <span class="string">"Content-Type: application/json"</span></span><br></pre></td></tr></table></figure></p>
<p>删除原始文件后，您可以创建一个新的ReplicaSet来替换它。只要旧的和新<code>.spec.selector</code>的相同，那么新的将采用旧的豆荚。但是，它不会做任何努力使现有的pod匹配一个新的，不同的pod模板。要以受控方式将pod更新为新规范，请使用<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/#rolling-updates" target="_blank" rel="noopener">滚动更新</a>。</p>
<h6 id="从副本集隔离pod"><a href="#从副本集隔离pod" class="headerlink" title="从副本集隔离pod"></a>从副本集隔离pod</h6><p>可以通过更改标签来从ReplicaSet的目标集中删除Pod。此技术可用于从服务中删除pod以进行调试，数据恢复等。以这种方式删除的Pod将自动替换（假设副本的数量也未更改）。</p>
<h6 id="缩放副本集"><a href="#缩放副本集" class="headerlink" title="缩放副本集"></a>缩放副本集</h6><p>只需更新<code>.spec.replicas</code>字段即可轻松扩展或缩小ReplicaSet 。ReplicaSet控制器确保具有匹配标签选择器的所需数量的pod可用且可操作。</p>
<h6 id="ReplicaSet作为水平Pod自动缩放器目标"><a href="#ReplicaSet作为水平Pod自动缩放器目标" class="headerlink" title="ReplicaSet作为水平Pod自动缩放器目标"></a>ReplicaSet作为水平Pod自动缩放器目标</h6><p>ReplicaSet也可以是 <a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" target="_blank" rel="noopener">Horizontal Pod Autoscalers (HPA)</a>的目标 。也就是说，HPA可以自动缩放ReplicaSet。以下是针对我们在上一个示例中创建的ReplicaSet的示例HPA。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#controllers/hpa-rs.yaml </span></span><br><span class="line"><span class="symbol">apiVersion:</span> autoscaling/v1</span><br><span class="line"><span class="symbol">kind:</span> HorizontalPodAutoscaler</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  name:</span> frontend-scaler</span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  scaleTargetRef:</span></span><br><span class="line"><span class="symbol">    kind:</span> ReplicaSet</span><br><span class="line"><span class="symbol">    name:</span> frontend</span><br><span class="line"><span class="symbol">  minReplicas:</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">  maxReplicas:</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">  targetCPUUtilizationPercentage:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure></p>
<p>将此清单保存<code>hpa-rs.yaml</code>到Kubernetes集群并将其提交到Kubernetes集群应该创建定义的HPA，该HPA根据复制的pod的CPU使用情况自动调整目标ReplicaSet。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f https:<span class="regexp">//</span>k8s.io<span class="regexp">/examples/</span>controllers<span class="regexp">/hpa-rs.yaml</span></span><br></pre></td></tr></table></figure></p>
<p>或者，您可以使用该<code>kubectl autoscale</code>命令来完成相同的操作（并且它更容易！）<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl autoscale rs frontend <span class="attribute">--max</span>=10</span><br></pre></td></tr></table></figure></p>
<h5 id="ReplicaSet的替代品"><a href="#ReplicaSet的替代品" class="headerlink" title="ReplicaSet的替代品"></a>ReplicaSet的替代品</h5><h6 id="部署（推荐）"><a href="#部署（推荐）" class="headerlink" title="部署（推荐）"></a>部署（推荐）</h6><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener"><code>Deployment</code></a>是一个更高级别的API对象，它以类似的方式更新其底层ReplicaSet及其Pod <code>kubectl rolling-update</code>。如果您需要此滚动更新功能，则建议进行部署，因为<code>kubectl rolling-update</code>它们不同于声明式，服务器端，并具有其他功能。有关使用部署运行无状态应用程序的更多信息，请阅读使用部署<a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/" target="_blank" rel="noopener">运行无状态应用程序</a>。</p>
<h6 id="Bare-Pods"><a href="#Bare-Pods" class="headerlink" title="Bare Pods"></a>Bare Pods</h6><p>与用户直接创建pod的情况不同，ReplicaSet会替换因任何原因而被删除或终止的pod，例如在节点故障或破坏性节点维护（例如内核升级）的情况下。因此，即使您的应用程序只需要一个pod，我们也建议您使用ReplicaSet。可以想象它与流程主管类似，只是它监控多个节点上的多个pod而不是单个节点上的单个进程。ReplicaSet将本地容器重新启动委派给节点上的某个代理程序（例如，Kubelet或Docker）。</p>
<h6 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h6><p>对于预期会自行终止的pod（即批处理作业），请使用<a href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/" target="_blank" rel="noopener"><code>Job</code></a>而不是ReplicaSet。</p>
<h6 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h6><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener"><code>DaemonSet</code></a>对于提供机器级功能的pod，例如机器监视或机器日志记录，请使用ReplicaSet而不是ReplicaSet。这些pod的生命周期与机器生命周期相关：pod需要在其他pod启动之前在机器上运行，并且当机器准备好重新启动/关闭时可以安全终止。</p>
<h4 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h4><blockquote>
<p>注意：现在建议使用配置ReplicaSet的Deployment来设置复制。</p>
</blockquote>
<p>ReplicationController确保pod副本的指定数量的在任何一个时间运行。换句话说，ReplicationController确保一个pod或一组同类pod总是可用。</p>
<ul>
<li>ReplicationController的工作原理</li>
<li>运行示例ReplicationController</li>
<li>编写ReplicationController规范</li>
<li>使用ReplicationControllers</li>
<li>常见的使用模式</li>
<li>编写复制程序</li>
<li>ReplicationController的职责</li>
<li>API对象</li>
<li>ReplicationController的替代品</li>
<li>欲获得更多信息</li>
</ul>
<h5 id="ReplicationController的工作原理"><a href="#ReplicationController的工作原理" class="headerlink" title="ReplicationController的工作原理"></a>ReplicationController的工作原理</h5><p>如果存在太多pod，则ReplicationController将终止额外的pod。如果太少，ReplicationController将启动更多pod。与手动创建的pod不同，ReplicationController维护的pod在失败，删除或终止时会自动替换。例如，在内核升级等破坏性维护之后，会在节点上重新创建pod。因此，即使应用程序只需要一个pod，也应该使用ReplicationController。ReplicationController类似于进程管理程序，但是ReplicationController不是监视单个节点上的各个进程，而是监视多个节点上的多个pod。</p>
<p>在讨论中，ReplicationController通常缩写为“rc”或“rcs”，并且作为kubectl命令中的快捷方式。</p>
<p>一个简单的例子是创建一个ReplicationController对象，以无限期地可靠地运行Pod的一个实例。更复杂的用例是运行复制服务的几个相同副本，例如Web服务器。</p>
<h5 id="运行示例ReplicationController"><a href="#运行示例ReplicationController" class="headerlink" title="运行示例ReplicationController"></a>运行示例ReplicationController</h5><p>此示例ReplicationController配置运行nginx Web服务器的三个副本。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#controllers/replication.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>通过下载示例文件然后运行此命令来运行示例作业：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>kubectl create -f <span class="symbol">https:</span>/<span class="regexp">/k8s.io/examples</span><span class="regexp">/controllers/replication</span>.yaml</span><br><span class="line">replicationcontroller/nginx created</span><br></pre></td></tr></table></figure></p>
<p>使用以下命令检查ReplicationController的状态：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe replicationcontrollers/nginx</span><br><span class="line">Name:        nginx</span><br><span class="line">Namespace:   default</span><br><span class="line">Selector:    <span class="attribute">app</span>=nginx</span><br><span class="line">Labels:      <span class="attribute">app</span>=nginx</span><br><span class="line">Annotations:    &lt;none&gt;</span><br><span class="line">Replicas:    3 current / 3 desired</span><br><span class="line">Pods Status: 0 Running / 3 Waiting / 0 Succeeded / 0 Failed</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:       <span class="attribute">app</span>=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:              nginx</span><br><span class="line">    Port:               80/TCP</span><br><span class="line">    Environment:        &lt;none&gt;</span><br><span class="line">    Mounts:             &lt;none&gt;</span><br><span class="line">  Volumes:              &lt;none&gt;</span><br><span class="line">Events:</span><br><span class="line">  FirstSeen       LastSeen     Count    <span class="keyword">From</span>                        SubobjectPath   <span class="built_in"> Type </span>     Reason              Message</span><br><span class="line">  ---------       --------     -----    ----                        -------------    ----      ------              -------</span><br><span class="line">  20s             20s          1        &#123;replication-controller &#125;                    Normal    SuccessfulCreate    Created pod: nginx-qrm3m</span><br><span class="line">  20s             20s          1        &#123;replication-controller &#125;                    Normal    SuccessfulCreate    Created pod: nginx-3ntk0</span><br><span class="line">  20s             20s          1        &#123;replication-controller &#125;                    Normal    SuccessfulCreate    Created pod: nginx-4ok8v</span><br></pre></td></tr></table></figure></p>
<p>  这里创建了三个pod，但没有一个正在运行，可能是因为正在拉动图像。稍后，相同的命令可能会显示：<br>  <figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pods Status:   <span class="number"> 3 </span>Running /<span class="number"> 0 </span>Waiting /<span class="number"> 0 </span>Succeeded /<span class="number"> 0 </span>Failed</span><br></pre></td></tr></table></figure></p>
<p>要以机器可读的形式列出属于ReplicationController的所有pod，可以使用如下命令：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  $ <span class="attribute">pods</span>=$(kubectl <span class="builtin-name">get</span> pods <span class="attribute">--selector</span>=app=nginx <span class="attribute">--output</span>=jsonpath=&#123;.items<span class="built_in">..</span>metadata.name&#125;)</span><br><span class="line">echo <span class="variable">$pods</span></span><br><span class="line">nginx-3ntk0 nginx-4ok8v nginx-qrm3m</span><br></pre></td></tr></table></figure></p>
<p>这里，选择器与ReplicationController的选择器相同（在<code>kubectl describe</code>输出中看到 ，并以不同的形式显示<code>replication.yaml</code>。该<code>--output=jsonpath</code>选项指定一个表达式，它只从返回列表中的每个pod获取名称。</p>
<h5 id="编写ReplicationController规范"><a href="#编写ReplicationController规范" class="headerlink" title="编写ReplicationController规范"></a>编写ReplicationController规范</h5><p>与所有其他Kubernetes配置，一个ReplicationController需要<code>apiVersion</code>，<code>kind</code>和<code>metadata</code>领域。有关使用配置文件的一般信息，请参阅<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">对象管理</a>。</p>
<p>ReplicationController还需要一个<a href="https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status" target="_blank" rel="noopener"><code>.spec</code>部分</a>。</p>
<h6 id="Pod模板-2"><a href="#Pod模板-2" class="headerlink" title="Pod模板"></a>Pod模板</h6><p>这<code>.spec.template</code>是唯一必需的领域<code>.spec</code>。</p>
<p>这<code>.spec.template</code>是一个<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#pod-templates" target="_blank" rel="noopener">pod模板</a>。它与pod具有完全相同的架构，除了它是嵌套的并且没有<code>apiVersion</code>或<code>kind</code>。</p>
<p>除了Pod的必需字段之外，ReplicationController中的pod模板还必须指定适当的标签和适当的重新启动策略。对于标签，请确保不要与其他控制器重叠。请参阅<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#pod-selector" target="_blank" rel="noopener">pod选择器</a>。</p>
<p>只允许<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy" target="_blank" rel="noopener"><code>.spec.template.spec.restartPolicy</code></a>等于<code>Always</code>，如果未指定，则为默认值。</p>
<p>对于本地容器重新启动，ReplicationControllers委托给节点上的代理程序，例如<a href="https://kubernetes.io/docs/admin/kubelet/" target="_blank" rel="noopener"><code>Kubelet</code></a>或Docker。</p>
<h6 id="ReplicationController上的标签"><a href="#ReplicationController上的标签" class="headerlink" title="ReplicationController上的标签"></a>ReplicationController上的标签</h6><p>ReplicationController本身可以有labels（<code>.metadata.labels</code>）。通常，您可以将它们设置为相同<code>.spec.template.metadata.labels</code>; 如果<code>.metadata.labels</code>未指定，则默认为<code>.spec.template.metadata.labels</code>。但是，允许它们不同，并且<code>.metadata.labels</code>不会影响ReplicationController的行为。</p>
<h6 id="Pod选择器-1"><a href="#Pod选择器-1" class="headerlink" title="Pod选择器"></a>Pod选择器</h6><p>该<code>.spec.selector</code>字段是<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors" target="_blank" rel="noopener">标签选择器</a>。ReplicationController管理具有与选择器匹配的标签的所有pod。它不区分它创建或删除的pod以及另一个人或进程创建或删除的pod。这允许在不影响正在运行的pod的情况下替换ReplicationController。</p>
<p>如果指定，则<code>.spec.template.metadata.labels</code>必须等于<code>.spec.selector</code>，否则将被API拒绝。如果<code>.spec.selector</code>未指定，则默认为<code>.spec.template.metadata.labels</code>。</p>
<p>此外，您通常不应创建任何标签与此选择器匹配的pod，可以直接创建，与另一个ReplicationController或其他控制器（如Job）匹配。如果这样做，ReplicationController会认为它创建了其他pod。Kubernetes并没有阻止你这样做。</p>
<p>如果最终有多个具有重叠选择器的控制器，则必须自己管理删除（见<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#working-with-replicationcontrollers" target="_blank" rel="noopener">下文</a>）。</p>
<h6 id="多个副本"><a href="#多个副本" class="headerlink" title="多个副本"></a>多个副本</h6><p>您可以通过设置<code>.spec.replicas</code>要同时运行的窗格数来指定应同时运行的窗格数。在任何时间运行的数字可能更高或更低，例如，如果副本只是增加或减少，或者如果正常关闭吊舱，并且提前开始更换。</p>
<p>如果未指定<code>.spec.replicas</code>，则默认为1。</p>
<h5 id="使用ReplicationControllers"><a href="#使用ReplicationControllers" class="headerlink" title="使用ReplicationControllers"></a>使用ReplicationControllers</h5><h6 id="删除ReplicationController及其Pod"><a href="#删除ReplicationController及其Pod" class="headerlink" title="删除ReplicationController及其Pod"></a>删除ReplicationController及其Pod</h6><p>要删除ReplicationController及其所有pod，请使用<code>kubectl delete</code>。在删除ReplicationController本身之前，Kubectl会将ReplicationController缩放为零并等待它删除每个pod。如果此kubectl命令被中断，则可以重新启动它。</p>
<p>使用REST API或转到客户端库时，需要显式执行这些步骤（将副本扩展为0，等待窗格删除，然后删除ReplicationController）。</p>
<h6 id="仅删除ReplicationController"><a href="#仅删除ReplicationController" class="headerlink" title="仅删除ReplicationController"></a>仅删除ReplicationController</h6><p>您可以删除ReplicationController而不影响其任何pod。</p>
<p>使用kubectl，指定<code>--cascade=false</code>选项<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#delete" target="_blank" rel="noopener"><code>kubectl delete</code></a>。</p>
<p>使用REST API或转到客户端库时，只需删除ReplicationController对象即可。</p>
<p>删除原始文件后，您可以创建一个新的ReplicationController来替换它。只要旧的和新<code>.spec.selector</code>的相同，那么新的将采用旧的pod。但是，它不会做任何努力使现有的pod匹配一个新的，不同的pod模板。要以受控方式将pod更新为新规范，请使用<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#rolling-updates" target="_blank" rel="noopener">滚动更新</a>。</p>
<h6 id="从ReplicationController中隔离pod"><a href="#从ReplicationController中隔离pod" class="headerlink" title="从ReplicationController中隔离pod"></a>从ReplicationController中隔离pod</h6><p>可以通过更改标签来从ReplicationController的目标集中删除Pod。此技术可用于从服务中删除pod以进行调试，数据恢复等。以这种方式删除的Pod将自动替换（假设副本的数量也未更改）。</p>
<h5 id="常见的使用模式"><a href="#常见的使用模式" class="headerlink" title="常见的使用模式"></a>常见的使用模式</h5><h6 id="重新安排"><a href="#重新安排" class="headerlink" title="重新安排"></a>重新安排</h6><p>如上所述，无论您是要保持运行1个pod还是1000个，ReplicationController都将确保存在指定数量的pod，即使在节点发生故障或pod终止时（例如，由于另一个控制剂）。</p>
<h6 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h6><p>通过简单地更新<code>replicas</code>字段，ReplicationController可以手动或通过自动缩放控制代理轻松扩展或缩小副本数量。</p>
<h6 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h6><p>ReplicationController旨在通过逐个替换pod来促进对服务的滚动更新。</p>
<p>如<a href="http://issue.k8s.io/1353" target="_blank" rel="noopener">＃1353</a>中所述，建议的方法是创建一个具有1个副本的新ReplicationController，逐个扩展新的（+1）和旧（-1）控制器，然后在它达到0个副本后删除旧控制器。无论意外故障如何，这都可以预测更新pod的集合。</p>
<p>理想情况下，滚动更新控制器会考虑应用程序准备情况，并确保在任何给定时间内有足够数量的pod可以高效地运行。</p>
<p>这两个ReplicationControllers需要创建具有至少一个区分标签的pod，例如pod的主容器的image标签，因为它通常是图像更新，可以激发滚动更新。</p>
<p>滚动更新在客户端工具中实现 <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rolling-update" target="_blank" rel="noopener"><code>kubectl rolling-update</code></a>。访问<a href="https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/" target="_blank" rel="noopener"><code>kubectl rolling-update</code></a>任务以获得更具体的示例。</p>
<h6 id="多个发行tracks"><a href="#多个发行tracks" class="headerlink" title="多个发行tracks"></a>多个发行tracks</h6><p>除了在滚动更新正在进行时运行多个版本的应用程序之外，通常使用多个版本跟踪长时间运行多个版本，甚至连续运行多个版本。轨道将按标签区分。</p>
<p>例如，服务可能会定位所有pod <code>tier in (frontend), environment in (prod)</code>。现在说你有10个复制的pod组成这个层。但是你希望能够’canary’这个组件的新版本。您可以<code>replicas</code>为大部分副本设置一个设置为9 的ReplicationController ，带有标签<code>tier=frontend, environment=prod, track=stable</code>，另一个<code>replicas</code>设置为1的带有标签的ReplicationController 用于canary<code>tier=frontend, environment=prod, track=canary</code>。现在该服务涵盖了canary和non-canary pods。但是你可以分别搞乱ReplicationControllers来测试，监视结果等。</p>
<h6 id="将ReplicationControllers与Services一起使用"><a href="#将ReplicationControllers与Services一起使用" class="headerlink" title="将ReplicationControllers与Services一起使用"></a>将ReplicationControllers与Services一起使用</h6><p>多个ReplicationControllers可以位于单个服务之后，例如，某些流量转到旧版本，有些流量转到新版本。</p>
<p>ReplicationController永远不会自行终止，但预计它不会像服务一样长寿。服务可以由多个ReplicationControllers控制的pod组成，并且预计可以在服务的生命周期内创建和销毁许多ReplicationController（例如，执行运行服务的pod的更新）。服务本身及其客户端都应该忽略维护服务pod的ReplicationControllers。</p>
<h5 id="编写复制程序"><a href="#编写复制程序" class="headerlink" title="编写复制程序"></a>编写复制程序</h5><p>由ReplicationController创建的Pod旨在是可互换的和语义相同的，尽管它们的配置可能随着时间的推移变得异构。这显然适用于复制的无状态服务器，但ReplicationControllers也可用于维护主选，分片和工作池应用程序的可用性。此类应用程序应使用动态工作分配机制，例如<a href="https://www.rabbitmq.com/tutorials/tutorial-two-python.html" target="_blank" rel="noopener">RabbitMQ工作队列</a>，而不是静态/一次性定制每个pod的配置，这被视为反模式。执行的任何pod自定义，例如资源的垂直自动调整（例如，cpu或内存），应由另一个在线控制器进程执行，与ReplicationController本身不同。</p>
<h5 id="ReplicationController的职责"><a href="#ReplicationController的职责" class="headerlink" title="ReplicationController的职责"></a>ReplicationController的职责</h5><p>ReplicationController只是确保所需数量的pod与其标签选择器匹配并且可以运行。目前，只有已终止的广告连播从其计数中排除。将来，可以考虑系统提供的<a href="http://issue.k8s.io/620" target="_blank" rel="noopener">准备情况</a>和其他信息，我们可以对替换策略添加更多控制，并且我们计划发出可以由外部客户使用的事件，以实现任意复杂的替换和/或扩展下行政策。</p>
<p>ReplicationController永远受限于这种狭隘的责任。它本身不会执行准备就绪或活力探测。它不是执行自动缩放，而是由外部自动缩放器控制（如<a href="http://issue.k8s.io/492" target="_blank" rel="noopener">＃492中所述</a>），这将改变其<code>replicas</code>字段。我们不会将调度策略（例如，<a href="http://issue.k8s.io/367#issuecomment-48428019" target="_blank" rel="noopener">传播</a>）添加到ReplicationController。它也不应该验证控制的pod与当前指定的模板匹配，因为这会妨碍自动调整大小和其他自动化过程。同样，完成期限，排序依赖性，配置扩展和其他功能属于其他地方。我们甚至计划分析批量pod创建的机制（<a href="http://issue.k8s.io/170" target="_blank" rel="noopener">＃170</a>）。</p>
<p>ReplicationController旨在成为可组合的构建块原语。我们希望在它和其他补充原语之上构建更高级别的API和/或工具，以便将来用户使用。kubectl目前支持的“宏”操作（运行，缩放，滚动更新）是概念验证的例子。例如，我们可以想象像<a href="http://techblog.netflix.com/2012/06/asgard-web-based-cloud-management-and.html" target="_blank" rel="noopener">Asgard</a>管理ReplicationControllers，自动缩放器，服务，调度策略，canary等。</p>
<h5 id="API对象-2"><a href="#API对象-2" class="headerlink" title="API对象"></a>API对象</h5><p>复制控制器是Kubernetes REST API中的顶级资源。有关API对象的更多详细信息，请访问： <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#replicationcontroller-v1-core" target="_blank" rel="noopener">ReplicationController API</a>对象。</p>
<h5 id="ReplicationController的替代品"><a href="#ReplicationController的替代品" class="headerlink" title="ReplicationController的替代品"></a>ReplicationController的替代品</h5><h6 id="ReplicaSet-1"><a href="#ReplicaSet-1" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h6><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener"><code>ReplicaSet</code></a>是支持新的<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#set-based-requirement" target="_blank" rel="noopener">基于集合的标签选择器</a>的下一代ReplicationController 。它主要用作<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener"><code>Deployment</code></a>协调pod创建，删除和更新的机制。请注意，除非您需要自定义更新编排或根本不需要更新，否则我们建议您使用“部署”而不是直接使用“副本集”。</p>
<h6 id="部署（推荐）-1"><a href="#部署（推荐）-1" class="headerlink" title="部署（推荐）"></a>部署（推荐）</h6><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener"><code>Deployment</code></a>是一个更高级别的API对象，它以类似的方式更新其基础副本集及其Pod <code>kubectl rolling-update</code>。如果您需要此滚动更新功能，则建议进行部署，因为<code>kubectl rolling-update</code>它们不同于声明式，服务器端，并具有其他功能。</p>
<h6 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h6><p>与用户直接创建pod的情况不同，ReplicationController替换因任何原因而被删除或终止的pod，例如在节点故障或破坏性节点维护（例如内核升级）的情况下。因此，即使您的应用程序只需要一个pod，我们也建议您使用ReplicationController。可以想象它与流程主管类似，只是它监控多个节点上的多个pod而不是单个节点上的单个进程。ReplicationController将本地容器重新启动委派给节点上的某个代理（例如，Kubelet或Docker）。</p>
<h6 id="job"><a href="#job" class="headerlink" title="job"></a>job</h6><p><a href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/" target="_blank" rel="noopener"><code>Job</code></a>对于预期会自行终止的pod（即批处理作业），请使用而不是ReplicationController。</p>
<h6 id="DaemonSet-1"><a href="#DaemonSet-1" class="headerlink" title="DaemonSet"></a>DaemonSet</h6><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener"><code>DaemonSet</code></a>对于提供机器级功能的pod，例如机器监视或机器日志记录，请使用而不是ReplicationController。这些pod的生命周期与机器生命周期相关：pod需要在其他pod启动之前在机器上运行，并且当机器准备好重新启动/关闭时可以安全终止。</p>
<h5 id="欲获得更多信息"><a href="#欲获得更多信息" class="headerlink" title="欲获得更多信息"></a>欲获得更多信息</h5><p>读取<a href="https://kubernetes.io/docs/tutorials/stateless-application/run-stateless-ap-replication-controller/" target="_blank" rel="noopener">运行无状态AP复制控制器</a>。</p>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>一个部署控制器提供声明更新<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="noopener">pod</a>和 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">ReplicaSets</a>。</p>
<p>您在Deployment对象中描述了所需的状态，Deployment控制器以受控速率将实际状态更改为所需状态。您可以定义部署以创建新的ReplicaSet，或者删除现有的部署并使用新的部署采用所有资源。</p>
<blockquote>
<p>注意：您不应管理部署所拥有的ReplicaSet。应通过操作Deployment对象来涵盖所有用例。如果您的用例未在下面介绍，请考虑在主Kubernetes存储库中打开一个问题。</p>
</blockquote>
<ul>
<li>用例</li>
<li>创建部署</li>
<li>更新部署</li>
<li>回滚部署</li>
<li>扩展部署</li>
<li>暂停和恢复部署</li>
<li>部署状态</li>
<li>清理政策</li>
<li>用例</li>
<li>编写部署规范</li>
<li>部署的替代方案</li>
</ul>
<h5 id="用例-1"><a href="#用例-1" class="headerlink" title="用例"></a>用例</h5><p>以下是部署的典型用例：</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#creating-a-deployment" target="_blank" rel="noopener">创建部署以部署副本集</a>。ReplicaSet在后台创建Pod。检查卷展栏的状态以查看它是否成功。</li>
<li>通过更新Deployment的PodTemplateSpec来<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#updating-a-deployment" target="_blank" rel="noopener">声明</a> Pod 的<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#updating-a-deployment" target="_blank" rel="noopener">新状态</a>。创建一个新的ReplicaSet，Deployment部署管理以受控速率将Pod从旧ReplicaSet移动到新ReplicaSet。每个新的ReplicaSet都会更新Deployment的修订版。</li>
<li>如果<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-back-a-deployment" target="_blank" rel="noopener">部署</a>的当前状态不稳定，则<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-back-a-deployment" target="_blank" rel="noopener">回滚到早期的部署修订版</a>。每次回滚都会更新Deployment的修订版。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#scaling-a-deployment" target="_blank" rel="noopener">扩展部署以促进更多负载</a>。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#pausing-and-resuming-a-deployment" target="_blank" rel="noopener">暂停部署</a>以将多个修复程序应用于其PodTemplateSpec，然后恢复它以启动新的部署。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#deployment-status" target="_blank" rel="noopener">使用部署的状态</a>作为卷展栏卡住的指示符。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#clean-up-policy" target="_blank" rel="noopener">清理</a>不再需要的<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#clean-up-policy" target="_blank" rel="noopener">旧ReplicaSet</a>。</li>
</ul>
<h5 id="创建部署"><a href="#创建部署" class="headerlink" title="创建部署"></a>创建部署</h5><p>以下是部署的示例。它创建一个ReplicaSet来调出三个Pod <code>nginx</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#controllers/nginx-deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中：</p>
<ul>
<li><code>nginx-deployment</code>创建名为的部署，由<code>.metadata.name</code>字段指示。</li>
<li>部署创建三个复制的Pod，由<code>replicas</code>字段指示。</li>
<li>该<code>selector</code>字段定义了Deployment如何找到要管理的Pod。在这种情况下，您只需选择Pod模板（<code>app: nginx</code>）中定义的标签。但是，只要Pod模板本身满足规则，就可以使用更复杂的选择规则。</li>
</ul>
<blockquote>
<p>注意： <code>matchLabels</code>是{key，value}对的映射。<code>matchLabels</code>映射中的单个{key，value} 等效<code>matchExpressions</code>于其元素，其键字段为“key”，运算符为“In”，值数组仅包含“value”。要求是AND。</p>
</blockquote>
<ul>
<li>该<code>template</code>字段包含以下子字段：<ul>
<li><code>app: nginx</code>使用该<code>labels</code>字段标记Pod 。</li>
<li>Pod模板的规范或.template.spec字段表示Pod 运行一个容器nginx，该容器在版本1.7.9下运行nginx Docker Hub映像。</li>
<li>创建一个容器并nginx使用该name字段命名。</li>
<li>nginx在版本运行图像1.7.9。</li>
<li>打开端口，80以便容器可以发送和接受流量。</li>
</ul>
</li>
</ul>
<p>要创建此部署，请运行以下命令：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f https:<span class="regexp">//</span>k8s.io<span class="regexp">/examples/</span>controllers<span class="regexp">/nginx-deployment.yaml</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：您可以指定<code>--record</code>标志以写入在资源批注中执行的命令kubernetes.io/change-cause。它对于将来的内省非常有用，例如，可以查看每个Deployment修订版中执行的命令。</p>
</blockquote>
<p>接下来，运行<code>kubectl get deployments</code>。输出类似于以下内容：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment   <span class="number">3</span>         <span class="number">0</span>         <span class="number">0</span>            <span class="number">0</span>           <span class="number">1</span>s</span><br></pre></td></tr></table></figure></p>
<p>检查群集中的“部署”时，将显示以下字段：</p>
<ul>
<li><code>NAME</code> 列出群集中的部署名称。</li>
<li><code>DESIRED</code>显示应用程序的所需副本数，您在创建部署时定义这些副本。这是理想的状态。</li>
<li><code>CURRENT</code> 显示当前正在运行的副本数量。</li>
<li><code>UP-TO-DATE</code> 显示已更新以实现所需状态的副本数。</li>
<li><code>AVAILABLE</code> 显示用户可以使用的应用程序副本数。</li>
<li><code>AGE</code> 显示应用程序运行的时间。</li>
</ul>
<p>请注意每个字段中的值如何与Deployment规范中的值相对应：</p>
<ul>
<li>根据<code>.spec.replicas</code>字段，所需副本的数量为3 。</li>
<li>根据<code>.status.replicas</code>字段，当前副本的数量为0 。</li>
<li>根据<code>.status.updatedReplicas</code>字段，最新副本的数量为0 。</li>
<li>根据<code>.status.availableReplicas</code>字段，可用副本的数量为0 。</li>
</ul>
<p>要查看“部署”卷展栏状态，请运行<code>kubectl rollout status deployment.v1.apps/nginx-deployment</code>。此命令返回以下输出：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Waiting <span class="keyword">for</span> rollout <span class="keyword">to</span> finish: <span class="number">2</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="number">3</span> <span class="keyword">new</span> replicas have been updated...</span><br><span class="line">deployment.apps/nginx-deployment successfully rolled <span class="keyword">out</span></span><br></pre></td></tr></table></figure></p>
<p><code>kubectl get deployments</code>几秒钟后再次运行：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>            <span class="number">3</span>           <span class="number">18</span>s</span><br></pre></td></tr></table></figure></p>
<p>请注意，Deployment已创建所有三个副本，并且所有副本都是最新的（它们包含最新的Pod模板）并且可用（Pod状态至少为Deployment的<code>.spec.minReadySeconds</code>字段值准备就绪）。</p>
<p>要查看<code>rs</code>部署创建的ReplicaSet（），请运行<code>kubectl get rs</code>：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                          DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deployment<span class="number">-2035384211</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>       <span class="number">18</span>s</span><br></pre></td></tr></table></figure></p>
<p>请注意，ReplicaSet的名称始终格式为<code>[DEPLOYMENT-NAME]-[POD-TEMPLATE-HASH-VALUE]</code>。创建部署时会自动生成哈希值。</p>
<p>要查看为每个pod自动生成的标签，请运行<code>kubectl get pods --show-labels</code>。返回以下输出：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                                READY     STATUS    RESTARTS   AGE       LABELS</span><br><span class="line">nginx-deployment<span class="number">-2035384211</span><span class="number">-7</span>ci7o   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">18</span>s       app=nginx,pod-template-hash=<span class="number">2035384211</span></span><br><span class="line">nginx-deployment<span class="number">-2035384211</span>-kzszj   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">18</span>s       app=nginx,pod-template-hash=<span class="number">2035384211</span></span><br><span class="line">nginx-deployment<span class="number">-2035384211</span>-qqcnn   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">18</span>s       app=nginx,pod-template-hash=<span class="number">2035384211</span></span><br></pre></td></tr></table></figure></p>
<p>创建的ReplicaSet确保始终有三个Pod <code>nginx</code>在运行。</p>
<blockquote>
<p>注意：您必须在部署中指定适当的选择器和Pod模板标签（在本例中 <code>app: nginx</code>）。不要将标签或选择器与其他控制器（包括其他部署和StatefulSet）重叠。Kubernetes不会阻止您重叠，如果多个控制器具有重叠的选择器，那么这些控制器可能会发生冲突并出现意外行为。</p>
</blockquote>
<h6 id="Pod-template-hash标签"><a href="#Pod-template-hash标签" class="headerlink" title="Pod-template-hash标签"></a>Pod-template-hash标签</h6><blockquote>
<p>注意：请勿更改此标签。</p>
</blockquote>
<p><code>pod-template-hash</code>部署控制器将标签添加到部署创建或采用的每个ReplicaSet。</p>
<p>此标签可确保部署的子ReplicaSet不重叠。它是通过散列<code>PodTemplate</code>ReplicaSet并使用生成的散列作为添加到ReplicaSet选择器，Pod模板标签以及ReplicaSet可能具有的任何现有Pod中的标签值生成的。</p>
<h5 id="更新部署"><a href="#更新部署" class="headerlink" title="更新部署"></a>更新部署</h5><blockquote>
<p>注意：当且仅当部署的pod模板（即<code>.spec.template</code>）更改时，才会触发Deployment的部署，例如，如果更新模板的标签或容器图像。其他更新（例如扩展部署）不会触发部署。</p>
</blockquote>
<p>假设您现在想要更新nginx Pod以使用<code>nginx:1.9.1</code>镜像而不是<code>nginx:1.7.9</code>图像。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl --record deployment.apps/nginx-deployment <span class="builtin-name">set</span> image deployment.v1.apps/nginx-deployment</span><br><span class="line"><span class="attribute">nginx</span>=nginx:1.9.1 image updated</span><br></pre></td></tr></table></figure></p>
<p>或者，您可以<code>edit</code>部署和改变<code>.spec.template.spec.containers[0].image</code>从<code>nginx:1.7.9</code>到<code>nginx:1.9.1</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl edit deployment<span class="selector-class">.v1</span><span class="selector-class">.apps</span>/nginx-deployment</span><br><span class="line">deployment.apps/nginx-deployment edited</span><br></pre></td></tr></table></figure>
<p>要查看卷展栏状态，请运行：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout status deployment.v1.apps/nginx-deployment</span><br><span class="line">Waiting <span class="keyword">for</span> rollout <span class="keyword">to</span> finish: <span class="number">2</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="number">3</span> <span class="keyword">new</span> replicas have been updated...</span><br><span class="line">deployment.apps/nginx-deployment successfully rolled <span class="keyword">out</span></span><br></pre></td></tr></table></figure></p>
<p>部署成功后，您可能需要<code>get</code>部署：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deployments</span><br><span class="line">NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>            <span class="number">3</span>           <span class="number">36</span>s</span><br></pre></td></tr></table></figure></p>
<p>最新副本的数量表示Deployment已将副本更新为最新配置。当前副本表示此部署管理的副本总数，可用副本表示可用的当前副本数。</p>
<p>您可以运行<code>kubectl get rs</code>以查看部署通过创建新的ReplicaSet并将其扩展到3个副本来更新Pod，以及将旧的ReplicaSet缩减为0个副本。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get rs</span><br><span class="line">NAME                          DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>       <span class="number">6</span>s</span><br><span class="line">nginx-deployment<span class="number">-2035384211</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">36</span>s</span><br></pre></td></tr></table></figure></p>
<p><code>get pods</code>现在运行应该只显示新的Pod：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME                                READY     STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span>-khku8   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>s</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span>-nacti   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>s</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span>-z9gth   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>s</span><br></pre></td></tr></table></figure></p>
<p>下次要更新这些Pod时，只需再次更新Deployment的pod模板。</p>
<p>部署可以确保在更新时只有一定数量的Pod可能会关闭。默认情况下，它确保至少比所需的Pod数量少25％（最大不可用25％）。</p>
<p>部署还可以确保在所需数量的Pod之上只能创建一定数量的Pod。默认情况下，它确保最多比所需数量的Pod多25％（最大浪涌25％）。</p>
<p>例如，如果仔细查看上面的部署，您将看到它首先创建了一个新的Pod，然后删除了一些旧的Pod并创建了新的Pod。在有足够数量的新Pod出现之前，它不会杀死旧的Pod，并且在足够数量的旧Pod被杀之前不会创建新的Pod。它确保可用Pod的数量至少为2，并且Pod的总数最多为4。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe deployments</span><br><span class="line">Name:                   nginx-deployment</span><br><span class="line">Namespace:              default</span><br><span class="line">CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000</span><br><span class="line">Labels:                 <span class="attribute">app</span>=nginx</span><br><span class="line">Annotations:            deployment.kubernetes.io/<span class="attribute">revision</span>=2</span><br><span class="line">Selector:               <span class="attribute">app</span>=nginx</span><br><span class="line">Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  <span class="attribute">app</span>=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:        nginx:1.9.1</span><br><span class="line">    Port:         80/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line"> <span class="built_in"> Type </span>          Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      <span class="literal">True</span>    MinimumReplicasAvailable</span><br><span class="line">  Progressing    <span class="literal">True</span>    NewReplicaSetAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   nginx-deployment-1564180365 (3/3 replicas created)</span><br><span class="line">Events:</span><br><span class="line"> <span class="built_in"> Type </span>   Reason             Age   <span class="keyword">From</span>                   Message</span><br><span class="line">  ----    ------             ----  ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 3</span><br><span class="line">  Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-1564180365 <span class="keyword">to</span> 1</span><br><span class="line">  Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 2</span><br><span class="line">  Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-1564180365 <span class="keyword">to</span> 2</span><br><span class="line">  Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 1</span><br><span class="line">  Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-1564180365 <span class="keyword">to</span> 3</span><br><span class="line">  Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 0</span><br></pre></td></tr></table></figure></p>
<p>在这里，您可以看到，当您第一次创建部署时，它创建了一个ReplicaSet（nginx-deployment-2035384211）并直接将其扩展到3个副本。更新部署时，它创建了一个新的ReplicaSet（nginx-deployment-1564180365）并将其扩展为1，然后将旧的ReplicaSet缩小为2，这样至少有2个Pod可用，最多创建了4个Pod一直。然后，它继续使用相同的滚动更新策略向上和向下扩展新旧ReplicaSet。最后，您将在新的ReplicaSet中拥有3个可用副本，并将旧的ReplicaSet缩小为0。</p>
<h6 id="Rollover-aka-multiple-updates-in-flight"><a href="#Rollover-aka-multiple-updates-in-flight" class="headerlink" title="Rollover (aka multiple updates in-flight)"></a>Rollover (aka multiple updates in-flight)</h6><p>每次部署控制器观察到新的部署对象时，如果没有现有的ReplicaSet，则会创建ReplicaSet以显示所需的Pod。现有的ReplicaSet控制其标签匹配<code>.spec.selector</code>但模板不匹配的Pod <code>.spec.template</code>按比例缩小。最终，新的ReplicaSet将缩放到，<code>.spec.replicas</code>并且所有旧的ReplicaSet将缩放为0。</p>
<p>如果在现有部署过程中更新部署，则部署将根据更新创建新的ReplicaSet并开始向上扩展，并将翻转之前正在扩展的ReplicaSet - 它会将其添加到其列表中旧的ReplicaSet和将开始缩小它。</p>
<p>例如，假设您创建了一个部署以创建5个副本<code>nginx:1.7.9</code>，但是<code>nginx:1.9.1</code>当仅创建了3个副本时，则更新部署以创建5个副本<code>nginx:1.7.9</code>。在这种情况下，部署将立即开始杀死<code>nginx:1.7.9</code>它创建的3个Pod，并将开始创建 <code>nginx:1.9.1Pod</code>。<code>nginx:1.7.9</code>在更改课程之前，它不会等待创建5个副本。</p>
<h6 id="标签选择器更新"><a href="#标签选择器更新" class="headerlink" title="标签选择器更新"></a>标签选择器更新</h6><p>通常不鼓励进行标签选择器更新，建议您事先规划选择器。在任何情况下，如果您需要执行标签选择器更新，请务必小心谨慎，并确保您已掌握所有含义。</p>
<blockquote>
<p>注意：在API版本中<code>apps/v1</code>，部署的标签选择器在创建后是不可变的。</p>
</blockquote>
<ul>
<li>选择器添加要求使用新标签更新部署规范中的pod模板标签，否则将返回验证错误。此更改是非重叠的，这意味着新选择器不会选择使用旧选择器创建的ReplicaSet和Pod，从而导致孤立所有旧ReplicaSet并创建新的ReplicaSet。</li>
<li>选择器更新 - 即更改选择器键中的现有值 - 导致与添加相同的行为。</li>
<li>选择器删除 - 即从部署选择器中删除现有密钥 - 不需要对pod模板标签进行任何更改。没有现有的ReplicaSet是孤立的，并且未创建新的ReplicaSet，但请注意，已删除的标签仍存在于任何现有的Pod和ReplicaSet中。</li>
</ul>
<h5 id="回滚部署"><a href="#回滚部署" class="headerlink" title="回滚部署"></a>回滚部署</h5><p>有时您可能想要回滚部署; 例如，当部署不稳定时，例如崩溃循环。默认情况下，所有Deployment的卷展栏历史记录都保留在系统中，以便您可以随时回滚（可以通过修改修订历史记录限制来更改）。</p>
<blockquote>
<p>注意：触发Deployment的部署时会创建Deployment的修订版。这意味着当且仅当部署的pod模板（<code>.spec.template</code>）发生更改时才会创建新修订，例如，如果更新模板的标签或容器图像。其他更新（例如扩展部署）不会创建部署版本，因此您可以方便地同时进行手动或自动扩展。这意味着当您回滚到早期版本时，仅回滚Deployment的pod模板部分。</p>
</blockquote>
<p>假设您在更新部署时输入了拼写错误，方法是将图像名称<code>nginx:1.91</code>替换为<code>nginx:1.9.1</code>：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">set</span> image deployment.v1.apps/nginx-deployment <span class="attribute">nginx</span>=nginx:1.91 <span class="attribute">--record</span>=<span class="literal">true</span></span><br><span class="line">deployment.apps/nginx-deployment image updated</span><br></pre></td></tr></table></figure>
<p>推出将被卡住。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout status deployment.v1.apps/nginx-deployment</span><br><span class="line">Waiting <span class="keyword">for</span> rollout <span class="keyword">to</span> finish: <span class="number">1</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="number">3</span> <span class="keyword">new</span> replicas have been updated...</span><br></pre></td></tr></table></figure></p>
<p>按Ctrl-C可停止上面的卷展状态监视。有关卡片推出的更多信息， <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#deployment-status" target="_blank" rel="noopener">请在此处阅读更多信息</a>。</p>
<p>您将看到旧副本的数量（nginx-deployment-1564180365和nginx-deployment-2035384211）为2，新副本（nginx-deployment-3066724191）为1。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get rs</span><br><span class="line">NAME                          DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>       <span class="number">25</span>s</span><br><span class="line">nginx-deployment<span class="number">-2035384211</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">36</span>s</span><br><span class="line">nginx-deployment<span class="number">-3066724191</span>   <span class="number">1</span>         <span class="number">1</span>         <span class="number">0</span>       <span class="number">6</span>s</span><br></pre></td></tr></table></figure></p>
<p>查看创建的Pod，您将看到由新ReplicaSet创建的1 Pod陷入图像拉环。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME                                READY     STATUS             RESTARTS   AGE</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span><span class="number">-70</span>iae   <span class="number">1</span>/<span class="number">1</span>       Running            <span class="number">0</span>          <span class="number">25</span>s</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span>-jbqqo   <span class="number">1</span>/<span class="number">1</span>       Running            <span class="number">0</span>          <span class="number">25</span>s</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span>-hysrc   <span class="number">1</span>/<span class="number">1</span>       Running            <span class="number">0</span>          <span class="number">25</span>s</span><br><span class="line">nginx-deployment<span class="number">-3066724191</span><span class="number">-08</span>mng   <span class="number">0</span>/<span class="number">1</span>       ImagePullBackOff   <span class="number">0</span>          <span class="number">6</span>s</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意： Deployment控制器将自动停止错误的卷展栏，并将停止扩展新的ReplicaSet。这取决于maxUnavailable您指定的rollingUpdate参数（特别是）。默认情况下，Kubernetes将值设置为25％。</p>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe deployment</span><br><span class="line">Name:           nginx-deployment</span><br><span class="line">Namespace:      default</span><br><span class="line">CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700</span><br><span class="line">Labels:         <span class="attribute">app</span>=nginx</span><br><span class="line">Selector:       <span class="attribute">app</span>=nginx</span><br><span class="line">Replicas:       3 desired | 1 updated | 4 total | 3 available | 1 unavailable</span><br><span class="line">StrategyType:       RollingUpdate</span><br><span class="line">MinReadySeconds:    0</span><br><span class="line">RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  <span class="attribute">app</span>=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:        nginx:1.91</span><br><span class="line">    Port:         80/TCP</span><br><span class="line">    Host Port:    0/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line"> <span class="built_in"> Type </span>          Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      <span class="literal">True</span>    MinimumReplicasAvailable</span><br><span class="line">  Progressing    <span class="literal">True</span>    ReplicaSetUpdated</span><br><span class="line">OldReplicaSets:     nginx-deployment-1564180365 (3/3 replicas created)</span><br><span class="line">NewReplicaSet:      nginx-deployment-3066724191 (1/1 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  FirstSeen LastSeen    Count   <span class="keyword">From</span>                    SubobjectPath  <span class="built_in"> Type </span>       Reason              Message</span><br><span class="line">  --------- --------    -----   ----                    -------------   --------    ------              -------</span><br><span class="line">  1m        1m          1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled up replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 3</span><br><span class="line">  22s       22s         1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled up replica <span class="builtin-name">set</span> nginx-deployment-1564180365 <span class="keyword">to</span> 1</span><br><span class="line">  22s       22s         1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled down replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 2</span><br><span class="line">  22s       22s         1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled up replica <span class="builtin-name">set</span> nginx-deployment-1564180365 <span class="keyword">to</span> 2</span><br><span class="line">  21s       21s         1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled down replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 1</span><br><span class="line">  21s       21s         1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled up replica <span class="builtin-name">set</span> nginx-deployment-1564180365 <span class="keyword">to</span> 3</span><br><span class="line">  13s       13s         1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled down replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 0</span><br><span class="line">  13s       13s         1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled up replica <span class="builtin-name">set</span> nginx-deployment-3066724191 <span class="keyword">to</span> 1</span><br></pre></td></tr></table></figure>
<p>要解决此问题，您需要回滚到稳定的以前版本的Deployment。</p>
<h6 id="检查部署的部署历史记录"><a href="#检查部署的部署历史记录" class="headerlink" title="检查部署的部署历史记录"></a>检查部署的部署历史记录</h6><p>首先，检查此部署的修订版：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout history deployment.v1.apps/nginx-deployment</span><br><span class="line">deployments <span class="string">"nginx-deployment"</span></span><br><span class="line">REVISION    CHANGE-CAUSE</span><br><span class="line">1           kubectl create <span class="attribute">--filename</span>=https://k8s.io/examples/controllers/nginx-deployment.yaml <span class="attribute">--record</span>=<span class="literal">true</span></span><br><span class="line">2           kubectl <span class="builtin-name">set</span> image deployment.v1.apps/nginx-deployment <span class="attribute">nginx</span>=nginx:1.9.1 <span class="attribute">--record</span>=<span class="literal">true</span></span><br><span class="line">3           kube    ctl <span class="builtin-name">set</span> image deployment.v1.apps/nginx-deployment <span class="attribute">nginx</span>=nginx:1.91 <span class="attribute">--record</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p><code>CHANGE-CAUSEkubernetes.io/change-cause</code>在创建时从部署批注复制到其修订版。您可以<code>CHANGE-CAUSE</code>通过以下方式指定消息： </p>
<ul>
<li>注释部署 <code>kubectl annotate deployment.v1.apps/nginx-deployment kubernetes.io/change-cause=&quot;image updated to 1.9.1&quot;</code></li>
<li>附加<code>--record</code>标志以保存<code>kubectl</code>对资源进行更改的命令。</li>
<li>手动编辑资源的清单。</li>
</ul>
<p>要进一步查看每个修订的详细信息，请运行：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout history deployment.v1.apps/nginx-deployment <span class="attribute">--revision</span>=2</span><br><span class="line">deployments <span class="string">"nginx-deployment"</span> revision 2</span><br><span class="line">  Labels:       <span class="attribute">app</span>=nginx</span><br><span class="line">          <span class="attribute">pod-template-hash</span>=1159050644</span><br><span class="line">  Annotations:  kubernetes.io/<span class="attribute">change-cause</span>=kubectl <span class="builtin-name">set</span> image deployment.v1.apps/nginx-deployment <span class="attribute">nginx</span>=nginx:1.9.1 <span class="attribute">--record</span>=<span class="literal">true</span></span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:      nginx:1.9.1</span><br><span class="line">    Port:       80/TCP</span><br><span class="line">     QoS Tier:</span><br><span class="line">        cpu:      BestEffort</span><br><span class="line">        memory:   BestEffort</span><br><span class="line">    Environment Variables:      &lt;none&gt;</span><br><span class="line">  <span class="literal">No</span> volumes.</span><br></pre></td></tr></table></figure></p>
<h6 id="回滚到以前的版本"><a href="#回滚到以前的版本" class="headerlink" title="回滚到以前的版本"></a>回滚到以前的版本</h6><p>现在，您已决定撤消当前的卷展栏并回滚到上一版本：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout undo deployment<span class="selector-class">.v1</span><span class="selector-class">.apps</span>/nginx-deployment</span><br><span class="line">deployment.apps/nginx-deployment</span><br></pre></td></tr></table></figure></p>
<p>或者，您可以通过在<code>--to-revision</code>以下位置指定回滚到特定修订：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout undo deployment<span class="selector-class">.v1</span><span class="selector-class">.apps</span>/nginx-deployment --to-revision=<span class="number">2</span></span><br><span class="line">deployment.apps/nginx-deployment</span><br></pre></td></tr></table></figure></p>
<p>有关与推出相关的命令的更多详细信息，请阅读<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rollout" target="_blank" rel="noopener">kubectl rollout</a>。</p>
<p>部署现在回滚到以前的稳定版本。如您所见，<code>DeploymentRollback</code>从Deployment控制器生成用于回滚到版本2 的事件。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">get</span> deployment nginx-deployment</span><br><span class="line">NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment   3         3         3            3           30m</span><br><span class="line"></span><br><span class="line">$ kubectl describe deployment nginx-deployment</span><br><span class="line">Name:                   nginx-deployment</span><br><span class="line">Namespace:              default</span><br><span class="line">CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500</span><br><span class="line">Labels:                 <span class="attribute">app</span>=nginx</span><br><span class="line">Annotations:            deployment.kubernetes.io/<span class="attribute">revision</span>=4</span><br><span class="line">                        kubernetes.io/<span class="attribute">change-cause</span>=kubectl <span class="builtin-name">set</span> image deployment.v1.apps/nginx-deployment <span class="attribute">nginx</span>=nginx:1.9.1 <span class="attribute">--record</span>=<span class="literal">true</span></span><br><span class="line">Selector:               <span class="attribute">app</span>=nginx</span><br><span class="line">Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  <span class="attribute">app</span>=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:        nginx:1.9.1</span><br><span class="line">    Port:         80/TCP</span><br><span class="line">    Host Port:    0/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line"> <span class="built_in"> Type </span>          Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      <span class="literal">True</span>    MinimumReplicasAvailable</span><br><span class="line">  Progressing    <span class="literal">True</span>    NewReplicaSetAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   nginx-deployment-c4747d96c (3/3 replicas created)</span><br><span class="line">Events:</span><br><span class="line"> <span class="built_in"> Type </span>   Reason              Age   <span class="keyword">From</span>                   Message</span><br><span class="line">  ----    ------              ----  ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-75675f5897 <span class="keyword">to</span> 3</span><br><span class="line">  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-c4747d96c <span class="keyword">to</span> 1</span><br><span class="line">  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica <span class="builtin-name">set</span> nginx-deployment-75675f5897 <span class="keyword">to</span> 2</span><br><span class="line">  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-c4747d96c <span class="keyword">to</span> 2</span><br><span class="line">  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica <span class="builtin-name">set</span> nginx-deployment-75675f5897 <span class="keyword">to</span> 1</span><br><span class="line">  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-c4747d96c <span class="keyword">to</span> 3</span><br><span class="line">  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica <span class="builtin-name">set</span> nginx-deployment-75675f5897 <span class="keyword">to</span> 0</span><br><span class="line">  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-595696685f <span class="keyword">to</span> 1</span><br><span class="line">  Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment <span class="string">"nginx-deployment"</span> <span class="keyword">to</span> revision 2</span><br><span class="line">  Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica <span class="builtin-name">set</span> nginx-deployment-595696685f <span class="keyword">to</span> 0</span><br></pre></td></tr></table></figure></p>
<h5 id="扩展部署"><a href="#扩展部署" class="headerlink" title="扩展部署"></a>扩展部署</h5><p>您可以使用以下命令扩展部署：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl scale deployment<span class="selector-class">.v1</span><span class="selector-class">.apps</span>/nginx-deployment --replicas=<span class="number">10</span></span><br><span class="line">deployment.apps/nginx-deployment scaled</span><br></pre></td></tr></table></figure></p>
<p>假设在群集中启用了<a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/" target="_blank" rel="noopener">水平pod自动缩放</a>，则可以为Deployment设置自动缩放器，并根据现有Pod的CPU利用率选择要运行的最小和最大<a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/" target="_blank" rel="noopener">Pod</a>数。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl autoscale deployment.v1.apps/nginx-deployment <span class="attribute">--min</span>=10 <span class="attribute">--max</span>=15 <span class="attribute">--cpu-percent</span>=80</span><br><span class="line">deployment.apps/nginx-deployment scaled</span><br></pre></td></tr></table></figure>
<h6 id="比例缩放"><a href="#比例缩放" class="headerlink" title="比例缩放"></a>比例缩放</h6><p>RollingUpdate Deployments支持同时运行多个版本的应用程序。当您或自动扩展器扩展正在部署（正在进行或暂停）的RollingUpdate部署时，部署控制器将平衡现有活动副本集（具有Pod的副本集）中的其他副本，以降低风险。这称为比例缩放。</p>
<p>例如，您正在运行具有10个副本的部署，<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#max-surge" target="_blank" rel="noopener"><code>maxSurge</code></a> = 3和<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#max-unavailable" target="_blank" rel="noopener"><code>maxUnavailable</code></a> = 2。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deploy</span><br><span class="line">NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment     <span class="number">10</span>        <span class="number">10</span>        <span class="number">10</span>           <span class="number">10</span>          <span class="number">50</span>s</span><br></pre></td></tr></table></figure></p>
<p>您更新到一个新的映像，该映像恰好在集群内部无法解析。<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> kubectl <span class="keyword">set</span> image <span class="comment">deployment.v1.apps</span>/nginx-deployment nginx=nginx:sometag</span><br><span class="line">deployment.apps/<span class="comment">nginx-deployment image updated</span></span><br></pre></td></tr></table></figure></p>
<p>图像更新使用ReplicaSet nginx-deployment-1989198191开始新的部署，但由于<code>maxUnavailable</code>您在上面提到的要求而被阻止 。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get rs</span><br><span class="line">NAME                          DESIRED   CURRENT   READY     AGE</span><br><span class="line">nginx-deployment<span class="number">-1989198191</span>   <span class="number">5</span>         <span class="number">5</span>         <span class="number">0</span>         <span class="number">9</span>s</span><br><span class="line">nginx-deployment<span class="number">-618515232</span>    <span class="number">8</span>         <span class="number">8</span>         <span class="number">8</span>         <span class="number">1</span>m</span><br></pre></td></tr></table></figure></p>
<p>然后出现一个新的部署扩展请求。自动缩放器将部署副本增加到15.部署控制器需要决定在哪里添加这些新的5个副本。如果您没有使用比例缩放，则所有5个都将添加到新的ReplicaSet中。通过比例缩放，您可以在所有ReplicaSet上传播其他副本。具有最多副本的ReplicaSets和较低比例的较大比例将转到具有较少副本的ReplicaSet。任何剩余物都会添加到具有最多副本的ReplicaSet中。零副本的ReplicaSet不会按比例放大。</p>
<p>在上面的示例中，3个副本将添加到旧的ReplicaSet中，2个副本将添加到新的ReplicaSet中。假设新副本变得健康，推出过程最终应将所有副本移动到新的ReplicaSet。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deploy</span><br><span class="line">NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment     <span class="number">15</span>        <span class="number">18</span>        <span class="number">7</span>            <span class="number">8</span>           <span class="number">7</span>m</span><br><span class="line">$ kubectl get rs</span><br><span class="line">NAME                          DESIRED   CURRENT   READY     AGE</span><br><span class="line">nginx-deployment<span class="number">-1989198191</span>   <span class="number">7</span>         <span class="number">7</span>         <span class="number">0</span>         <span class="number">7</span>m</span><br><span class="line">nginx-deployment<span class="number">-618515232</span>    <span class="number">11</span>        <span class="number">11</span>        <span class="number">11</span>        <span class="number">7</span>m</span><br></pre></td></tr></table></figure></p>
<h5 id="暂停和恢复部署"><a href="#暂停和恢复部署" class="headerlink" title="暂停和恢复部署"></a>暂停和恢复部署</h5><p>您可以在触发一个或多个更新之前暂停部署，然后恢复它。这将允许您在暂停和恢复之间应用多个修复，而不会触发不必要的部署。</p>
<p>例如，使用刚刚创建的部署：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deploy</span><br><span class="line">NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx     <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>            <span class="number">3</span>           <span class="number">1</span>m</span><br><span class="line">$ kubectl get rs</span><br><span class="line">NAME               DESIRED   CURRENT   READY     AGE</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>         <span class="number">1</span>m</span><br></pre></td></tr></table></figure></p>
<p>通过运行以下命令暂停：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout pause deployment<span class="selector-class">.v1</span><span class="selector-class">.apps</span>/nginx-deployment</span><br><span class="line">deployment.apps/nginx-deployment paused</span><br></pre></td></tr></table></figure></p>
<p>然后更新部署的映像：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> kubectl <span class="keyword">set</span> image <span class="comment">deployment.v1.apps</span>/nginx-deployment nginx=nginx:<span class="number">1.9</span><span class="number">.1</span></span><br><span class="line">deployment.apps/<span class="comment">nginx-deployment image updated</span></span><br></pre></td></tr></table></figure></p>
<p>请注意，没有新的卷展栏开始：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout history deployment.v1.apps/nginx-deployment</span><br><span class="line">deployments <span class="string">"nginx"</span></span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line"><span class="number">1</span>   &lt;none&gt;</span><br><span class="line"></span><br><span class="line">$ kubectl get rs</span><br><span class="line">NAME               DESIRED   CURRENT   READY     AGE</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>         <span class="number">2</span>m</span><br></pre></td></tr></table></figure></p>
<p>您可以根据需要进行更多更新，例如，更新将使用的资源：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">set</span> resources deployment.v1.apps/nginx-deployment <span class="attribute">-c</span>=nginx <span class="attribute">--limits</span>=cpu=200m,memory=512Mi</span><br><span class="line">deployment.apps/nginx-deployment<span class="built_in"> resource </span>requirements updated</span><br></pre></td></tr></table></figure></p>
<p>暂停之前部署的初始状态将继续其功能，但只要部署暂停，部署的新更新将不会产生任何影响。</p>
<p>最后，恢复部署并观察一个新的ReplicaSet，提供所有新的更新：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout resume deployment.v1.apps/nginx-deployment</span><br><span class="line">deployment.apps/nginx-deployment resumed</span><br><span class="line">$ kubectl get rs -w</span><br><span class="line">NAME               DESIRED   CURRENT   READY     AGE</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">2</span>         <span class="number">2</span>         <span class="number">2</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">2</span>         <span class="number">2</span>         <span class="number">0</span>         <span class="number">6</span>s</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">2</span>         <span class="number">2</span>         <span class="number">1</span>         <span class="number">18</span>s</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">1</span>         <span class="number">2</span>         <span class="number">2</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">1</span>         <span class="number">2</span>         <span class="number">2</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">3</span>         <span class="number">2</span>         <span class="number">1</span>         <span class="number">18</span>s</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">3</span>         <span class="number">2</span>         <span class="number">1</span>         <span class="number">18</span>s</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">1</span>         <span class="number">1</span>         <span class="number">1</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">1</span>         <span class="number">18</span>s</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">2</span>         <span class="number">19</span>s</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">0</span>         <span class="number">1</span>         <span class="number">1</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">0</span>         <span class="number">1</span>         <span class="number">1</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>         <span class="number">20</span>s</span><br><span class="line">^C</span><br><span class="line">$ kubectl get rs</span><br><span class="line">NAME               DESIRED   CURRENT   READY     AGE</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>         <span class="number">28</span>s</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：在恢复暂停部署之前，无法回滚暂停部署。</p>
</blockquote>
<h5 id="部署状态"><a href="#部署状态" class="headerlink" title="部署状态"></a>部署状态</h5><p>部署在其生命周期中进入各种状态。它可以<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progressing-deployment" target="_blank" rel="noopener"><code>前进</code></a>，同时推出新ReplicaSet，也可以是<a href="hhttps://kubernetes.io/docs/concepts/workloads/controllers/deployment/#complete-deployment" target="_blank" rel="noopener">完整的</a>，也可以<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#failed-deployment" target="_blank" rel="noopener">不取得进展</a>。</p>
<h6 id="进步部署"><a href="#进步部署" class="headerlink" title="进步部署"></a>进步部署</h6><p>当执行以下任务之一时，Kubernetes将部署标记为进度：</p>
<ul>
<li>部署创建一个新的ReplicaSet。</li>
<li>部署正在扩展其最新的ReplicaSet。</li>
<li>部署正在缩减其旧的ReplicaSet。</li>
<li>新Pod已准备就绪或可用（至少准备<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds" target="_blank" rel="noopener">MinReadySeconds</a>）。</li>
</ul>
<p>您可以使用监视部署的进度<code>kubectl rollout status</code>。</p>
<h6 id="完成部署"><a href="#完成部署" class="headerlink" title="完成部署"></a>完成部署</h6><p>Kubernetes 在具有以下特征时将部署标记为完成：</p>
<ul>
<li>与部署关联的所有副本都已更新为您指定的最新版本，这意味着您已请求的任何更新已完成。</li>
<li>可以使用与部署关联的所有副本。</li>
<li>没有旧的部署副本正在运行。</li>
</ul>
<p>您可以使用检查部署是否已完成<code>kubectl rollout status</code>。如果卷展栏成功完成，则<code>kubectl rollout status</code>返回零退出代码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl rollout status deployment.v1.apps/nginx-deployment</span></span><br><span class="line">Waiting for rollout to finish: 2 of 3 updated replicas are available...</span><br><span class="line">deployment.apps/nginx-deployment successfully rolled out</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h6 id="部署失败"><a href="#部署失败" class="headerlink" title="部署失败"></a>部署失败</h6><p>您的部署可能会在尝试部署其最新的ReplicaSet时遇到困难，而无需完成。这可能是由于以下一些因素造成的：</p>
<ul>
<li>配额不足</li>
<li>准备探针失败</li>
<li>图像拉错误</li>
<li>权限不足</li>
<li>限制范围</li>
<li>应用程序运行时配置错误</li>
</ul>
<p>检测此情况的一种方法是在部署规范中指定截止时间参数:(<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds" target="_blank" rel="noopener"><code>.spec.progressDeadlineSeconds</code></a>）。<code>.spec.progressDeadlineSeconds</code>表示部署控制器在指示（在“部署”状态中）部署进度已停止之前等待的秒数。</p>
<p>以下<code>kubectl</code>命令设置规范<code>progressDeadlineSeconds</code>以使控制器报告在10分钟后缺少部署进度：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl patch deployment<span class="selector-class">.v1</span><span class="selector-class">.apps</span>/nginx-deployment -<span class="selector-tag">p</span> <span class="string">'&#123;"spec":&#123;"progressDeadlineSeconds":600&#125;&#125;'</span></span><br><span class="line">deployment.apps/nginx-deployment patched</span><br></pre></td></tr></table></figure>
<p>超过截止日期后，Deployment控制器会向Deployment部署一个具有以下属性的DeploymentCondition <code>.status.conditions</code>：</p>
<ul>
<li>类型=进展</li>
<li>状态=假</li>
<li>原因= ProgressDeadlineExceeded</li>
</ul>
<p>有关状态条件的更多信息，请参阅<a href="https://git.k8s.io/community/contributors/devel/api-conventions.md#typical-status-properties" target="_blank" rel="noopener">Kubernetes API约定</a>。</p>
<blockquote>
<p>注意：除了报告状态条件之外，Kubernetes不对停顿的部署采取任何操作 <code>Reason=ProgressDeadlineExceeded</code>。更高级别的协调器可以利用它并相应地采取相应措施，例如，将部署回滚到其先前版本。</p>
</blockquote>
<blockquote>
<p>注意：如果您暂停部署，Kubernetes不会根据您指定的截止日期检查进度。您可以安全地在部署和暂停期间暂停部署，而不会触发超出截止日期的条件。</p>
</blockquote>
<p>由于您设置的超时时间较短或者由于任何其他可被视为瞬态的错误，您可能会遇到部署的暂时性错误。例如，假设您的配额不足。如果您描述部署，您将注意到以下部分：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">describe</span> <span class="string">deployment</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="string">&lt;...&gt;</span></span><br><span class="line"><span class="attr">Conditions:</span></span><br><span class="line">  <span class="string">Type</span>            <span class="string">Status</span>  <span class="string">Reason</span></span><br><span class="line"><span class="bullet">  -</span><span class="meta">---</span>            <span class="bullet">------</span>  <span class="bullet">------</span></span><br><span class="line">  <span class="string">Available</span>       <span class="literal">True</span>    <span class="string">MinimumReplicasAvailable</span></span><br><span class="line">  <span class="string">Progressing</span>     <span class="literal">True</span>    <span class="string">ReplicaSetUpdated</span></span><br><span class="line">  <span class="string">ReplicaFailure</span>  <span class="literal">True</span>    <span class="string">FailedCreate</span></span><br><span class="line"><span class="string">&lt;...&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果您运行<code>kubectl get deployment nginx-deployment -o yaml</code>，部署状态可能如下所示：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">status:</span></span><br><span class="line"><span class="attr">  availableReplicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  conditions:</span></span><br><span class="line"><span class="attr">  - lastTransitionTime:</span> <span class="number">2016</span><span class="bullet">-10</span><span class="bullet">-04</span><span class="attr">T12:25:39Z</span></span><br><span class="line"><span class="attr">    lastUpdateTime:</span> <span class="number">2016</span><span class="bullet">-10</span><span class="bullet">-04</span><span class="attr">T12:25:39Z</span></span><br><span class="line"><span class="attr">    message:</span> <span class="string">Replica</span> <span class="string">set</span> <span class="string">"nginx-deployment-4262182780"</span> <span class="string">is</span> <span class="string">progressing.</span></span><br><span class="line"><span class="attr">    reason:</span> <span class="string">ReplicaSetUpdated</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Progressing</span></span><br><span class="line"><span class="attr">  - lastTransitionTime:</span> <span class="number">2016</span><span class="bullet">-10</span><span class="bullet">-04</span><span class="attr">T12:25:42Z</span></span><br><span class="line"><span class="attr">    lastUpdateTime:</span> <span class="number">2016</span><span class="bullet">-10</span><span class="bullet">-04</span><span class="attr">T12:25:42Z</span></span><br><span class="line"><span class="attr">    message:</span> <span class="string">Deployment</span> <span class="string">has</span> <span class="string">minimum</span> <span class="string">availability.</span></span><br><span class="line"><span class="attr">    reason:</span> <span class="string">MinimumReplicasAvailable</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Available</span></span><br><span class="line"><span class="attr">  - lastTransitionTime:</span> <span class="number">2016</span><span class="bullet">-10</span><span class="bullet">-04</span><span class="attr">T12:25:39Z</span></span><br><span class="line"><span class="attr">    lastUpdateTime:</span> <span class="number">2016</span><span class="bullet">-10</span><span class="bullet">-04</span><span class="attr">T12:25:39Z</span></span><br><span class="line"><span class="attr">    message:</span> <span class="string">'Error creating: pods "nginx-deployment-4262182780-" is forbidden: exceeded quota:</span></span><br><span class="line"><span class="string">      object-counts, requested: pods=1, used: pods=3, limited: pods=2'</span></span><br><span class="line"><span class="attr">    reason:</span> <span class="string">FailedCreate</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">ReplicaFailure</span></span><br><span class="line"><span class="attr">  observedGeneration:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  unavailableReplicas:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>最终，一旦超出部署进度截止日期，Kubernetes将更新状态和进度条件的原因：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Conditions:</span></span><br><span class="line">  <span class="string">Type</span>            <span class="string">Status</span>  <span class="string">Reason</span></span><br><span class="line"><span class="bullet">  -</span><span class="meta">---</span>            <span class="bullet">------</span>  <span class="bullet">------</span></span><br><span class="line">  <span class="string">Available</span>       <span class="literal">True</span>    <span class="string">MinimumReplicasAvailable</span></span><br><span class="line">  <span class="string">Progressing</span>     <span class="literal">False</span>   <span class="string">ProgressDeadlineExceeded</span></span><br><span class="line">  <span class="string">ReplicaFailure</span>  <span class="literal">True</span>    <span class="string">FailedCreate</span></span><br></pre></td></tr></table></figure></p>
<p>您可以通过缩小部署，缩小可能正在运行的其他控制器或增加命名空间中的配额来解决配额不足的问题。如果您满足配额条件，然后部署控制器完成“部署”卷展栏，您将看到部署状态更新成功条件（<code>Status=True</code>和<code>Reason=NewReplicaSetAvailable</code>）。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Conditions:</span></span><br><span class="line">  <span class="string">Type</span>          <span class="string">Status</span>  <span class="string">Reason</span></span><br><span class="line"><span class="bullet">  -</span><span class="meta">---</span>          <span class="bullet">------</span>  <span class="bullet">------</span></span><br><span class="line">  <span class="string">Available</span>     <span class="literal">True</span>    <span class="string">MinimumReplicasAvailable</span></span><br><span class="line">  <span class="string">Progressing</span>   <span class="literal">True</span>    <span class="string">NewReplicaSetAvailable</span></span><br></pre></td></tr></table></figure></p>
<p><code>Type=Available</code>与<code>Status=True</code>您的部署具有最小可用性手段。最低可用性由部署策略中指定的参数决定。<code>Type=Progressing</code>和 <code>Status=True</code>表示您的部署正处于推出过程中并且正在进行中或已成功完成其进度并且所需的最小新副本可用（请参阅详细信息的条件原因 - 在我们的情况下 <code>Reason=NewReplicaSetAvailable</code>意味着部署完成）。</p>
<p>您可以使用检查部署是否未能进展<code>kubectl rollout status</code>。<code>kubectl rollout status</code> 如果部署已超过进度截止日期，则返回非零退出代码。</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout status deployment.v1.apps/nginx-deployment</span><br><span class="line">Waiting for rollout to finish: 2 out of 3 new replicas have been updated...</span><br><span class="line"><span class="keyword">error: </span>deployment "nginx" exceeded its progress deadline</span><br><span class="line">$ echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h6 id="在失败的部署上运行"><a href="#在失败的部署上运行" class="headerlink" title="在失败的部署上运行"></a>在失败的部署上运行</h6><p>适用于完整部署的所有操作也适用于失败的部署。如果需要在“部署”窗格模板中应用多个调整，可以向上/向下缩放，回滚到以前的版本，甚至可以暂停它。</p>
<h5 id="清理政策"><a href="#清理政策" class="headerlink" title="清理政策"></a>清理政策</h5><p>您可以<code>.spec.revisionHistoryLimit</code>在部署中设置字段，以指定要保留此部署的旧ReplicaSet数。其余的将在后台进行垃圾收集。默认情况下，它是10。</p>
<blockquote>
<p>注意：将此字段显式设置为0将导致清理部署的所有历史记录，从而部署将无法回滚。</p>
</blockquote>
<h5 id="用例-2"><a href="#用例-2" class="headerlink" title="用例"></a>用例</h5><h6 id="Canary部署"><a href="#Canary部署" class="headerlink" title="Canary部署"></a>Canary部署</h6><p>如果要使用部署将发布部署到用户或服务器的子集，则可以按照<a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments" target="_blank" rel="noopener">管理资源</a>中描述的canary模式创建多个部署，每个版本一个 。</p>
<h5 id="编写部署规范"><a href="#编写部署规范" class="headerlink" title="编写部署规范"></a>编写部署规范</h5><p>与所有其他Kubernetes CONFIGS，部署需求<code>apiVersion</code>，<code>kind</code>以及<code>metadata</code>各个领域。有关使用配置文件的一般信息，请参阅<a href="https://kubernetes.io/docs/tutorials/stateless-application/run-stateless-application-deployment/" target="_blank" rel="noopener">部署应用程序</a>，配置容器以及<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">使用kubectl管理资源文档</a>。</p>
<p>部署还需要一个<a href="https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status" target="_blank" rel="noopener"><code>.spec</code>部分</a>。</p>
<h6 id="Pod模板-3"><a href="#Pod模板-3" class="headerlink" title="Pod模板"></a>Pod模板</h6><p>这<code>.spec.template</code>是唯一必需的领域<code>.spec</code>。</p>
<p>这<code>.spec.template</code>是一个<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#pod-templates" target="_blank" rel="noopener">pod模板</a>。它与Pod具有完全相同的架构，除了它是嵌套的并且没有 <code>apiVersion</code>或<code>kind</code>。</p>
<p>除了Pod的必填字段外，部署中的pod模板还必须指定适当的标签和适当的重新启动策略。对于标签，请确保不要与其他控制器重叠。见<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#selector" target="_blank" rel="noopener">选择器</a>）。</p>
<p>只允许<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy" target="_blank" rel="noopener"><code>.spec.template.spec.restartPolicy</code></a>等于<code>Always</code>，如果未指定，则为默认值。</p>
<h6 id="副本-1"><a href="#副本-1" class="headerlink" title="副本"></a>副本</h6><p><code>.spec.replicas</code>是一个可选字段，指定所需Pod的数量。默认为1。</p>
<h6 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h6><p><code>.spec.selector</code>是一个可选字段，用于指定 此部署所针对的Pod 的标签选择器。</p>
<p><code>.spec.selector</code>必须匹配<code>.spec.template.metadata.labels</code>，否则它将被API拒绝。</p>
<p>在API版本<code>apps/v1</code>，<code>.spec.selector</code>并且<code>.metadata.labels</code>不默认<code>.spec.template.metadata.labels</code>，如果没有设置。所以必须明确设置它们。另请注意，<code>.spec.selector</code>在创建部署后，它是不可变的<code>apps/v1</code>。</p>
<p>部署可以终止其标签与选择器匹配的Pod，如果它们的模板不同<code>.spec.template</code>或者此类Pod的总数超过<code>.spec.replicas</code>。<code>.spec.template</code>如果Pod 的数量小于所需的数量，它会调出新的Pod 。</p>
<blockquote>
<p>注意：您不应通过创建另一个部署或通过创建另一个控制器（如ReplicaSet或ReplicationController）来创建其标签与此选择器匹配的其他pod。如果您这样做，第一个部署认为它创建了这些其他pod。Kubernetes并没有阻止你这样做。</p>
</blockquote>
<p>如果您有多个具有重叠选择器的控制器，控制器将相互争斗并且行为不正确。</p>
<h6 id="战略"><a href="#战略" class="headerlink" title="战略"></a>战略</h6><p><code>.spec.strategy</code>指定用于替换旧Pod的策略。 <code>.spec.strategy.type</code>可以是“重新创建”或“RollingUpdate”。“RollingUpdate”是默认值。</p>
<h5 id="重新创建部署"><a href="#重新创建部署" class="headerlink" title="重新创建部署"></a>重新创建部署</h5><p>所有现有的Pod都会在创建新的Pod之前被杀死.spec.strategy.type==Recreate。</p>
<h5 id="滚动更新部署"><a href="#滚动更新部署" class="headerlink" title="滚动更新部署"></a>滚动更新部署</h5><p>部署时会以滚动更新 方式更新Pod <code>.spec.strategy.type==RollingUpdate</code>。您可以指定<code>maxUnavailable</code>并<code>maxSurge</code>控制滚动更新过程。</p>
<p><strong>maxUnavailable</strong></p>
<p><code>.spec.strategy.rollingUpdate.maxUnavailable</code>是一个可选字段，指定更新过程中可用的最大Pod数。该值可以是绝对数（例如，5）或所需Pod的百分比（例如，10％）。通过四舍五入计算绝对数字的百分比。如果<code>.spec.strategy.rollingUpdate.maxSurge</code>为0，则该值不能为0.默认值为25％。</p>
<p>例如，当此值设置为30％时，旧的ReplicaSet可以在滚动更新开始时立即按比例缩小到所需Pod的70％。准备好新的Pod后，可以进一步缩小旧的ReplicaSet，然后扩展新的ReplicaSet，确保在更新期间始终可用的Pod总数至少是所需Pod的70％。</p>
<p><strong>Max Surge</strong></p>
<p><code>.spec.strategy.rollingUpdate.maxSurge</code>是一个可选字段，指定可以在所需数量的Pod上创建的最大Pod数。该值可以是绝对数（例如，5）或所需Pod的百分比（例如，10％）。如果<code>MaxUnavailable</code>为0，则该值不能为0.绝对数量是通过向上舍入的百分比计算的。默认值为25％。</p>
<p>例如，当此值设置为30％时，可以在滚动更新开始时立即按比例放大新的ReplicaSet，这样旧的和新的Pod的总数不会超过所需Pod的130％。一旦旧的Pod被杀死，新的ReplicaSet可以进一步扩展，确保在更新期间随时运行的Pod总数最多为所需Pod的130％。</p>
<h6 id="进度截止日期"><a href="#进度截止日期" class="headerlink" title="进度截止日期"></a>进度截止日期</h6><p><code>.spec.progressDeadlineSeconds</code>是一个可选字段，指定在系统报告部署失败进度之前等待部署进度的秒数 - 表示为带有<code>Type=Progressing</code>，<code>Status=False</code>。的条件。以及<code>Reason=ProgressDeadlineExceeded</code>资源的状态。部署控制器将继续重试部署。将来，一旦实现自动回滚，部署控制器将在观察到这种情况后立即回滚部署。</p>
<p>如果指定，则此字段必须大于<code>.spec.minReadySeconds</code>。</p>
<h6 id="Min-Ready-Seconds"><a href="#Min-Ready-Seconds" class="headerlink" title="Min Ready Seconds"></a>Min Ready Seconds</h6><p><code>.spec.minReadySeconds</code>是一个可选字段，指定新创建的Pod应该在没有任何容器崩溃的情况下准备好的最小秒数，以使其可用。默认为0（Pod一旦准备好就会被视为可用）。要了解有关何时认为Pod已准备就绪的详细信息，请参阅<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes" target="_blank" rel="noopener">容器探测器</a>。</p>
<h6 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h6><p>现场<code>.spec.rollbackTo</code>已被弃用的API版本<code>extensions/v1beta1</code>和<code>apps/v1beta1</code>，并在API版本不再支持开始<code>apps/v1beta2</code>。相反，应该使用<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-back-to-a-previous-revision" target="_blank" rel="noopener">回滚到先前版本</a>中的<code>kubectl rollout undo</code>介绍。</p>
<h6 id="修订历史限制"><a href="#修订历史限制" class="headerlink" title="修订历史限制"></a>修订历史限制</h6><p>部署的修订历史记录存储在它控制的副本集中。</p>
<p><code>.spec.revisionHistoryLimit</code>是一个可选字段，指定要保留以允许回滚的旧ReplicaSet的数量。其理想值取决于新部署的频率和稳定性。如果未设置此字段，则默认情况下将保留所有旧的ReplicaSet，消耗资源<code>etcd</code>并拥挤输出<code>kubectl get rs</code>。每个Deployment修订版的配置都存储在其ReplicaSet中; 因此，一旦删除旧的ReplicaSet，您将无法回滚到该部署版本。</p>
<p>更具体地说，将此字段设置为零意味着将清除所有具有0副本的旧ReplicaSet。在这种情况下，无法撤消新的“部署”卷展栏，因为它的修订历史记录已清除。</p>
<h6 id="已暂停"><a href="#已暂停" class="headerlink" title="已暂停"></a>已暂停</h6><p><code>.spec.paused</code>是一个可选的布尔字段，用于暂停和恢复部署。暂停部署与未暂停部署之间的唯一区别是，暂停部署的PodTemplateSpec的任何更改都不会触发新的部署，只要它暂停即可。默认情况下，部署在创建时不会暂停。</p>
<h5 id="部署的替代方案"><a href="#部署的替代方案" class="headerlink" title="部署的替代方案"></a>部署的替代方案</h5><h6 id="kubectl滚动更新"><a href="#kubectl滚动更新" class="headerlink" title="kubectl滚动更新"></a>kubectl滚动更新</h6><p><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rolling-update" target="_blank" rel="noopener"><code>kubectl rolling update</code></a>以类似的方式更新Pod和ReplicationControllers。但建议使用部署，因为它们是声明性的，服务器端，并且具有其他功能，例如即使在滚动更新完成后回滚到任何先前的修订版。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/01/11/CentOS上安装Shadowsocks客户端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/11/CentOS上安装Shadowsocks客户端/" itemprop="url">CentOS上安装Shadowsocks客户端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T15:47:00+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/11/CentOS上安装Shadowsocks客户端/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/01/11/CentOS上安装Shadowsocks客户端/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CentOS上安装Shadowsocks客户端"><a href="#CentOS上安装Shadowsocks客户端" class="headerlink" title="CentOS上安装Shadowsocks客户端"></a>CentOS上安装Shadowsocks客户端</h1><h2 id="Shadowsocks简介"><a href="#Shadowsocks简介" class="headerlink" title="Shadowsocks简介"></a>Shadowsocks简介</h2><p>Shadowsocks，是一种加密的传输方式（一种基于 Socks5 代理方式的网络数据加密传输包）；SS 是目前主流的科学上网方式，是目前最稳定最好用的科学上网工具之一。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h3><p>pip是Python的包管理工具，我们接下来是使用pip安装的Shadowsocks。</p>
<ol>
<li><p>通过yum管理工具安装：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> -y pip</span><br></pre></td></tr></table></figure>
</li>
<li><p>镜像库没有这个包，那么可以手动安装:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">"https://bootstrap.pypa.io/get-pip.py"</span> -<span class="keyword">o</span> <span class="string">"get-pip.py"</span></span><br><span class="line"><span class="keyword">python</span> <span class="built_in">get</span>-pip.<span class="keyword">py</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="安装Shadowsocks客户端"><a href="#安装Shadowsocks客户端" class="headerlink" title="安装Shadowsocks客户端"></a>安装Shadowsocks客户端</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> <span class="comment">--upgrade pip</span></span><br><span class="line">pip <span class="keyword">install</span> shadowsocks</span><br></pre></td></tr></table></figure>
<p>新建配置文件<code>vi /etc/shadowsocks.json</code>：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"server"</span>:<span class="string">"x.x.x.x"</span>,</span><br><span class="line"><span class="attr">"server_port"</span>:<span class="number">25247</span>,</span><br><span class="line"><span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line"><span class="attr">"local_port"</span>:<span class="number">25252</span>,</span><br><span class="line"><span class="attr">"password"</span>:<span class="string">"123456"</span>,</span><br><span class="line"><span class="attr">"timeout"</span>:<span class="number">1000</span>,</span><br><span class="line"><span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line"><span class="attr">"workers"</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编写启动服务<code>vi /etc/systemd/system/shadowsocks.service</code>:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=shadowsocks</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">TimeoutStartSec</span>=<span class="number">30</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/sslocal -c /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>启动服务<code>systemctl start shadowsocks</code>，运行 <code>curl --socks5 127.0.0.1:25252 http://httpbin.org/ip</code> ， 返回你ss服务器ip，则说明Shadowsocks客户端启动成功。</p>
<h2 id="使用Privoxy把shadowsocks转换为Http代理"><a href="#使用Privoxy把shadowsocks转换为Http代理" class="headerlink" title="使用Privoxy把shadowsocks转换为Http代理"></a>使用Privoxy把shadowsocks转换为Http代理</h2><h3 id="Privoxy简介"><a href="#Privoxy简介" class="headerlink" title="Privoxy简介"></a>Privoxy简介</h3><p>Privoxy是一个代理辅助工具，这里用Privoxy把Shadowsocks socks5代理转换为http代理。可以作为kubernetes的docker容器需要访问google的服务，也同时可以作为命令行的代理，本实例用作命令行代理。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>使用yum安装：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> privoxy -y</span><br></pre></td></tr></table></figure></p>
<p>修改配置文件<code>vi /etc/privoxy/config</code>，加入一行代码<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 / <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">25252</span> .</span><br><span class="line">listen-address <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">8118</span>  #这里的<span class="built_in">ip</span>也可以是k8s的<span class="built_in">ip</span></span><br></pre></td></tr></table></figure></p>
<p>启动服务<code>systemctl start privoxy</code>，执行命令<code>curl -x localhost:8118 google.com</code>，返回数据则表示服务启动成功</p>
<h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><p>编辑文件<code>vi /etc/profile</code>：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">http_proxy</span>=http://127.0.0.1:8118</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">https_proxy</span>=http://127.0.0.1:8118</span><br></pre></td></tr></table></figure></p>
<p>使配置生效<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure></p>
<p>测试代码<code>curl www.google.com</code>，返回数据则成功设置全局命令行代理</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/01/07/基于Frp内网穿透反向代理的端口转发实现本地服务器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/07/基于Frp内网穿透反向代理的端口转发实现本地服务器/" itemprop="url">基于Frp内网穿透反向代理的端口转发实现本地服务器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-07T15:47:00+08:00">
                2019-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/07/基于Frp内网穿透反向代理的端口转发实现本地服务器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/01/07/基于Frp内网穿透反向代理的端口转发实现本地服务器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基于frp内网穿透反向代理的端口转发实现本地服务器"><a href="#基于frp内网穿透反向代理的端口转发实现本地服务器" class="headerlink" title="基于frp内网穿透反向代理的端口转发实现本地服务器"></a>基于frp内网穿透反向代理的端口转发实现本地服务器</h1><h2 id="frp简介"><a href="#frp简介" class="headerlink" title="frp简介"></a>frp简介</h2><p><a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a> 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。</p>
<ul>
<li>利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。</li>
<li>对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。</li>
<li>利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h3><p>公网服务器一台，内网服务器一台，公网服务器绑定域名1个。</p>
<h3 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h3><h4 id="公网服务器"><a href="#公网服务器" class="headerlink" title="公网服务器"></a>公网服务器</h4><p>ssh连接到公网服务器上，新建目录</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/<span class="built_in">local</span>/frp</span><br></pre></td></tr></table></figure>
<p>根据对应的操作系统及架构，从 <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">Release</a> 页面下载最新版本的程序。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/fatedier/</span>frp<span class="regexp">/releases/</span>download<span class="regexp">/v0.22.0/</span>frp_0.<span class="number">22.0</span>_linux_arm64.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-zxvf</span>  <span class="selector-tag">frp_0</span><span class="selector-class">.22</span><span class="selector-class">.0_linux_arm64</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure>
<p>首先删掉<code>frpc</code>、<code>frpc.ini</code>两个文件，然后再进行配置<br>修改<code>frps.ini</code>文件，这里使用了最简化的配置：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frps.ini</span></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">vhost_http_port = 6081</span><br><span class="line">max_pool_count = 20</span><br><span class="line">allow_ports = 2000-3000,6081,4000-50000 <span class="comment">#端口白名单</span></span><br><span class="line">dashboard_port = 7500</span><br><span class="line">dashboard_user = admin</span><br><span class="line">dashboard_pwd = admin</span><br><span class="line">token = 123456 <span class="comment">#客户端也要配置一样的token</span></span><br><span class="line">authentication_timeout = 90000 <span class="comment">#超时时间，如果客户端遇到服务启动认证失败，大概率是时区问题，服务器设置一下就好了</span></span><br></pre></td></tr></table></figure>
<p>保存然后启动服务<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./frps</span> -c <span class="string">./frps.ini</span></span><br></pre></td></tr></table></figure></p>
<p>这是前台启动，后台启动命令为</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup <span class="string">./frps</span> -c <span class="string">./frps.ini</span> &amp;</span><br></pre></td></tr></table></figure>
<p>可以通过访问<code>http://xx.xx.xx.xx:7500/static/#/proxies/tcp</code>访问<code>frp</code>服务的监控界面，账号密码与上面配置的一致。</p>
<h4 id="内网服务器"><a href="#内网服务器" class="headerlink" title="内网服务器"></a>内网服务器</h4><p>根据对应的操作系统及架构，从 <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">Release</a> 页面下载最新版本的程序。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/fatedier/</span>frp<span class="regexp">/releases/</span>download<span class="regexp">/v0.22.0/</span>frp_0.<span class="number">22.0</span>_linux_arm64.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-zxvf</span>  <span class="selector-tag">frp_0</span><span class="selector-class">.22</span><span class="selector-class">.0_linux_arm64</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure>
<p>首先删掉<code>frpc</code>、<code>frpc.ini</code>两个文件，然后再进行配置<br>修改 <code>frpc.ini</code> 文件。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line">[common]</span><br><span class="line">server_addr = xx.xx.xx.xx <span class="comment">#公网ip地址</span></span><br><span class="line">server_port = 7000</span><br><span class="line">token = 123456</span><br><span class="line"> </span><br><span class="line"><span class="comment">#公网通过ssh访问内部服务器</span></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp              <span class="comment">#连接协议</span></span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22         <span class="comment">#ssh默认端口号</span></span><br><span class="line">remote_port = 6000      <span class="comment">#自定义的访问内部ssh端口号</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#公网访问内部web服务器以http方式</span></span><br><span class="line">[web]</span><br><span class="line">type = http         <span class="comment">#访问协议</span></span><br><span class="line">local_port = 8081   <span class="comment">#内网web服务的端口号</span></span><br><span class="line">custom_domains = strongcat.top <span class="comment">#所绑定的公网服务器域名，一级、二级域名都可以</span></span><br></pre></td></tr></table></figure>
<p>保存然后执行启动</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./frpc</span> -c <span class="string">./frpc.ini</span></span><br></pre></td></tr></table></figure>
<p>这是前台启动，后台启动命令为</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup <span class="string">./frpc</span> -c <span class="string">./frpc.ini</span> &amp;</span><br></pre></td></tr></table></figure>
<h4 id="认证超时解决办法"><a href="#认证超时解决办法" class="headerlink" title="认证超时解决办法"></a>认证超时解决办法</h4><p>一般认证超时的原因是由于2个服务器之间时间不同，可以通过命令tzselect修改时区，按照步骤设置时区<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tzselect</span></span><br></pre></td></tr></table></figure></p>
<p>同步服务器时间<br><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">sudo </span><span class="string">yum </span><span class="string">install </span><span class="string">ntp</span></span><br><span class="line"><span class="string">timedatectl </span><span class="built_in">set-timezone</span> <span class="string">Asia/</span><span class="string">Shanghai</span></span><br><span class="line"><span class="string">timedatectl </span><span class="built_in">set-ntp</span> <span class="string">yes</span></span><br></pre></td></tr></table></figure></p>
<p>查看时间确保同步<code>timedatectl</code></p>
<h2 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h2><p>我用的是centOS7的操作系统，为了防止因为网络或者重启问题Frp失效，所以写了一个开机启动服务，公网服务器配置：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=frp</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">TimeoutStartSec</span>=<span class="number">30</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">ExecStart</span>=/root/frp/frp_0.<span class="number">22.0</span>_linux_386/frps -c /root/frp/frp_0.<span class="number">22.0</span>_linux_386/frps.ini</span><br><span class="line"><span class="attr">ExecStop</span>=/bin/kill <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">60</span>s</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>
<p>内网服务器配置：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=frp</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"><span class="attr">Wants</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">TimeoutStartSec</span>=<span class="number">30</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">ExecStart</span>=/root/frp/frp_0.<span class="number">22.0</span>_linux_386/frpc -c /root/frp/frp_0.<span class="number">22.0</span>_linux_386/frpc.ini</span><br><span class="line"><span class="attr">ExecStop</span>=/bin/kill <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">60</span>s</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>文件保存到<code>/etc/systemd/system/frp.service</code>中，并执行<code>systemctl daemon-reload</code>，<code>systemctl start frp</code>,开机启动<code>systemctl enable frp</code></p>
<p>外网ssh访问内网服务器（直接使用配置里面数据演示）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -oPort=<span class="number">6000</span> root@x<span class="selector-class">.x</span><span class="selector-class">.x</span><span class="selector-class">.x</span></span><br></pre></td></tr></table></figure>
<p> 将 <code>www.strongcat.top</code> 的域名 A 记录解析到 IP <code>x.x.x.x</code>，如果服务器已经有对应的域名，也可以将 CNAME 记录解析到服务器原先的域名。</p>
<p> 通过浏览器访问 <code>http://www.yourdomain.com:8080</code> 即可访问到处于内网机器上的 <code>web</code> 服务。</p>
<p> 有些系统默认自带防火墙，需要开通端口</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd <span class="attribute">--zone</span>=public <span class="attribute">--add-port</span>=6000/tcp --permanent  </span><br><span class="line">systemctl stop firewalld.service  </span><br><span class="line">systemctl start firewalld.service</span><br></pre></td></tr></table></figure>
<p>如果遇到<code>authorization timeout</code>错误的话，需要进行2个服务器之间的时间同步。2边服务器都执行下面的命令：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#下载ntpdate</span></span><br><span class="line">yum install -y ntpdate</span><br><span class="line"><span class="meta">#调整时区为上海，也就是北京时间+8区</span></span><br><span class="line">cp <span class="meta-keyword">/usr/</span>share<span class="meta-keyword">/zoneinfo/</span>Asia/Shanghai <span class="meta-keyword">/etc/</span>localtime</span><br><span class="line">yes | cp -f <span class="meta-keyword">/usr/</span>share<span class="meta-keyword">/zoneinfo/</span>Asia/Shanghai <span class="meta-keyword">/etc/</span>localtime</span><br><span class="line"><span class="meta">#使用NTP来同步时间</span></span><br><span class="line">ntpdate us.pool.ntp.org</span><br><span class="line"><span class="meta">#定时同步时间（每隔10分钟同步时钟）</span></span><br><span class="line">crontab -l &gt;<span class="meta-keyword">/tmp/</span>crontab.bak</span><br><span class="line">echo <span class="string">"*/10 * * * * /usr/sbin/ntpdate us.pool.ntp.org | logger -t NTP"</span> &gt;&gt; <span class="meta-keyword">/tmp/</span>crontab.bak</span><br><span class="line">crontab <span class="meta-keyword">/tmp/</span>crontab.bak</span><br></pre></td></tr></table></figure></p>
<p>如果是像我这种笔记本的话，可以设置系统关闭盖子的动作<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/systemd/logind.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HandlePowerKey         按下电源键后的行为，默认power off</span><br><span class="line">HandleSleepKey          按下挂起键后的行为，默认<span class="keyword">suspend</span></span><br><span class="line">HandleHibernateKey   按下休眠键后的行为，默认hibernate</span><br><span class="line">HandleLidSwitch          合上笔记本盖后的行为，默认<span class="keyword">suspend</span></span><br><span class="line"></span><br><span class="line">ignore 忽略，跳过</span><br><span class="line">power off 关机</span><br><span class="line">eboot 重启</span><br><span class="line">halt 挂起</span><br><span class="line"><span class="keyword">suspend</span> <span class="keyword">shell</span>内建指令，可暂停目前正在执行的<span class="keyword">shell</span>。若要恢复，则必须使用SIGCONT信息。所有的进程都会暂停，但不是消失（halt是进程关闭）</span><br><span class="line">hibernate 让笔记本进入休眠状态</span><br><span class="line">hybrid-<span class="keyword">sleep</span> 混合睡眠，主要是为台式机设计的，是睡眠和休眠的结合体，当你选择Hybird时，系统会像休眠一样把内存里的数据从头到尾复制到硬盘里 ，然后进入睡眠状态，即内存和CPU还是活动的，其他设置不活动，这样你想用电脑时就可以快速恢复到之前的状态了，笔记本一般不用这个功能。</span><br><span class="line">lock 仅锁屏，计算机继续工作。</span><br></pre></td></tr></table></figure>
<p>更多指令可以参考<a href="http://www.jinbuguo.com/systemd/logind.conf.html" target="_blank" rel="noopener">这篇博客</a></p>
<p>最后重新加载服务使配置生效<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl restart systemd-logind</span></span><br></pre></td></tr></table></figure></p>
<h2 id="进阶（配合nginx实现域名转发）"><a href="#进阶（配合nginx实现域名转发）" class="headerlink" title="进阶（配合nginx实现域名转发）"></a>进阶（配合nginx实现域名转发）</h2><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>购买域名，国内需要备案，然后再阿里云中添加域名，创建域名解析，如图所示<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fgy1g0and9vxv5j225607ut9t.jpg" alt="image"></p>
<h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker pull nginx</span></span><br></pre></td></tr></table></figure>
<p>新建文件<code>nginx.conf</code><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># frp的接收http请求的反向代理</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> <span class="regexp">*.strongsickcat.com</span> strongsickcat.com;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 7071端口即为frp监听的http端口</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>:<span class="number">80</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">proxy_connect_timeout</span> <span class="number">7d</span>;</span><br><span class="line">            <span class="attribute">proxy_send_timeout</span> <span class="number">7d</span>;</span><br><span class="line">            <span class="attribute">proxy_read_timeout</span> <span class="number">7d</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment"># 防止爬虫抓取</span></span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$http_user_agent</span> <span class="regexp">~* "360Spider|JikeSpider|Spider|spider|bot|Bot|2345Explorer|curl|wget|webZIP|qihoobot|Baiduspider|Googlebot|Googlebot-Mobile|Googlebot-Image|Mediapartners-Google|Adsbot-Google|Feedfetcher-Google|Yahoo!</span> Slurp|Yahoo! Slurp China|YoudaoBot|Sosospider|Sogou spider|Sogou web spider|MSNBot|ia_archiver|Tomato Bot|NSPlayer|bingbot<span class="string">")</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                return 403;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>docker启动nginx<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -<span class="selector-tag">p</span> <span class="number">80</span>:<span class="number">80</span> --name mynginx -v <span class="variable">$PWD</span>/www:/www -v <span class="variable">$PWD</span>/nginx<span class="selector-class">.conf</span>:/etc/nginx/nginx<span class="selector-class">.conf</span> -v <span class="variable">$PWD</span>/logs:/wwwlogs  -d nginx</span><br></pre></td></tr></table></figure></p>
<p>附上frp客户端与服务端配置<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#frps.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">max_pool_count</span> = <span class="number">20</span></span><br><span class="line"><span class="attr">allow_ports</span> = <span class="number">4000</span>-<span class="number">50000</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br><span class="line"><span class="attr">dashboard_user</span> = admin</span><br><span class="line"><span class="attr">dashboard_pwd</span> = <span class="number">742041978</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">2524668868</span></span><br><span class="line"><span class="attr">authentication_timeout</span> = <span class="number">900</span></span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">8080</span></span><br><span class="line"><span class="attr">subdomain_host</span> = strongsickcat.com</span><br></pre></td></tr></table></figure></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#客户端 frpc.ini</span></span><br><span class="line">[common]</span><br><span class="line">server_addr = 106.15.226.184</span><br><span class="line">server_port = 7000</span><br><span class="line">token = 2524668868</span><br><span class="line">admin_addr = 127.0.0.1</span><br><span class="line">admin_port = 7400</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line">[test_static_file]</span><br><span class="line">type = tcp</span><br><span class="line">remote_port = 16001</span><br><span class="line">plugin = static_file</span><br><span class="line">plugin_local_path = /root/file</span><br><span class="line">plugin_strip_prefix = static</span><br><span class="line">plugin_http_user = admin</span><br><span class="line">plugin_http_passwd = 742041978</span><br><span class="line"></span><br><span class="line">[kibana]</span><br><span class="line">type = http</span><br><span class="line"><span class="comment"># local_port代表你想要暴露给外网的本地web服务端口</span></span><br><span class="line">local_port = 5601</span><br><span class="line"><span class="comment"># subdomain 在全局范围内要确保唯一，每个代理服务的subdomain不能重名，否则会影响正常使用。</span></span><br><span class="line"><span class="comment"># 客户端的subdomain需和服务端的subdomain_host配合使用</span></span><br><span class="line">subdomain = kibana</span><br><span class="line"></span><br><span class="line">[elasticsearch]</span><br><span class="line">type = http</span><br><span class="line">local_port = 9200</span><br><span class="line">subdomain = elasticsearch</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">type = tcp</span><br><span class="line">local_port = 3306</span><br><span class="line">remote_port = 13306</span><br><span class="line"></span><br><span class="line">[prometheus]</span><br><span class="line">type = http</span><br><span class="line">local_port = 9090</span><br><span class="line">subdomain = prometheus</span><br><span class="line"></span><br><span class="line">[prometheus-linux]</span><br><span class="line">type = tcp</span><br><span class="line">local_port = 9100</span><br><span class="line">remote_port = 9100</span><br><span class="line"></span><br><span class="line">[prometheus-mysql]</span><br><span class="line">type = tcp</span><br><span class="line">local_port = 9104</span><br><span class="line">remote_port = 9104</span><br><span class="line"></span><br><span class="line">[grafana]</span><br><span class="line">type = http</span><br><span class="line">local_port = 3000</span><br><span class="line">subdomain = grafana</span><br><span class="line"></span><br><span class="line">[prometheusa]</span><br><span class="line">type = tcp</span><br><span class="line">local_port = 9090</span><br><span class="line">remote_port = 9090</span><br></pre></td></tr></table></figure>
<p>按照我的配置文件，可以直接通过子域名访问kibana服务<br><a href="http://kibana.strongsickcat.com:8080" target="_blank" rel="noopener">http://kibana.strongsickcat.com:8080</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/01/04/Selenium测试框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/Selenium测试框架/" itemprop="url">Selenium测试框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-04T09:47:00+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/04/Selenium测试框架/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/01/04/Selenium测试框架/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.seleniumhq.org/" target="_blank" rel="noopener">Selenium官网</a></p>
<h1 id="Selenium简介"><a href="#Selenium简介" class="headerlink" title="Selenium简介"></a>Selenium简介</h1><p>Selenium可以对浏览器进行自动化测试。它主要用于自动化Web应用程序以进行测试，但当然不仅限于此。无聊的基于Web的管理任务也可以自动化。 Selenium得到了一些最大的浏览器供应商的支持，这些供应商已采取（或正在采取）将Selenium作为其浏览器本机部分的步骤。它也是无数其他浏览器自动化工具，API和框架的核心技术。支持多种语言，在java中可以作为自动化测试框架，在python中可以模拟页面用户点击对自动化爬虫进行补充。</p>
<p>支持的浏览器：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/007yGiDRgy1fyy2e6qz72j310m0wu45r.jpg" alt="image"></p>
<h1 id="Selenium使用"><a href="#Selenium使用" class="headerlink" title="Selenium使用"></a>Selenium使用</h1><p>Selenium提供了一种非常简单的开发方式，例如用Chrome开发的话，去开发者工具下载Katalon Selenium IDE，如图所示。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/007yGiDRgy1fyy2ex4m1gj315o15gjwi.jpg" alt="image"></p>
<h2 id="开始录制"><a href="#开始录制" class="headerlink" title="开始录制"></a>开始录制</h2><p>录制过程中，IDE会自动帮我们把命令行插入到测试用例中，包括：</p>
<ul>
<li>单击链接</li>
<li>输入值</li>
<li>从下拉框选择数据</li>
<li>单击按钮或者选择框<br>点击开始录制，在最上方输入网站域名，后期可以通过更换域名来实现不同域名下的应用的测试。</li>
</ul>
<h2 id="使用上下文菜单添加验证和断言"><a href="#使用上下文菜单添加验证和断言" class="headerlink" title="使用上下文菜单添加验证和断言"></a>使用上下文菜单添加验证和断言</h2><p>使用Selenium IDE录制，转到显示测试应用程序的浏览器，然后右键单击页面上的任意位置。您将看到一个显示验证和/或断言命令的上下文菜单。<br>Selenium命令有三种“风格”：动作，访问器和断言。</p>
<ul>
<li>动作是通常操纵应用程序状态的命令。他们执行“点击此链接”和“选择该选项”之类的操作。如果操作失败或出错，则停止执行当前测试。</li>
<li>访问者检查应用程序的状态并将结果存储在变量中，例如“storeTitle”。它们还用于自动生成断言。</li>
<li>断言与访问器类似，但它们验证应用程序的状态是否符合预期。示例包括“确保页面标题为X”和“验证是否选中此复选框”。</li>
</ul>
<h2 id="脚本语法"><a href="#脚本语法" class="headerlink" title="脚本语法"></a>脚本语法</h2><p>命令很简单，由2个参数构成：</p>
<table>
<thead>
<tr>
<th>verifyText</th>
<th>//div//a[2]</th>
<th>Login</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>这些参数并不总是必需的;这取决于命令。在某些情况下，两者都是必需的，在其他情况下需要一个参数，而在另一些情况下，命令可能根本不需要参数。这里有几个例子：</p>
<table>
<thead>
<tr>
<th>chooseCancelOnNextPrompt</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>pause</td>
<td>500</td>
<td></td>
</tr>
<tr>
<td>type</td>
<td>id=phone</td>
<td>(555) 666-7066</td>
</tr>
<tr>
<td>type</td>
<td>id=address1</td>
<td>${myVariableAddress}</td>
</tr>
</tbody>
</table>
<p>命令参考描述了每个命令的参数要求。 参数有所不同，但它们通常是：</p>
<ul>
<li>Locators用于标识页面内UI元素的定位器。</li>
<li>text patterns用于验证或声明预期页面内容的文本模式。</li>
<li>text patterns or selenium variables文本模式或selenium变量，用于在输入字段中输入文本或从选项列表中选择选项。<h3 id="常用的Selenium命令"><a href="#常用的Selenium命令" class="headerlink" title="常用的Selenium命令"></a>常用的Selenium命令</h3></li>
<li><strong>open</strong> 打开url页面</li>
<li><strong>click</strong> 执行单击操作，并可选择等待加载新页面。</li>
<li><strong>verifyTitle/assertTitle</strong> 验证预期的页面标题。</li>
<li><strong>verifyTextPresent</strong> 验证预期文本是否在页面上的某个位置。</li>
<li><strong>verifyText</strong> 验证预期文本及其相应的HTML标记出现在页面上。</li>
<li><strong>verifyTable</strong> 验证表的预期内容。</li>
</ul>
<h3 id="验证页面元素"><a href="#验证页面元素" class="headerlink" title="验证页面元素"></a>验证页面元素</h3><h4 id="断言与验证的选择"><a href="#断言与验证的选择" class="headerlink" title="断言与验证的选择"></a>断言与验证的选择</h4><ul>
<li><strong>assert</strong> 错误后会不继续执行并中断当前的测试用例</li>
<li><strong>verify</strong> 错误后会继续执行<br>的最佳用途是对测试命令进行逻辑分组，并使用“assert”后跟一个或多个“verify”测试命令启动每个组。一个例子如下：</li>
</ul>
<h5 id="verifyElementPresent"><a href="#verifyElementPresent" class="headerlink" title="verifyElementPresent"></a>verifyElementPresent</h5><table>
<thead>
<tr>
<th>Command</th>
<th>Target</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>verifyElementPresent</td>
<td>//div/p/img</td>
<td></td>
</tr>
</tbody>
</table>
<p>此命令验证页面上是否存在由<code>&lt;img&gt;</code> HTML标记的存在指定的图像，并且它遵循<code>&lt;div&gt;</code>标记和<code>&lt;p&gt;</code>标记。第一个（也是唯一的）参数是一个定位器，用于告诉Selenese命令如何查找元素。<br><code>verifyElementPresent</code>可用于检查页面中是否存在任何HTML标记。您可以检查链接，段落，分区<code>&lt;div&gt;</code>等是否存在。以下是一些示例。</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Target</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>verifyElementPresent</td>
<td>//div/p</td>
<td></td>
</tr>
<tr>
<td>verifyElementPresent</td>
<td>//div/a</td>
<td></td>
</tr>
<tr>
<td>verifyElementPresent</td>
<td>id=Login</td>
<td></td>
</tr>
<tr>
<td>verifyElementPresent</td>
<td>link=Go to Marketing Research</td>
<td></td>
</tr>
<tr>
<td>verifyElementPresent</td>
<td>//a[2]</td>
<td></td>
</tr>
<tr>
<td>verifyElementPresent</td>
<td>//head/title</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="verifyText"><a href="#verifyText" class="headerlink" title="verifyText"></a>verifyText</h5><p>必须在测试文本及其UI元素时使用verifyText。 verifyText必须使用定位器。如果选择XPath或DOM定位器，则可以验证特定文本是否显示在页面上相对于页面上其他UI组件的特定位置。<br>Command | Target | Value<br>—|— |—<br>verifyText |//table/tr/td/div/p | This is my text and it occurs right after the div inside the table.</p>
<h4 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h4><p>对于许多Selenium命令，需要一个目标。此目标标识Web应用程序内容中的元素，并包含位置策略，后跟位置格式为locatorType = location。在许多情况下可以省略定位器类型。下面解释各种定位器类型，每个定位器类型都有示例。</p>
<h5 id="按标识符定位"><a href="#按标识符定位" class="headerlink" title="按标识符定位"></a>按标识符定位</h5><p>例如，页面源可以具有id和name属性，如下所示：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&lt;html&gt;</span></span><br><span class="line"> <span class="symbol">&lt;body&gt;</span></span><br><span class="line">  &lt;form id=<span class="string">"loginForm"</span>&gt;</span><br><span class="line">   &lt;<span class="built_in">input</span> name=<span class="string">"username"</span> <span class="built_in">type</span>=<span class="string">"text"</span> /&gt;</span><br><span class="line">   &lt;<span class="built_in">input</span> name=<span class="string">"password"</span> <span class="built_in">type</span>=<span class="string">"password"</span> /&gt;</span><br><span class="line">   &lt;<span class="built_in">input</span> name=<span class="string">"continue"</span> <span class="built_in">type</span>=<span class="string">"submit"</span> value=<span class="string">"Login"</span> /&gt;</span><br><span class="line">   &lt;<span class="built_in">input</span> name=<span class="string">"continue"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"Clear"</span> /&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line"><span class="symbol">&lt;html&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>以下定位器策略将返回上面由行号指示的HTML片段中的元素：</p>
<ul>
<li>identifier=loginForm (3)</li>
<li>identifier=password (5)</li>
<li>identifier=continue (6)</li>
<li>continue (6)<br>由于定位器的标识符类型是默认值，因此上面的前三个示例中的标识符=不是必需的。</li>
</ul>
<p><strong>通过id定位</strong></p>
<p> id=loginForm (3)</p>
<p> <strong>通过名称定位</strong></p>
<ul>
<li>name=username (4)</li>
<li>name=continue value=Clear (7)</li>
<li>name=continue Clear (7)</li>
<li>name=continue type=button (7)</li>
</ul>
<p>与某些类型的XPath和DOM定位器不同，上面三种类型的定位器允许Selenium测试UI元素，而与其在页面上的位置无关。因此，如果页面结构和组织被更改，测试仍将通过。您可能想也可能不想测试页面结构是否发生变化。在Web设计者经常更改页面但其功能必须经过回归测试的情况下，通过id和name属性进行测试，或者通过任何HTML属性进行测试变得非常重要。</p>
<p>由于只有xpath定位符以“//”开头，因此在指定XPath定位符时不必包含xpath =标签。</p>
<ul>
<li>xpath=/html/body/form[1] (3) - 绝对路径（如果HTML仅稍微更改，则会中断）</li>
<li>//form[1] (3) - HTML中的第一个表单元素</li>
<li>xpath=//form[@id=’loginForm’] (3) - 表单元素，其属性名为“id”，值为“loginForm”</li>
<li>xpath=//form[input/@name=’username’] (3) - 带有输入子元素的第一个表单元素，其属性名为“name”，值为“username”</li>
<li>//input[@name=’username’] (4) - 第一个输入元素，其属性名为“name”，值为“username”</li>
<li>//form[@id=’loginForm’]/input[1] (4) - 表单元素的第一个输入子元素，其属性名为“id”，值为“loginForm”</li>
<li>//input[@name=’continue’][@type=’button’] (7) -输入名为’name’的属性和值’continue’以及名为’type’的属性和值’button’</li>
<li>//form[@id=’loginForm’]/input[4] (7) - 表单元素的第四个输入子元素，其属性名为“id”，值为“loginForm”</li>
</ul>
<p>主要的语法参考<a href="https://www.w3.org/TR/2017/REC-xpath-31-20170321/" target="_blank" rel="noopener">Xpath</a><br>可以使用浏览器的devtools复制XPath：<br><img src="https://www.seleniumhq.org/docs/_images/chapt2_img18_Copy_xpath.png" alt="image"></p>
<p><strong>通过链接文本查找超链接</strong></p>
<p>这是一种使用链接文本在网页中查找超链接的简单方法。如果存在具有相同文本的两个链接，则将使用第一个匹配。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Are you sure you want to do this?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"continue.html"</span>&gt;</span>Continue<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"cancel.html"</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>link=Continue (4)</li>
<li>link=Cancel (5)</li>
</ul>
<p><strong>通过CSS定位</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">  &lt;form id=<span class="string">"loginForm"</span>&gt;</span><br><span class="line">   &lt;input <span class="class"><span class="keyword">class</span></span>=<span class="string">"required"</span> name=<span class="string">"username"</span> <span class="class"><span class="keyword">type</span></span>=<span class="string">"text"</span> /&gt;</span><br><span class="line">   &lt;input <span class="class"><span class="keyword">class</span></span>=<span class="string">"required passfield"</span> name=<span class="string">"password"</span> <span class="class"><span class="keyword">type</span></span>=<span class="string">"password"</span> /&gt;</span><br><span class="line">   &lt;input name=<span class="string">"continue"</span> <span class="class"><span class="keyword">type</span></span>=<span class="string">"submit"</span> value=<span class="string">"Login"</span> /&gt;</span><br><span class="line">   &lt;input name=<span class="string">"continue"</span> <span class="class"><span class="keyword">type</span></span>=<span class="string">"button"</span> value=<span class="string">"Clear"</span> /&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;html&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>css=form#loginForm (3)</li>
<li>css=input[name=”username”] (4)</li>
<li>css=input.required[type=”text”] (4)</li>
<li>css=input.passfield (5)</li>
<li>css=#loginForm input[type=”button”] (7)</li>
<li>css=#loginForm input:nth-child(2) (5)</li>
</ul>
<p>可以参考<a href="http://www.w3.org/TR/css3-selectors/" target="_blank" rel="noopener"> the W3C publication</a></p>
<p>没有明确的设定选择器的话，将会默认使用id选择器</p>
<h3 id="存储命令和Selenium变量"><a href="#存储命令和Selenium变量" class="headerlink" title="存储命令和Selenium变量"></a>存储命令和Selenium变量</h3><p>可以使用Selenium变量在脚本开头存储常量。此外，当与数据驱动的测试设计（在后面的部分中讨论）结合使用时，Selenium变量可用于存储从命令行，从另一个程序或从文件传递到测试程序的值。</p>
<p>plain store命令是许多存储命令中最基本的命令，可用于在selenium变量中简单地存储常量值。它需要两个参数，即要存储的文本值和一个selenium变量。在为变量选择名称时，请使用仅包含字母数字字符的标准变量命名约定。</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Target</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>store</td>
<td><a href="mailto:paul@mysite.org" target="_blank" rel="noopener">paul@mysite.org</a></td>
<td>userName</td>
</tr>
</tbody>
</table>
<p>稍后在脚本中，将需要使用变量的存储值。要访问变量的值，请将变量括在大括号（{}）中，并在其前面加上美元符号。</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Target</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>verifyText</td>
<td>//div/p</td>
<td>${userName}</td>
</tr>
</tbody>
</table>
<p>变量的常见用途是存储输入字段的输入</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Target</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>id=login</td>
<td>${userName}</td>
</tr>
</tbody>
</table>
<p><strong>storeText</strong></p>
<p>StoreText对应于verifyText。它使用定位器来标识特定的页面文本。如果找到该文本，则存储在变量中。 StoreText可用于从正在测试的页面中提取文本。</p>
<p>echo命令可以用来打印变量</p>
<h3 id="Alerts-Popups-and-Multiple-Windows"><a href="#Alerts-Popups-and-Multiple-Windows" class="headerlink" title="Alerts, Popups, and Multiple Windows"></a>Alerts, Popups, and Multiple Windows</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">output</span><span class="params">(resultText)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'output'</span>).childNodes[<span class="number">0</span>].nodeValue=resultText;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">show_confirm</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> confirmation=confirm(<span class="string">"Chose an option."</span>);</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (confirmation==<span class="literal">true</span>)&#123;</span></span><br><span class="line"><span class="actionscript">        output(<span class="string">"Confirmed."</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">        output(<span class="string">"Rejected!"</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">show_alert</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      alert(<span class="string">"I'm blocking!"</span>);</span></span><br><span class="line"><span class="actionscript">      output(<span class="string">"Alert is gone."</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">show_prompt</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> response = prompt(<span class="string">"What's the best web QA tool?"</span>,<span class="string">"Selenium"</span>);</span></span><br><span class="line"><span class="undefined">      output(response);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">open_window</span><span class="params">(windowName)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.open(<span class="string">"newWindow.html"</span>,windowName);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btnConfirm"</span> <span class="attr">onclick</span>=<span class="string">"show_confirm()"</span> <span class="attr">value</span>=<span class="string">"Show confirm box"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btnAlert"</span> <span class="attr">onclick</span>=<span class="string">"show_alert()"</span> <span class="attr">value</span>=<span class="string">"Show alert"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btnPrompt"</span> <span class="attr">onclick</span>=<span class="string">"show_prompt()"</span> <span class="attr">value</span>=<span class="string">"Show prompt"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"newWindow.html"</span> <span class="attr">id</span>=<span class="string">"lnkNewWindow"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>New Window Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btnNewNamelessWindow"</span> <span class="attr">onclick</span>=<span class="string">"open_window()"</span> <span class="attr">value</span>=<span class="string">"Open Nameless Window"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btnNewNamedWindow"</span> <span class="attr">onclick</span>=<span class="string">"open_window('Mike')"</span> <span class="attr">value</span>=<span class="string">"Open Named Window"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"output"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>assertFoo(pattern)</td>
<td>如果模式与弹出窗口的文本不匹配，则抛出错误</td>
</tr>
<tr>
<td>assertFooPresent</td>
<td>如果弹出窗口不可用则抛出错误</td>
</tr>
<tr>
<td>assertFooNotPresent</td>
<td>如果存在任何弹出窗口则抛出错误</td>
</tr>
<tr>
<td>storeFoo(variable)</td>
<td>将弹出文本存储在变量中</td>
</tr>
<tr>
<td>storeFooPresent(variable)</td>
<td>将弹出窗口的文本存储在变量中并返回true或false</td>
</tr>
</tbody>
</table>
<p>在Selenium下运行时，不会显示JavaScript弹出窗口。这是因为函数调用实际上是由Selenium自己的JavaScript在运行时覆盖的。但是，仅仅因为你看不到弹出窗口并不意味着你不必处理它。要处理弹出窗口，必须调用其assertFoo（模式）函数。如果您未能断言是否存在弹出窗口，则您的下一个命令将被阻止，您将收到类似于以下错误的错误[错误]错误<br><code>error] Error: There was an unexpected Confirmation! [Chose an option.]</code></p>
<h4 id="Alerts"><a href="#Alerts" class="headerlink" title="Alerts"></a>Alerts</h4><p>让我们从Alerts开始，因为它们是最简单的弹出窗口。首先，在浏览器中打开上面的HTML示例，然后单击“Show alert”按钮。您会注意到，在您关闭警报后，页面上会显示“警报已消失。”文本。现在使用Selenium IDE录制完成相同的步骤，并在关闭警报后验证是否添加了文本。您的测试看起来像这样：</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Target</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>/</td>
<td></td>
</tr>
<tr>
<td>click</td>
<td>btnAlert</td>
<td></td>
</tr>
<tr>
<td>assertAlert</td>
<td>I’m blocking!</td>
<td></td>
</tr>
<tr>
<td>verifyTextPresent</td>
<td>Alert is gone.</td>
<td></td>
</tr>
</tbody>
</table>
<p>您可能会想“这很奇怪，我从未试图断言该警报。”但这是Selenium-IDE处理并为您关闭警报。如果您删除该步骤并重播测试，您将获得以下内容 <code>[error] Error: There was an unexpected Alert! [I&#39;m blocking!].</code></p>
<p>如果您只想声明警报存在但是不知道或不关心它包含哪个文本，则可以使用assertAlertPresent。这将返回true或false，错误地停止测试。</p>
<h4 id="Confirmations"><a href="#Confirmations" class="headerlink" title="Confirmations"></a>Confirmations</h4><p>确认的行为与警报的行为大致相同，其中assertConfirmation和assertConfirmationPresent提供与其警报对应物相同的特征。但是，默认情况下，Selenium会在弹出确认时选择“确定”。尝试单击示例页面中的“显示确认框”按钮，但单击弹出窗口中的“取消”按钮，然后断言输出文本。您的测试可能如下所示：</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Target</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>/</td>
<td></td>
</tr>
<tr>
<td>click</td>
<td>btnAlert</td>
<td></td>
</tr>
<tr>
<td>chooseCancelOnNextConfirmation</td>
<td></td>
<td></td>
</tr>
<tr>
<td>assertConfirmation</td>
<td>Choose an option.</td>
<td></td>
</tr>
<tr>
<td>verifyTextPresent</td>
<td>Rejected</td>
<td></td>
</tr>
</tbody>
</table>
<p>chooseCancelOnNextConfirmation函数告诉Selenium所有后续确认都应该返回false。可以通过调用chooseOkOnNextConfirmation来重置它。</p>
<p>可能会注意到您无法重播此测试，因为Selenium抱怨存在未经处理的确认。这是因为Selenium-IDE记录的事件顺序导致click和chooseCancelOnNextConfirmation被置于错误的顺序（如果考虑它就有意义，Selenium在打开确认之前无法知道正在取消）切换这两个命令，你的测试运行正常。</p>
<h4 id="Prompts"><a href="#Prompts" class="headerlink" title="Prompts"></a>Prompts</h4><p>提示的行为与警报的行为大致相同，其中assertPrompt和assertPromptPresent提供与其警报对应项相同的特征。默认情况下，Selenium会在弹出提示时等待您输入数据。尝试单击示例页面中的“显示提示”按钮，然后在提示中输入“Selenium”。测试可能如下所示：</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Target</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>/</td>
<td></td>
</tr>
<tr>
<td>answerOnNextPrompt</td>
<td>Selenium!</td>
<td></td>
</tr>
<tr>
<td>click</td>
<td>id=btnPrompt</td>
<td></td>
</tr>
<tr>
<td>assertPrompt</td>
<td>What’s the best web QA tool?</td>
<td></td>
</tr>
<tr>
<td>verifyTextPresent</td>
<td>Selenium!</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果在提示中选择取消，您可能会注意到answerOnNextPrompt只显示空白目标。 Selenium对取消和提示上的空白条目基本上是一样的。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><h4 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h4><p>要设置断点，请选择一个命令，单击鼠标右键，然后从上下文菜单中选择“切换断点”。然后单击“运行”按钮以从开始到断点运行测试用例。<br>从测试用例的中间位置到结束位置运行测试用例或者到达起始点之后的断点有时也很有用。例如，假设您的测试用例首先登录到网站，然后执行一系列测试，并且您正在尝试调试其中一个测试。但是，您只需要登录一次，但是在开发测试时需要不断重新运行测试。您可以登录一次，然后从测试用例的登录部分之后的起点运行测试用例。这将阻止您每次重新运行测试用例时都必须手动注销。</p>
<h4 id="按步骤执行测试"><a href="#按步骤执行测试" class="headerlink" title="按步骤执行测试"></a>按步骤执行测试</h4><p>要一次执行一个测试用例（“step through”），只需重复按此按钮。</p>
<p><img src="https://www.seleniumhq.org/docs/_images/chapt2_img09_Step.png" alt="image"></p>
<h4 id="Find-Button"><a href="#Find-Button" class="headerlink" title="Find Button"></a>Find Button</h4><p>“查找”按钮用于查看当前显示的网页（在浏览器中）中当前选定的Selenium命令中使用的UI元素。在为命令的第一个参数构建定位器时，这非常有用（请参阅定位元素一节）。它可以与标识网页上UI元素的任何命令一起使用，例如，单击，单击和等待，键入，以及某些断言和验证命令等。 从表视图中，选择具有locator参数的任何命令。单击“查找”按钮。现在查看网页：应该有一个明亮的绿色矩形，包围locator参数指定的元素。</p>
<h2 id="Java中应用Selenium"><a href="#Java中应用Selenium" class="headerlink" title="Java中应用Selenium"></a>Java中应用Selenium</h2><p><a href="https://github.com/dinghuang/seleniumJavaTest" target="_blank" rel="noopener">项目地址</a></p>
<p>我在本地录制了一个简单的脚本，选择导出到java+junit，类似下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchGoogle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WebDriver driver;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> acceptNextAlert = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> StringBuffer verificationErrors = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">private</span> SeleniumConfigure seleniumConfigure = SeleniumConfigureParse.getSeleniumConfigure();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        driver = DriverUtil.getDriver();</span><br><span class="line">        driver .manage().window().maximize();<span class="comment">//全屏</span></span><br><span class="line">        driver.manage().timeouts().implicitlyWait(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSearchGoogle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        driver.get(seleniumConfigure.getBaseUrl());</span><br><span class="line">        driver.findElement(By.name(<span class="string">"q"</span>)).click();</span><br><span class="line">        driver.findElement(By.name(<span class="string">"q"</span>)).clear();</span><br><span class="line">        driver.findElement(By.name(<span class="string">"q"</span>)).sendKeys(<span class="string">"google"</span>);</span><br><span class="line">        driver.findElement(By.name(<span class="string">"q"</span>)).sendKeys(Keys.ENTER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        driver.quit();</span><br><span class="line">        String verificationErrorString = verificationErrors.toString();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">""</span>.equals(verificationErrorString)) &#123;</span><br><span class="line">            fail(verificationErrorString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementPresent</span><span class="params">(By by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            driver.findElement(by);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAlertPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            driver.switchTo().alert();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoAlertPresentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">closeAlertAndGetItsText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Alert alert = driver.switchTo().alert();</span><br><span class="line">            String alertText = alert.getText();</span><br><span class="line">            <span class="keyword">if</span> (acceptNextAlert) &#123;</span><br><span class="line">                alert.accept();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert.dismiss();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> alertText;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            acceptNextAlert = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>新建项目，pom.xml如下<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"> <span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></span><br><span class="line"><span class="xml">         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="xml">         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>choerodon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>selenium<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.seleniumhq.selenium<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>selenium-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.yaml/snakeyaml --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.yaml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>snakeyaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!--&lt;dependency&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!--&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!--&lt;artifactId&gt;lombok&lt;/artifactId&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!--&lt;version&gt;1.18.4&lt;/version&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!--&lt;/dependency&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0-M3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.surefire<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>surefire-junit47<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0-M3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;basedir&#125;</span><span class="xml">/output<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">outputName</span>&gt;</span>测试报告<span class="tag">&lt;/<span class="name">outputName</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!--&lt;plugin&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="comment">&lt;!--&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="comment">&lt;!--&lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="comment">&lt;!--&lt;version&gt;2.1&lt;/version&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="comment">&lt;!--&lt;configuration&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="comment">&lt;!--&lt;outputDirectory&gt;$</span></span><span class="template-variable">&#123;basedir&#125;</span><span class="xml"><span class="comment">/output&lt;/outputDirectory&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="comment">&lt;!--&lt;outputName&gt;测试报告&lt;/outputName&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="comment">&lt;!--&lt;/configuration&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!--&lt;/plugin&gt;--&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="与Docker结合"><a href="#与Docker结合" class="headerlink" title="与Docker结合"></a>与Docker结合</h2><p> 使用远程的驱动服务来测试，目前只支持Chrome和FireFox，本地如果要起服务，请在docker中执行下面的命令启动服务<br> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull elgalu/selenium</span><br><span class="line">docker <span class="builtin-name">run</span> -d <span class="attribute">--name</span>=grid -p 4444:24444 -p 5900:25900  -e <span class="attribute">TZ</span>=<span class="string">"Asia/Shanghai"</span> -e <span class="attribute">MAX_INSTANCES</span>=20 -e <span class="attribute">MAX_SESSIONS</span>=20  -v /Users/dinghuang/Documents/Tool/selenium/shm:/dev/shm --privileged elgalu/selenium</span><br><span class="line">docker exec grid wait_all_done 30s</span><br></pre></td></tr></table></figure></p>
<p> 可以在<code>http://localhost:4444/grid/console</code>中查看详情</p>
<p> 关闭服务命令：<br> <figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> grid <span class="keyword">stop</span></span><br><span class="line">docker <span class="keyword">stop</span> grid</span><br></pre></td></tr></table></figure></p>
<p> 在JAVA代码中，可以通过远程的docker容器启动浏览器进行测试<br> <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webDriver = <span class="keyword">new</span> <span class="type">RemoteWebDriver</span>(<span class="keyword">new</span> <span class="type">URL</span>(<span class="string">"http://localhost:4444/wd/hub"</span>), browser);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/dinghuang.png"
                alt="强壮的病猫" />
            
              <p class="site-author-name" itemprop="name">强壮的病猫</p>
              <p class="site-description motion-element" itemprop="description">学习、生活、闲谈、足球</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dinghuang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">强壮的病猫</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://dinghuang-1.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
