<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="WSWvVPyzUsUM54ydNcrE1pUzdYt5xGKnqD1i7XpWVF8" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/images/site.webmanifest">


  <meta name="msapplication-config" content="/images/browserconfig.xml" />



  <meta name="keywords" content="Welcome" />










<meta name="description" content="学习、生活、闲谈、足球">
<meta property="og:type" content="website">
<meta property="og:title" content="一只病猫">
<meta property="og:url" content="https://dinghuang.github.io/page/2/index.html">
<meta property="og:site_name" content="一只病猫">
<meta property="og:description" content="学习、生活、闲谈、足球">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一只病猫">
<meta name="twitter:description" content="学习、生活、闲谈、足球">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dinghuang.github.io/page/2/"/>





  <title>一只病猫</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-108021384-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?00a1ba3f5c477c92d7c1ccbb00c6427b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一只病猫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">静坐常思己过，闲谈莫论人非</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'HcRPHRrBuwozvgUoLNyX','2.0.0');
</script>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/06/01/面试分享(三).数据库相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/01/面试分享(三).数据库相关/" itemprop="url">面试分享(三).数据库相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-01T18:33:00+08:00">
                2019-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/01/面试分享(三).数据库相关/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/06/01/面试分享(三).数据库相关/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h1><h2 id="读过MyBatis源码没有？"><a href="#读过MyBatis源码没有？" class="headerlink" title="读过MyBatis源码没有？"></a>读过MyBatis源码没有？</h2><p><a href="https://www.cnblogs.com/zhjh256/p/8512392.html" target="_blank" rel="noopener">可以参考本文</a></p>
<h2 id="聊一聊对分库分表的理解"><a href="#聊一聊对分库分表的理解" class="headerlink" title="聊一聊对分库分表的理解"></a>聊一聊对分库分表的理解</h2><h3 id="大众点评设计案例"><a href="#大众点评设计案例" class="headerlink" title="大众点评设计案例"></a>大众点评设计案例</h3><p>原大众点评的订单单表早就已经突破两百G，由于查询维度较多，即使加了两个从库，优化索引，仍然存在很多查询不理想的情况。去年大量抢购活动的开展，使数据库达到瓶颈，应用只能通过限速、异步队列等对其进行保护；业务需求层出不穷，原有的订单模型很难满足业务需求，但是基于原订单表的DDL又非常吃力，无法达到业务要求。随着这些问题越来越突出，订单数据库的切分就愈发急迫了。这次切分，我们的目标是未来十年内不需要担心订单容量的问题。先对订单库进行垂直切分，将原有的订单库分为基础订单库、订单流程库等。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1b24c0df.png" alt="image"><br>垂直切分缓解了原来单集群的压力，但是在抢购时依然捉襟见肘。原有的订单模型已经无法满足业务需求，于是我们设计了一套新的统一订单模型，为同时满足C端用户、B端商户、客服、运营等的需求，我们分别通过用户ID和商户ID进行切分，并通过PUMA（我们内部开发的MySQL binlog实时解析服务）同步到一个运营库。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/8aff3f22.png" alt="image"></p>
<ul>
<li>切分策略<ul>
<li>查询切分：将ID和库的Mapping关系记录在一个单独的库中。优点：ID和库的Mapping算法可以随意更改。缺点：引入额外的单点。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/ddb1ceb8.png" alt="image"></li>
<li>范围切分：比如按照时间区间或ID区间来切分。优点：单表大小可控，天然水平扩展。缺点：无法解决集中写入瓶颈的问题。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/f80cafa2.png" alt="image"></li>
<li>Hash切分：一般采用Mod来切分，下面着重讲一下Mod的策略。数据水平切分后我们希望是一劳永逸或者是易于水平扩展的，所以推荐采用mod 2^n这种一致性Hash。以统一订单库为例，我们分库分表的方案是32*32的，即通过UserId后四位mod 32分到32个库中，同时再将UserId后四位Div 32 Mod 32将每个库分为32个表，共计分为1024张表。线上部署情况为8个集群(主从)，每个集群4个库。为什么说这种方式是易于水平扩展的呢？我们分析如下两个场景。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/52610d6d.png" alt="image"><ul>
<li>场景一：数据库性能达到瓶颈<ul>
<li>方法一：按照现有规则不变，可以直接扩展到32个数据库集群。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/b301cb95.png" alt="image"></li>
<li>方法二：如果32个集群也无法满足需求，那么将分库分表规则调整为(32<em>2^n)</em>(32⁄2^n)，可以达到最多1024个集群。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/c573941e.png" alt="image"></li>
</ul>
</li>
<li>场景二：单表容量达到瓶颈（或者1024已经无法满足你）<br>  方法：假如单表都已突破200G，200<em>1024=200T（按照现有的订单模型算了算，大概一万千亿订单，相信这一天，嗯，指日可待！），没关系，32     </em>(32 <em>2^n)，这时分库规则不变，单库里的表再进行裂变，当然，在目前订单这种规则下（用userId后四位 mod）还是有极限的，因为只有四位，所以最多拆8192个表，至于为什么只取后四位，后面会有篇幅讲到。另外一个维度是通过ShopID进行切分，规则8 </em>8和UserID比较类似，就不再赘述，需要注意的是Shop库我们仅存储了订单主表，用来满足Shop维度的查询。<br>  <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/494ebd9e.png" alt="image"></li>
</ul>
</li>
</ul>
</li>
<li><p>唯一ID方案：这个方案也很多，主流的有那么几种:</p>
<ul>
<li>利用数据库自增ID：优点：最简单。 缺点：单点风险、单机性能瓶颈。</li>
<li>利用数据库集群并设置相应的步长（Flickr方案）：优点：高可用、ID较简洁。 缺点：需要单独的数据库集群。</li>
<li>Twitter Snowflake：优点：高性能高可用、易拓展。 缺点：需要独立的集群以及ZK。</li>
<li>一大波GUID、Random算法：优点：简单。 缺点：生成ID较长，有重复几率。</li>
<li><p>我们的方案：为了减少运营成本并减少额外的风险我们排除了所有需要独立集群的方案，采用了带有业务属性的方案： &gt; 时间戳+用户标识码+随机数有下面几个好处：</p>
<ul>
<li>方便、成本低。</li>
<li>基本无重复的可能。</li>
<li>自带分库规则，这里的用户标识码即为用户ID的后四位，在查询的场景下，只需要订单号就可以匹配到相应的库表而无需用户ID，只取四位是希望订单号尽可能的短一些，并且评估下来四位已经足够。</li>
<li>可排序，因为时间戳在最前面。</li>
</ul>
<p>当然也有一些缺点，比如长度稍长，性能要比int/bigint的稍差等。</p>
</li>
</ul>
</li>
<li>其他问题<ul>
<li>事务支持：我们是将整个订单领域聚合体切分，维度一致，所以对聚合体的事务是支持的。</li>
<li>复杂查询：垂直切分后，就跟join说拜拜了；水平切分后，查询的条件一定要在切分的维度内，比如查询具体某个用户下的各位订单等；禁止不带切分的维度的查询，即使中间件可以支持这种查询，可以在内存中组装，但是这种需求往往不应该在</li>
<li>在线库查询，或者可以通过其他方法转换到切分的维度来实现。</li>
</ul>
</li>
<li><p>数据迁移</p>
<p>  数据库拆分一般是业务发展到一定规模后的优化和重构，为了支持业务快速上线，很难一开始就分库分表，垂直拆分还好办，改改数据源就搞定了，一旦开始水平拆分，数据清洗就是个大问题，为此，我们经历了以下几个阶段。</p>
<ul>
<li>第一阶段<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2ae1ba98.png" alt="image"><ul>
<li>数据库双写（事务成功以老模型为准），查询走老模型。</li>
<li>每日job数据对账（通过DW），并将差异补平。</li>
<li>通过job导历史数据。</li>
</ul>
</li>
<li>第二阶段<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0a93304e.png" alt="image"><ul>
<li>历史数据导入完毕并且数据对账无误。</li>
<li>依然是数据库双写，但是事务成功与否以新模型为准，在线查询切新模型。</li>
<li>每日job数据对账，将差异补平。</li>
</ul>
</li>
<li>第三阶段<br>  <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/a8d54b30.png" alt="image"><ul>
<li>老模型不再同步写入，仅当订单有终态时才会异步补上。</li>
<li>此阶段只有离线数据依然依赖老的模型，并且下游的依赖非常多，待DW改造完就可以完全废除老模型了。</li>
</ul>
</li>
</ul>
</li>
<li>总结<br>并非所有表都需要水平拆分，要看增长的类型和速度，水平拆分是大招，拆分后会增加开发的复杂度，不到万不得已不使用。在大规模并发的业务上，尽量做到在线查询和离线查询隔离，交易查询和运营/客服查询隔离。拆分维度的选择很重要，要尽可能在解决拆分前问题的基础上，便于开发。数据库没你想象的那么坚强，需要保护，尽量使用简单的、良好索引的查询，这样数据库整体可控，也易于长期容量规划以及水平扩展。</li>
</ul>
<h3 id="亿级数据下的分库分表方案"><a href="#亿级数据下的分库分表方案" class="headerlink" title="亿级数据下的分库分表方案"></a>亿级数据下的分库分表方案</h3><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>分区表是由多个相关的底层表实现，这些底层表也是由句柄对象表示，所以我们也可以直接访问各个分区，存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），分区表的索引只是在各个底层表上各自加上一个相同的索引，从存储引擎的角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。这个方案也不错，它对用户屏蔽了sharding的细节，即使查询条件没有sharding column，它也能正常工作（只是这时候性能一般）。不过它的缺点很明显：很多的资源都受到单机的限制，例如连接数，网络吞吐等。如何进行分区，在实际应用中是一个非常关键的要素之一。在我们的项目中，以客户信息为例，客户数据量5000万加，项目背景要求保存客户的银行卡绑定关系，客户的证件绑定关系，以及客户绑定的业务信息。此业务背景下，该如何设计数据库呢。项目一期的时候，我们建立了一张客户业务绑定关系表，里面冗余了每一位客户绑定的业务信息。基本结构大致如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1086caaj20fa06m761.jpg" alt=""><br>查询时，对银行卡做索引，业务编号做索引，证件号做索引。随着需求大增多，这张表的索引会达到10个以上。而且客户解约再签约，里面会保存两条数据，只是绑定的状态不同。假设我们有5千万的客户，5个业务类型，每位客户平均2张卡，那么这张表的数据量将会达到惊人的5亿，事实上我们系统用户量还没有过百万时就已经不行了。mysql数据库中的数据是以文件的形势存在磁盘上的，默认放在/mysql/data下面（可以通过my.cnf中的datadir来查看）， 一张表主要对应着三个文件，一个是frm存放表结构的，一个是myd存放表数据的，一个是myi存表索引的。这三个文件都非常的庞大，尤其是.myd文件，快5个G了。 下面进行第一次分区优化 ，Mysql支持的分区方式有四种：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e11m0q1wj20fa066tbt.jpg" alt=""><br>在我们的项目中，range分区和list分区没有使用场景，如果基于绑定编号做range或者list分区，绑定编号没有实际的业务含义，无法通过它进行查询，因此，我们就剩下 HASH 分区和 KEY 分区了， HASH 分区仅支持int类型列的分区，且是其中的一列。看看我们的库表结构，发现没有哪一列是int类型的，如何做分区呢？可以增加一列，绑定时间列，将此列设置为int类型，然后按照绑定时间进行分区，将每一天绑定的用户分到同一个区里面去。这次优化之后，我们的插入快了许多，但是查询依然很慢，为什么，因为在做查询的时候，我们也只是根据银行卡或者证件号进行查询，并没有根据时间查询，相当于每次查询，mysql都会将所有的分区表查询一遍。</p>
<p>然后进行第二次方案优化，既然hash分区和key分区要求其中的一列必须是int类型的，那么创造出一个int类型的列出来分区是否可以。分析发现，银行卡的那串数字有秘密。银行卡一般是16位到19位不等的数字串，我们取其中的某一位拿出来作为表分区是否可行呢，通过分析发现，在这串数字中，其中确实有一位是0到9随机生成的，不同的卡串长度，这一位不同，绝不是最后一位，最后位数字一般都是校验位，不具有随机性。我们新设计的方案，基于银行卡号+随机位进行KEY分区，每次查询的时候，通过计算截取出这位随机位数字，再加上卡号，联合查询，达到了分区查询的目的，需要说明的是，分区后，建立的索引，也必须是分区列，否则的话，Mysql还是会在所有的分区表中查询数据。那么通过银行卡号查询绑定关系的问题解决了，那么证件号呢，如何通过证件号来查询绑定关系。前面已经讲过，做索引一定是要在分区健上进行，否则会引起全表扫描。我们再创建了一张新表，保存客户的证件号绑定关系，每位客户的证件号都是唯一的，新的证件号绑定关系表里，证件号作为了主键，那么如何来计算这个分区健呢，客户的证件信息比较庞杂，有身份证号，港澳台通行证，机动车驾驶证等等，如何在无序的证件号里找到分区健。为了解决这个问题，我们将证件号绑定关系表一分为二，其中的一张表专用于保存身份证类型的证件号，另一张表则保存其他证件类型的证件号，在身份证类型的证件绑定关系表中，我们将身份证号中的月数拆分出来作为了分区健，将同一个月出生的客户证件号保存在同一个区，这样分成了12个区，其他证件类型的证件号，数据量不超过10万，就没有必要进行分区了。这样每次查询时，首先通过证件类型确定要去查询哪张表，再计算分区健进行查询。</p>
<p>作了分区设计之后，保存2000万用户数据的时候，银行卡表的数据保存文件就分成了10个小文件，证件表的数据保存文件分成了12个小文件，解决了这两个查询的问题，还剩下一个问题就是，业务编号呢，怎么办，一个客户有多个签约业务，如何进行保存，这时候，采用分区的方案就不太合适了，它需要用到分表的方案。</p>
<h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p>如何进行分库分表，目前互联网上有许多的版本，比较知名的一些方案：</p>
<ul>
<li>阿里的TDDL，DRDS和cobar</li>
<li>京东金融的sharding-jdbc</li>
<li>民间组织的MyCAT</li>
<li>360的Atlas</li>
<li>美团的zebra</li>
<li>其他比如网易，58，京东等公司都有自研的中间件。</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0f0ubx3knj20oc0fd45s.jpg" alt=""></p>
<p>百花齐放的景象。但是这么多的分库分表中间件方案，归总起来，就两类： client模式和proxy模式 。</p>
<ul>
<li>client模式<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1osp6e3j20fa0c2ta5.jpg" alt=""></li>
<li>和proxy模式<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1v26i8nj20fa0gxmyt.jpg" alt=""></li>
</ul>
<p>无论是client模式，还是proxy模式，几个核心的步骤是一样的：SQL解析，重写，路由，执行，结果归并。个人比较倾向于采用client模式，它架构简单，性能损耗也比较小，运维成本低。如果在项目中引入mycat或者cobar，他们的单机模式无法保证可靠性，一旦宕机则服务就变得不可用，你又不得不引入HAProxy来实现它的高可用集群部署方案， 为了解决HAProxy的高可用问题，又需要采用Keepalived来实现。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e2eu3bjvj20fa0gy0zk.jpg" alt=""></p>
<p>我们在项目中放弃了这个方案，采用了shardingjdbc的方式。回到刚才的业务问题，如何对业务类型进行分库分表。分库分表第一步也是最重要的一步，即sharding column的选取，sharding column选择的好坏将直接决定整个分库分表方案最终是否成功。而sharding column的选取跟业务强相关。在我们的项目场景中，sharding column无疑最好的选择是业务编号。通过业务编号，将客户不同的绑定签约业务保存到不同的表里面去，查询时，根据业务编号路由到相应的表中进行查询，达到进一步优化sql的目的。</p>
<p>前面我们讲到了基于客户签约绑定业务场景的数据库优化，下面我们再聊一聊，对于海量数据的保存方案。</p>
<h5 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h5><h6 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h6><p>也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。</p>
<h6 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h6><p>垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。如下图：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ezns2ifaj20bf08kgml.jpg" alt=""></p>
<p>优点</p>
<p>数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于 Web 和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破 IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。</p>
<p>缺点</p>
<ul>
<li>跨库 join 的问题</li>
<li>跨库事务（分布式事务）的问题</li>
</ul>
<p>解决方式</p>
<ul>
<li>全局表<ul>
<li>所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库 join 查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。</li>
</ul>
</li>
<li>字段冗余<ul>
<li>这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免 join 查询。</li>
</ul>
</li>
<li>数据同步<ul>
<li>定时 A 库中的 tab_a 表和 B 库中 tbl_b 有关联，可以定时将指定的表做同步。当然，同步本来会对数据库带来一定的影响，需要性能影响和数据时效性中取得一个平衡。这样来避免复杂的跨库查询。例如ETL工具。</li>
</ul>
</li>
<li>系统层组装<ul>
<li>在系统层面，通过调用不同模块的组件或者服务，获取到数据并进行字段拼装。说起来很容易，但实践起来可真没有这么简单，尤其是数据库设计上存在问题但又无法轻易调整的时候。</li>
</ul>
</li>
</ul>
<p>对于每分钟要处理近1000万的流水，每天流水近1亿的量，如何高效的写入和查询，是一项比较大的挑战。还是老办法，分库分表分区，读写分离，只不过这一次，我们先分表，再分库，最后分区。我们将消息流水按照不同的业务类型进行分表，相同业务的消息流水进入同一张表，分表完成之后，再进行分库。我们将流水相关的数据单独保存到一个库里面去，这些数据，写入要求高，查询和更新到要求低，将它们和那些更新频繁的数据区分开。分库之后，再进行分区。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e30hgeqaj20fa06c75g.jpg" alt=""></p>
<p>这是基于业务垂直度进行的分库操作，垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库，以达到系统资源的饱和利用率。这样的分库方案结合应用的微服务治理，每个微服务系统使用独立的一个数据库。将不同模块的数据分库存储，模块间不能进行相互关联查询，如果有，要么通过数据冗余解决，要么通过应用代码进行二次加工进行解决。若不能杜绝跨库关联查询，则将小表到数据冗余到大数据量大库里去。假如，流水大表中查询需要关联获得渠道信息，渠道信息在基础管理库里面，那么，要么在查询时，代码里二次查询基础管理库中的渠道信息表，要么将渠道信息表冗余到流水大表中。</p>
<p>将每天过亿的流水数据分离出去之后，流水库中单表的数据量还是太庞大，我们将单张流水表继续分区，按照一定的业务规则，（一般是查询索引列）将单表进行分区，一个表编程N个表，当然这些变化对应用层是无法感知的。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e5r0z2zoj20fa0lgjw2.jpg" alt=""></p>
<p>分区表的设置，一般是以查询索引列进行分区，例如，对于流水表A，查询需要根据手机号和批次号进行查询，所以我们在创建分区的时候，就选择以手机号和批次号进行分区，这样设置后，查询都会走索引，每次查询Mysql都会根据查询条件计算出来，数据会落在那个分区里面，直接到对应的分区表中检索即可，避免了全表扫描。</p>
<p>对于每天流水过亿的数据，当然是要做历史表进行数据迁移的工作了。客户要求流水数据需要保存半年的时间，有的关键流水需要保存一年。删数据是不可能的了，也跑不了路，虽然当时非常有想删数据跑路的冲动。其实即使是删数据也是不太可能的了，delete的拙劣表演先淘汰了，truncate也快不了多少，我们采用了一种比较巧妙方法，具体步骤如下：</p>
<ul>
<li>创建一个原表一模一样的临时表1 <code>create table test_a_serial_1 like test_a_serial</code>;</li>
<li>将原表命名为临时表2 <code>alter table test_a_serial rename test_a_serial_{date}</code>;</li>
<li>将临时表1改为原表 <code>alter table able test_a_serial_1 rename able test_a_serial</code>; 此时，当日流水表就是一张新的空表了，继续保存当日的流水，而临时表2则保存的是昨天的数据和部分今天的数据，临时表2到名字中的date时间是通过计算获得的昨日的日期；每天会产生一张带有昨日日期的临时表2，每个表内的数据大约是有1000万。</li>
<li>将当日表中的历史数据迁移到昨日流水表中去 这样的操作都是用的定时任务进行处理，定时任务触发一般会选择凌晨12点以后，这个操作即使是几秒内完成，也有可能会有几条数据落入到当日表中去。因此我们最后还需要将当日表内的历史流水数据插入到昨日表内； <code>insert into test_a_serial_{date}(cloumn1,cloumn2….) select(cloumn1,cloumn2….) from test_a_serial where LEFT(create_time,8) &gt; CONCAT(date); commit</code>;</li>
</ul>
<p>如此，便完成了流水数据的迁移；<br>根据业务需要，有些业务数据需要保存半年，超过半年的进行删除,在进行删除的时候，就可以根据表名中的_{date}筛选出大于半年的流水直接删表；</p>
<p>半年的时间，对于一个业务流水表大约就会有180多张表，每张表又有20个分区表，那么如何进实时计算统计行查询呢？由于我们的项目对于流水的查询实时性要求不是特别高，因此我们在做查询时，进行了根据查询时间区间段进行路由查询的做法。大致做法时，根据客户选择的时间区间段，带上查询条件，分别去时间区间段内的每一张表内查询，将查询结果保存到一张临时表内，然后，再去查询临时表获得最终的查询结果。</p>
<p>半年的时间，对于一个业务流水表大约就会有180多张表，每张表又有20个分区表，那么如何进行查询呢？由于我们的项目对于流水的查询实时性要求不是特别高，因此我们在做查询时，进行了根据查询时间区间段进行路由查询的做法。大致做法时，根据客户选择的时间区间段，带上查询条件，分别去时间区间段内的每一张表内查询，将查询结果保存到一张临时表内，然后，再去查询临时表获得最终的查询结果。</p>
<p>以上便是我们面对大数据量的场景下，数据库层面做的相应的优化，一张每天一亿的表，经过拆分后，每个表分区内的数据在500万左右。</p>
<h6 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h6><ul>
<li><p>水平分表</p>
<p>  针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用。</p>
<p>  <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ezurxr0cj20bk07hwhl.jpg" alt=""></p>
<p>  某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破 IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。</p>
</li>
<li><p>水平分库分表</p>
<p>  将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。</p>
</li>
<li><p>水平分库分表切分规则</p>
<ul>
<li>RANGE<ul>
<li>从0到10000一个表，10001到20000一个表；</li>
</ul>
</li>
<li>HASH取模<ul>
<li>一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 取用户id，然后hash取模，分配到不同的数据库上。</li>
</ul>
</li>
<li>地理区域<ul>
<li>比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。</li>
</ul>
</li>
<li>时间<ul>
<li>按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="MySQL主从同步与主主同步"><a href="#MySQL主从同步与主主同步" class="headerlink" title="MySQL主从同步与主主同步"></a>MySQL主从同步与主主同步</h2><h3 id="MySQL复制"><a href="#MySQL复制" class="headerlink" title="MySQL复制"></a>MySQL复制</h3><p> MySQL内建的复制功能是构建大型，高性能应用程序的基础。将MySQL的数据分布到多个系统上去，这种分布的机制，是通过将mysql的某一台主机的数据复制到其它主机（slave）上，并重新执行一遍来实现。</p>
<p>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循坏，这些日志可以记录发送到从服务器的更新。当一个从服务器</p>
<p>连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知的更新。</p>
<p>需注意的是：</p>
<p>在进行mysql复制时，所有对复制中的表的更新必须在主服务器上进行。否则必须要小心，以避免用户对主服器上的表进行更新与对从服务器上的表所进行更新之间的冲突。</p>
<h4 id="mysql支持哪些复制"><a href="#mysql支持哪些复制" class="headerlink" title="mysql支持哪些复制"></a>mysql支持哪些复制</h4><p> a.基于语句的复制：在主服务器上执行的sql语句，在从服务器上执行同样的语句。mysql默认采用基于语句的复制，效率边角高。一旦发现没法精确复制时，会自动选着基于行的复制。</p>
<p>b.基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍。从mysql 5.0开始支持</p>
<p>c.混合类型的复制：默认采用基于语句的复制，一旦发现基于语句的无法精确复制时，就会采用基于行的复制。</p>
<h4 id="mysql复制解决的问题"><a href="#mysql复制解决的问题" class="headerlink" title="mysql复制解决的问题"></a>mysql复制解决的问题</h4><p>a.数据分布（data distribution）</p>
<p> b.负载平衡（load balancing）</p>
<p> c.数据备份（backup），保证数据安全</p>
<p> d.高可用性与容错行（high availability and failover）</p>
<p> e.实现读写分离，缓解数据库压力</p>
<h4 id="mysql主从复制原理"><a href="#mysql主从复制原理" class="headerlink" title="mysql主从复制原理"></a>mysql主从复制原理</h4><p>master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，</p>
<p>   如果发生改变，则开始一个I/O Thread请求master二进制事件，同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志</p>
<p>  中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/O Thread和SQL Thread将进入睡眠状态，等待下一次被唤醒。</p>
<p>注意几点：</p>
<p> 1–master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。</p>
<p> 2–slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和 master数据保持一致了。</p>
<p> 3–Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。</p>
<p> 4–Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）</p>
<p> 5–master和slave两节点间时间需同步</p>
<p>Mysql复制的流程图如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/907596-20170106160057409-885292032.png" alt="image"></p>
<p>如上图所示：</p>
<p> Mysql复制过程的第一部分就是master记录二进制日志。在每个事务更新数据完成之前，master在二日志记录这些改变。MySQL将事务串行的写入二进制日志，即使事务中的语句都是交叉执行的。在事件写入二进制日志完成后，master通知存储引擎提交事务。</p>
<p>第二部分就是slave将master的binary log拷贝到它自己的中继日志。首先，slave开始一个工作线程——I/O线程。I/O线程在master上打开一个普通的连接，然后开始binlog dump process。Binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件。I/O线程将这些事件写入中继日志。</p>
<p>SQL slave thread（SQL从线程）处理该过程的最后一步。SQL线程从中继日志读取事件，并重放其中的事件而更新slave的数据，使其与master中的数据一致。只要该线程与I/O线程保持一致，中继日志通常会位于OS的缓存中，所以中继日志的开销很小。</p>
<p>此外，在master中也有一个工作线程：和其它MySQL的连接一样，slave在master中打开一个连接也会使得master开始一个线程。复制过程有一个很重要的限制——复制在slave上是串行化的，也就是说master上的并行更新操作不能在slave上并行操作。</p>
<h4 id="mysql复制的模式"><a href="#mysql复制的模式" class="headerlink" title="mysql复制的模式"></a>mysql复制的模式</h4><p>  1–主从复制：主库授权从库远程连接，读取binlog日志并更新到本地数据库的过程；主库写数据后，从库会自动同步过来（从库跟着主库变）；</p>
<p> 2–主主复制：主从相互授权连接，读取对方binlog日志并更新到本地数据库的过程；只要对方数据改变，自己就跟着改变；</p>
<h4 id="mysql主从复制优点"><a href="#mysql主从复制优点" class="headerlink" title="mysql主从复制优点"></a>mysql主从复制优点</h4><p> 1–在从服务器可以执行查询工作(即我们常说的读功能)，降低主服务器压力;（主库写，从库读，降压）</p>
<p> 2–在从主服务器进行备份，避免备份期间影响主服务器服务;（确保数据安全）</p>
<p> 3–当主服务器出现问题时，可以切换到从服务器。（提升性能）</p>
<h4 id="mysql主从复制工作流程细节"><a href="#mysql主从复制工作流程细节" class="headerlink" title="mysql主从复制工作流程细节"></a>mysql主从复制工作流程细节</h4><p>a. MySQL支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。MySQL复制基于主服务器在二进制日志中跟踪所有对数据库的更改(更新、删除等等)。因此，要进行复制，必须在主服务器上启用二进制日志。每个从服务器从主服务器接收主服务器上已经记录到其二进制日志的保存的更新。当一个从服务器连接主服务器时，它通知主服务器定位到从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，并在本机上执行相同的更新。然后封锁并等待主服务器通知新的更新。从服务器执行备份不会干扰主服务器，在备份过程中主服务器可以继续处理更新。</p>
<p> b. MySQL使用3个线程来执行复制功能，其中两个线程(Sql线程和IO线程)在从服务器，另外一个线程(IO线程)在主服务器。<br>当发出START SLAVE时，从服务器创建一个I/O线程，以连接主服务器并让它发送记录在其二进制日志中的语句。主服务器创建一个线程将二进制日志中的内容发送到从服务器。该线程可以即为主服务器上SHOW PROCESSLIST的输出中的Binlog Dump线程。从服务器I/O线程读取主服务器Binlog Dump线程发送的内容并将该数据拷贝到从服务器数据目录中的本地文件中，即中继日志。第3个线程是SQL线程，由从服务器创建，用于读取中继日志并执行日志中包含的更新。在从服务器上，读取和执行更新语句被分成两个独立的任务。当从服务器启动时，其I/O线程可以很快地从主服务器索取所有二进制日志内容，即使SQL线程执行更新的远远滞后。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主从数据完成同步的过程：</p>
<p>1）在Slave 服务器上执行sartslave命令开启主从复制开关，开始进行主从复制。</p>
<p>2）此时，Slave服务器的IO线程会通过在master上已经授权的复制用户权限请求连接master服务器，并请求从执行binlog日志文件的指定位置（日志文件名和位置就是在配置主从复制服务时执行change master命令指定的）之后开始发送binlog日志内容</p>
<p>3）Master服务器接收到来自Slave服务器的IO线程的请求后，其上负责复制的IO线程会根据Slave服务器的IO线程请求的信息分批读取指定binlog日志文件指定位置之后的binlog日志信息，然后返回给Slave端的IO线程。返回的信息中除了binlog日志内容外，还有在Master服务器端记录的IO线程。返回的信息中除了binlog中的下一个指定更新位置。</p>
<p>4）当Slave服务器的IO线程获取到Master服务器上IO线程发送的日志内容、日志文件及位置点后，会将binlog日志内容依次写到Slave端自身的Relay Log（即中继日志）文件（Mysql-relay-bin.xxx）的最末端，并将新的binlog文件名和位置记录到master-info文件中，以便下一次读取master端新binlog日志时能告诉Master服务器从新binlog日志的指定文件及位置开始读取新的binlog日志内容</p>
<p>5）Slave服务器端的SQL线程会实时检测本地Relay Log 中IO线程新增的日志内容，然后及时把Relay LOG 文件中的内容解析成sql语句，并在自身Slave服务器上按解析SQL语句的位置顺序执行应用这样sql语句，并在relay-log.info中记录当前应用中继日志的文件名和位置点</p>
<h4 id="主从复制条件"><a href="#主从复制条件" class="headerlink" title="主从复制条件"></a>主从复制条件</h4><p>1）开启Binlog功能</p>
<p>2）主库要建立账号</p>
<p>3）从库要配置<code>master.info</code>（CHANGE MASTER to…相当于配置密码文件和Master的相关信息）</p>
<p>4）start slave 开启复制功能</p>
<h5 id="需要了解的"><a href="#需要了解的" class="headerlink" title="需要了解的"></a>需要了解的</h5><p>1）3个线程，主库IO，从库IO和SQL及作用</p>
<p>2）<code>master.info</code>（从库）作用</p>
<p>3）<code>relay-log</code> 作用</p>
<p>4）异步复制</p>
<p>5）binlog作用（如果需要级联需要开启Binlog）</p>
<h5 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h5><p>1）主从复制是异步的逻辑的SQL语句级的复制</p>
<p>2）复制时，主库有一个I/O线程，从库有两个线程，I/O和SQL线程</p>
<p>3）实现主从复制的必要条件是主库要开启记录binlog功能</p>
<p>4）作为复制的所有Mysql节点的server-id都不能相同</p>
<p>5）binlog文件只记录对数据库有更改的SQL语句（来自主库内容的变更），不记录任何查询（select，show）语句</p>
<h5 id="彻底解除主从复制关系"><a href="#彻底解除主从复制关系" class="headerlink" title="彻底解除主从复制关系"></a>彻底解除主从复制关系</h5><p>1)stop slave;</p>
<p>2)reset slave; 或直接删除<code>master.info</code>和<code>relay-log.info</code>这两个文件；</p>
<p>3)修改<code>my.cnf</code>删除主从相关配置参数。</p>
<p>让slave不随MySQL自动启动</p>
<p>修改<code>my.cnf</code> 在[mysqld]中增加 <code>skip-slave-start</code> 选项。</p>
<p>做了MySQL主从复制以后，使用mysqldump对数据备份时，一定要注意按照如下方式：</p>
<p><code>mysqldump --master-data --single-transaction --user=username --password=password dbname&gt; dumpfilename</code></p>
<p>这样就可以保留 file 和 position 的信息，在新搭建一个slave的时候，还原完数据库， file 和 position 的信息也随之更新，接着再start slave 就可以很迅速</p>
<p>的完成增量同步！</p>
<p>需要限定同步哪些数据库，有3个思路：</p>
<p>1）在执行grant授权的时候就限定数据库；</p>
<p>2）在主服务器上限定<code>binlog_do_db</code> = 数据库名；</p>
<p>3）主服务器上不限定数据库，在从服务器上限定<code>replicate-do-db</code> = 数据库名；</p>
<p>如果想实现 主-从（主）-从 这样的链条式结构，需要设置：</p>
<p><code>log-slave-updates</code>   只有加上它，从前一台机器上同步过来的数据才能同步到下一台机器。</p>
<p>当然，二进制日志也是必须开启的：</p>
<p><code>log-bin=/opt/mysql/binlogs/bin-log</code></p>
<p><code>log-bin-index=/opt/mysql/binlogs/bin-log.index</code></p>
<p>还可以设置一个log保存周期：</p>
<p><code>expire_logs_days=14</code></p>
<h3 id="下面记录下mysql主从／主主同步环境的实施过程"><a href="#下面记录下mysql主从／主主同步环境的实施过程" class="headerlink" title="下面记录下mysql主从／主主同步环境的实施过程"></a>下面记录下mysql主从／主主同步环境的实施过程</h3><h4 id="环境描述"><a href="#环境描述" class="headerlink" title="环境描述"></a>环境描述</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">centos</span> 7<span class="selector-class">.4</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">master</span>：192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.103</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">slave</span>： 192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.104</span></span><br></pre></td></tr></table></figure>
<p>注意下面几点：</p>
<p>1）要保证同步服务期间之间的网络联通。即能相互ping通，能使用对方授权信息连接到对方数据库（防火墙开放3306端口）。</p>
<p>2）关闭selinux。</p>
<p>3）同步前，双方数据库中需要同步的数据要保持一致。这样，同步环境实现后，再次更新的数据就会如期同步了。</p>
<h4 id="主从复制实现过程"><a href="#主从复制实现过程" class="headerlink" title="主从复制实现过程"></a>主从复制实现过程</h4><p>(1)设置master数据库的<code>my.cnf</code>文件（<code>my.cnf</code> 查找顺序 <code>/etc/my.cnf ---&gt; $basedir/my.cnf</code>,在[mysqld]配置区域添加下面内容）</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# vim /etc/my.cnf</span><br><span class="line">    <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">   [mysqld] </span><br><span class="line"><span class="attribute">server-id</span>=1        #数据库唯一ID，主从的标识号绝对不能重复。</span><br><span class="line"><span class="attribute">log-bin</span>=mysql-bin    #开启bin-log，并指定文件目录和文件名前缀</span><br><span class="line"><span class="attribute">binlog-do-db</span>=liting　  #需要同步liting数据库。如果是多个同步库，就以此格式另写几行即可。如果不指明对某个具体库同步，就去掉此行，表示同步所有库（除了ignore忽略的库）。</span><br><span class="line"><span class="attribute">binlog-ignore-db</span>=mysql  #不同步mysql系统数据库。如果是多个不同步库，就以此格式另写几行；也可以在一行，中间逗号隔开。</span><br><span class="line">sync_binlog = 1      ＃确保binlog日志写入后与硬盘同步</span><br><span class="line">binlog_checksum = none  ＃跳过现有的采用checksum的事件，mysql5.6.5以后的版本中<span class="attribute">binlog_checksum</span>=crc32,而低版本都是binlog_checksum=none</span><br><span class="line">binlog_format = mixed   ＃bin-log日志文件格式，设置为MIXED可以防止主键重复。</span><br></pre></td></tr></table></figure>
<p> 温馨提示：在主服务器上最重要的二进制日志设置是<code>sync_binlog</code>，这使得mysql在每次提交事务的时候把二进制日志的内容同步到磁盘上，即使服务器崩溃也会把事件写入日志中。<br><code>sync_binlog</code>这个参数是对于MySQL系统来说是至关重要的，他不仅影响到Binlog对MySQL所带来的性能损耗，而且还影响到MySQL中数据的完整性。对于”sync_binlog”参数的各种设置的说明如下：<br><code>sync_binlog</code>=0，当事务提交之后，MySQL不做fsync之类的磁盘同步指令刷新<code>binlog_cache</code>中的信息到磁盘，而让Filesystem自行决定什么时候来做同步，或者cache满了之后才同步到磁盘。<br><code>sync_binlog</code>=n，当每进行n次事务提交之后，MySQL将进行一次fsync之类的磁盘同步指令来将<code>binlog_cache</code>中的数据强制写入磁盘。</p>
<p>在MySQL中系统默认的设置是<code>sync_binlog</code>=0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦系统Crash，在<code>binlog_cache</code>中的所有binlog信息都会被丢失。而当设置为“1”的时候，是最安全但是性能损耗最大的设置。因为当设置为1的时候，即使系统Crash，也最多丢失<code>binlog_cache</code>中未完成的一个事务，对实际数据没有任何实质性影响。</p>
<p><strong>从以往经验和相关测试来看，对于高并发事务的系统来说，“<code>sync_binlog</code>”设置为0和设置为1的系统写入性能差距可能高达5倍甚至更多。</strong></p>
<p>(2)导出master数据库多余slave数据库中的数据，然后导入到slave数据库中。保证双方在同步环境实现前的数据一致。[新建环境可忽略次步骤]</p>
<p>导出数据库之前先锁定数据库<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush tables with <span class="keyword">read</span> lock;    <span class="comment">#数据库只读锁定命令，防止导出数据库的时候有数据写入。unlock tables命令解除锁定</span></span><br><span class="line">    </span><br><span class="line">导出<span class="literal">master</span>数据库中需要同步的库(<span class="literal">master</span>数据库的root用户登陆密码：<span class="number">123456</span>)</span><br><span class="line">[root@<span class="keyword">master</span> <span class="title">~]#mysqldump</span> -uroot liting -p123456 &gt;/opt/liting.sql</span><br><span class="line">[root@<span class="keyword">master</span> <span class="title">~]#rsync</span>  -e <span class="string">"ssh -p22"</span> -avpgolr /opt/liting.sql <span class="number">192.168</span>.<span class="number">0.104</span>:/opt/   ＃将导出的sql文件上传到<span class="literal">slave</span>机器上</span><br></pre></td></tr></table></figure></p>
<p>(3)在master上设置数据同步权限<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant replication slave,replication client on *.* to repl@'<span class="number">192.168</span><span class="number">.0</span><span class="number">.104</span>' identified by <span class="string">"repl123"</span>;  #只允许<span class="number">192.168</span><span class="number">.0</span><span class="number">.104</span>使用repl，且密码为<span class="string">"repl123"</span>连接主库做数据同步</span><br><span class="line"> Query OK, <span class="number">0</span> rows affected (<span class="number">0.02</span> sec)                                    #若要所有网段则设置repl@'%' ；部分网段：repl@'<span class="number">192.168</span><span class="number">.0</span>.%'</span><br><span class="line"> mysql&gt; flush privileges;</span><br><span class="line"> Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>温馨提示：<br>权限查看方式<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show grants;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show grants <span class="keyword">for</span> repl@<span class="string">'192.168.0.104'</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>(4)查看主服务器master状态(注意File与Position项，从服务器需要这两项参数)<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">| File       | Position | Binlog<span class="emphasis">_Do_</span>DB | Binlog<span class="emphasis">_Ignore_</span>DB | Executed<span class="emphasis">_Gtid_</span>Set |</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">| mysql-bin.000007 | 120    |  liting   |     mysql   |          |</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>下面是slave数据库上的操作</p>
<p>(1)设置slave数据库的my.cnf配置文件<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@master ~]<span class="comment"># vim /etc/my.cnf</span></span><br><span class="line">.......</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="attr">server-id=2</span>   <span class="comment">#设置从服务器id，必须于主服务器不同</span></span><br><span class="line"><span class="attr">log-bin=mysql-bin</span>   <span class="comment">#启动MySQ二进制日志系统</span></span><br><span class="line"><span class="attr">replicate-do-db=liting</span>  <span class="comment">#需要同步的数据库名。如果不指明同步哪些库，就去掉这行，表示所有库的同步（除了ignore忽略的库）。</span></span><br><span class="line"><span class="attr">replicate-ignore-db=mysql</span>  <span class="comment">#不同步test数据库</span></span><br><span class="line"><span class="attr">slave-skip-errors</span> = all   <span class="comment">#跳过所有的错误，继续执行复制操作</span></span><br></pre></td></tr></table></figure></p>
<p>温馨提示：<br>当只针对某些库的某张表进行同步时，如下，只同步liting库的haha表和test库的heihei表：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">replicate-<span class="keyword">do</span>-<span class="keyword">db</span> = liting</span><br><span class="line">replicate-wild-<span class="keyword">do</span>-<span class="keyword">table</span> = liting.haha       <span class="comment">//当只同步几个或少数表时，可以这样设置。注意这要跟上面的库指定配合使用；</span></span><br><span class="line">replicate-<span class="keyword">do</span>-<span class="keyword">db</span> = <span class="keyword">test</span></span><br><span class="line">replicate-wild-<span class="keyword">do</span>-<span class="keyword">table</span> = <span class="keyword">test</span>.heihei      <span class="comment">//如果同步的库的表比较多时，就不能这样一一指定了，就把这个选项配置去掉，直接根据指定的库进行同步。</span></span><br></pre></td></tr></table></figure></p>
<p>(2)在slave数据库中导入从master传过来的数据。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE DATABASE liting CHARACTER SET utf8 COLLATE utf8_general_ci;   <span class="comment">#先创建一个liting空库，否则下面导入数据时会报错说此库不存在。</span></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use liting;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">source</span> /opt/liting.sql;   ＃导入master中多余的数据。</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure></p>
<p>(3）配置主从同步指令<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">stop</span> <span class="string">slave;</span>   <span class="string">＃执行同步前，要先关闭slave</span></span><br><span class="line"><span class="string">mysql&gt;</span> <span class="string">change</span> <span class="string">master</span> <span class="string">to</span> <span class="string">master_host='192.168.0.103',master_user='repl',master_password='repl123',master_log_file='mysql-bin.000007',master_log_pos=120;</span></span><br><span class="line">    </span><br><span class="line"><span class="string">mysql&gt;</span> <span class="string">start</span> <span class="string">slave;</span></span><br><span class="line"><span class="string">mysql&gt;</span> <span class="string">show</span> <span class="string">slave</span> <span class="string">status</span> <span class="string">\G;</span></span><br><span class="line"><span class="string">.......</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">        Slave_IO_State:</span> <span class="string">Waiting</span> <span class="string">for</span> <span class="string">master</span> <span class="string">to</span> <span class="string">send</span> <span class="string">event</span></span><br><span class="line"><span class="attr">         Master_Host:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.103</span></span><br><span class="line"><span class="attr">         Master_User:</span> <span class="string">repl</span></span><br><span class="line"><span class="attr">         Master_Port:</span> <span class="number">3306</span></span><br><span class="line"><span class="attr">        Connect_Retry:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">       Master_Log_File:</span> <span class="string">mysql-bin.000007</span></span><br><span class="line"><span class="attr">     Read_Master_Log_Pos:</span> <span class="number">120</span></span><br><span class="line"><span class="attr">       Relay_Log_File:</span> <span class="string">mysql-relay-bin.000002</span></span><br><span class="line"><span class="attr">       Relay_Log_Pos:</span> <span class="number">279</span></span><br><span class="line"><span class="attr">   Relay_Master_Log_File:</span> <span class="string">mysql-bin.000007</span></span><br><span class="line"><span class="attr">     Slave_IO_Running:</span> <span class="literal">Yes</span></span><br><span class="line"><span class="attr">     Slave_SQL_Running:</span> <span class="literal">Yes</span></span><br><span class="line"><span class="attr">      Replicate_Do_DB:</span> <span class="string">liting</span></span><br><span class="line"><span class="attr">    Replicate_Ignore_DB:</span> <span class="string">mysql</span></span><br><span class="line">     <span class="string">.............</span></span><br><span class="line"><span class="attr">   Seconds_Behind_Master:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>如上，当IO和SQL线程的状态均为Yes，则表示主从已实现同步了！</p>
<p>下面测试下Mysql主从同步的效果<br>在master主数据库上写入新数据<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use liting;    </span><br><span class="line">mysql&gt;<span class="keyword">create</span> table <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> haha (id int(<span class="number">10</span>) <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> AUTO_INCREMENT,name varchar(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">into</span> huanqiu.haha <span class="keyword">values</span>(<span class="number">100</span>,<span class="string">"anhui"</span>);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>然后在slave数据库上查看，发现master上新写入的数据已经同步过来了<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from liting.haha;</span><br><span class="line"><span class="code">+-----+</span>-----------+</span><br><span class="line">| id   | name    |</span><br><span class="line"><span class="code">+-----+</span>-----------+</span><br><span class="line">| 100 | anhui   |</span><br><span class="line"><span class="code">+-----+</span>-----------+</span><br><span class="line">1 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>至此，主从同步环境已经实现！</p>
<p>注意：<br>Mysql主从环境部署一段时间后，发现主从不同步时，如何进行数据同步至一致？<br>有以下两种做法：<br>1）参考：<a href="http://www.cnblogs.com/kevingrace/p/6261111.html" target="_blank" rel="noopener">mysql主从同步(2)-问题梳理</a> 中的第（4）步的第二种方法<br>2）参考：<a href="http://www.cnblogs.com/kevingrace/p/6261091.html" target="_blank" rel="noopener">mysql主从同步(3)-percona-toolkit工具</a>（数据一致性监测、延迟监控）使用梳理</p>
<h3 id="主主复制实现过程"><a href="#主主复制实现过程" class="headerlink" title="主主复制实现过程"></a>主主复制实现过程</h3><p>根据上面的主从环境部署，master和slave已经实现同步，即在master上写入新数据，自动同步到slave。而从库只能读不能写，一旦从库有写入数据，就会造成主从数据不一致！<br>下面就说下Mysql主主复制环境，在slave上更新数据时，master也能自动同步过来。</p>
<p>温馨提示：</p>
<p>在做主主同步前，提醒下需要特别注意的一个问题：</p>
<p>主主复制和主从复制有一些区别，因为多主中都可以对服务器有写权限，所以设计到自增长重复问题，例如：</p>
<p>出现的问题（多主自增长ID重复）</p>
<p>1）首先在A和B两个库上创建test表结构;</p>
<p>2）停掉A，在B上对数据表test(存在自增长属性的ID字段)执行插入操作，返回插入ID为1;</p>
<p>3）然后停掉B，在A上对数据表test(存在自增长属性的ID字段)执行插入操作，返回的插入ID也是1;</p>
<p>4）然后 同时启动A,B，就会出现主键ID重复</p>
<p>解决方法：</p>
<p>只要保证两台服务器上的数据库里插入的自增长数据不同就可以了<br>如：A插入奇数ID，B插入偶数ID，当然如果服务器多的话，还可以自定义算法，只要不同就可以了<br>在下面例子中，在两台主主服务器上加入参数，以实现奇偶插入！<br>记住:在做主主同步时需要设置自增长的两个相关配置，如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto_increment_offset     表示自增长字段从那个数开始，取值范围是<span class="number">1</span> .. <span class="number">65535</span>。这个就是序号。如果有n台mysql机器，则从第一台开始分为设<span class="number">1</span>，<span class="number">2.</span>..n</span><br><span class="line">auto_increment_increment    表示自增长字段每次递增的量，其默认值是<span class="number">1</span>，取值范围是<span class="number">1</span> .. <span class="number">65535</span>。如果有n台mysql机器，这个值就设置为n。</span><br></pre></td></tr></table></figure></p>
<p>在主主同步配置时，需要将两台服务器的：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto_increment_increment     增长量都配置为<span class="number">2</span></span><br><span class="line">auto_increment_offset        分别配置为<span class="number">1</span>和<span class="number">2</span>。这是序号，第一台从<span class="number">1</span>开始，第二台就是<span class="number">2</span>，以此类推.....</span><br></pre></td></tr></table></figure></p>
<p>这样才可以避免两台服务器同时做更新时自增长字段的值之间发生冲突。（针对的是有自增长属性的字段）</p>
<h4 id="主主同步实现操作过程"><a href="#主主同步实现操作过程" class="headerlink" title="主主同步实现操作过程"></a>主主同步实现操作过程</h4><p>1）在master上的my.cnf配置：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># vim /etc/my.cnf</span></span><br><span class="line"><span class="attr">server-id</span> = <span class="number">1</span>        </span><br><span class="line"><span class="attr">log-bin</span> = mysql-bin  </span><br><span class="line"><span class="attr">binlog-ignore-db</span> = mysql,information_schema</span><br><span class="line"><span class="attr">sync_binlog</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">binlog_checksum</span> = none</span><br><span class="line"><span class="attr">binlog_format</span> = mixed</span><br><span class="line"><span class="attr">auto-increment-increment</span> = <span class="number">2</span>    </span><br><span class="line"><span class="attr">auto-increment-offset</span> = <span class="number">1</span>   </span><br><span class="line"><span class="attr">slave-skip-errors</span> = all     </span><br><span class="line">[root@master ~]<span class="comment"># /etc/init.d/mysql restart</span></span><br><span class="line">Shutting down MySQL. SUCCESS!</span><br><span class="line">Starting MySQL.. SUCCESS!</span><br></pre></td></tr></table></figure></p>
<p>数据同步授权（iptables防火墙开启3306端口，要确保对方机器能使用下面权限连接到本机mysql）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mysql</span>&gt; <span class="selector-tag">grant</span> <span class="selector-tag">replication</span> <span class="selector-tag">slave</span>,<span class="selector-tag">replication</span> <span class="selector-tag">client</span> <span class="selector-tag">on</span> *.* <span class="selector-tag">to</span> <span class="selector-tag">repl</span>@'<span class="keyword">192</span>.<span class="keyword">168</span>.<span class="keyword">0</span>.<span class="keyword">104</span>' identified by <span class="string">"repl123"</span>;</span><br><span class="line"><span class="selector-tag">mysql</span>&gt; <span class="selector-tag">flush</span> <span class="selector-tag">privileges</span>;</span><br></pre></td></tr></table></figure></p>
<p>最好将库锁住，仅仅允许读，以保证数据一致性；待主主同步环境部署后再解锁；锁住后，就不能往表里写数据，但是重启mysql服务后就会自动解锁！<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; FLUSH TABLES WITH READ LOCK;    //注意该参数设置后，如果自己同步对方数据，同步前一定要记得先解锁！</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="code"> </span></span><br><span class="line">mysql&gt; show master status;</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">| File       | Position | Binlog<span class="emphasis">_Do_</span>DB | Binlog<span class="emphasis">_Ignore_</span>DB | Executed<span class="emphasis">_Gtid_</span>Set |</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">| mysql-bin.000001 |   158 |        |         |          |</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>2）slave数据库上<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@slave ~]<span class="comment"># vim /etc/my.cnf</span></span><br><span class="line"><span class="attr">server-id</span> = <span class="number">2</span>       </span><br><span class="line"><span class="attr">log-bin</span> = mysql-bin  </span><br><span class="line"><span class="attr">binlog-ignore-db</span> = mysql,information_schema</span><br><span class="line"><span class="attr">sync_binlog</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">binlog_checksum</span> = none</span><br><span class="line"><span class="attr">binlog_format</span> = mixed</span><br><span class="line"><span class="attr">auto-increment-increment</span> = <span class="number">2</span>    </span><br><span class="line"><span class="attr">auto-increment-offset</span> = <span class="number">2</span>   </span><br><span class="line"><span class="attr">slave-skip-errors</span> = all</span><br><span class="line"> </span><br><span class="line">[root@slave ~]<span class="comment"># /etc/init.d/mysql restart</span></span><br><span class="line">Shutting down MySQL. SUCCESS!</span><br><span class="line">Starting MySQL.. SUCCESS!</span><br></pre></td></tr></table></figure></p>
<p>数据同步授权（iptables防火墙开启3306端口，要确保对方机器能使用下面权限连接到本机mysql）<br>同理，slave也要授权给master机器远程同步数据的权限<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant replication slave ,replication client on <span class="strong">*.*</span> to repl@<span class="emphasis">'192.168.0.103'</span> identified by "repl123";  </span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line"><span class="code"> </span></span><br><span class="line">mysql&gt; FLUSH TABLES WITH READ LOCK;</span><br><span class="line">mysql&gt; show master status;</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">| File       | Position | Binlog<span class="emphasis">_Do_</span>DB | Binlog<span class="emphasis">_Ignore_</span>DB | Executed<span class="emphasis">_Gtid_</span>Set |</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">| mysql-bin.000001 |   256 |       |          |          |</span><br><span class="line"><span class="code">+------------------+</span>----------<span class="code">+--------------+</span>------------------<span class="code">+-------------------+</span></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>3）执行主张同步操作</p>
<p>先在slave数据库上做同步master的设置。（确保slave上要同步的数据，提前在master上存在。最好双方数据保持一致）<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">unlock</span> <span class="string">tables;</span>     <span class="string">//先解锁，将对方数据同步到自己的数据库中</span></span><br><span class="line"><span class="string">mysql&gt;</span> <span class="string">slave</span> <span class="string">stop；</span></span><br><span class="line"><span class="string">mysql&gt;</span> <span class="string">change</span> <span class="string">master</span> <span class="string">to</span> <span class="string">master_host='192.168.0.103',master_user='repl',master_password='repl123',master_log_file='master-bin.000001',master_log_pos=158;</span></span><br><span class="line"> </span><br><span class="line"><span class="string">mysql&gt;</span> <span class="string">start</span> <span class="string">slave;</span></span><br><span class="line"><span class="string">mysql&gt;</span> <span class="string">show</span> <span class="string">slave</span> <span class="string">status</span> <span class="string">\G;</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">             Slave_IO_State:</span> <span class="string">Waiting</span> <span class="string">for</span> <span class="string">master</span> <span class="string">to</span> <span class="string">send</span> <span class="string">event</span></span><br><span class="line"><span class="attr">              Master_Host:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.103</span></span><br><span class="line"><span class="attr">              Master_User:</span> <span class="string">repl</span></span><br><span class="line"><span class="attr">              Master_Port:</span> <span class="number">3306</span></span><br><span class="line"><span class="attr">             Connect_Retry:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">            Master_Log_File:</span> <span class="string">mysql-bin.000001</span></span><br><span class="line"><span class="attr">          Read_Master_Log_Pos:</span> <span class="number">158</span></span><br><span class="line"><span class="attr">           nelay_Log_File:</span> <span class="string">mysql-relay-bin.000003</span></span><br><span class="line"><span class="attr">             Relay_Log_Pos:</span> <span class="number">750</span></span><br><span class="line"><span class="attr">        Relay_Master_Log_File:</span> <span class="string">mysql-bin.000001</span></span><br><span class="line"><span class="attr">            Slave_IO_Running:</span> <span class="literal">Yes</span></span><br><span class="line"><span class="attr">            Slave_SQL_Running:</span> <span class="literal">Yes</span></span><br><span class="line">            <span class="string">..................</span></span><br></pre></td></tr></table></figure></p>
<p>这样就实现了slave－&gt;master的同步环境。</p>
<p>再在master数据库上做同步slave的设置。（确保slave上要同步的数据，提前在master上存在。最好双方数据保持一致）<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; unlock tables;</span><br><span class="line">mysql&gt; slave stop；</span><br><span class="line">mysql&gt; change master <span class="keyword">to</span> <span class="attribute">master_host</span>=<span class="string">'192.168.0.104'</span>,master_user='repl',master_password='repl123',master_log_file='master-bin.000001',master_log_pos=256;</span><br><span class="line"> </span><br><span class="line">mysql&gt; start slave;</span><br><span class="line">mysql&gt; show slave status \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Slave_IO_State: Waiting <span class="keyword">for</span> master <span class="keyword">to</span> send event</span><br><span class="line">             Master_Host: 192.168.0.103</span><br><span class="line">             Master_User: repl</span><br><span class="line">             Master_Port: 3306</span><br><span class="line">            Connect_Retry: 60</span><br><span class="line">           Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 256</span><br><span class="line">           Relay_Log_File: mysql-relay-bin.000003</span><br><span class="line">           Relay_Log_Pos: 750</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">            Slave_IO_Running: <span class="literal">Yes</span></span><br><span class="line">            Slave_SQL_Running: <span class="literal">Yes</span></span><br><span class="line">            <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure></p>
<p>这样就实现了master－&gt;slave的同步环境。至此，主主双向同步环境已经实现！</p>
<h4 id="最后测试下Mysql主主同步的效果"><a href="#最后测试下Mysql主主同步的效果" class="headerlink" title="最后测试下Mysql主主同步的效果"></a>最后测试下Mysql主主同步的效果</h4><p>在master上写入新数据<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from liting.haha;</span><br><span class="line"><span class="code">+-----+</span>-----------+</span><br><span class="line">| id   | name    |</span><br><span class="line"><span class="code">+-----+</span>-----------+</span><br><span class="line">| 100 | anhui   |</span><br><span class="line"><span class="code">+-----+</span>-----------+</span><br><span class="line">1 rows in set (0.00 sec)</span><br><span class="line"><span class="code"> </span></span><br><span class="line">mysql&gt; insert into huanqiu.haha values(10,"beijing");</span><br></pre></td></tr></table></figure></p>
<p>在slave数据库中查看，发现master新写入的数据已经同步过来了<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from liting.haha;</span><br><span class="line"><span class="code">+-----+</span>------------+</span><br><span class="line">| id  | name    |</span><br><span class="line"><span class="code">+-----+</span>------------+</span><br><span class="line">|  10| beijing  |</span><br><span class="line">| 100 | anhui   |</span><br><span class="line"><span class="code">+-----+</span>------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>在slave上删除数据<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">delete</span> <span class="keyword">from</span> liting.haha <span class="keyword">where</span> id=<span class="number">100</span>;</span><br></pre></td></tr></table></figure></p>
<p>在master数据库中查看<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from liting.haha;</span><br><span class="line"><span class="code">+-----+</span>------------+</span><br><span class="line">| id  | name    |</span><br><span class="line"><span class="code">+-----+</span>------------+</span><br><span class="line">|  10 | beijing  |</span><br><span class="line"><span class="code">+-----+</span>------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>以上，主主同步实现</p>
<h3 id="binlog，redo-log，undo-log区别"><a href="#binlog，redo-log，undo-log区别" class="headerlink" title="binlog，redo log，undo log区别"></a>binlog，redo log，undo log区别</h3><ol>
<li><p>binlog是MySQL Server层记录的日志， redo log是InnoDB存储引擎层的日志。 两者都是记录了某些操作的日志(不是所有)自然有些重复（但两者记录的格式不同）。</p>
</li>
<li><p>选择binlog日志作为replication我想主要原因是MySQL的特点就是支持多存储引擎，为了兼容绝大部分引擎来支持复制这个特性，那么自然要采用MySQL Server自己记录的日志而不是仅仅针对InnoDB的redo log，因为如果采用了InnoDB redo log复制，那么其他引擎也想复制，此时改怎么办呢？对吧</p>
</li>
</ol>
<p>binlog属于逻辑日志，是逻辑操作。innodb redo属于物理日志，是物理变更。<br>逻辑日志有个缺点是难以并行，而物理日志可以比较好的并行操作，所以redo复制还是有优势的，也许5.7能搞出来。</p>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>binlog日志用于记录所有更新且提交了数据或者已经潜在更新提交了数据（例如，没有匹配任何行的一个DELETE）的所有语句。语句以“事件”的形式保存，它描述数据更改。</p>
<p>binlog作用</p>
<p>1.恢复使能够最大可能地更新数据库，因为二进制日志包含备份后进行的所有更新。<br>2.在主复制服务器上记录所有将发送给从服务器的语句。 </p>
<p>binlog 主要参数</p>
<p><code>log_bin</code><br>设置此参数表示启用binlog功能，并指定路径名称</p>
<p><code>innodb_flush_log_at_trx_commit = N</code>：</p>
<p>N=0  – 每隔一秒，把事务日志缓存区的数据写到日志文件中，以及把日志文件的数据刷新到磁盘上；</p>
<p>N=1  – 每个事务提交时候，把事务日志从缓存区写到日志文件中，并且刷新日志文件的数据到磁盘上；</p>
<p>N=2  – 每事务提交的时候，把事务日志数据从缓存区写到日志文件中；每隔一秒，刷新一次日志文件，但不一定刷新到磁盘上，而是取决于操作系统的调度；</p>
<p><code>sync_binlog =  N</code>：</p>
<p>N&gt;0  — 每向二进制日志文件写入N条SQL或N个事务后，则把二进制日志文件的数据刷新到磁盘上；</p>
<p>N=0  — 不主动刷新二进制日志文件的数据到磁盘上，而是由操作系统决定；</p>
<p>推荐配置组合：</p>
<p>N=1,1  — 适合数据安全性要求非常高，而且磁盘IO写能力足够支持业务，比如充值消费系统；</p>
<p>N=1,0  — 适合数据安全性要求高，磁盘IO写能力支持业务不富余，允许备库落后或无复制；</p>
<p>N=2,0或2,<code>m(0&lt;m&lt;100)</code> — 适合数据安全性有要求，允许丢失一点事务日志，复制架构的延迟也能接受；</p>
<p>N=0,0  — 磁盘IO写能力有限，无复制或允许复制延迟稍微长点能接受，例如：日志性登记业务；</p>
<h4 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h4><p>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用UndoLog来实现多版本并发控制(简称：MVCC)。</p>
<h5 id="事务的原子性-Atomicity"><a href="#事务的原子性-Atomicity" class="headerlink" title="事务的原子性(Atomicity)"></a>事务的原子性(Atomicity)</h5><pre><code>- 事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。
</code></pre><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLo）。<br>然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用UndoLog中的备份将数据恢复到事务开始之前的状态。<br>除了可以保证事务的原子性，Undo Log也可以用来辅助完成事务的持久化。</p>
<h5 id="事务的持久性-Durability"><a href="#事务的持久性-Durability" class="headerlink" title="事务的持久性(Durability)"></a>事务的持久性(Durability)</h5><p>事务一旦完成，该事务对数据库所做的所有修改都会持久的保存到数据库中。为了保证持久性，数据库系统会将修改后的数据完全的记录到持久的存储上。</p>
<h5 id="用Undo-Log"><a href="#用Undo-Log" class="headerlink" title="用Undo Log"></a>用Undo Log</h5><p>实现原子性和持久化的事务的简化过程</p>
<p>假设有A、B两个数据，值分别为1,2。<br>A.事务开始.</p>
<p>B.记录A=1到undolog.</p>
<p>C.修改A=3.</p>
<p>D.记录B=2到undolog.</p>
<p>E.修改B=4.</p>
<p>F.将undolog写到磁盘。</p>
<p>G.将数据写到磁盘。</p>
<p>H.事务提交</p>
<p>这里有一个隐含的前提条件：‘数据都是先读到内存中，然后修改内存中的数据，最后将数据写回磁盘’。</p>
<p>之所以能同时保证原子性和持久化，是因为以下特点：</p>
<p>A.更新数据前记录Undo log。</p>
<p>B.为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。</p>
<p>C.Undo log<br>必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的，可以用来回滚事务。</p>
<p>D.如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。</p>
<p>缺陷：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即</p>
<h4 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h4><p>记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，<br>但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。</p>
<p>-Undo+Redo<br>事务的简化过程</p>
<p>假设有A、B两个数据，值分别为1,2.</p>
<p>A.事务开始.</p>
<p>B.记录A=1到undolog.</p>
<p>C.修改A=3.</p>
<p>D.记录A=3到redolog.</p>
<p>E.记录B=2到undolog.</p>
<p>F.修改B=4.</p>
<p>G.记录B=4到redolog.</p>
<p>H.将redolog写入磁盘。</p>
<p>I.事务提交</p>
<p>-Undo+Redo<br>事务的特点</p>
<p>A.为了保证持久性，必须在事务提交前将<br>RedoLog持久化。</p>
<p>B.数据不需要在事务提交前写入磁盘，而是缓存在内存中。</p>
<p>C.RedoLog保证事务的持久性。</p>
<p>D.UndoLog保证事务的原子性。</p>
<p>E.有一个隐含的特点，数据必须要晚于redolog写入持久存</p>
<h2 id="mysql有哪些索引类型？有哪些存储引擎？有什么区别"><a href="#mysql有哪些索引类型？有哪些存储引擎？有什么区别" class="headerlink" title="mysql有哪些索引类型？有哪些存储引擎？有什么区别"></a>mysql有哪些索引类型？有哪些存储引擎？有什么区别</h2><ul>
<li>索引类型<ul>
<li>FULLTEXT：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%”这类针对文本的模糊查询效率较低的问题。</li>
<li>HASH：由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</li>
<li>BTREE：BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。</li>
<li>RTREE：RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，RTREE的优势在于范围查找。</li>
</ul>
</li>
<li>索引种类：<ul>
<li>普通索引：仅加速查询。</li>
<li>唯一索引：加速查询 + 列值唯一（可以有null）</li>
<li>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</li>
<li>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li>
<li>全文索引：对文本的内容进行分词，进行搜索</li>
</ul>
</li>
<li>存储引擎<ul>
<li>InnoDB<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1343758042_8526.png" alt="image"><ul>
<li>InnoDB 也采用 B+Tree这种数据结构来实现 B-Tree索引。而很大的区别在于，InnoDB 存储引擎采用“聚集索引”的数据存储方式实现B-Tree索引，所谓“聚集”，就是指数据行和相邻的键值紧凑地存储在一起，注意 InnoDB 只能聚集一个叶子页（16K）的记录（即聚集索引满足一定的范围的记录），因此包含相邻键值的记录可能会相距甚远。</li>
<li>当InnoDB做全表扫描时并不高效，因为 InnoDB 实际上并没有顺序读取,在大多情况下是在随机读取。做全表扫描时,InnoDB 会按主键顺序扫描页面和行。这应用于所有的InnoDB 表，包括碎片化的表。如果主键页表没有碎片（存储主键和行的页表),全表扫描是相当快，因为读取顺序接近物理存储顺序。但是当主键页有碎片时，该扫描就会变得十分缓慢</li>
<li>遵循ACID原则(atomicity原子性，consistency一致性，isolation隔离性，durability持久性)，具有事务特性的能力：commit，rollback，crash-recovery。<ul>
<li>仅InnoDB和NDB(Network DB clustered database engine)支持事务和MVCC</li>
</ul>
</li>
<li>行级锁和Oracle风格的读一致性，提高多用户下的并发度和性能，提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”。<ul>
<li>只有通过索引条件检索数据，InnoDB才使用行级锁，否则仍然使用表锁</li>
<li>读一致性：query时使用snapshot快照，允许其他事务进行修改，之后再根据undo log调整数据</li>
<li>默认的隔离级别是可重复读，即同一个事务中多次读取，数据相同</li>
</ul>
</li>
<li>使用主键优化查询，主键索引是聚集索引(Clustered index，仅InnoDB支持)，使查询主键时的I/O最小化<ul>
<li>聚集索引是指整个表是按照这个索引来组织的，物理存储顺序与索引顺序相同，所以聚集索引字段的修改需要很大开销</li>
<li>InnoDB聚集索引的实现方式，同时也体现了一张 innoDB表的结构，可以看到，InnoDB 中，主键索引和数据是一体的，没有分开。</li>
</ul>
</li>
<li>支持外码约束</li>
<li>崩溃后能很好地恢复<ul>
<li>未完成的事务将根据redo log的数据重做</li>
<li>已提交但未写入的修改，将从doublewrite buffer重做</li>
<li>系统闲时会purge buffer</li>
</ul>
</li>
<li>维护一个内存中的buffer pool缓冲池，数据被访问时，表和索引数据会被缓存</li>
<li>对增删改的change buffering策略，如果被修改数据的页不在缓冲池中，则这个修改可以存在change buffer中，等相应页被放进缓冲池(发生对该页的访问)时，再写入修改，称为merge</li>
<li>adaptive hash index，经常被访问的页会自动在内存建立一个哈希索引，适于=和IN的查询。buffer pool中会预留这种索引需要的内存空间。建立在已有的B树索引基础上，哈希索引可以是部分的，B树索引不需要全部缓存在缓冲池中</li>
<li>使用checksum校验和机制检测内存或硬盘的损坏</li>
<li>InnoDB是为处理巨大数据量的最大性能设计</li>
<li>可以在一个查询中join混用InnoDB引擎的表和其他引擎的表</li>
</ul>
</li>
<li>MyISAM<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1343757655_1008.png" alt="image"><ul>
<li>适用场景：read-only or read-mostly workloads in Web and data warehousing configurations(查询效率很高，适合大量读操作的场景)</li>
<li>每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。MyISAM索引文件【.MYI (MYIndex)】和数据文件【.MYD (MYData)】是分离的，索引文件仅保存记录所在页的指针（物理位置），通过这些地址来读取页，进而读取被索引的行</li>
<li>MyISAM 默认会把索引读入内存，直接在内存中操作</li>
<li>Innodb强调多功能性，支持的拓展功能比较多，myisam主要侧重于性能</li>
<li>将创建3个文件，一个.frm文件，一个.MYD(MYData)文件存数据，一个.MYI(MYIndex)文件存索引</li>
<li>数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>所有数据值都按小字节(low byte first)存储，因此独立于操作系统(可移植性)。但没有明显降低速度，只是需要多处理一下对齐问题，况且获取列值所花的时间不是最主要的</li>
<li>所有数字键都按大字节(high byte first)存储，利于压缩</li>
<li>BLOB和TEXT列可以创建索引</li>
<li>每一个character列可以使用不同的字符编码</li>
<li>会保存表的具体行数</li>
<li>使用B树索引，string索引会被压缩，当string是索引第一项时还会压缩前缀</li>
<li>支持真正的变长字段varchar</li>
<li>支持并发的insert</li>
</ul>
</li>
<li>区别<ul>
<li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li>
<li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li>
</ul>
</li>
<li>如何选择<ul>
<li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li>
<li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li>
</ul>
</li>
<li>ARCHIVE<ul>
<li>适用场景：作为仓库，存储大量的独立的作为历史记录的数据(插入速度快但查询支持较差）</li>
<li>不支持索引</li>
<li>没有存储大小限制(InnoDB是64TB)</li>
<li>能很好地压缩数据</li>
<li>使用行级锁</li>
<li>支持INSERT, REPLACE, SELECT, 不支持 DELETE, UPDATE</li>
<li>使用zlib 无损数据压缩。数据insert后即被压缩，放在一个压缩缓冲区中，select操作会导致清空缓冲区，此时数据被真正存储。支持批处理insert。</li>
<li>行会根据需要解压，不设缓冲。select会导致全表扫描。select是读一致性的。大量查询during insertion会影响压缩。使用REPAIR TABLE或OPTIMIZE TABLE能获取更好的压缩。</li>
</ul>
</li>
<li>BLACKHOLE<ul>
<li>适用场景:转发器（会保存SQL语句的日志，并且复制给slave servers）</li>
<li>过滤器（设置使用黑洞引擎的“dummy” slave进程，依据一定规则将master的日志进行过滤并在BLACKHOLE表写一个新的日志，再复制给slaves，这样只会导致很少的开销）</li>
<li>像黑洞一样接受数据但不存储</li>
<li>创建table A会生成一个A.frm表文件，没有其他文件</li>
<li>支持所有索引</li>
<li>会保存SQL语句的日志，并且复制给slave servers，适合做转发器或过滤器</li>
<li>会导致错误，因为不论log文件是row-based还是statement-based，blackhole表不会存储自增列的数据，所以在slaves上insert时会出现重复的主码错误</li>
<li>使用row-based replication时，如果slaves的表的字段比master少，那么过滤机制其实是在slaves上。如果缺失字段是私密的，不能给slaves获取的；或是有很多slaves，需要在发送数据前就把数据过滤掉以减少网络负载，就不适合这种方式。BLACKHOLE表就能实现在master上进行过滤。</li>
</ul>
</li>
<li>MRG_MYISAM<ul>
<li>适用场景：Good for VLDB environments such as data warehousing</li>
<li>要求多个Mylsam表要有相同的列信息(包括顺序)和索引信息(包括索引的order)</li>
<li>这些信息不同不会影响表合并<ul>
<li>列名和索引名</li>
<li>所有的备注comment</li>
<li>表的选项，例如 <code>AVG_ROW_LENGTH</code>, <code>MAX_ROWS</code>, or <code>PACK_KEYS</code></li>
</ul>
</li>
<li>创建merge表时会创建2个文件，一个是存数据的.frm文件，一个是.mrg文件(存储哪些表应当merge起来使用)</li>
<li>merge表中的表可以存于不同的数据库中</li>
<li>支持merge表的增删改查，前提是必须拥有处理其中所有表的权限</li>
<li>drop table只是删除了merge表，实际存储数据的表不会被删除</li>
<li>建表需要指定UNION=(list-of-tables)表明使用哪些表，以及INSERT_METHOD=LAST/FIRST表明在哪一个表中插入数据，否则无法执行insert操作</li>
<li>merge表没有主键，因为不能强制实行唯一索引</li>
</ul>
</li>
<li>FEDERATED<ul>
<li>适用场景：Very good for distributed or data mart environments</li>
<li>数据不存储在本地，而是在远程数据库，本地访问时会pull远程数据库的数据</li>
<li>远程数据库的表可以是任何存储引擎的表</li>
<li>本地表和远程表应有相同的定义</li>
<li>本地用.frm文件存储表定义，并且包含一个指向远程数据库的连接字符串</li>
<li>本地执行操作时，会发送给远程去执行，使用MySQL client API</li>
<li>远程表可以是一个FEDERATED表，但注意不要造成一个循环</li>
<li>FEDERATED表不支持一般意义上的索引，要远程表上有索引才有效</li>
<li>如果一个查询语句不能使用远程表的索引，会导致全表扫描，本地数据库会获取全表数据（存在本地内存中，如果数据量过大会引起交换和挂起），再在本地进行过滤</li>
<li>不支持alter table或drop table，执行drop table只会删除本地FEDERATED表</li>
<li>不支持分区</li>
<li>如果远程表改变，本地表无法获知</li>
</ul>
</li>
<li>PERFORMANCE_SCHEMA<ul>
<li>关注收集mysql server运行中的性能数据，会监视server的所有events</li>
<li>performance_schema数据库名及其表名都是小写的，查询时要用小写</li>
<li>很多表都是只读的，对数据库所有表的GRANT ALL授权是不允许的</li>
<li>数据库中表的更改不会写在日志中</li>
<li>是完全in-memory的，不占用磁盘空间，mysql服务启动时表会被重新填充，关闭服务时便丢弃</li>
<li>数据收集的实现是在源码中添加”监控点”(instrumentation)，没有用额外的线程(不像”复制”或”事件调度”)</li>
<li>用户不能创建存储该类型的表</li>
</ul>
</li>
<li>MEMORY<ul>
<li>适用场景：存储临时、不重要的数据，例如作为缓存，适合大量读的情形 (limited updates)</li>
<li>不支持变长的数据类型variable-length data types (including BLOB and TEXT)</li>
<li>不支持外码约束</li>
<li>不支持压缩</li>
<li>不支持MVCC</li>
<li>支持哈希索引和B树索引，不支持全文索引和T树索引</li>
<li>mysql服务关闭或重启，数据会消失(表还在)</li>
<li>数据量不能超过内存大小</li>
<li>性能限制<ul>
<li>单线程执行</li>
<li>表更新用表级锁(高并发读写情形下，表级锁严重降低性能，还不如InnoDB快)</li>
</ul>
</li>
<li>内置的临时表(也在内存中)太大时会自动转成磁盘存储，但用户自创的内存表永远不会转化</li>
<li>可以从persistent data source装载数据到内存表</li>
<li>被删除的row会放进一个链表(不会回收内存)，等插入新数据时拿出来复用，只有整个表被删除后才会回收内存。采用定长的行存储，即使是varchar也是定长存储的。</li>
<li>默认使用哈希索引，并且允许非唯一的哈希索引(但如果字段含大量重复值，性能会很低，这种情况最好用B树索引)，被索引字段可以有NULL。</li>
</ul>
</li>
<li>CSV<ul>
<li>创建一个csv表，除了.frm文件外，还创建一个.csv文件用于存储数据，还有一个.csm文件存储表状态、行数等信息，称为metafile</li>
<li>所有字段都必须NOT NULL</li>
<li>不支持索引、分区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="对索引的理解，组合索引，索引的最佳实践"><a href="#对索引的理解，组合索引，索引的最佳实践" class="headerlink" title="对索引的理解，组合索引，索引的最佳实践"></a>对索引的理解，组合索引，索引的最佳实践</h2><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul>
<li>B-Tree 索引：MySQL 中最主要的索引；</li>
<li>RTREE 索引：仅仅是 MyISAM，GIS；</li>
<li>哈希索引：MyISAM，5.6 开始的 Innodb。</li>
</ul>
<h3 id="BTREE-索引能做什么？"><a href="#BTREE-索引能做什么？" class="headerlink" title="BTREE 索引能做什么？"></a>BTREE 索引能做什么？</h3><ul>
<li>直接查看 KEY=5 的所有列；</li>
<li>找到 KEY &gt; 5 的列，范围查找；</li>
<li>查找 5&lt;KEY&lt;10 之间的所有列，封闭范围查找；</li>
<li>不能找到 KEY 的最后一个数字是 0 的列（这个不是范围查找）。</li>
</ul>
<h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><ul>
<li>字符串索引实际上也没什么不同，按照字典顺序排列，例如 ”AAAA” &lt; “AAAB”;</li>
<li>like 前缀是一个特殊排序，例如 LIKE “ABC%” 意味着 “ABC[LOWEST]”&lt;KEY&lt;“ABC[HIGHEST]”，但是 LIKE “%ABC” 不走索引。</li>
</ul>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><ul>
<li>按照定义的顺序从左往右进行比较，例如在 KEY(col1,col2,col3) 中，(1,2,3) &lt; (1,3,1)；</li>
<li>多列索引仍然是一个 BTREE 索引，但不是每列都是一个单独的 BTREE。</li>
</ul>
<h3 id="MySQL-怎么使用索引"><a href="#MySQL-怎么使用索引" class="headerlink" title="MySQL 怎么使用索引"></a>MySQL 怎么使用索引</h3><h4 id="在数据查询中使用索引"><a href="#在数据查询中使用索引" class="headerlink" title="在数据查询中使用索引"></a>在数据查询中使用索引</h4><p>用了索引 LAST_NAME<br><code>SELECT * FROM EMPLOYEES WHERE LAST_NAME=“Smith”;</code></p>
<p>用了索引 (DEPT,LAST_NAME)</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * <span class="keyword">FROM</span> EMPLOYEES WHERE</span><br><span class="line"> <span class="attribute">LAST_NAME</span>=“Smith” <span class="keyword">AND</span></span><br><span class="line"> <span class="attribute">DEPT</span>=“Accounting”</span><br></pre></td></tr></table></figure>
<p>这里虽然索引字段顺序和查询的顺序颠倒，依然会走索引，不是因为最左匹配不走索引。</p>
<p>多列索引会变的困难，对于索引 (A,B,C)：</p>
<ul>
<li>下面的条件会走索引:<ul>
<li>A&gt;5</li>
<li>A=5 AND B&gt;6</li>
<li>A=5 AND B=6 AND C=7</li>
<li>A=5 AND B IN (2,3) AND C&gt;5</li>
<li>下面的条件不走索引，因为不符合最左匹配，缺少第一列</li>
<li>B &gt; 5</li>
<li>B = 6 AND C = 7</li>
</ul>
</li>
</ul>
<blockquote>
<p>在 MySQL5.7 中使用 explain 执行了一下，发现还是会走索引的，估计 MySQL 底层做了什么优化？</p>
</blockquote>
<ul>
<li>下面条件会走部分索引<ul>
<li>A&gt;5 AND B=2</li>
<li>A=5 AND B&gt;6 AND C=2</li>
</ul>
</li>
</ul>
<p>SQL 优化的第一原则：</p>
<p>MySQL 在多列索引中，一遇到 （&lt;,&gt;,between）就会停止使用 key，然而能继续使用 key 直到 in 范围的右边。</p>
<h4 id="在排序中使用索引"><a href="#在排序中使用索引" class="headerlink" title="在排序中使用索引"></a>在排序中使用索引</h4><p>排序</p>
<p><code>SELECT * FROM PLAYERS ORDER BY SCORE DESC LIMIT 10</code></p>
<ul>
<li>该 SQL 会使用建立在 SCORE 列上的 索引；</li>
<li>如果排序的时候没有使用索引，将会导致非常耗时的文件排序；</li>
<li>在排序中经常会考虑组合索引， 例如下面的 SQL 可以考虑(COUNTRY,SCORE) 索引：</li>
</ul>
<p><code>SELECT * FROM PLAYERS WHERE COUNTRY=“US” ORDER BY   SCORE DESC LIMIT 10</code><br>使用多列索引进行高效的排序，在排序中使用索引有很多的限制，对于 KEY(A，B）:</p>
<ul>
<li>下面排序会使用索引：<ul>
<li>ORDER BY A：主列索引；</li>
<li>A=5 ORDER BY B：通过第一列过滤数据，第二列进行排序；</li>
<li>ORDER BY A DESC, B DESC：用相同的排序进行排序；</li>
<li>A&gt;5 ORDER BY A：主列上进行查询和排序</li>
</ul>
</li>
<li>下面的语句不会使用索引：<ul>
<li>ORDER BY B ：非主列索引排序；</li>
<li>A&gt;5 ORDER BY B：第一列上使用范围，第二列进行排序；</li>
<li>A IN(1,2) ORDER BY B：第一列上用 IN；</li>
<li>ORDER BY A ASC, B DESC：两列的排列顺序不同。</li>
</ul>
</li>
</ul>
<p>使用索引进行排序的规则</p>
<ul>
<li>两列的排列顺序不能不一致；</li>
<li>非排序的列中索引部分只能用 =，in 也不能用。</li>
</ul>
<h4 id="表中存在多个索引"><a href="#表中存在多个索引" class="headerlink" title="表中存在多个索引"></a>表中存在多个索引</h4><ul>
<li>MySQL 中可以存在多个索引：会有索引合并；</li>
<li>SELECT * FROM TBL WHERE A=5 AND B=6：该语句能分别使用在 A 和 B 上的索引，但是在 （A,B) 上建立索引是更好的；</li>
<li>SELECT * FROM TBL WHERE A=5 OR B=6：该语句使用两个独立的索引，但不会使用在（A,B) 上建立的索引</li>
</ul>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>可以在索引最左边一列上建立前缀索引：</p>
<ul>
<li>ALTER TABLE TITLE ADD KEY(TITLE(20));</li>
<li>需要在 BLOB/TEXT 上建立索引；</li>
<li>能显著的提升效率；</li>
<li>不能被用作覆盖索引；</li>
<li>选择合适的前缀长度是一个问题。</li>
</ul>
<h2 id="Explain命令详解"><a href="#Explain命令详解" class="headerlink" title="Explain命令详解"></a>Explain命令详解</h2><p><strong> EXPLAIN 输出格式</strong></p>
<p>EXPLAIN 命令的输出内容大致如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: <span class="literal">NULL</span></span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>各列的含义如下:</p>
<ul>
<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>
<li>select_type: SELECT 查询的类型.</li>
<li>table: 查询的是哪个表</li>
<li>partitions: 匹配的分区</li>
<li>type: join 类型</li>
<li>possible_keys: 此次查询中可能选用的索引</li>
<li>key: 此次查询中确切使用到的索引.</li>
<li>ref: 哪个字段或常数与 key 一起被使用</li>
<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>
<li>filtered: 表示此查询条件所过滤的数据的百分比</li>
<li>extra: 额外的信息</li>
</ul>
<p>接下来我们来重点看一下比较重要的几个字段.</p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>select_type 表示了查询的类型, 它的常用取值有:</p>
<ul>
<li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li>
<li>PRIMARY, 表示此查询是最外层的查询</li>
<li>UNION, 表示此查询是 UNION 的第二或随后的查询</li>
<li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li>
<li>UNION RESULT, UNION 的结果</li>
<li>SUBQUERY, 子查询中的第一个 SELECT</li>
<li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li>
</ul>
<p>最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型, 例如:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: <span class="literal">NULL</span></span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    -&gt; UNION</span><br><span class="line">    -&gt; (SELECT * FROM user_info WHERE id IN (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line">| <span class="type">id</span> | <span class="type">select_type</span>  | <span class="type">table</span>      | <span class="type">partitions</span> | <span class="type">type</span>  | <span class="type">possible_keys</span> | <span class="type">key</span>     | <span class="type">key_len</span> | <span class="type">ref</span>  | <span class="type">rows</span> | <span class="type">filtered</span> | <span class="type">Extra</span>           |<span class="type"></span></span><br><span class="line"><span class="type">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="type">|  1</span> | <span class="type">PRIMARY</span>      | <span class="type">user_info</span>  | <span class="type">NULL</span>       | <span class="type">range</span> | <span class="type">PRIMARY</span>       | <span class="type">PRIMARY</span> | <span class="type">8</span>       | <span class="type">NULL</span> |    <span class="type">3</span> |   <span class="type">100</span><span class="number">.00</span> | <span class="type">Using</span> <span class="keyword">where</span>     |<span class="type"></span></span><br><span class="line"><span class="type">|  2</span> | <span class="type">UNION</span>        | <span class="type">user_info</span>  | <span class="type">NULL</span>       | <span class="type">range</span> | <span class="type">PRIMARY</span>       | <span class="type">PRIMARY</span> | <span class="type">8</span>       | <span class="type">NULL</span> |    <span class="type">3</span> |   <span class="type">100</span><span class="number">.00</span> | <span class="type">Using</span> <span class="keyword">where</span>     |<span class="type"></span></span><br><span class="line"><span class="type">| NULL</span> | <span class="type">UNION</span> RESULT | <span class="type">&lt;union1</span>,<span class="number">2</span>&gt; | <span class="type">NULL</span>       | <span class="type">ALL</span>   | <span class="type">NULL</span>          | <span class="type">NULL</span>    | <span class="type">NULL</span>    | <span class="type">NULL</span> | <span class="type">NULL</span> |     <span class="type">NULL</span> | <span class="type">Using</span> temporary |<span class="type"></span></span><br><span class="line"><span class="type">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="type">3</span> rows <span class="built_in">in</span> <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示查询涉及的表或衍生表</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.</p>
<h4 id="type-常用类型"><a href="#type-常用类型" class="headerlink" title="type 常用类型"></a>type 常用类型</h4><p>type 常用的取值有:</p>
<ul>
<li>system: 表中只有一条数据. 这个类型是特殊的 const 类型.</li>
<li>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.</li>
<li><p>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: <span class="literal">NULL</span></span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">user_info,</span> <span class="string">order_info</span> <span class="string">WHERE</span> <span class="string">user_info.id</span> <span class="string">=</span> <span class="string">order_info.user_id\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">314</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">where;</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">2.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">eq_ref</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">test.order_info.user_id</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="number">2</span> <span class="string">rows</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.<br>例如下面这个例子中, 就使用到了 ref 类型的查询:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">user_info,</span> <span class="string">order_info</span> <span class="string">WHERE</span> <span class="string">user_info.id</span> <span class="string">=</span> <span class="string">order_info.user_id</span> <span class="string">AND</span> <span class="string">order_info.user_id</span> <span class="string">=</span> <span class="number">5</span><span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">const</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">const</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">2.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">ref</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">const</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">2</span> <span class="string">rows</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.01</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.</p>
</li>
</ul>
<p>例如下面的例子就是一个范围查询:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT *</span><br><span class="line">    -&gt;         <span class="keyword">FROM</span> user_info</span><br><span class="line">    -&gt;         WHERE id BETWEEN 2 <span class="keyword">AND</span> 8 \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: range</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: <span class="literal">NULL</span></span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.</li>
</ul>
<p>例如:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">name</span> <span class="string">FROM</span>  <span class="string">user_info</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">name_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">152</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure></p>
<p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.</p>
<ul>
<li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">age</span> <span class="string">FROM</span>  <span class="string">user_info</span> <span class="string">WHERE</span> <span class="string">age</span> <span class="string">=</span> <span class="number">20</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">ALL</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">10.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">where</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure>
<p><strong>type 类型的性能比较</strong></p>
<p>通常来说, 不同的 type 类型的性能关系如下:<br><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><br>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p>
<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><code>possible_keys</code> 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p>
<ul>
<li>字符串<ul>
<li>char(n): n 字节长度</li>
<li>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.</li>
</ul>
</li>
<li>数值类型:<ul>
<li>TINYINT: 1字节</li>
<li>SMALLINT: 2字节</li>
<li>MEDIUMINT: 3字节</li>
<li>INT: 4字节</li>
<li>BIGINT: 8字节 </li>
</ul>
</li>
<li>时间类型<ul>
<li>DATE: 3字节</li>
<li>TIMESTAMP: 4字节</li>
<li>DATETIME: 8字节</li>
</ul>
</li>
</ul>
<p>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p>
<p>我们来举两个简单的栗子:<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order_info <span class="keyword">WHERE</span> user_id &lt; <span class="number">3</span> <span class="keyword">AND</span> product_name = <span class="string">'p1'</span> <span class="keyword">AND</span> productor = <span class="string">'WHH'</span> \G</span><br><span class="line">*************************** <span class="number">1.</span> row ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         <span class="built_in">type</span>: range</span><br><span class="line">possible_keys: user_product_detail_index</span><br><span class="line">          <span class="keyword">key</span>: user_product_detail_index</span><br><span class="line">      key_len: <span class="number">9</span></span><br><span class="line">          ref: <span class="literal">NULL</span></span><br><span class="line">         rows: <span class="number">5</span></span><br><span class="line">     filtered: <span class="number">11.11</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span>; Using <span class="keyword">index</span></span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>上面的例子是从表 <code>order_info</code>中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 <code>order_info</code> 有一个联合索引:<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure></p>
<p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39;</code> 中, 因为先进行 <code>user_id</code> 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 <code>user_id</code>, 因此在 EXPLAIN 中, 显示的 <code>key_len</code> 为 9. 因为 <code>user_id</code> 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将<code>user_id</code> 字段改为 <code>BIGINT(20) NOT NULL DEFAULT &#39;0&#39;</code>, 则 <code>key_length</code> 应该是8.</p>
<p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p>
<p>接下来我们来看一下下一个例子:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">order_info</span> <span class="string">WHERE</span> <span class="string">user_id</span> <span class="string">=</span> <span class="number">1</span> <span class="string">AND</span> <span class="string">product_name</span> <span class="string">=</span> <span class="string">'p1'</span> <span class="string">\G;</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">ref</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">161</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">const,const</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure>
<p>这次的查询中, 我们没有使用到范围查询, <code>key_len</code> 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = &#39;p1&#39;</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>
<ul>
<li>Using filesort<ul>
<li>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li>
</ul>
</li>
</ul>
<p>例如下面的例子:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">order_info</span> <span class="string">ORDER</span> <span class="string">BY</span> <span class="string">product_name</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">253</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index;</span> <span class="string">Using</span> <span class="string">filesort</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure></p>
<p>我们的索引是<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure></p>
<p>但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.<br>如果我们将排序依据改为<code>ORDER BY user_id, product_name,</code> 那么就不会出现 <code>Using filesort</code> 了. 例如:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">order_info</span> <span class="string">ORDER</span> <span class="string">BY</span> <span class="string">user_id,</span> <span class="string">product_name</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">253</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>Using index<ul>
<li>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li>
</ul>
</li>
<li>Using temporary<ul>
<li>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>
</ul>
</li>
</ul>
<h2 id="数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？"><a href="#数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？" class="headerlink" title="数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？"></a>数据库和缓存的一致性问题。先更新数据库，再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？</h2><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>主要有两种情况，会导致缓存和 DB 的一致性问题：</p>
<ul>
<li>并发的场景下，导致读取老的 DB 数据，更新到缓存中。</li>
<li>缓存和 DB 的操作，不在一个事务中，可能只有一个操作成功，而另一个操作失败，导致不一致。</li>
</ul>
<p>当然，有一点我们要注意，缓存和 DB 的一致性，我们指的更多的是最终一致性。我们使用缓存只要是提高读操作的性能，真正在写操作的业务逻辑，还是以数据库为准。例如说，我们可能缓存用户钱包的余额在缓存中，在前端查询钱包余额时，读取缓存，在使用钱包余额时，读取数据库。</p>
<h3 id="更新缓存的设计模式"><a href="#更新缓存的设计模式" class="headerlink" title="更新缓存的设计模式"></a>更新缓存的设计模式</h3><h4 id="Cache-Aside-Pattern-旁路缓存"><a href="#Cache-Aside-Pattern-旁路缓存" class="headerlink" title="Cache Aside Pattern(旁路缓存)"></a>Cache Aside Pattern(旁路缓存)</h4><p>这是最常用最常用的pattern了。其具体逻辑如下：</p>
<ul>
<li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li>命中：应用程序从cache中取数据，取到后返回。</li>
<li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225116942.png" alt="image"></p>
<p>一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。</p>
<blockquote>
<p>要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。</p>
</blockquote>
<h4 id="Read-Write-Through-Pattern"><a href="#Read-Write-Through-Pattern" class="headerlink" title="Read/Write Through Pattern"></a>Read/Write Through Pattern</h4><p>在上面的Cache Aside套路中，我们的应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。</p>
<p>Read Through</p>
<p>Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p>
<p>Write Through</p>
<p>Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）</p>
<p>下图自来Wikipedia的Cache词条。其中的Memory你可以理解为就是我们例子里的数据库。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225333630.png" alt="image"></p>
<h4 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h4><p>Write Behind 又叫 Write Back。write back就是Linux文件系统的Page Cache的算法。</p>
<p>Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。</p>
<blockquote>
<p>这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>
</blockquote>
<p>但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道Unix/Linux非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍Trade-Off。</p>
<p>另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。</p>
<p>在wikipedia上有一张write back的流程图，基本逻辑如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225423934.png" alt="image"></p>
<h3 id="缓存架构设计"><a href="#缓存架构设计" class="headerlink" title="缓存架构设计"></a>缓存架构设计</h3><h4 id="更新缓存-VS-淘汰缓存"><a href="#更新缓存-VS-淘汰缓存" class="headerlink" title="更新缓存 VS 淘汰缓存"></a>更新缓存 VS 淘汰缓存</h4><p>更新缓存：数据不但写入数据库，还会写入缓存；优点：缓存不会增加一次miss，命中率高</p>
<p>淘汰缓存：数据只会写入数据库，不会写入缓存，只会把数据淘汰掉；优点：简单</p>
<p>这两者的选择主要取决于“更新缓存的复杂度”。</p>
<p>例如，上述场景，只是简单的把余额money设置成一个值，那么：</p>
<p>（1）淘汰缓存的操作为deleteCache(uid)</p>
<p>（2）更新缓存的操作为setCache(uid, money)</p>
<p>更新缓存的代价很小，此时我们应该更倾向于更新缓存，以保证更高的缓存命中率</p>
<p>如果余额是通过很复杂的数据计算得出来的，例如业务上除了账户表account，还有商品表product，折扣表discount</p>
<p>account(uid, money)</p>
<p>product(pid, type, price, pinfo)</p>
<p>discount(type, zhekou)</p>
<p>业务场景是用户买了一个商品product，这个商品的价格是price，这个商品从属于type类商品，type类商品在做促销活动要打折扣zhekou，购买了商品过后，这个余额的计算就复杂了，需要：</p>
<p>（1）先把商品的品类，价格取出来：SELECT type, price FROM product WHERE pid=XXX</p>
<p>（2）再把这个品类的折扣取出来：SELECT zhekou FROM discount WHERE type=XXX</p>
<p>（3）再把原有余额从缓存中查询出来money = getCache(uid)</p>
<p>（4）再把新的余额写入到缓存中去setCache(uid, money-price*zhekou)</p>
<p>更新缓存的代价很大，此时我们应该更倾向于淘汰缓存。</p>
<p>总之，淘汰缓存操作简单，并且带来的副作用只是增加了一次cache miss，建议作为通用的处理方式。</p>
<h4 id="先操作数据库-vs-先操作缓存"><a href="#先操作数据库-vs-先操作缓存" class="headerlink" title="先操作数据库 vs 先操作缓存"></a>先操作数据库 vs 先操作缓存</h4><p>当写操作发生时，假设淘汰缓存作为对缓存通用的处理方式，又面临两种抉择：</p>
<p>（1）先写数据库，再淘汰缓存</p>
<p>（2）先淘汰缓存，再写数据库</p>
<p>对于一个不能保证事务性的操作，一定涉及“哪个任务先做，哪个任务后做”的问题，解决这个问题的方向是：如果出现不一致，谁先做对业务的影响较小，就谁先执行。</p>
<p>由于写数据库与淘汰缓存不能保证原子性，谁先谁后同样要遵循上述原则。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225728222.png" alt="image"></p>
<p>假设先写数据库，再淘汰缓存：第一步写数据库操作成功，第二步淘汰缓存失败，则会出现DB中是新数据，Cache中是旧数据，数据不一致。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225736738.png" alt="image"></p>
<p>假设先淘汰缓存，再写数据库：第一步淘汰缓存成功，第二步写数据库失败，则只会引发一次Cache miss。</p>
<p>结论：数据和缓存的操作时序：先淘汰缓存，再写数据库。</p>
<h4 id="缓存架构优化"><a href="#缓存架构优化" class="headerlink" title="缓存架构优化"></a>缓存架构优化</h4><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225756637.png" alt="image"></p>
<p>上述缓存架构有一个缺点：业务方需要同时关注缓存与DB，主要有两种优化方案：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2019070822580935.png" alt="image"></p>
<p>一种方案是服务化：加入一个服务层，向上游提供帅气的数据访问接口，向上游屏蔽底层数据存储的细节，这样业务线不需要关注数据是来自于cache还是DB。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225823969.png" alt="image"></p>
<p>另一种方案是异步缓存更新：业务线所有的写操作都走数据库，所有的读操作都总缓存，由一个异步的工具来做数据库与缓存之间数据的同步，具体细节是：</p>
<p>（1）要有一个init cache的过程，将需要缓存的数据全量写入cache</p>
<p>（2）如果DB有写操作，异步更新程序读取binlog，更新cache</p>
<p>在（1）和（2）的合作下，cache中有全部的数据，这样：</p>
<p>（a）业务线读cache，一定能够hit（很短的时间内，可能有脏数据），无需关注数据库</p>
<p>（b）业务线写DB，cache中能得到异步更新，无需关注缓存</p>
<p>这样将大大简化业务线的调用逻辑，存在的缺点是，如果缓存的数据业务逻辑比较复杂，async-update异步更新的逻辑可能也会比较复杂。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>（1）淘汰缓存是一种通用的缓存处理方式</p>
<p>（2）先淘汰缓存，再写数据库</p>
<p>（3）服务化是向业务方屏蔽底层数据库与缓存复杂性的一种通用方式</p>
<h3 id="缓存和DB一致性的解决方案"><a href="#缓存和DB一致性的解决方案" class="headerlink" title="缓存和DB一致性的解决方案"></a>缓存和DB一致性的解决方案</h3><h4 id="先淘汰缓存，再写数据库"><a href="#先淘汰缓存，再写数据库" class="headerlink" title="先淘汰缓存，再写数据库"></a>先淘汰缓存，再写数据库</h4><p>因为先淘汰缓存，所以数据的最终一致性是可以得到有效的保证的。因为先淘汰缓存，即使写数据库发生异常，也就是下次缓存读取时，多读取一次数据库。</p>
<p>但是，这种方案会存在缓存和 DB 的数据会不一致的情况，参照《缓存与数据库一致性优化》 所说。</p>
<p>我们需要解决缓存并行写，实现串行写。比较简单的方式，引入分布式锁。</p>
<ul>
<li>在写请求时，先淘汰缓存之前，获取该分布式锁。</li>
<li>在读请求时，发现缓存不存在时，先获取分布式锁。</li>
</ul>
<p>这样，缓存的并行写就成功的变成串行写落。写请求时，是否主动更新缓存，根据自己业务的需要，是否有，都没问题。</p>
<h4 id="先写数据库，再更新缓存"><a href="#先写数据库，再更新缓存" class="headerlink" title="先写数据库，再更新缓存"></a>先写数据库，再更新缓存</h4><p>按照“先写数据库，再更新缓存”，我们要保证 DB 和缓存的操作，能够在“同一个事务”中，从而实现最终一致性。</p>
<p>基于定时任务来实现</p>
<ul>
<li>首先，写入数据库。</li>
<li>然后，在写入数据库所在的事务中，插入一条记录到任务表。该记录会存储需要更新的缓存 KEY 和 VALUE 。</li>
<li>【异步】最后，定时任务每秒扫描任务表，更新到缓存中，之后删除该记录。</li>
</ul>
<p>基于消息队列来实现</p>
<ul>
<li>首先，写入数据库。</li>
<li>然后，发送带有缓存 KEY 和 VALUE 的事务消息。此时，需要有支持事务消息特性的消息队列，或者我们自己封装消息队列，支持事务消息。</li>
<li>【异步】最后，消费者消费该消息，更新到缓存中。</li>
</ul>
<p>这两种方式，可以进一步优化，可以先尝试更新缓存，如果失败，则插入任务表，或者事务消息。</p>
<p>另外，极端情况下，如果并发写执行时，先更新成功 DB 的，结果后更新缓存：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708225900770.png" alt="image"></p>
<p>理论来说，希望的更新缓存顺序是，线程 1 快于线程 2 ，但是实际线程1 晚于线程 2 ，导致数据不一致。</p>
<p>图中一直是基于定时任务或消息队列来实现异步更新缓存，如果网络抖动，导致【插入任务表，或者事务消息】的顺序不一致。</p>
<p>那么怎么解决呢？需要做如下三件事情：</p>
<p>1、在缓存值中，拼接上数据版本号或者时间戳。例如说：value = {value: 原值, version: xxx} 。</p>
<p>2、在任务表的记录，或者事务消息中，增加上数据版本号或者时间戳的字段。</p>
<p>3、在定时任务或消息队列执行更新缓存时，先读取缓存，对比版本号或时间戳，大于才进行更新。 当然，此处也会有并发问题，所以还是得引入分布式锁或 CAS 操作。</p>
<p>关于 Redis 分布式锁，可以看看 <a href="http://svip.iocoder.cn/Redis/Interview" target="_blank" rel="noopener">《精尽 Redis 面试题》</a> 的 <a href="http://svip.iocoder.cn/Cache/Interview/#" target="_blank" rel="noopener">「如何使用 Redis 实现分布式锁？」 </a>问题。</p>
<p>关于 Redis CAS 操作，可以看看 <a href="http://svip.iocoder.cn/Redis/Interview" target="_blank" rel="noopener">《精尽 Redis 面试题》</a> 的 <a href="http://svip.iocoder.cn/Cache/Interview/#" target="_blank" rel="noopener">「什么是 Redis 事务？」 </a>问题。</p>
<h4 id="基于数据库的-binlog-日志"><a href="#基于数据库的-binlog-日志" class="headerlink" title="基于数据库的 binlog 日志"></a>基于数据库的 binlog 日志</h4><h5 id="重客户端"><a href="#重客户端" class="headerlink" title="重客户端"></a>重客户端</h5><p>写入缓存：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230031559.png" alt="image"></p>
<ul>
<li>应用同时更新数据库和缓存</li>
<li>如果数据库更新成功，则开始更新缓存，否则如果数据库更新失败，则整个更新过程失败。</li>
<li>判断更新缓存是否成功，如果成功则返回</li>
<li>如果缓存没有更新成功，则将数据发到MQ中</li>
<li>应用监控MQ通道，收到消息后继续更新Redis。</li>
</ul>
<p>问题点：如果更新Redis失败，同时在将数据发到MQ之前的时间，应用重启了，这时候MQ就没有需要更新的数据，如果Redis对所有数据没有设置过期时间，同时在读多写少的场景下，只能通过人工介入来更新缓存。</p>
<p>读缓存：</p>
<p>如何来解决这个问题？那么在写入Redis数据的时候，在数据中增加一个时间戳插入到Redis中。在从Redis中读取数据的时候，首先要判断一下当前时间有没有过期，如果没有则从缓存中读取，如果过期了则从数据库中读取最新数据覆盖当前Redis数据并更新时间戳。具体过程如下图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230102585.png" alt="image"></p>
<h5 id="客户端数据库与缓存解耦"><a href="#客户端数据库与缓存解耦" class="headerlink" title="客户端数据库与缓存解耦"></a>客户端数据库与缓存解耦</h5><p>上述方案对于应用的研发人员来讲比较重，需要研发人员同时考虑数据库和Redis是否成功来做不同方案，如何让研发人员只关注数据库层面，而不用关心缓存层呢？请看下图：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190708230139385.png" alt="image"></p>
<ul>
<li>应用直接写数据到数据库中。</li>
<li>数据库更新binlog日志。</li>
<li>利用Canal中间件读取binlog日志。</li>
<li>Canal借助于限流组件按频率将数据发到MQ中。</li>
<li>应用监控MQ通道，将MQ的数据更新到Redis缓存中。</li>
</ul>
<p>可以看到这种方案对研发人员来说比较轻量，不用关心缓存层面，而且这个方案虽然比较重，但是却容易形成统一的解决方案。</p>
<p>PS：下面这两种比较实用</p>
<p>“先淘汰缓存，再写数据库”的方案，并且无需引入分布式锁。</p>
<p>“先写数据库，再更新缓存”的方案，并且无需引入定时任务或者消息队列。</p>
<p>使用缓存过程中，经常会遇到缓存数据的不一致性和脏读现象。一般情况下，采取缓存双淘汰机制，在更新数据库的前淘汰缓存。此外，设定超时时间，例如三十分钟。</p>
<p>极端场景下，即使有脏数据进入缓存，这个脏数据也最存在一段时间后自动销毁。</p>
<h3 id="主从DB与cache一致性优化"><a href="#主从DB与cache一致性优化" class="headerlink" title="主从DB与cache一致性优化"></a><a href="https://www.w3cschool.cn/architectroad/architectroad-consistency-of-cache-with-master-and-slave-database.html" target="_blank" rel="noopener">主从DB与cache一致性优化</a></h3><h2 id="聚簇索引-非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？"><a href="#聚簇索引-非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？" class="headerlink" title="聚簇索引/非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？"></a>聚簇索引/非聚簇索引，MySQL索引底层实现，为什么不用B-Tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p> 1.所有非叶子结点至多拥有两个儿子（Left和Right）；</p>
<p>2.所有结点存储一个关键字；</p>
<p>3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</p>
<p>如：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1.JPG" alt="image"></p>
<p>二叉搜索树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；</p>
<p>否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入</p>
<p>右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；</p>
<p>如果 二叉搜索树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么 二叉搜索树</p>
<p>的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变 二叉搜索树结构</p>
<p>（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；</p>
<p>如：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2.JPG" alt="image"></p>
<p>但 二叉搜索树在经过多次插入与删除后，有可能导致不同的结构：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/31.JPG" alt="image"></p>
<p>右边也是一个 二叉搜索树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的</p>
<p>树结构索引；所以，使用 二叉搜索树还要考虑尽可能让 二叉搜索树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；      </p>
<p>实际使用的 二叉搜索树都是在原二叉搜索树的基础上加上平衡算法，即“平衡二叉树”；如何保持 二叉搜索树</p>
<p>结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在 二叉搜索树中插入和删除结点的策略；</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>是一种多路搜索树（并不是二叉的）：</p>
<p>1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；</p>
<p>2.根结点的儿子数为[2, M]；</p>
<p>3.除根结点以外的非叶子结点的儿子数为[M/2, M]；</p>
<p>4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</p>
<p>5.非叶子结点的关键字个数=指向儿子的指针个数-1；</p>
<p>6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</p>
<p>7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</p>
<p>8.所有叶子结点位于同一层；</p>
<p>如：（M=3）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/4.JPG" alt="image"></p>
<p>  B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果</p>
<p>命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为</p>
<p>空，或已经是叶子结点；</p>
<p>B-树的特性：</p>
<p>1.关键字集合分布在整颗树中；</p>
<p>2.任何一个关键字出现且只出现在一个结点中；</p>
<p>3.搜索有可能在非叶子结点结束；</p>
<p>4.其搜索性能等价于在关键字全集内做一次二分查找；</p>
<p>5.自动层次控制；</p>
<p>由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少</p>
<p>利用率，其最底搜索性能为：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/0.JPG" alt="image"></p>
<p>其中，M为设定的非叶子结点最多子树个数，N为关键字总数；</p>
<p>所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；</p>
<p>由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p> B+树是B-树的变体，也是一种多路搜索树：</p>
<p>1.其定义基本与B-树同，除了：</p>
<p>2.非叶子结点的子树指针与关键字个数相同；</p>
<p>3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树</p>
<p>（B-树是开区间）；</p>
<p>5.为所有叶子结点增加一个链指针；</p>
<p>6.所有关键字都在叶子结点出现；<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/5.JPG" alt="image"></p>
<p> B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在</p>
<p>非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<p>B+的特性：</p>
<p>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好</p>
<p>是有序的；</p>
<p>2.不可能在非叶子结点命中；</p>
<p>3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储</p>
<p>（关键字）数据的数据层；</p>
<p>4.更适合文件索引系统；</p>
<h3 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B*树"></a>B*树</h3><p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/6.JPG" alt="image"></p>
<p><code>B*</code>树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3</p>
<p>（代替B+树的1/2）；</p>
<p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据</p>
<p>复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父</p>
<p>结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分</p>
<p>数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字</p>
<p>（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之</p>
<p>间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</p>
<p>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p>
<p>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>
<p>B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>所谓聚簇索引，就是指主索引文件和数据文件为同一份文件，聚簇索引主要用在Innodb存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引，如下图所示：</p>
<p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
<h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引就是指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。主要用在MyISAM存储引擎中</p>
<p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111257402.png" alt="image"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111258238.png" alt="image"></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<p>InnoDB索引实现</p>
<p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111259913.png" alt="image"></p>
<p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20121130111300494.png" alt="image"></p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<ul>
<li>MyisAM顺序储存数据，索引叶子节点保存对应数据行地址，辅助索引跟主键索引相差无几（主键索引key不能相同）；InnoDB主键节点同时保存数据行，其他辅助索引保存的是主键索引的值；</li>
</ul>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调(可能是指“非递增”的意思)的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调(可能是指“非递增”的意思)的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<h3 id="为什么选用B-Tree"><a href="#为什么选用B-Tree" class="headerlink" title="为什么选用B+/-Tree"></a>为什么选用B+/-Tree</h3><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</p>
<p>B-Tree：如果一次检索需要访问4个节点，数据库系统设计者利用磁盘预读原理，把节点的大小设计为一个页，那读取一个节点只需要一次I/O操作，完成这次检索操作，最多需要3次I/O(根节点常驻内存)。数据记录越小，每个节点存放的数据就越多，树的高度也就越小，I/O操作就少了，检索效率也就上去了。</p>
<p>B+Tree：非叶子节点只存key，大大滴减少了非叶子节点的大小，那么每个节点就可以存放更多的记录，树更矮了，I/O操作更少了。所以B+Tree拥有更好的性能。</p>
<h2 id="MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？"><a href="#MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？" class="headerlink" title="MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？"></a>MySQL默认的事务隔离级别，MVCC、RR怎么实现的？RC如何实现的？</h2><h3 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h3><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<ul>
<li>mysql 默认的隔离级别:可重复读</li>
<li>Oracle 默认的隔离</li>
<li>级别:读已提交</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>MVCC(Multi Version Concurrency Control的简称)，代表多版本并发控制。与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。<br>MVCC最大的优势：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能</p>
<p>了解MVCC前，我们先学习下Mysql架构和数据库事务隔离级别</p>
<h4 id="MYSQL-架构"><a href="#MYSQL-架构" class="headerlink" title="MYSQL 架构"></a>MYSQL 架构</h4><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190706105542781.png" alt="image"></p>
<p>MySQL从概念上可以分为四层，顶层是接入层，不同语言的客户端通过mysql的协议与mysql服务器进行连接通信，接入层进行权限验证、连接池管理、线程管理等。下面是mysql服务层，包括sql解析器、sql优化器、数据缓冲、缓存等。再下面是mysql中的存储引擎层，mysql中存储引擎是基于表的。最后是系统文件层，保存数据、索引、日志等。</p>
<h4 id="MVCC是为了解决什么问题"><a href="#MVCC是为了解决什么问题" class="headerlink" title="MVCC是为了解决什么问题?"></a>MVCC是为了解决什么问题?</h4><ul>
<li>大多数的MYSQL事务型存储引擎,如,InnoDB，Falcon以及PBXT都不使用一种简单的行锁机制.事实上,他们都和MVCC–多版本并发控制来一起使用。</li>
<li>大家都应该知道,锁机制可以控制并发操作,但是其系统开销较大,而MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销。</li>
</ul>
<h4 id="MVCC具体实现"><a href="#MVCC具体实现" class="headerlink" title="MVCC具体实现"></a>MVCC具体实现</h4><p>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。<br>下面看一下在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。</p>
<ul>
<li>SELECT<ul>
<li>InnoDB会根据以下两个条件检查每行记录：<ul>
<li>1、InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>
<li>2、行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li>
<li>只有符合上述两个条件的记录，才能返回作为查询结果。</li>
</ul>
</li>
</ul>
</li>
<li>INSERT<ul>
<li>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</li>
</ul>
</li>
<li>DELETE<ul>
<li>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</li>
</ul>
</li>
<li>UPDATE<ul>
<li>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</li>
<li>保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作</li>
</ul>
</li>
</ul>
<p>举例Demo<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> riemann( </span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment, </span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure></p>
<p>transaction 1:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> riemann <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'riemann'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> riemann <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'chow'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p>
<p>假设系统初始事务ID为1；</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>创建时间(事务ID)</th>
<th>过期时间(事务ID)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>riemann</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>chow</td>
<td>1</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p>transaction 2:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> riemann ;  //(1)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> riemann ;  //(2)</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>
<h5 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务3：</p>
<p>transaction 3:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> riemann <span class="keyword">values</span>(<span class="literal">NULL</span>,<span class="string">'peng'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>创建时间(事务ID)</th>
<th>过期时间(事务ID)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>riemann</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>chow</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>3</td>
<td>peng</td>
<td>3</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p>事务3执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2的，所以事务3新增的记录在事务2中是查不出来的，这就通过乐观锁的方式避免了幻读的产生。</p>
<h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务4：</p>
<p>transaction session 4:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">update</span> riemann <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'edgar'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p>
<p>InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要UPDATE的行的删除时间。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>创建时间(事务ID)</th>
<th>过期时间(事务ID)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>riemann</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>chow</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>edgar</td>
<td>4</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p>事务4执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2的，所以事务修改的记录在事务2中是查不出来的，这样就保证了事务在两次读取时读取到的数据的状态是一致的。</p>
<h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><p>假设当执行事务2的过程中，准备执行语句(2)时，开始执行事务5：</p>
<p>transaction session 5:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> riemann <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>创建时间(事务ID)</th>
<th>过期时间(事务ID)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>riemann</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>chow</td>
<td>1</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>事务5执行完毕，开始执行事务2 语句2，由于事务2只能查询创建时间小于等于2、并且过期时间大于等于2，所以id=2的记录在事务2 语句2中，也是可以查出来的,这样就保证了事务在两次读取时读取到的数据的状态是一致的。</p>
<h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h3><p>MVCC(Multi-Version Concurrent Control)：多版本并发控制，只作用于RC和RR隔离级别，主要是为了避免脏读、非重复读，而非幻读，很多文章说通过MVCC避免幻读，其实这种说法是不完善的，RR隔离级别是通过next-key lock 来避免幻读。</p>
<p>优点：避免了许多需要加锁的情形</p>
<p>缺点：需要维护每行记录版本号，造成额外资源消耗</p>
<p>怎么避免脏读、不可重复读、幻读？</p>
<p>采用RR隔离级别，结合MVCC特性，可以避免脏读、非重复读，有些文章说MVCC用来避免幻读，其实这是不准确的，MVCC通过多版本并发控制来避免非重复读，像幻读定义所说的情况即使有MVCC还是会存在。RR隔离级别是通过禁用innodb_locks_unsafe_for_binlog，在搜索和扫描索引的时候使用next-key locks来避免幻读（下面有对锁说明）。也就是为什么RR隔离级别下，非主键索引DML的操作并发性能会下降的原因了。</p>
<p>为了减少Next-key lock影响，可以设置innodb_locks_unsafe_for_binlog=1，就是disable Next-Key lock，但是并不建议。</p>
<p>想要真正避免幻读只能采取serializable串行化隔离级别，因为都要加表级共享锁或排他锁，所以性能会很差，一般不会采用。</p>
<p>MVCC如何避免非重复读：</p>
<p>MVCC为查询提供了一个基于时间的点的快照。这个查询只能看到在自己之前提交的数据，而在查询开始之后提交的数据是不可以看到的。</p>
<p>在每行记录后面记录两个隐藏的列，一个记录创建时间，一个记录删除时间，记录的是版本号，这里可以理解为事物号。</p>
<p>INSERT：Innodb 为新插入的每一行保存当前系统版本号作为行版本号；</p>
<p>DELETE：Innodb 为删除的每一行保存当前系统版本号作为行删除标识；</p>
<p>UPDATE：Innodb 为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
<h4 id="RR隔离级别下锁介绍"><a href="#RR隔离级别下锁介绍" class="headerlink" title="RR隔离级别下锁介绍"></a>RR隔离级别下锁介绍</h4><h5 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h5><p>在主键或唯一索引上对单行记录加锁</p>
<h5 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h5><p>针对非唯一索引而言，锁定一个范围的记录，但不包括记录本身。锁加在未使用的空闲空间上，可能是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。</p>
<p>如果更新两端的记录会影响到间隙锁，那么操作会被挂起，等待间隙锁释放。</p>
<p>比如锁定范围（4，7），update table set v1=6 where v1=1; 虽然1不在此范围，但是6在（4，7）范围还是会锁定。</p>
<h5 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h5><p>针对非唯一索引而言，行记录锁与间隙锁组合起来用就叫做Next-Key Lock。锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</p>
<p>通过一个例子介绍间隙锁</p>
<p>表test5中存在如下数据：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180727113023312.png" alt="image"></p>
<p>select * from test5 where v1=45 for update; 对v1=45的行加X锁，此时会对(40,45][45,50)加间隙锁，其他事物不能操作在此范围内的数据。</p>
<p>但是为什么在左侧值为40，右侧值为50的时候，有时候操作会被挂起，有时候操作不会挂起呢？</p>
<p>update table set v1=41 where v1=40;41在(40，50)范围会被锁定。</p>
<p>update table set v1=39 where v1=40; 39不在(40，50)范围不会被锁定。</p>
<p>update table set v1=42 where v1=1; 42在(40，50)范围会被锁定。</p>
<p>update table set v1=30 where v1=45; 30不在(40，50)范围，但是45行上面存在的行级record lock，45行记录也被加了锁。</p>
<p>insert into table(id,name) values(14,40);可以插入</p>
<p>insert into table(id,name) values(20,40);不可以插入</p>
<p>insert into table(id,name) values(13,50);不可以插入</p>
<p>insert into table(id,name) values(21,40);可以插入</p>
<p>当插入左侧值的时候，即插入v1=40的时候，要求插入的id值小于id=16的范围。当v1=40的记录有多条的时候，插入的id值要小于其中的最大id值。则可以成功插入；</p>
<p>当插入右侧值的时候，即插入v1=50的时候，要求插入的id值要大于id=18的范围。当v1=50的记录有多条的时候，插入的id值要大于其中的最小id值。则可以成功插入。</p>
<p>所以为什么RR隔离级别下并发性能会有所下降，就是因为存在间隙锁。我们应该尽量使用主键或唯一索引，因为唯一索引会把Next-Key Lock降级为Record Lock。</p>
<h5 id="AUTO-INC-Lock"><a href="#AUTO-INC-Lock" class="headerlink" title="AUTO-INC Lock"></a>AUTO-INC Lock</h5><p>只针对存在主键的insert操作，由innodb_autoinc_lock_mode参数决定锁粒度。</p>
<p>在了解自增锁前需要知道mysql都有哪些insert操作：</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSERT-like</td>
<td>所有可以向表中增加行的语句</td>
</tr>
<tr>
<td>Simple inserts</td>
<td>可以预先确定要插入的行数insert…values…</td>
</tr>
<tr>
<td>Bulk inserts</td>
<td>事先不知道要插入的行数（INSERT…SELECT,REPLACE…SELECT,LOAD  DATA）</td>
</tr>
<tr>
<td>Mixed-mode inserts</td>
<td>一些是“Simple  inserts”语句但是有一些是null的自增值</td>
</tr>
</tbody>
</table>
<p>innodb_autoinc_lock_mode= 0 传统锁定模式（所有insert采用传统AUTO-INC机制），所有“INSERT-like”语句获得一个特殊的表级AUTO-INC锁，在存在自增列的表获得一个特殊的表级AUTO-INC锁，(statement-based replication)操作是安全。</p>
<p>innodb_autoinc_lock_mode= 1 默认锁定模式（bulk-insert采用表级锁）</p>
<p>“bulk inserts”仍然使用AUTO-INC表级锁,并保持到语句结束；“Simple inserts”（要插入的行数事先已知）通过在mutex（轻量锁）的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁，只在分配的时间内持有，不是整个语句，(statement-based replication)操作是安全。</p>
<p>innodb_autoinc_lock_mode= 2 轻量锁定模式(所有insert采用轻量级）</p>
<p>所有类INSERT(“INSERT-like” )语句都不会使用表级AUTO-INC lock，”批量插入”时，在由任何给定语句分配的自动递增值中可能存在间隙，(statement-based replication)操作是不安全。</p>
<p>可以汇总为如下表格：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180727113110216.png" alt="image"></p>
<p>示例：innodb_autoinc_lock_mode= 1时不连续</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">创建一个表id为自增主键：</span><br><span class="line"></span><br><span class="line">CREATE TABLE `test6` (</span><br><span class="line"></span><br><span class="line">id int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">name int(11),</span><br><span class="line">modified TIMESTAMP<span class="built_in"> DEFAULT </span>CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) <span class="attribute">ENGINE</span>=InnoDB <span class="attribute">AUTO_INCREMENT</span>=1<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
<p>先插入一条记录，然后再多次自插入数据，发现id没有5、10~12，如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180727113601623.png" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2018072711355127.png" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2018072711351276.png" alt="image"></p>
<p>这种情况就是上面锁说的，insert…select…属于Bulk insert，不能预判要插入多少条数据，所以在自增值分配上每次都会按照2^n-1分配：</p>
<p>第一次，先分配一个自增值，因为只有一条数据，正好</p>
<p>第二次，先分配一个自增值3，发现还有数据，继续按2^n-1分配，分配4、5，此时只剩一条数据4，但5已经被分配出去。</p>
<p>第三次，因为5已经被分配出去，此时只能从6开始，以此类推。</p>
<h5 id="Dead-lock"><a href="#Dead-lock" class="headerlink" title="Dead lock"></a>Dead lock</h5><p>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。</p>
<p>死锁检测开关innodb_deadlock_detect 5.7.15后引入，关闭会提升性能，一般应用在秒杀等场景。</p>
<p>出现死锁场景很多，绝大多数是高并发下同时操作一行数据，加锁顺序相反引起。</p>
<p>先删再插，两条insert当需要进行唯一性冲突检测时，需要先加一个S锁，也会产生死锁。</p>
<p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</p>
<h3 id="MySQL-中RC和RR隔离级别的区别"><a href="#MySQL-中RC和RR隔离级别的区别" class="headerlink" title="MySQL 中RC和RR隔离级别的区别"></a>MySQL 中RC和RR隔离级别的区别</h3><p>MySQL数据库中默认隔离级别为RR，但是实际情况是使用RC 和 RR隔离级别的都不少。好像淘宝、网易都是使用的 RC 隔离级别。那么在MySQL中 RC 和 RR有什么区别呢？我们该如何选择呢？为什么MySQL将RR作为默认的隔离级别呢？</p>
<h4 id="RC-与-RR-在锁方面的区别"><a href="#RC-与-RR-在锁方面的区别" class="headerlink" title="RC 与 RR 在锁方面的区别"></a>RC 与 RR 在锁方面的区别</h4><p>1&gt; 显然 RR 支持 gap lock(next-key lock)，而RC则没有gap lock。因为MySQL的RR需要gap lock来解决幻读问题。而RC隔离级别则是允许存在不可重复读和幻读的。所以RC的并发一般要好于RR；</p>
<p>2&gt; RC 隔离级别，通过 where 条件过滤之后，不符合条件的记录上的行锁，会释放掉(虽然这里破坏了“两阶段加锁原则”)；但是RR隔离级别，即使不符合where条件的记录，也不会是否行锁和gap lock；所以从锁方面来看，RC的并发应该要好于RR；另外 insert into t select … from s where 语句在s表上的锁也是不一样的，参见下面的例子2；</p>
<p>下面是来自 <a href="http://www.itpub.net/thread-1941624-1-1.html" target="_blank" rel="noopener">github</a> 的一个例子：</p>
<p>MySQL5.6, 隔离级别RR，autocommit=off;</p>
<p>表结构：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">create</span> table t1\G</span><br><span class="line">*************************** <span class="number">1.</span> row ***************************</span><br><span class="line">       Table: t1</span><br><span class="line"><span class="keyword">Create</span> Table: <span class="keyword">CREATE</span> TABLE <span class="symbol">`t1`</span> (</span><br><span class="line">  <span class="symbol">`a`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="symbol">`b`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="symbol">`c`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="symbol">`d`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="symbol">`e`</span> varchar(<span class="number">20</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="symbol">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="symbol">`idx_t1_bcd`</span> (<span class="symbol">`b`</span>,<span class="symbol">`c`</span>,<span class="symbol">`d`</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>表数据：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select <span class="symbol">*</span> from t1;</span><br><span class="line">+---+---+---+---+------+</span><br><span class="line">|<span class="string"> a </span>|<span class="string"> b </span>|<span class="string"> c </span>|<span class="string"> d </span>|<span class="string"> e    </span>|</span><br><span class="line">+---+---+---+---+------+</span><br><span class="line">|<span class="string"> 1 </span>|<span class="string"> 1 </span>|<span class="string"> 1 </span>|<span class="string"> 1 </span>|<span class="string"> a    </span>|</span><br><span class="line">|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> b    </span>|</span><br><span class="line">|<span class="string"> 3 </span>|<span class="string"> 3 </span>|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> c    </span>|</span><br><span class="line">|<span class="string"> 4 </span>|<span class="string"> 3 </span>|<span class="string"> 1 </span>|<span class="string"> 1 </span>|<span class="string"> d    </span>|</span><br><span class="line">|<span class="string"> 5 </span>|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 5 </span>|<span class="string"> e    </span>|</span><br><span class="line">|<span class="string"> 6 </span>|<span class="string"> 6 </span>|<span class="string"> 4 </span>|<span class="string"> 4 </span>|<span class="string"> f    </span>|</span><br><span class="line">|<span class="string"> 7 </span>|<span class="string"> 4 </span>|<span class="string"> 5 </span>|<span class="string"> 5 </span>|<span class="string"> g    </span>|</span><br><span class="line">|<span class="string"> 8 </span>|<span class="string"> 8 </span>|<span class="string"> 8 </span>|<span class="string"> 8 </span>|<span class="string"> h    </span>|</span><br><span class="line">+---+---+---+---+------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>session 1:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from <span class="built_in">t1</span> where <span class="keyword">b&gt;2 </span><span class="keyword">and </span><span class="keyword">b&lt;5 </span><span class="keyword">and </span>c=<span class="number">2</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>执行计划如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> t1 where b&gt;2 <span class="keyword">and</span> b&lt;5 <span class="keyword">and</span> <span class="attribute">c</span>=2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: idx_t1_bcd</span><br><span class="line">          key: idx_t1_bcd</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: <span class="literal">NULL</span></span><br><span class="line">         rows: 2</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">1 row <span class="keyword">in</span> <span class="builtin-name">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>session 2:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span> <span class="built_in">from</span> t1 where <span class="keyword">a</span>=<span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>结果 session 2 被锁住。<br>session 3:<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select <span class="symbol">*</span> from information_schema.innodb_locks;</span><br><span class="line">+---------------+-------------+-----------+-----------+-------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">|<span class="string"> lock_id       </span>|<span class="string"> lock_trx_id </span>|<span class="string"> lock_mode </span>|<span class="string"> lock_type </span>|<span class="string"> lock_table  </span>|<span class="string"> lock_index </span>|<span class="string"> lock_space </span>|<span class="string"> lock_page </span>|<span class="string"> lock_rec </span>|<span class="string"> lock_data </span>|</span><br><span class="line">+---------------+-------------+-----------+-----------+-------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">|<span class="string"> 38777:390:3:5 </span>|<span class="string"> 38777       </span>|<span class="string"> X         </span>|<span class="string"> RECORD    </span>|<span class="string"> `test`.`t1` </span>|<span class="string"> PRIMARY    </span>|<span class="string">        390 </span>|<span class="string">         3 </span>|<span class="string">        5 </span>|<span class="string"> 4         </span>|</span><br><span class="line">|<span class="string"> 38771:390:3:5 </span>|<span class="string"> 38771       </span>|<span class="string"> X         </span>|<span class="string"> RECORD    </span>|<span class="string"> `test`.`t1` </span>|<span class="string"> PRIMARY    </span>|<span class="string">        390 </span>|<span class="string">         3 </span>|<span class="string">        5 </span>|<span class="string"> 4         </span>|</span><br><span class="line">+---------------+-------------+-----------+-----------+-------------+------------+------------+-----------+----------+-----------+</span><br></pre></td></tr></table></figure></p>
<p>根据锁及ICP的知识，此时加锁的情况应该是在索引  <code>idx_t1_bcd</code> 上的<code>b&gt;2 and b&lt;5</code>之间加<code>gap lock</code>, <code>idx_t1_bcd</code>上的c=2 加 X锁主键 a=3 加 x 锁。<br>应该a=4上是没有加X锁的，可以进行删除与更改。<br>但是从session3上的结果来，此时a=4上被加上了X锁。<br>求大牛解惑，谢谢。</p>
<p>要理解这里为什么 a=4 被锁住了，需要理解 gap lock，锁处理 RR 隔离级别和RC隔离级别的区别等等。</p>
<p>这里的原因如下：</p>
<p>很简单，我们注意到：<code>key_len</code>: 4 和 Extra: Using index condition<br>这说明了，仅仅使用了索引 <code>idx_t1_bcd</code> 中的 b 一列，没有使用到 c 这一列。c 这一列是在ICP时进行过滤的。所以：</p>
<p><code>delete from t1 where b&gt;2 and b&lt;5 and c=2</code> 其实锁定的行有：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 where b&gt;2 and b&lt;=6;</span><br><span class="line"><span class="code">+---+</span>---<span class="code">+---+</span>---<span class="code">+------+</span></span><br><span class="line">| a | b | c | d | e    |</span><br><span class="line"><span class="code">+---+</span>---<span class="code">+---+</span>---<span class="code">+------+</span></span><br><span class="line">| 3 | 3 | 2 | 2 | c    |</span><br><span class="line">| 4 | 3 | 1 | 1 | d    |</span><br><span class="line">| 6 | 6 | 4 | 4 | f    |</span><br><span class="line">| 7 | 4 | 5 | 5 | g    |</span><br><span class="line"><span class="code">+---+</span>---<span class="code">+---+</span>---<span class="code">+------+</span></span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>所以显然 <code>delete from t1 where a=4</code>就被阻塞了。那么为什么 <code>delete from t1 where a=6</code> 也会被阻塞呢？？？</p>
<p>这里 <code>b&lt;=6</code>的原因是，b 列中没有等于 5 的记录，所以 <code>and b&lt;5</code> 实现为锁定 <code>b&lt;=6</code> 的所有索引记录，这里有等于号的原因是，如果我们不锁定 =6 的索引记录，那么怎么实现锁定 <code>&lt;5</code> 的gap 呢？也就是说锁定 b=6 的索引记录，是为了实现锁定 <code>b&lt; 5</code> 的gap。也就是不能删除 b=6 记录的原因。<br>而这里 b &gt;2 没有加等于号(b&gt;=2) 的原因，是因为 b&gt;2的这个gap 是由 b=3这个索引记录(的gap)来实现的，不是由 b=2索引记录(的gap) 来实现的，b=2的索引记录的gap lock只能实现锁定<code>&lt;2</code>的gap，b&gt;2的gap锁定功能，需要由 b=3的索引记录对应的gap来实现(b&gt;2，<code>b&lt;3</code>的gap)。<br>所以我们在session2中可以删除：a=1,2,5,8的记录，但是不能删除 a=6(因为该行的b=6)的记录。</p>
<p>如果我们使用 RC 隔离级别时，则不会发生阻塞，其原因就是：</p>
<p>RC和RR隔离级别中的锁处理不一样，RC隔离级别时，在使用c列进行ICP where条件过滤时，对于不符合条件的记录，锁会释放掉，而RR隔离级别时，即使不符合条件的记录，锁也不会释放(虽然违反了“2阶段锁”原则)。所以RC隔离级别时session 2不会被阻塞。</p>
<p>Gap lock: This is a lock on a gap between index records, or a lock on the gap before the first or after the last index record.</p>
<p>例子2：<code>insert into t select ... from s where</code> 在RC 和 RR隔离级别下的加锁过程</p>
<p>下面是官方文档中的<a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-locks-set.html" target="_blank" rel="noopener">说明</a>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T <span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> S <span class="keyword">WHERE</span> ... <span class="keyword">sets</span> an exclusive <span class="keyword">index</span> <span class="built_in">record</span> <span class="keyword">lock</span> (<span class="keyword">without</span> a gap <span class="keyword">lock</span>) <span class="keyword">on</span> <span class="keyword">each</span> <span class="keyword">row</span> inserted <span class="keyword">into</span> T. <span class="keyword">If</span> the <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">READ</span> COMMITTED, <span class="keyword">or</span> innodb_locks_unsafe_for_binlog <span class="keyword">is</span> enabled <span class="keyword">and</span> the <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">SERIALIZABLE</span>, <span class="keyword">InnoDB</span> does the <span class="keyword">search</span> <span class="keyword">on</span> S <span class="keyword">as</span> a <span class="keyword">consistent</span> <span class="keyword">read</span> (<span class="keyword">no</span> locks). Otherwise, <span class="keyword">InnoDB</span> <span class="keyword">sets</span> <span class="keyword">shared</span> <span class="keyword">next</span>-<span class="keyword">key</span> locks <span class="keyword">on</span> <span class="keyword">rows</span> <span class="keyword">from</span> S. <span class="keyword">InnoDB</span> has <span class="keyword">to</span> <span class="keyword">set</span> locks <span class="keyword">in</span> the latter <span class="keyword">case</span>: <span class="keyword">In</span> roll-forward <span class="keyword">recovery</span> <span class="keyword">from</span> a <span class="keyword">backup</span>, every <span class="keyword">SQL</span> <span class="keyword">statement</span> must be executed <span class="keyword">in</span> exactly the same way it was done originally.</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ... <span class="keyword">SELECT</span> ... performs the <span class="keyword">SELECT</span> <span class="keyword">with</span> <span class="keyword">shared</span> <span class="keyword">next</span>-<span class="keyword">key</span> locks <span class="keyword">or</span> <span class="keyword">as</span> a <span class="keyword">consistent</span> <span class="keyword">read</span>, <span class="keyword">as</span> <span class="keyword">for</span> <span class="keyword">INSERT</span> ... SELECT.</span><br><span class="line"></span><br><span class="line"><span class="keyword">When</span> a <span class="keyword">SELECT</span> <span class="keyword">is</span> used <span class="keyword">in</span> the constructs <span class="keyword">REPLACE</span> <span class="keyword">INTO</span> t <span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> s <span class="keyword">WHERE</span> ... <span class="keyword">or</span> <span class="keyword">UPDATE</span> t ... <span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> s ...), <span class="keyword">InnoDB</span> <span class="keyword">sets</span> <span class="keyword">shared</span> <span class="keyword">next</span>-<span class="keyword">key</span> locks <span class="keyword">on</span> <span class="keyword">rows</span> <span class="keyword">from</span> <span class="keyword">table</span> s.</span><br></pre></td></tr></table></figure>
<p><code>insert inot t select ... from s where ...</code>语句和 <code>create table ... select ... from s where</code>加锁过程是相似的(RC 和 RR 加锁不一样)：</p>
<p>1&gt; RC 隔离级别时和 RR隔离级别但是设置<code>innodb_locks_unsafe_for_binlog=1</code> 时，<code>select ... from s where</code>对 s 表进行的是一致性读，所以是无需加锁的；</p>
<p>2&gt; 如果是RR隔离级别(默认<code>innodb_locks_unsafe_for_binlog</code>=0)，或者是 serializable隔离级别，那么对 s 表上的每一行都要加上 <code>shared next-key lock</code>.</p>
<p>这个区别是一个很大的不同，下面是生成中的一个 <code>insert into t select ... from s where</code>导致的系统宕机的案例：</p>
<p>一程序猿执行一个分表操作：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_async_src_acct_201508 <span class="keyword">select</span> * <span class="keyword">from</span> tb_async_src_acct </span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> src_status=<span class="number">3</span> <span class="keyword">and</span> create_time&gt;=<span class="string">'2015-08-01 00:00:00'</span> <span class="keyword">and</span> create_time &lt;= <span class="string">'2015-08-31 23:59:59'</span>;</span><br></pre></td></tr></table></figure></p>
<p>表 <code>tb_async_src_acct</code>有4000W数据。分表的目的是想提升下性能。结果一执行该语句，该条SQL被卡住，然后所有向 <code>tb_async_src_acct</code>的写操作，要么是 get lock fail, 要么是 lost connection，全部卡住，然后主库就宕机了。</p>
<p>显然这里的原因，就是不知道默认RR隔离级别中 <code>insert into t select ... from s where</code>语句的在 s 表上的加锁过程，该语句一执行，所有符合 where 条件的 s 表中的行记录都会加上 <code>shared next-key lock</code>(如果没有使用到索引，还会锁住表中所有行)，在整个事务过程中一直持有，因为表 <code>tb_async_src_acct</code> 数据很多，所以运行过程是很长的，所以加锁过程也是很长，所以其它所有的对<code>tb_async_src_acct</code> 的insert, delete, update, DDL 都会被阻塞掉，这样被阻塞的事务就越来越多，而事务也会申请其它的表中的行锁，结果就是系统中被卡住的事务越来越多，系统自然就宕机了。</p>
<h4 id="RC-与-RR-在复制方面的区别"><a href="#RC-与-RR-在复制方面的区别" class="headerlink" title="RC 与 RR 在复制方面的区别"></a>RC 与 RR 在复制方面的区别</h4><ul>
<li>RC 隔离级别不支持 statement 格式的bin log，因为该格式的复制，会导致主从数据的不一致；只能使用 mixed 或者 row 格式的bin log; 这也是为什么MySQL默认使用RR隔离级别的原因。复制时，我们最好使用：<code>binlog_format=row</code></li>
<li>MySQL5.6 的早期版本，RC隔离级别是可以设置成使用statement格式的bin log，后期版本则会直接报错；</li>
</ul>
<h4 id="RC-与-RR-在一致性读方面的区别"><a href="#RC-与-RR-在一致性读方面的区别" class="headerlink" title="RC 与 RR 在一致性读方面的区别"></a>RC 与 RR 在一致性读方面的区别</h4><p>简单而且，RC隔离级别时，事务中的每一条select语句会读取到他自己执行时已经提交了的记录，也就是每一条select都有自己的一致性读ReadView; 而RR隔离级别时，事务中的一致性读的ReadView是以第一条select语句的运行时，作为本事务的一致性读snapshot的建立时间点的。只能读取该时间点之前已经提交的数据。</p>
<h4 id="RC-支持半一致性读，RR不支持"><a href="#RC-支持半一致性读，RR不支持" class="headerlink" title="RC 支持半一致性读，RR不支持"></a>RC 支持半一致性读，RR不支持</h4><p>RC隔离级别下的update语句，使用的是半一致性读(semi consistent)；而RR隔离级别的update语句使用的是当前读；当前读会发生锁的阻塞。</p>
<p>1&gt; 半一致性读：</p>
<blockquote>
<p>A type of read operation used for UPDATE statements, that is a combination of read committed and consistent read. When an UPDATE statement examines a row that is already locked, InnoDB returns the latest committed version to MySQL so that MySQL can determine whether the row matches the WHERE condition of the UPDATE. If the row matches (must be updated), MySQL reads the row again, and this time InnoDB either locks it or waits for a lock on it. This type of read operation can only happen when the transaction has the read committed isolation level, or when the innodb_locks_unsafe_for_binlog option is enabled.</p>
</blockquote>
<p>简单来说，semi-consistent read是read committed与consistent read两者的结合。一个update语句，如果读到一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足 update的where条件。若满足(需要更新)，则MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)。semi-consistent read只会发生在read committed隔离级别下，或者是参数<code>innodb_locks_unsafe_for_binlog</code>被设置为true(该参数即将被废弃)。</p>
<p>对比RR隔离级别，update语句会使用当前读，如果一行被锁定了，那么此时会被阻塞，发生锁等待。而不会读取最新的提交版本，然后来判断是否符合where条件。</p>
<p>半一致性读的优点：</p>
<p>减少了update语句时行锁的冲突；对于不满足update更新条件的记录，可以提前放锁，减少并发冲突的概率。</p>
<p>具体可以<a href="http://hedengcheng.com/?p=220" target="_blank" rel="noopener">参见</a>：</p>
<p>Oracle中的update好像有“重启动”的概念。</p>
<h2 id="MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁"><a href="#MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁" class="headerlink" title="MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁"></a>MySQL间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的SQL语句，死锁发生了如何解决，MySQL有没有提供什么机制去解决死锁</h2><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>之前我们介绍了排他锁，其实innodb下的记录锁（也叫行锁），间隙锁，next-key锁统统属于排他锁。</p>
<p>行锁<br>记录锁其实很好理解，对表中的记录加锁，叫做记录锁，简称行锁。</p>
<p>生活中的间隙锁<br>编程的思想源于生活，生活中的例子能帮助我们更好的理解一些编程中的思想。<br>生活中排队的场景，小明，小红，小花三个人依次站成一排，此时，如何让新来的小刚不能站在小红旁边，这时候只要将小红和她前面的小明之间的空隙封锁，将小红和她后面的小花之间的空隙封锁，那么小刚就不能站到小红的旁边。<br>这里的小红，小明，小花，小刚就是数据库的一条条记录。<br>他们之间的空隙也就是间隙，而封锁他们之间距离的锁，叫做间隙锁。</p>
<p>Mysql中的间隙锁<br>下表中（见图一），id为主键，number字段上有非唯一索引的二级索引，有什么方式可以让该表不能再插入number=5的记录？<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-ad0d50c44dc041be.png" alt="image"></p>
<p>图一<br>根据上面生活中的例子，我们自然而然可以想到，只要控制几个点，number=5之前不能插入记录，number=5现有的记录之间不能再插入新的记录，number=5之后不能插入新的记录，那么新的number=5的记录将不能被插入进来。</p>
<p>那么，mysql是如何控制number=5之前，之中，之后不能有新的记录插入呢（防止幻读）？<br>答案是用间隙锁，在RR级别下，mysql通过间隙锁可以实现锁定number=5之前的间隙，number=5记录之间的间隙，number=5之后的间隙，从而使的新的记录无法被插入进来。</p>
<p>间隙是怎么划分的？</p>
<p>注：为了方面理解，我们规定（id=A,number=B）代表一条字段id=A,字段number=B的记录，（C，D）代表一个区间，代表C-D这个区间范围。</p>
<p>图一中，根据number列，我们可以分为几个区间：（无穷小，2），（2，4），（4，5），（5，5），（5,11），（11，无穷大）。<br>只要这些区间对应的两个临界记录中间可以插入记录，就认为区间对应的记录之间有间隙。<br>例如：区间（2，4）分别对应的临界记录是（id=1,number=2），（id=3，number=4），这两条记录中间可以插入（id=2,number=3）等记录，那么就认为（id=1,number=2）与（id=3，number=4）之间存在间隙。</p>
<p>很多人会问，那记录（id=6，number=5）与（id=8，number=5）之间有间隙吗？<br>答案是有的，（id=6，number=5）与（id=8，number=5）之间可以插入记录（id=7，number=5），因此（id=6,number=5）与（id=8,number=5）之间有间隙的，</p>
<p>间隙锁锁定的区域<br>根据检索条件向左寻找最靠近检索条件的记录值A，作为左区间，向右寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为（A，B）。<br>图一中，where number=5的话，那么间隙锁的区间范围为（4,11）；</p>
<p>间隙锁的目的是为了防止幻读，其主要通过两个方面实现这个目的：<br>（1）防止间隙内有新数据被插入<br>（2）防止已存在的数据，更新成间隙内的数据（例如防止numer=3的记录通过update变成number=5）</p>
<p>innodb自动使用间隙锁的条件：<br>（1）必须在RR级别下<br>（2）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）</p>
<p>接下来，通过实际操作观察下间隙锁的作用范围</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-ad0d50c44dc041be.png" alt="image"></p>
<h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line"></span><br><span class="line">session 2:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">4</span>);#（阻塞）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">2</span>);#（阻塞）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">4</span>);#（阻塞）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">5</span>);#（阻塞）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">7</span>,<span class="number">5</span>);#（执行成功）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">9</span>,<span class="number">5</span>);#（执行成功）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">11</span>,<span class="number">5</span>);#（执行成功）</span><br></pre></td></tr></table></figure>
<p>检索条件number=4,向左取得最靠近的值2作为左区间，向右取得最靠近的5作为右区间，因此，session 1的间隙锁的范围（2，4），（4，5），如下图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-b1ddc3677c81c9b5.png" alt="image"></p>
<p>间隙锁锁定的区间为（2，4），（4，5），即记录（id=1,number=2）和记录（id=3,number=4）之间间隙会被锁定，记录（id=3,number=4）和记录（id=6,number=5）之间间隙被锁定。</p>
<p>因此记录（id=2,number=4），（id=2,number=2），（id=4,number=4），（id=4,number=5）正好处在（id=3,number=4）和（id=6,number=5）之间，所以插入不了，需要等待锁的释放，而记录(id=7,number=5)，（id=9,number=5），（id=11,number=5）不在上述锁定的范围内，因此都会插入成功。</p>
<h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">13</span> <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line"></span><br><span class="line">session 2:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">11</span>,<span class="number">5</span>);#(执行成功)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">12</span>,<span class="number">11</span>);#(执行成功)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">14</span>,<span class="number">11</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">15</span>,<span class="number">12</span>);#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">14</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">11</span>;#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">11</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">11</span>;#(执行成功)</span><br></pre></td></tr></table></figure>
<p>检索条件number=13,向左取得最靠近的值11作为左区间，向右由于没有记录因此取得无穷大作为右区间，因此，session 1的间隙锁的范围（11，无穷大），如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-1f499d02104728e0.png" alt="image"></p>
<p>此表中没有number=13的记录的，innodb依然会为该记录左右两侧加间隙锁，间隙锁的范围（11，无穷大）。</p>
<p>有人会问，为啥update news set id=14 where number=11会阻塞，但是update news set id=11 where number=11却执行成功呢？</p>
<p>间隙锁采用在指定记录的前面和后面以及中间的间隙上加间隙锁的方式避免数据被插入，此图间隙锁锁定的区域是（11，无穷大），也就是记录（id=13,number=11）之后不能再插入记录，update news set id=14 where number=11这条语句如果执行的话，将会被插入到（id=13,number=11）的后面，也就是在区间（11，无穷大）之间，由于该区间被间隙锁锁定，所以只能阻塞等待，而update news set id=11 where number=11执行后是会被插入到（id=13,number=11）的记录前面，也就不在（11，无穷大）的范围内，所以无需等待，执行成功。</p>
<h4 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">session 2:</span><br><span class="line">start  transaction ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">4</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">5</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">5</span>,<span class="number">5</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">7</span>,<span class="number">11</span>);#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">9</span>,<span class="number">12</span>);#(执行成功)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">12</span>,<span class="number">11</span>);#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> <span class="keyword">number</span>=<span class="number">5</span> <span class="keyword">where</span> id=<span class="number">1</span>;#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">11</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">11</span>;#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> ;#（执行成功）</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">4</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> ;#（阻塞）</span><br></pre></td></tr></table></figure>
<p>检索条件number=5,向左取得最靠近的值4作为左区间，向右取得11为右区间，因此，session 1的间隙锁的范围（4，5），（5，11），如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-35dc3a0aed8a0f9a.png" alt="image"></p>
<p>有人会问，为啥<code>insert into news value(9,12)</code>会执行成功？间隙锁采用在指定记录的前面和后面以及中间的间隙上加间隙锁的方式避免数据被插入，（id=9,number=12）很明显在记录（13,11）的后面，因此不再锁定的间隙范围内。</p>
<p>为啥u<code>pdate news set number=5 where id=1</code>会阻塞？<br>number=5的记录的前面，后面包括中间都被封锁了，你这个update news set number=5 where id=1根本没法执行，因为innodb已经把你可以存放的位置都锁定了，因为只能等待。</p>
<p>同理，<code>update news set id=11 where number=11</code>由于记录（id=10,number=5）与记录（id=13,number=11）中间的间隙被封锁了，你这句sql也没法执行，必须等待，因为存放的位置被封锁了。</p>
<h4 id="案例四"><a href="#案例四" class="headerlink" title="案例四"></a>案例四</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">start  transaction;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">number</span>&gt;<span class="number">4</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">session 2:</span><br><span class="line">start  transaction;</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> ;#(执行成功)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">4</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">4</span> ;#(阻塞)</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> id=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">number</span>=<span class="number">5</span> ;#(阻塞)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">3</span>);#(执行成功)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="literal">null</span>,<span class="number">13</span>);#(阻塞)</span><br></pre></td></tr></table></figure>
<p>检索条件number&gt;4,向左取得最靠近的值4作为左区间，向右取无穷大，因此，session 1的间隙锁的范围（4，无穷大），如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2604566-3e7aaef9e3865926.png" alt="image"></p>
<p>session2中之所以有些阻塞，有些执行成功，其实就是因为插入的区域被锁定，从而阻塞。</p>
<p>next-key锁</p>
<p>next-key锁其实包含了记录锁和间隙锁，即锁定一个范围，并且锁定记录本身，InnoDB默认加锁方式是next-key 锁。<br>上面的案例一session 1中的sql是：select * from news where number=4 for update ;<br>next-key锁锁定的范围为间隙锁+记录锁，即区间（2，4），（4，5）加间隙锁，同时number=4的记录加记录锁。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>MySQL有三种锁的级别：页级、表级、行级。</p>
<p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p>
<p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p>
<p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<p>算法：</p>
<p>next KeyLocks锁，同时锁住记录(数据)，并且锁住记录前面的Gap<br>Gap锁，不锁记录，仅仅记录前面的Gap</p>
<p>Recordlock锁（锁数据，不锁Gap）</p>
<p>所以其实 Next-KeyLocks=Gap锁+ Recordlock锁</p>
<h5 id="什么情况下会造成死锁"><a href="#什么情况下会造成死锁" class="headerlink" title="什么情况下会造成死锁"></a>什么情况下会造成死锁</h5><p>所谓死锁<code>&lt;DeadLock&gt;</code>: 是指两个或两个以上的进程在执行过程中,<br>因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.<br>此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程.<br>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.</p>
<p>死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。</p>
<p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序</p>
<h4 id="一些常见的死锁案例"><a href="#一些常见的死锁案例" class="headerlink" title="一些常见的死锁案例"></a>一些常见的死锁案例</h4><h5 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h5><p>需求：将投资的钱拆成几份随机分配给借款人。</p>
<p>起初业务程序思路是这样的：</p>
<p>投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条<code>select for update</code> 去更新借款人表里面的余额等。</p>
<p>抽象出来就是一个session通过for循环会有几条如下的语句：<br><code>Select * from xxx where id=&#39;随机id&#39; for update</code></p>
<p>基本来说，程序开启后不一会就死锁。<br>这可以是说最经典的死锁情形了。</p>
<p>例如两个用户同时投资，A用户金额随机分为2份，分给借款人1，2<br>B用户金额随机分为2份，分给借款人2，1由于加锁的顺序不一样，死锁当然很快就出现了。</p>
<p>对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。</p>
<p><code>Select * from xxx where id in (xx,xx,xx) for update</code></p>
<p>在in里面的列表值mysql是会自动从小到大排序，加锁也是一条条从小到大加的锁<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">例如（以下会话<span class="built_in">id</span>为主键）：</span><br><span class="line"></span><br><span class="line">Session1:</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (<span class="number">8</span>,<span class="number">9</span>) <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">| <span class="built_in">id</span> | course | <span class="built_in">name</span> | ctime               |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">|  <span class="number">8</span> | WA     | f    | <span class="number">2016</span><span class="number">-03</span><span class="number">-02</span> <span class="number">11</span>:<span class="number">36</span>:<span class="number">30</span> |</span><br><span class="line"></span><br><span class="line">|  <span class="number">9</span> | JX     | f    | <span class="number">2016</span><span class="number">-03</span><span class="number">-01</span> <span class="number">11</span>:<span class="number">36</span>:<span class="number">30</span> |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line">rows <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session2:</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (<span class="number">10</span>,<span class="number">8</span>,<span class="number">5</span>) <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">锁等待中……</span><br><span class="line"></span><br><span class="line">其实这个时候<span class="built_in">id</span>=<span class="number">10</span>这条记录没有被锁住的，但<span class="built_in">id</span>=<span class="number">5</span>的记录已经被锁住了，锁的等待在<span class="built_in">id</span>=<span class="number">8</span>的这里。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">不信请看</span><br><span class="line"></span><br><span class="line">Session3:</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span>=<span class="number">5</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">锁等待中</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session4:</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span>=<span class="number">10</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">| <span class="built_in">id</span> | course | <span class="built_in">name</span> | ctime               |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">| <span class="number">10</span> | JB     | g    | <span class="number">2016</span><span class="number">-03</span><span class="number">-10</span> <span class="number">11</span>:<span class="number">45</span>:<span class="number">05</span> |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line">row <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">在其它session中<span class="built_in">id</span>=<span class="number">5</span>是加不了锁的，但是<span class="built_in">id</span>=<span class="number">10</span>是可以加上锁的。</span><br></pre></td></tr></table></figure></p>
<h5 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h5><p>在开发中，经常会做这类的判断需求：根据字段值查询（有索引），如果不存在，则插入；否则更新。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">以id为主键为例，目前还没有id=22的行</span><br><span class="line"></span><br><span class="line">Session1:</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">22</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">session2:</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">23</span>  <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session1:</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t3 <span class="keyword">values</span>(<span class="number">22</span>,<span class="string">'ac'</span>,<span class="string">'a'</span>,<span class="keyword">now</span>());</span><br><span class="line"></span><br><span class="line">锁等待中……</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session2:</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t3 <span class="keyword">values</span>(<span class="number">23</span>,<span class="string">'bc'</span>,<span class="string">'b'</span>,<span class="keyword">now</span>());</span><br><span class="line"></span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get <span class="keyword">lock</span>; try restarting transaction</span><br></pre></td></tr></table></figure>
<p>当对存在的行进行锁的时候(主键)，mysql就只有行锁。</p>
<p>当对未存在的行进行锁的时候(即使条件为主键)，mysql是会锁住一段范围（有gap锁）</p>
<p>锁住的范围为：</p>
<p>(无穷小或小于表中锁住id的最大值，无穷大或大于表中锁住id的最小值)</p>
<p>如：如果表中目前有已有的id为（11 ， 12）</p>
<p>那么就锁住（12，无穷大）</p>
<p>如果表中目前已有的id为（11 ， 30）</p>
<p>那么就锁住（11，30）</p>
<p>对于这种死锁的解决办法是：</p>
<p><code>insert into t3(xx,xx) on duplicate key update `xx`=&#39;XX&#39;;</code></p>
<p>用mysql特有的语法来解决此问题。因为insert语句对于主键来说，插入的行不管有没有存在，都会只有行锁。</p>
<h5 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span>=<span class="number">9</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">| <span class="built_in">id</span> | course | <span class="built_in">name</span> | ctime               |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line"></span><br><span class="line">|  <span class="number">9</span> | JX     | f    | <span class="number">2016</span><span class="number">-03</span><span class="number">-01</span> <span class="number">11</span>:<span class="number">36</span>:<span class="number">30</span> |</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+--------+------+---------------------+</span></span><br><span class="line">row <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session2:</span><br><span class="line"></span><br><span class="line">mysql&gt; select * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="built_in">id</span>&lt;<span class="number">20</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">锁等待中</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Session1:</span><br><span class="line"></span><br><span class="line">mysql&gt; insert <span class="keyword">into</span> t3 values(<span class="number">7</span>,'ae','a',now());</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock found when trying <span class="keyword">to</span> <span class="keyword">get</span> lock; <span class="keyword">try</span> restarting <span class="keyword">transaction</span></span><br></pre></td></tr></table></figure>
<p>这个跟案例一其它是差不多的情况，只是session1不按常理出牌了，</p>
<p>Session2在等待Session1的id=9的锁，session2又持了1到8的锁（注意9到19的范围并没有被session2锁住），最后，session1在插入新行时又得等待session2,故死锁发生了。</p>
<p>这种一般是在业务需求中基本不会出现，因为你锁住了id=9，却又想插入id=7的行，这就有点跳了，当然肯定也有解决的方法，那就是重理业务需求，避免这样的写法。</p>
<h2 id="有两个表，table-a，table-b，写SQL查询出仅在table-a中的数据、仅在table-b中的数据、既在table-a-又在table-b-中的数据？"><a href="#有两个表，table-a，table-b，写SQL查询出仅在table-a中的数据、仅在table-b中的数据、既在table-a-又在table-b-中的数据？" class="headerlink" title="有两个表，table a，table b，写SQL查询出仅在table a中的数据、仅在table b中的数据、既在table a 又在table b 中的数据？"></a>有两个表，table a，table b，写SQL查询出仅在table a中的数据、仅在table b中的数据、既在table a 又在table b 中的数据？</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/05/18/面试分享(二).框架相关(Spring)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/18/面试分享(二).框架相关(Spring)/" itemprop="url">面试分享(二).框架相关(Spring)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T18:33:00+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/05/18/面试分享(二).框架相关(Spring)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/05/18/面试分享(二).框架相关(Spring)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="框架相关（Spring）"><a href="#框架相关（Spring）" class="headerlink" title="框架相关（Spring）"></a>框架相关（Spring）</h1><h2 id="Spring源码看过没有，会多少讲多少？"><a href="#Spring源码看过没有，会多少讲多少？" class="headerlink" title="Spring源码看过没有，会多少讲多少？"></a>Spring源码看过没有，会多少讲多少？</h2><p>灵魂问题，，，自己发挥</p>
<h3 id="各个组件"><a href="#各个组件" class="headerlink" title="各个组件"></a>各个组件</h3><h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><p>是对资源的抽象，每一个接口实现类都代表了一种资源类型，如 ClasspathResource 、 URLResource ， FileSystemResource 等。每一个资源类型都封装了对某一种特定资源的访问策略。它是 spring 资源访问策略的一个基础实现，应用在很多场景。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/ead09fcb-3c6c-3740-9e36-6de33fd65cca.jpg" alt="image"></p>
<h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p>用来抽象和描述一个具体 bean 对象。是描述一个 bean 对象的基本数据结构。</p>
<h4 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h4><p>BeanDefinitionReader 将外部资源对象描述的 bean 定义统一转化为统一的内部数据结构 BeanDefinition 。对应不同的描述需要有不同的 Reader 。如 XmlBeanDefinitionReader 用来读取 xml 描述配置的 bean 对象。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/c4143d16-02e2-3d7b-9734-4d19a9a984dd.jpg" alt="image"></p>
<h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>用来定义一个很纯粹的 bean 容器。它是一个 bean 容器的必备结构。同时和外部应用环境等隔离。 BeanDefinition 是它的基本数据结构。它维护一个 BeanDefinitions Map, 并可根据 BeanDefinition 的描述进行 bean 的创建和管理。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/24095923-75cd-363b-bc2f-9fbc603c341f.jpg" alt="image"></p>
<h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>从名字来看叫应用上下文，是和应用环境息息相关的。没错这个就是我们平时开发中经常直接使用打交道的一个类，应用上下文，或者也叫做 spring 容器。其实它的基本实现是会持有一个 BeanFactory 对象，并基于此提供一些包装和功能扩展。为什么要这么做呢？因为 BeanFactory 实现了一个容器基本结构和功能，但是与外部环境隔离。那么读取配置文件，并将配置文件解析成 BeanDefinition ，然后注册到 BeanFactory 的这一个过程的封装自然就需要 ApplicationContext 。 ApplicationContext 和应用环境细细相关，常见实现有 <code>ClasspathXmlApplicationContext</code>,<code>FileSystemXmlApplicationContext</code>,<code>WebApplicationContext</code> 等。 Classpath 、 xml 、 FileSystem 、 Web 等词都代表了应用和环境相关的一些意思，从字面上不难理解各自代表的含义。</p>
<p>当然 ApplicationContext 和 BeanFactory 的区别远不止于此，有：</p>
<ol>
<li><p>资源访问功能：在 Resource 和 ResourceLoader 的基础上可以灵活的访问不同的资源。</p>
</li>
<li><p>支持不同的信息源。</p>
</li>
<li><p>支持应用事件：继承了接口 ApplicationEventPublisher ，这样在上下文中为 bean 之间提供了事件机制。</p>
</li>
</ol>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/c456f949-7b9c-34db-ad1a-ca3141219b6d.jpg" alt="image"></p>
<p>以上 5 个组件基本代表了 ioc 容器的一个最基本组成，而组件的组合是放在 ApplicationContext 的实现这一层来完成。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/d9a0e8c8-29d6-36a3-888e-e22c2d1bb44f.jpg" alt="image"><br>左边黄色部分是 ApplicationContext 体系继承结构，右边是 BeanFactory 的结构体系,两个结构是典型模板方法设计模式的使用。</p>
<p>从该继承体系可以看出：</p>
<ol>
<li><p>BeanFactory 是一个 bean 工厂的最基本定义，里面包含了一个 bean 工厂的几个最基本的方法， getBean(…) 、 containsBean(…) 等 ,是一个很纯粹的bean工厂，不关注资源、资源位置、事件等。 ApplicationContext 是一个容器的最基本接口定义，它继承了 BeanFactory, 拥有工厂的基本方法。同时继承了 ApplicationEventPublisher 、 MessageSource 、 ResourcePatternResolver 等接口，使其 定义了一些额外的功能，如资源、事件等这些额外的功能。</p>
</li>
<li><p>AbstractBeanFactory 和 AbstractAutowireCapableBeanFactory 是两个模板抽象工厂类。 AbstractBeanFactory 提供了 bean 工厂的抽象基类，同时提供了 ConfigurableBeanFactory 的完整实现。 AbstractAutowireCapableBeanFactory 是继承了 AbstractBeanFactory 的抽象工厂，里面提供了 bean 创建的支持，包括 bean 的创建、依赖注入、检查等等功能，是一个核心的 bean 工厂基类。</p>
</li>
<li><p>ClassPathXmlApplicationContext之 所以拥有 bean 工厂的功能是通过持有一个真正的 bean 工厂 DefaultListableBeanFactory 的实例，并通过 代理 该工厂完成。</p>
</li>
<li><p>ClassPathXmlApplicationContext 的初始化过程是对本身容器的初始化同时也是对其持有的 DefaultListableBeanFactory 的初始化。</p>
</li>
</ol>
<h3 id="容器初始化过程"><a href="#容器初始化过程" class="headerlink" title="容器初始化过程"></a>容器初始化过程</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/370101b5-b3d1-3b79-b9b2-3bba91d092d7.jpg" alt="image"><br>整个过程可以理解为是容器的初始化过程。第一个过程是 ApplicationContext 的职责范围，第二步是 BeanFactory 的职责范围。可以看出 ApplicationContext 是一个运行时的容器需要提供不容资源环境的支持，屏蔽不同环境的差异化。而 BeanDifinition 是内部关于 bean 定义的基本结构。 Bean 的创建就是基于它，回头会介绍一下改结构的定义。下面看一下整个容器的初始化过程。</p>
<p>容器的初始化是通过调用 refresh() 来实现。该方法是非常重要的一个方法，定义在 AbstractApplicationContext 接口里。 AbstractApplicationContext 是容器的最基础的一个抽象父类。也就是说在该里面定义了一个容器初始化的基本流程，流程里的各个方法有些有提供了具体实现，有些是抽象的 ( 因为不同的容器实例不一样 ) ，由继承它的每一个具体容器完成定制。看看 refresh 的基本流程：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;  </span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.  </span></span><br><span class="line">        prepareRefresh();  </span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.  </span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();  </span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.  </span></span><br><span class="line">        prepareBeanFactory(beanFactory);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.  </span></span><br><span class="line">            postProcessBeanFactory(beanFactory);  </span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.  </span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);  </span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.  </span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);  </span><br><span class="line">            <span class="comment">// Initialize message source for this context.  </span></span><br><span class="line">            initMessageSource();  </span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.  </span></span><br><span class="line">            initApplicationEventMulticaster();  </span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.  </span></span><br><span class="line">            onRefresh();  </span><br><span class="line">            <span class="comment">// Check for listener beans and register them.  </span></span><br><span class="line">            registerListeners();  </span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.  </span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);  </span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.  </span></span><br><span class="line">            finishRefresh();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.  </span></span><br><span class="line">            beanFactory.destroySingletons();  </span><br><span class="line">            <span class="comment">// Reset 'active' flag.  </span></span><br><span class="line">            cancelRefresh(ex);  </span><br><span class="line">            <span class="comment">// Propagate exception to caller.  </span></span><br><span class="line">            <span class="keyword">throw</span> ex;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2187e288-5c0b-313b-8053-82992267fab6.jpg" alt="image"></p>
<h3 id="Bean-的创建过程"><a href="#Bean-的创建过程" class="headerlink" title="Bean 的创建过程"></a>Bean 的创建过程</h3><p>Bean的创建过程基本是BeanFactory所要完成的事情.</p>
<p>根据以上过程，将会重点带着以下两个个问题来理解核心代码：</p>
<p>1.Bean 的创建时机</p>
<p>bean 是在什么时候被创建的，有哪些规则。</p>
<p>2.Bean 的创建过程</p>
<p>bean 是怎么创建的，会选择哪个构造函数？依赖如何注入？ InitializingBean 的 set 方法什么时候被调用？实现 ApplicationContextAware, BeanFactoryAware,BeanNameAware, ResourceLoaderAware 这些接口的 bean 的 set 方法何时被调用？</p>
<p>在解释这两个问题前，先看一下 BeanDefinition 接口的定义。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2beb44aa-4b38-3d87-a444-308d8f380e87.jpg" alt="image"></p>
<p>从该接口定义可以看出，通过 bean 定义能够得到 bean 的详细信息，如类名子、工厂类名称、 scope 、是否单例、是否抽象、是否延迟加载等等。基于此，来看一下以下两个问题：</p>
<h4 id="问题-1-：-Bean-的创建时机"><a href="#问题-1-：-Bean-的创建时机" class="headerlink" title="问题 1 ： Bean 的创建时机"></a>问题 1 ： Bean 的创建时机</h4><p>bean 是在什么时候被创建的，有哪些规则？</p>
<p>容器初始化的时候会预先对单例和非延迟加载的对象进行预先初始化。其他的都是延迟加载是在第一次调用 getBean 的时候被创建。从 DefaultListableBeanFactory 的 preInstantiateSingletons 里可以看到这个规则的实现。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> void preInstantiateSingletons() throws <span class="keyword">BeansException </span>&#123;  </span><br><span class="line">    <span class="meta">if</span> (this.logger.isInfoEnabled()) &#123;  </span><br><span class="line">        this.logger.info(<span class="string">"Pre-instantiating singletons in "</span> + this)<span class="comment">;  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    synchronized (this.<span class="keyword">beanDefinitionMap) </span>&#123;  </span><br><span class="line">        for (<span class="keyword">Iterator </span><span class="keyword">it </span>= this.<span class="keyword">beanDefinitionNames.iterator(); </span><span class="keyword">it.hasNext();) </span>&#123;  </span><br><span class="line">            <span class="keyword">String </span><span class="keyword">beanName </span>= (<span class="keyword">String) </span><span class="keyword">it.next(); </span> </span><br><span class="line">            RootBeanDefinition <span class="keyword">bd </span>= getMergedLocalBeanDefinition(<span class="keyword">beanName); </span> </span><br><span class="line">            <span class="meta">if</span> (!<span class="keyword">bd.isAbstract() </span>&amp;&amp; <span class="keyword">bd.isSingleton() </span>&amp;&amp; !<span class="keyword">bd.isLazyInit()) </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//对非抽象、单例的和非延迟加载的对象进行实例化。  </span><br><span class="line">                <span class="meta">if</span> (isFactoryBean(<span class="keyword">beanName)) </span>&#123;  </span><br><span class="line">                    FactoryBean factory = (FactoryBean) getBean(FACTORY_BEAN_PREFIX + <span class="keyword">beanName); </span> </span><br><span class="line">                    <span class="meta">if</span> (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean) factory).isEagerInit()) &#123;  </span><br><span class="line">                        getBean(<span class="keyword">beanName); </span> </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="meta">else</span> &#123;  </span><br><span class="line">                    getBean(<span class="keyword">beanName); </span> </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面来看对于以下配置，只有 singletonBean 会被预先创建。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"GB2312"</span><span class="meta">?&gt;</span></span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"otherBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.OtherBean"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.MyBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"singletonBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.SingletonBean"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="问题二：Bean-的创建过程"><a href="#问题二：Bean-的创建过程" class="headerlink" title="问题二：Bean 的创建过程"></a>问题二：Bean 的创建过程</h4><p>对于 bean 的创建过程其实都是通过调用工厂的 getBean 方法来完成的。这里面将会完成对构造函数的选择、依赖注入等。</p>
<p>无论预先创建还是延迟加载都是调用getBean实现，AbstractBeanFactory 定义了 getBean 的过程：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> doGetBean(  </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> name, <span class="keyword">final</span> Class requiredType, <span class="keyword">final</span> <span class="keyword">Object</span>[] args, <span class="built_in">boolean</span> typeCheckOnly) <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span> beanName = transformedBeanName(name);  </span><br><span class="line">    <span class="keyword">Object</span> bean = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.  </span></span><br><span class="line">    <span class="keyword">Object</span> sharedInstance = getSingleton(beanName);  </span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;  </span><br><span class="line">                logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +  </span><br><span class="line">                        <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// Fail if we're already creating this bean instance:  </span></span><br><span class="line">        <span class="comment">// We're assumably within a circular reference.  </span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if bean definition exists in this factory.  </span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();  </span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;  </span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.  </span></span><br><span class="line">            <span class="keyword">String</span> nameToLookup = originalBeanName(name);  </span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.  </span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, args);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.  </span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;  </span><br><span class="line">            markBeanAsCreated(beanName);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);  </span><br><span class="line">        checkMergedBeanDefinition(mbd, beanName, args);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Guarantee initialization of beans that the current bean depends on.  </span></span><br><span class="line">        <span class="keyword">String</span>[] dependsOn = mbd.getDependsOn();  </span><br><span class="line">        <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dependsOn.length; i++) &#123;  </span><br><span class="line">                <span class="keyword">String</span> dependsOnBean = dependsOn[i];  </span><br><span class="line">                getBean(dependsOnBean);  </span><br><span class="line">                registerDependentBean(dependsOnBean, beanName);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// Create bean instance.  </span></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;<span class="comment">//单例对象创建过程,间接通过getSingleton方法来创建，里面会实现将单例对象缓存 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">Object</span> getObject() <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">                        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there  </span></span><br><span class="line">                        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.  </span></span><br><span class="line">                        <span class="comment">// Also remove any beans that received a temporary reference to the bean.  </span></span><br><span class="line">                        destroySingleton(beanName);  </span><br><span class="line">                        <span class="keyword">throw</span> ex;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;<span class="comment">//非单例对象创建</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// It's a prototype -&gt; create a new instance.  </span></span><br><span class="line">            <span class="keyword">Object</span> prototypeInstance = <span class="keyword">null</span>;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                beforePrototypeCreation(beanName);  </span><br><span class="line">                prototypeInstance = createBean(beanName, mbd, args);<span class="comment">//直接调用createBean</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">finally</span> &#123;  </span><br><span class="line">                afterPrototypeCreation(beanName);  </span><br><span class="line">            &#125;  </span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">String</span> scopeName = mbd.getScope();  </span><br><span class="line">            <span class="keyword">final</span> Scope scope = (Scope) <span class="keyword">this</span>.scopes.<span class="built_in">get</span>(scopeName);  </span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope '"</span> + scopeName + <span class="string">"'"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">Object</span> scopedInstance = scope.<span class="built_in">get</span>(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">Object</span> getObject() <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">                        beforePrototypeCreation(beanName);  </span><br><span class="line">                        <span class="keyword">try</span> &#123;  </span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">finally</span> &#123;  </span><br><span class="line">                            afterPrototypeCreation(beanName);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;);  </span><br><span class="line">                bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,  </span><br><span class="line">                        <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; "</span> +  </span><br><span class="line">                        <span class="string">"consider defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,  </span><br><span class="line">                        ex);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Check if required type matches the type of the actual bean instance.  </span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> bean;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GetBean 的大概过程：</p>
<p>1.先试着从单例缓存对象里获取。</p>
<p>2.从父容器里取定义，有则由父容器创建。</p>
<p>3.如果是单例，则走单例对象的创建过程：在 spring 容器里单例对象和非单例对象的创建过程是一样的。都会调用父类 AbstractAutowireCapableBeanFactory 的 createBean 方法。 不同的是单例对象只创建一次并且需要缓存起来。 DefaultListableBeanFactory 的父类 DefaultSingletonBeanRegistry 提供了对单例对象缓存等支持工作。所以是单例对象的话会调用 DefaultSingletonBeanRegistry 的 getSingleton 方法，它会间接调用 AbstractAutowireCapableBeanFactory 的 createBean 方法。</p>
<p>如果是 Prototype 多例则直接调用父类 AbstractAutowireCapableBeanFactory 的 createBean 方法。</p>
<p>bean的创建是由AbstractAutowireCapableBeanFactory来定义：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> createBean(<span class="keyword">final</span> <span class="keyword">String</span> beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="keyword">Object</span>[] args)  </span><br><span class="line">            <span class="keyword">throws</span> BeanCreationException &#123;  </span><br><span class="line">    AccessControlContext acc = AccessController.getContext();  </span><br><span class="line">    <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">Object</span> run() &#123;  </span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// Make sure bean class is actually resolved at this point.  </span></span><br><span class="line">            resolveBeanClass(mbd, beanName);  </span><br><span class="line">            <span class="comment">// Prepare method overrides.  </span></span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                mbd.prepareMethodOverrides();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(),  </span><br><span class="line">                        beanName, <span class="string">"Validation of method overrides failed"</span>, ex);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.  </span></span><br><span class="line">                <span class="keyword">Object</span> bean = resolveBeforeInstantiation(beanName, mbd);  </span><br><span class="line">                <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    <span class="keyword">return</span> bean;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,  </span><br><span class="line">                        <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">Object</span> beanInstance = doCreateBean(beanName, mbd, args);  </span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> beanInstance;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;, acc);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>createBean 会调用 doCreateBean 方法：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> doCreateBean(<span class="keyword">final</span> <span class="keyword">String</span> beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="keyword">Object</span>[] args) &#123;  </span><br><span class="line">    <span class="comment">// Instantiate the bean.  </span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;  </span><br><span class="line">        instanceWrapper = (BeanWrapper) <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">Object</span> bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);  </span><br><span class="line">    Class beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.  </span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;  </span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);  </span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references  </span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.  </span></span><br><span class="line">    <span class="built_in">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;  </span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));  </span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +  </span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">Object</span> getObject() <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">                <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Initialize the bean instance.  </span></span><br><span class="line">    <span class="keyword">Object</span> exposedObject = bean;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);  </span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;  </span><br><span class="line">        <span class="keyword">Object</span> earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);  </span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;  </span><br><span class="line">                exposedObject = earlySingletonReference;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;  </span><br><span class="line">                <span class="keyword">String</span>[] dependentBeans = getDependentBeans(beanName);  </span><br><span class="line">                Set actualDependentBeans = <span class="keyword">new</span> LinkedHashSet(dependentBeans.length);  </span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dependentBeans.length; i++) &#123;  </span><br><span class="line">                    <span class="keyword">String</span> dependentBean = dependentBeans[i];  </span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;                         actualDependentBeans.<span class="built_in">add</span>(dependentBean);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;  </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,  </span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +  </span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +  </span><br><span class="line">                            <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +  </span><br><span class="line">                            <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +  </span><br><span class="line">                            <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +  </span><br><span class="line">                            <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Register bean as disposable.  </span></span><br><span class="line">    registerDisposableBeanIfNecessary(beanName, bean, mbd);  </span><br><span class="line">    <span class="keyword">return</span> exposedObject;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>doCreateBean 的流程：</p>
<p>1.会创建一个 BeanWrapper 对象 用于存放实例化对象。</p>
<p>2.如果没有指定构造函数，会通过反射拿到一个默认的构造函数对象，并赋予 beanDefinition.resolvedConstructorOrFactoryMethod 。</p>
<p>3.调用 spring 的 BeanUtils 的 instantiateClass 方法，通过反射创建对象。</p>
<p>4.applyMergedBeanDefinitionPostProcessors</p>
<p>5.populateBean(beanName, mbd, instanceWrapper); 根据注入方式进行注入。根据是否有依赖检查进行依赖检查。</p>
<p>执行 bean 的注入里面会选择注入类型：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||  </span><br><span class="line">                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </span><br><span class="line">    MutablePropertyValues <span class="keyword">new</span><span class="type">Pvs</span> = <span class="keyword">new</span> <span class="type">MutablePropertyValues</span>(pvs);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add property values based on autowire by name if applicable.  </span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;  </span><br><span class="line">        autowireByName(beanName, mbd, bw, <span class="keyword">new</span><span class="type">Pvs</span>);  </span><br><span class="line">    &#125;<span class="comment">//根据名字注入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add property values based on autowire by type if applicable.  </span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </span><br><span class="line">        autowireByType(beanName, mbd, bw, <span class="keyword">new</span><span class="type">Pvs</span>);  </span><br><span class="line">    &#125;<span class="comment">//根据类型注入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pvs = <span class="keyword">new</span><span class="type">Pvs</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.initializeBean(beanName, exposedObject, mbd);</p>
<p>判断是否实现了 BeanNameAware 、 BeanClassLoaderAware 等 spring 提供的接口，如果实现了，进行默认的注入。同时判断是否实现了 InitializingBean 接口，如果是的话，调用 afterPropertySet 方法。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">protected</span> Object initializeBean(<span class="keyword">String </span><span class="keyword">beanName, </span>Object <span class="keyword">bean, </span>RootBeanDefinition mbd) &#123;  </span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">bean </span>instanceof <span class="keyword">BeanNameAware) </span>&#123;  </span><br><span class="line">        ((<span class="keyword">BeanNameAware) </span><span class="keyword">bean).setBeanName(beanName); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">bean </span>instanceof <span class="keyword">BeanClassLoaderAware) </span>&#123;  </span><br><span class="line">        ((<span class="keyword">BeanClassLoaderAware) </span><span class="keyword">bean).setBeanClassLoader(getBeanClassLoader()); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">bean </span>instanceof <span class="keyword">BeanFactoryAware) </span>&#123;  </span><br><span class="line">        ((<span class="keyword">BeanFactoryAware) </span><span class="keyword">bean).setBeanFactory(this); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">    Object wrappedBean = <span class="keyword">bean; </span> </span><br><span class="line">    <span class="meta">if</span> (mbd == null <span class="title">||</span> !mbd.isSynthetic()) &#123;  </span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, <span class="keyword">beanName); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        invokeInitMethods(<span class="keyword">beanName, </span>wrappedBean, mbd)<span class="comment">;  </span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    catch (Throwable ex) &#123;  </span><br><span class="line">        throw new <span class="keyword">BeanCreationException( </span> </span><br><span class="line">                (mbd != null ? mbd.getResourceDescription() : null),  </span><br><span class="line">                <span class="keyword">beanName, </span><span class="string">"Invocation of init method failed"</span>, ex)<span class="comment">;  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">if</span> (mbd == null <span class="title">||</span> !mbd.isSynthetic()) &#123;  </span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, <span class="keyword">beanName); </span> </span><br><span class="line">    &#125;  </span><br><span class="line">    return wrappedBean<span class="comment">;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中invokeInitMethods实现如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> invokeInitMethods(<span class="keyword">String</span> beanName, <span class="keyword">Object</span> bean, RootBeanDefinition mbd)  </span><br><span class="line">        <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);  </span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            logger.debug(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        ((InitializingBean) bean).afterPropertiesSet();<span class="comment">//调用afterPropertiesSet方法  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">String</span> initMethodName = (mbd != <span class="keyword">null</span> ? mbd.getInitMethodName() : <span class="keyword">null</span>);  </span><br><span class="line">    <span class="keyword">if</span> (initMethodName != <span class="keyword">null</span> &amp;&amp; !(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;  </span><br><span class="line">            !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;  </span><br><span class="line">        invokeCustomInitMethod(beanName, bean, initMethodName, mbd.isEnforceInitMethod());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spring-xml-ioc-容器常用标签和自定义标签"><a href="#Spring-xml-ioc-容器常用标签和自定义标签" class="headerlink" title="Spring  xml ioc 容器常用标签和自定义标签"></a>Spring  xml ioc 容器常用标签和自定义标签</h3><p>以 Xml 资源定义的容器配置是我们最常见的一种方式。</p>
<p>Spring 容器需要解析 xml 的标签，并把 xml 里 bean 的定义转化为内部的结构 BeanDifinition 。</p>
<p>Spring 的标签有很多种，其支持的常见的标签有：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;bean&gt;</code></td>
<td>最常用的，定义一个普通 bean。</td>
<td><code>&lt;bean id=&quot;myBean&quot;          class=&quot;com.test.MyBean&quot; lazy-init=&quot;true&quot;/&gt;</code></td>
</tr>
<tr>
<td><code>&lt;tx&gt;</code></td>
<td>如<code>&lt;tx: advice&gt;</code> 等,提供事务配置通用支持。</td>
<td><code>&lt;tx:advice id=&quot;txAdvice&quot;transaction-manager=&quot;transactionManager&quot;&gt;  &lt;tx:attributes&gt; &lt;tx:method name=&quot;save*&quot;/&gt;  &lt;tx:method name=&quot;remove*&quot;/&gt;   &lt;tx:method name=&quot;*&quot; read-only=&quot;true&quot;/&gt;  &lt;/tx:attributes&gt;  &lt;/tx:advice&gt;</code></td>
</tr>
<tr>
<td><code>&lt;aop&gt;</code></td>
<td><code>&lt;aop:config&gt;</code>,<code>&lt;aop: aspectj-autoproxy&gt;</code> 等提供代理 bean 通用配置支持。</td>
<td><code>&lt;aop:configproxy-target-class=&quot;true&quot;&gt;  &lt;aop:advisor pointcut=&quot;...&quot; advice-ref=&quot;txAdvice&quot;/&gt; &lt;aop:advisorpointcut=&quot;...&quot; advice-ref=&quot;fooAdvice&quot;/&gt;   &lt;/aop:config&gt;</code></td>
</tr>
<tr>
<td><code>&lt;util&gt;</code></td>
<td>提供在容器内配置一些JDK自带的工具类、集合类和常量的支持。</td>
<td><code>&lt;util:list id=&quot;list&quot;list-class=&quot;java.util.ArrayList&quot;&gt;&lt;value&gt;listValue1&lt;/value&gt;   &lt;value&gt;listValue2&lt;/value&gt;  &lt;/util:list&gt;  &lt;util:map id=&quot;map&quot;&gt;  &lt;entry key=&quot;key1&quot;  value=&quot;mapValue1&quot;&gt;&lt;/entry&gt;&lt;entry key=&quot;key12&quot; value=&quot;mapValue2&quot;&gt;&lt;/entry&gt;  &lt;/util:map&gt;</code></td>
</tr>
<tr>
<td><code>&lt;p&gt;</code></td>
<td>属性的简单访问。</td>
<td><code>&lt;bean id=&quot;loginAction&quot; class=&quot;com.test.LoginAction&quot; p:name=&quot;test&quot;&gt;&lt;/bean&gt;</code></td>
</tr>
<tr>
<td><code>&lt;lang&gt;</code></td>
<td><code>&lt;lang:groovy&gt; &lt;lang:jruby&gt;</code>等，提供对动态脚本的支持。</td>
<td><code>&lt;lang:groovy id=&quot;test&quot;  refresh-check-delay=&quot;5000&quot; script-source=&quot;classpath:com/test/groovy/test.groovy&quot;&gt;  &lt;/lang:groovy&gt;</code></td>
</tr>
<tr>
<td><code>&lt;jee&gt;</code></td>
<td><code>&lt;jee:jndi-lookup/&gt;</code>等，对一些javaEE规范的bean配置的简化，如jndi等。</td>
<td><code>&lt;jee:jndi-lookup id=&quot;simple&quot; jndi-name=&quot;jdbc/MyDataSource&quot;    cache=&quot;true&quot;  resource-ref=&quot;true&quot;    lookup-on-startup=&quot;false&quot; expected-type=&quot;com.myapp.DefaultFoo&quot;     proxy-interface=&quot;com.myapp.Foo&quot;/&gt;</code></td>
</tr>
</tbody>
</table>
<p>基本上每一种标签都是用来定义一类 bean 的（P标签除外）。以上都是 spring 自带的一些标签，当然 spring 也支持自定义标签。其实 <code>&lt;tx&gt;&lt;aop&gt;</code> 这些也可以认为是自定义标签，不过是由 spring 扩展的而已。</p>
<p>其实所有的bean定义都可以用bean标签来实现定义的。而衍生这种自定义标签来定义 bean 有几个好处：</p>
<ol>
<li><p>见名知意。</p>
</li>
<li><p>对于同一类的通用 bean。封装不必要的配置，只给外部暴露一个简单易用的标签和一些需要配置的属性。很多时候对于一个框架通用的 bean ，我们不需要把 bean 的所有配置都暴露出来，甚至像类名、默认值等我们都想直接封装，这个时候就可以使用自定义标签了，如： &lt;services:property-placeholder /&gt; 可能这个标签就默认代表配置了一个支持 property placeholder 的通用 bean ，我们都不需要去知道配这样一个 bean 的类路径是什么。</p>
</li>
</ol>
<p>可以说自定义标签是 spring 的 xml 容器的一个扩展点，本身 spring 自己的很多标签也是基于这个设计上面来构造出来的。</p>
<h3 id="Spring-对于自定义（声明式）bean标签解析如何设计"><a href="#Spring-对于自定义（声明式）bean标签解析如何设计" class="headerlink" title="Spring 对于自定义（声明式）bean标签解析如何设计"></a>Spring 对于自定义（声明式）bean标签解析如何设计</h3><p>Bean 的定义方式有千千万万种，无论是何种标签，无论是何种资源定义，无论是何种容器，最终的 bean 定义内部表示都将转换为内部的唯一结构： BeanDefinition 。外部的各种定义说白了就是为了方便配置。</p>
<p>Spring 提供对其支持的标签解析的天然支持。所以只要按照 spring 的规范编写 xml 配置文件。所有的配置，在启动时都会正常的被解析成 BeanDefinition 。但是如果我们要实现一个自定义标签，则需要提供对自定义标签的全套支持。</p>
<p>我们知道要去完成一个自定义标签，需要完成的事情有：</p>
<ol>
<li><p>编写自定义标签 schema 定义文件，放在某个 classpath 下。</p>
</li>
<li><p>在 classpath 的在 META-INF 下面增加 spring.schemas 配置文件，指定 schema 虚拟路径和实际 xsd 的映射。我们在 xml 里的都是虚拟路径，如：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"  </span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">            "</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"otherBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.OtherBean"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.MyBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"singletonBean"</span>          <span class="attr">class</span>=<span class="string">"com.test.SingletonBean"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>头部的<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>www.springframework.org<span class="regexp">/schema/</span>beans http:<span class="regexp">//</span>www.springframework.org<span class="regexp">/schema/</span>beans<span class="regexp">/spring-beans-2.5.xsd</span></span><br></pre></td></tr></table></figure></p>
<p> 就是一个虚拟路径，其对应的真实路径在spring jar包里的META-INF/spring.schemas里面有映射到classpath定义：<br> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\:<span class="regexp">//</span>www.springframework.org<span class="regexp">/schema/</span>beans<span class="regexp">/spring-beans-2.5.xsd=org/</span>springframework<span class="regexp">/beans/</span>factory<span class="regexp">/xml/</span>spring-beans-<span class="number">2.5</span>.xsd</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>增加一个 NamespaceHandler 和 BeanDefinitionParser ，用于解析自定义的标签，将自定义标签的 bean 解析成一个 BeanDefinition 返回。</li>
</ol>
<ol start="4">
<li><p>在 classpath 的在 META-INF 下面增加 spring.handlers 配置文件，指定标签命名空间和 handlers 的映射。</p>
<p>为什么要做以上几个事情？我们来看看设计：</p>
</li>
</ol>
<p>Spring 对标签解析的设计的过程如下：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/a2d7e37b-e394-3f90-bf20-7f480db1dc5d.jpg" alt="image"></p>
<p>解释：</p>
<p>Step 1： 将 xml 文件解析成 Dom 树。将 xml 文件解析成 dom 树的时候，需要 xml 标签定义 schema 来验证文件的语法结构。 Spring 约定将所有的 shema 的虚拟路径和真是文件路径映射定义在 classpath 的在 META-INF/spring.schemas 下面。在容器启动时 Spring 会扫描所有的 META-INF/spring.schemas 并将映射维护到一个 map 里。</p>
<p>如 spring jar 包里会有自带的标签的 schemas 映射，可以看一下部分配置：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/aop/spring-aop-<span class="number">2.0</span>.xsd  =  org/springframework/aop/config/spring-aop-<span class="number">2.0</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/aop/spring-aop-<span class="number">2.5</span>.xsd  =  org/springframework/aop/config/spring-aop-<span class="number">2.5</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/aop/spring-aop.xsd  =  org/springframework/aop/config/spring-aop-<span class="number">2.5</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/beans/spring-beans-<span class="number">2.0</span>.xsd  =  org/springframework/beans/factory/xml/spring-beans-<span class="number">2.0</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/beans/spring-beans-<span class="number">2.5</span>.xsd  =  org/springframework/beans/factory/xml/spring-beans-<span class="number">2.5</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/beans/spring-beans.xsd  =  org/springframework/beans/factory/xml/spring-beans-<span class="number">2.5</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/context/spring-context-<span class="number">2.5</span>.xsd  =  org/springframework/context/config/spring-context-<span class="number">2.5</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/context/spring-context.xsd  =  org/springframework/context/config/spring-context-<span class="number">2.5</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/jee/spring-jee-<span class="number">2.0</span>.xsd  =  org/springframework/ejb/config/spring-jee-<span class="number">2.0</span>.xsd  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/jee/spring-jee-<span class="number">2.5</span>.xsd  =  org/springframework/ejb/config/spring-jee-<span class="number">2.5</span>.xsd  </span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>等号左边是虚拟路径，右边是真是路径(classpath下的)。<br>虚拟路径用在我们的bean定义配置文件里，如：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans <span class="attribute">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line">    xmlns:<span class="attribute">xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xmlns:<span class="attribute">context</span>=<span class="string">"http://www.springframework.org/schema/context"</span>  </span><br><span class="line">    xmlns:<span class="attribute">p</span>=<span class="string">"http://www.springframework.org/schema/p"</span>  </span><br><span class="line">    xsi:<span class="attribute">schemaLocation</span>=<span class="string">"  </span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&gt;  </span></span><br><span class="line"><span class="string">&lt;bean&gt;  </span></span><br><span class="line"><span class="string">&lt;/beans&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>beans里面的<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>www.springframework.org<span class="regexp">/schema/</span>beans http:<span class="regexp">//</span>www.springframework.org<span class="regexp">/schema/</span>beans<span class="regexp">/spring-beans-2.5.xsd</span></span><br></pre></td></tr></table></figure></p>
<p>就是个虚拟路径。</p>
<p>Step 2： 将 dom 树解析成 BeanDifinition 。将定义 bean 的标签和 xml 定义解析成 BeanDefinition 的过程。如果是默认的 bean 标签， spring 会直接进行解析。而如果不是默认的 bean 标签，包括自定义和 spring 扩展的 <code>&lt;aop&gt;</code>、 <code>&lt;p&gt;</code>、 <code>&lt;util&gt;</code> 等标签，则需要提供专门的 xmlparser 来处理。 paorser由自己定义和编写，并通过handler注册到容器。Spring 约定了 META-INF/spring.handlers 文件，在这里面定义了标签命名空间和 handler 的映射。容器起来的时候会加载 handler ， handler 会向容器注册该命名空间下的标签和解析器。在解析的自定义标签的时候， spring 会根据标签的命名空间和标签名找到一个解析器。由该解析器来完成对该标签内容的解析，并返回一个 BeanDefinition 。</p>
<p>以下是 spring jar 包自带的一些自定义标签扩展的 spring.handlers 文件，可以看到定义了 aop\p 等其扩展标签的 handlers 。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/jms=org.springframework.jms.config.JmsNamespaceHandler  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandler  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/tx=org.springframework.transaction.config.TxNamespaceHandler  </span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler</span><br></pre></td></tr></table></figure></p>
<p>看看UtilNamespaceHandler的代码实现<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void init() &#123;  </span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"constant"</span>, <span class="keyword">new</span> <span class="type">ConstantBeanDefinitionParser</span>());  </span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"property-path"</span>, <span class="keyword">new</span> <span class="type">PropertyPathBeanDefinitionParser</span>());  </span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"list"</span>, <span class="keyword">new</span> <span class="type">ListBeanDefinitionParser</span>());  </span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"set"</span>, <span class="keyword">new</span> <span class="type">SetBeanDefinitionParser</span>());  </span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"map"</span>, <span class="keyword">new</span> <span class="type">MapBeanDefinitionParser</span>());  </span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"properties"</span>, <span class="keyword">new</span> <span class="type">PropertiesBeanDefinitionParser</span>());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现了标签和对应parser的映射注册。</p>
<p>ListBeanDefinitionParser的实现如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">ListBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Class</span> getBeanClass(<span class="type">Element</span> element) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="type">ListFactoryBean</span>.<span class="keyword">class</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> void doParse(<span class="type">Element</span> element, <span class="type">ParserContext</span> parserContext, <span class="type">BeanDefinitionBuilder</span> builder) &#123;  </span><br><span class="line">        <span class="type">String</span> listClass = element.getAttribute(<span class="string">"list-class"</span>);  </span><br><span class="line">        <span class="type">List</span> parsedList = parserContext.getDelegate().parseListElement(element, builder.getRawBeanDefinition());  </span><br><span class="line">        builder.addPropertyValue(<span class="string">"sourceList"</span>, parsedList);  </span><br><span class="line">        <span class="keyword">if</span> (<span class="type">StringUtils</span>.hasText(listClass)) &#123;  </span><br><span class="line">            builder.addPropertyValue(<span class="string">"targetListClass"</span>, listClass);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">String</span> scope = element.getAttribute(<span class="type">SCOPE_ATTRIBUTE</span>);  </span><br><span class="line">        <span class="keyword">if</span> (<span class="type">StringUtils</span>.hasLength(scope)) &#123;  </span><br><span class="line">            builder.setScope(scope);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里父类代码不贴了，主要完成的是beanDifinition的生成。</p>
<h4 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h4><p>Spring 对于自定义（声明式）bean标签源码实现大概的源码结构如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1486692b-7ba3-3d1d-a6f6-1c70aa45a21e.jpg" alt="image"><br>XmlBeanDefinitionReader 是核心类，它接收 spring 容器传给它的资源 resource 文件，由它负责完成整个转换。它调用 DefaultDocumentLoader 来完成将 Resource 到 Dom 树的转换。调用 DefaultBeanDefinitionDocumentReader 完成将 Dom 树到 BeanDefinition 的转换。</p>
<p>具体的代码流程细节完全可以基于这个结构去阅读，下面就贴几个核心源码段：</p>
<p>源码段 1 ： 加载 spring.shemas，在PluggableSchemaResolver.java里实现：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluggableSchemaResolver</span> <span class="title">implements</span> <span class="title">EntityResolver</span> </span>&#123;  </span><br><span class="line"><span class="comment">/***定义schema location的映射文件路径***/</span>  </span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> String DEFAULT_SCHEMA_MAPPINGS_LOCATION = <span class="string">"META-INF/spring.schemas"</span>;  </span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> Log logger = LogFactory.getLog(PluggableSchemaResolver.<span class="keyword">class</span>);  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String schemaMappingsLocation;  </span><br><span class="line">    <span class="comment">/** Stores the mapping of schema URL -&gt; local schema path */</span>  </span><br><span class="line">    <span class="keyword">private</span> Properties schemaMappings;  </span><br><span class="line">    <span class="keyword">public</span> PluggableSchemaResolver(ClassLoader classLoader) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;  </span><br><span class="line">        <span class="keyword">this</span>.schemaMappingsLocation = DEFAULT_SCHEMA_MAPPINGS_LOCATION;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> PluggableSchemaResolver(ClassLoader classLoader, String schemaMappingsLocation) &#123;  </span><br><span class="line">        Assert.hasText(schemaMappingsLocation, <span class="string">"'schemaMappingsLocation' must not be empty"</span>);  </span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;  </span><br><span class="line">        <span class="keyword">this</span>.schemaMappingsLocation = schemaMappingsLocation;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**==========中间省略部分代码=========**/</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/***此处完成schema的加载***/</span>  </span><br><span class="line">    <span class="keyword">protected</span> String getSchemaMapping(String systemId) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.schemaMappings == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                logger.debug(<span class="string">"Loading schema mappings from ["</span> + <span class="keyword">this</span>.schemaMappingsLocation + <span class="string">"]"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">this</span>.schemaMappings =  </span><br><span class="line">                        PropertiesLoaderUtils.loadAllProperties(<span class="keyword">this</span>.schemaMappingsLocation, <span class="keyword">this</span>.classLoader);  </span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                    logger.debug(<span class="string">"Loaded schema mappings: "</span> + <span class="keyword">this</span>.schemaMappings);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (IOException ex) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> new FatalBeanException(  </span><br><span class="line">                        <span class="string">"Unable to load schema mappings from location ["</span> + <span class="keyword">this</span>.schemaMappingsLocation + <span class="string">"]"</span>, ex);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.schemaMappings.getProperty(systemId);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>源码段 2 ： 加载 spring.handlers,在 DefaultNamespaceHandlerResolver里实现：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DefaultNamespaceHandlerResolver</span> <span class="keyword">implements</span> <span class="title">NamespaceHandlerResolver</span> </span>&#123;  </span><br><span class="line">    <span class="comment"><span class="markdown">/** </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     * The location to look for </span></span>the<span class="markdown"> mapping files. Can be present in multiple JAR files. </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span>  </span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> DEFAULT_HANDLER_MAPPINGS_LOCATION = <span class="string">"META-INF/spring.handlers"</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** Logger available to subclasses *</span>/</span></span>  </span><br><span class="line">    protected <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());  </span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** ClassLoader to use for NamespaceHandler classes *</span>/</span></span>  </span><br><span class="line">    private <span class="keyword">final</span> ClassLoader classLoader;  </span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** Resource location to search for *</span>/</span></span>  </span><br><span class="line">    private <span class="keyword">final</span> <span class="built_in">String</span> handlerMappingsLocation;  </span><br><span class="line">    <span class="comment"><span class="markdown">/** Stores </span>the<span class="markdown"> mappings from namespace URI to NamespaceHandler class name / instance */</span></span>  </span><br><span class="line">    private <span class="built_in">Map</span> handlerMappings;  </span><br><span class="line">  </span><br><span class="line">    public DefaultNamespaceHandlerResolver() &#123;  </span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, DEFAULT_HANDLER_MAPPINGS_LOCATION);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public DefaultNamespaceHandlerResolver(ClassLoader classLoader) &#123;  </span><br><span class="line">        <span class="keyword">this</span>(classLoader, DEFAULT_HANDLER_MAPPINGS_LOCATION);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public DefaultNamespaceHandlerResolver(ClassLoader classLoader, <span class="built_in">String</span> handlerMappingsLocation) &#123;  </span><br><span class="line">        Assert.notNull(handlerMappingsLocation, <span class="string">"Handler mappings location must not be null"</span>);  </span><br><span class="line">        <span class="keyword">this</span>.classLoader = (classLoader != <span class="keyword">null</span> ? classLoader : ClassUtils.getDefaultClassLoader());  </span><br><span class="line">        <span class="keyword">this</span>.handlerMappingsLocation = handlerMappingsLocation;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">**==========中间省略部分代码=========**</span>/</span></span>  </span><br><span class="line">  </span><br><span class="line">        </span><br><span class="line">       <span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span>* </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     * Load </span></span>the<span class="markdown"> specified NamespaceHandler mappings lazily. </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">        *  此处加载延迟加载spring.handlers，只有第一次自定义标签被解析到，才会被加载。 </span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">        ****************************/</span></span></span>  </span><br><span class="line">    private <span class="built_in">Map</span> getHandlerMappings() &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                Properties mappings =  </span><br><span class="line">                        PropertiesLoaderUtils.loadAllProperties(<span class="keyword">this</span>.handlerMappingsLocation, <span class="keyword">this</span>.classLoader);  </span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                    logger.debug(<span class="string">"Loaded mappings ["</span> + mappings + <span class="string">"]"</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> HashMap(mappings);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (IOException ex) &#123;  </span><br><span class="line">                IllegalStateException ise = <span class="keyword">new</span> IllegalStateException(  </span><br><span class="line">                        <span class="string">"Unable to load NamespaceHandler mappings from location ["</span> + <span class="keyword">this</span>.handlerMappingsLocation + <span class="string">"]"</span>);  </span><br><span class="line">                ise.initCause(ex);  </span><br><span class="line">                <span class="keyword">throw</span> ise;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.handlerMappings;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>源码段3 ： xml 到 dom 树的解析。</p>
<p>在 XmlBeanDefinitionReader.java 的 doLoadBeanDefinitions 方法里，调用 DefaultDocumentLoader 完成。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource,<span class="built_in"> Resource </span>resource)  </span><br><span class="line">            throws BeanDefinitionStoreException &#123;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        int validationMode = getValidationModeForResource(resource);  </span><br><span class="line">        Document doc = this.documentLoader.loadDocument(  </span><br><span class="line">                inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware());  </span><br><span class="line">        return registerBeanDefinitions(doc, resource);  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (BeanDefinitionStoreException ex) &#123;  </span><br><span class="line">        throw ex;  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (SAXParseException ex) &#123;  </span><br><span class="line">        throw new XmlBeanDefinitionStoreException(resource.getDescription(),  </span><br><span class="line">                <span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> +<span class="built_in"> resource </span>+ <span class="string">" is invalid"</span>, ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (SAXException ex) &#123;  </span><br><span class="line">        throw new XmlBeanDefinitionStoreException(resource.getDescription(),  </span><br><span class="line">                <span class="string">"XML document from "</span> +<span class="built_in"> resource </span>+ <span class="string">" is invalid"</span>, ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (ParserConfigurationException ex) &#123;  </span><br><span class="line">        throw new BeanDefinitionStoreException(resource.getDescription(),  </span><br><span class="line">                <span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (IOException ex) &#123;  </span><br><span class="line">        throw new BeanDefinitionStoreException(resource.getDescription(),  </span><br><span class="line">                <span class="string">"IOException parsing XML document from "</span> + resource, ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (Throwable ex) &#123;  </span><br><span class="line">        throw new BeanDefinitionStoreException(resource.getDescription(),  </span><br><span class="line">                <span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getEntityResolver</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>会完成spring.schemas的装载,里面会间接调用源码段1。穿进去的entityResolver作为标签解析使用。</p>
<p>源码段4 ： dom 树到 Beandifinition：</p>
<p>在 XmlBeanDefinitionReader .java 的 doLoadBeanDefinitions 方法里，调用 BeanDefinitionDocumentReader 完成。</p>
 <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </span><br><span class="line">    <span class="comment">// Support old XmlBeanDefinitionParser SPI for backwards-compatibility.  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parserClass != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        XmlBeanDefinitionParser parser =  </span><br><span class="line">                (XmlBeanDefinitionParser) BeanUtils.instantiateClass(<span class="keyword">this</span>.parserClass);  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> parser.<span class="title">registerBeanDefinitions</span><span class="params">(<span class="keyword">this</span>, doc, resource)</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Read document based on new BeanDefinitionDocumentReader SPI.  </span></span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();  </span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();  </span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));  </span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AOP底层实现原理"><a href="#AOP底层实现原理" class="headerlink" title="AOP底层实现原理"></a>AOP底层实现原理</h3><p>代理设计模式</p>
<p>什么是代理模式</p>
<p>通过代理控制对象的访问,可以详细访问某个对象的方法，在这个方法调用处理，或调用后处理。既(AOP微实现) ,AOP核心技术面向切面编程。</p>
<p>代理模式应用场景</p>
<p>SpringAOP、事物原理、日志打印、权限控制、远程调用、安全代理 可以隐蔽真实角色</p>
<p>代理的分类</p>
<p>静态代理(静态定义代理类)</p>
<p>动态代理(动态生成代理类)</p>
<p>Jdk自带动态代理</p>
<p>Cglib 、javaassist（字节码操作库）</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>什么是静态代理</p>
<p>由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"已经保存数据..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代理类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IUserDao <span class="keyword">target</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(IUserDao iuserDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = iuserDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启事物..."</span>);</span><br><span class="line">        <span class="keyword">target</span>.save();</span><br><span class="line">        System.out.println(<span class="string">"关闭事物..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="什么是动态代理"><a href="#什么是动态代理" class="headerlink" title="什么是动态代理"></a>什么是动态代理</h4><p>1.代理对象,不需要实现接口</p>
<p>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)</p>
<p>3.动态代理也叫做:JDK代理,接口代理</p>
<h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><p>1)原理：是根据类加载器和接口创建代理类（此代理类是接口的实现类，所以必须使用接口 面向接口生成代理，位于java.lang.reflect包下）</p>
<p>2)实现方式：</p>
<p>通过实现InvocationHandler接口创建自己的调用处理器 <code>IvocationHandler handler = new InvocationHandlerImpl(…);</code></p>
<p>通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类<code>Class clazz = Proxy.getProxyClass(classLoader,new Class[]{…});</code></p>
<p>通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型<code>Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});</code></p>
<p>通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入<code>Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler));</code></p>
<p>缺点：jdk动态代理，必须是面向接口，目标业务类必须实现接口<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object <span class="keyword">target</span>;<span class="comment">// 这其实业务实现类对象，用来调用具体的业务方法</span></span><br><span class="line">    <span class="comment">// 通过构造函数传入目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationHandlerImpl</span><span class="params">(Object <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"调用开始处理"</span>);</span><br><span class="line">        result = method.invoke(<span class="keyword">target</span>, args);</span><br><span class="line">        System.out.println(<span class="string">"调用结束处理"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> NoSuchMethodException, SecurityException, InstantiationException,</span><br><span class="line">            IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">// 被代理对象</span></span><br><span class="line">        IUserDao userDao = <span class="keyword">new</span> UserDao();</span><br><span class="line">        InvocationHandlerImpl invocationHandlerImpl = <span class="keyword">new</span> InvocationHandlerImpl(userDao);</span><br><span class="line">        ClassLoader loader = userDao.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = userDao.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 主要装载器、一组接口及调用处理动态代理实例</span></span><br><span class="line">        IUserDao newProxyInstance = (IUserDao) Proxy.newProxyInstance(loader, interfaces, invocationHandlerImpl);</span><br><span class="line">        newProxyInstance.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h5><p>原理：利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p>
<p>什么是CGLIB动态代理</p>
<p>使用cglib[Code Generation Library]实现动态代理，并不要求委托类必须实现接口，底层采用asm字节码生成框架生成代理类的字节码</p>
<p>CGLIB动态代理相关代码</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> targetObject;</span><br><span class="line">    <span class="comment">// 这里的目标类型为Object，则可以接受任意一种参数作为被代理类，实现了动态代理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Object</span> getInstance(<span class="keyword">Object</span> target) &#123;</span><br><span class="line">        <span class="comment">// 设置需要创建子类的类</span></span><br><span class="line">        <span class="keyword">this</span>.targetObject = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Object</span> intercept(<span class="keyword">Object</span> obj, Method method, <span class="keyword">Object</span>[] args, MethodProxy proxy) <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"开启事物"</span>);</span><br><span class="line">        <span class="keyword">Object</span> result = proxy.invoke(targetObject, args);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"关闭事物"</span>);</span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        CglibProxy cglibProxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">        UserDao userDao = (UserDao) cglibProxy.getInstance(<span class="keyword">new</span> UserDao());</span><br><span class="line">        userDao.<span class="built_in">save</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CGLIB动态代理与JDK动态区别"><a href="#CGLIB动态代理与JDK动态区别" class="headerlink" title="CGLIB动态代理与JDK动态区别"></a>CGLIB动态代理与JDK动态区别</h5><p>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</p>
<p>而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p>
<p>Spring中。</p>
<p>1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP</p>
<p>2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP</p>
<p>3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</p>
<p>JDK动态代理只能对实现了接口的类生成代理，而不能针对类 。 CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 。 因为是继承，所以该类或方法最好不要声明成final ，final可以阻止继承和多态。</p>
<h2 id="springcloud的整体架构"><a href="#springcloud的整体架构" class="headerlink" title="springcloud的整体架构"></a>springcloud的整体架构</h2><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p>心跳检测机制，如果某个实例在规定的时间内没有进行通讯则会自动被剔除掉，避免了某个实例挂掉而影响服务，Eureka就自动具有了注册中心、负载均衡、故障转移的功能。</p>
<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>Hystrix会在某个服务连续调用N次不响应的情况下，立即通知调用端调用失败，避免调用端持续等待而影响了整体服务。Hystrix间隔时间会再次检查此服务，如果服务恢复将继续提供服务。 </p>
<h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><p>解决分布式系统的配置管理方案。它包含了Client和Server两个部分，Server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，Client通过接口获取数据、并依据此数据初始化自己的应用。 </p>
<h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><p>通过轻量消息代理连接各个分布的节点。这会用在广播状态的变化（例如配置变化）或者其它的消息指令中。Spring Cloud Bus的一个核心思想是通过分布式的启动器对Spring Boot应用进行扩展，也可以用来建立一个或多个应用之间的通信频道。目前唯一实现的方式是用AMQP消息代理作为通道。 有了Spring Cloud Bus之后，当我们改变配置文件提交到版本库中时，会自动的触发对应实例的Refresh。</p>
<h3 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h3><p>Spring Cloud体系中支持API Gateway落地的技术就是Zuul。Spring Cloud Zuul路由是微服务架构中不可或缺的一部分，提供动态路由，监控，弹性，安全等的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。 它的具体作用就是服务转发，接收并转发所有内外部的客户端调用。使用Zuul可以作为资源的统一访问入口，同时也可以在网关做一些权限校验等类似的功能。 </p>
<h3 id="链路跟踪"><a href="#链路跟踪" class="headerlink" title="链路跟踪"></a>链路跟踪</h3><p>Spring Cloud Sleuth和Zipkin，Spring Cloud Sleuth为服务之间调用提供链路追踪。通过Sleuth可以很清楚的了解到一个服务请求经过了哪些服务，每个服务处理花费了多长时间。从而让我们可以很方便的理清各微服务间的调用关系。Zipkin是Twitter的一个开源项目，允许开发者收集 Twitter 各个服务上的监控数据，并提供查询接口 。</p>
<h3 id="Feign技术"><a href="#Feign技术" class="headerlink" title="Feign技术"></a>Feign技术</h3><p>利用此技术可以伪造接口实现。</p>
<h2 id="负载均衡的算法有哪些"><a href="#负载均衡的算法有哪些" class="headerlink" title="负载均衡的算法有哪些"></a>负载均衡的算法有哪些</h2><h3 id="轮询（Round-Robin）法"><a href="#轮询（Round-Robin）法" class="headerlink" title="轮询（Round Robin）法"></a>轮询（Round Robin）法</h3><p>将所有请求，依次分发到每台服务器上，适合服务器硬件相同的场景。</p>
<ul>
<li>优点：服务器请求数目相同；</li>
<li>缺点：服务器压力不一样，不适合服务器配置不同的情况，为了做到请求转移的绝对均衡，必须付出相当大的代价，因为为了保证pos变量修改的互斥性，需要引入重量级的悲观锁synchronized，这将会导致该段轮询代码的并发吞吐量发生明显的下降；</li>
</ul>
<h3 id="随机（Random）法"><a href="#随机（Random）法" class="headerlink" title="随机（Random）法"></a>随机（Random）法</h3><p>基于概率统计的理论，吞吐量越大，随机算法的效果越接近于轮询算法的效果。</p>
<ul>
<li>优点：使用简单；</li>
<li>缺点：不适合机器配置不同的场景；</li>
</ul>
<h3 id="源地址哈希（Hash）法"><a href="#源地址哈希（Hash）法" class="headerlink" title="源地址哈希（Hash）法"></a>源地址哈希（Hash）法</h3><p>源地址哈希的思想是获取客户端访问的IP地址值，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是要访问的服务器的序号。</p>
<ul>
<li>优点：保证了相同客户端IP地址将会被哈希到同一台后端服务器，直到后端服务器列表变更。根据此特性可以在服务消费者与服务提供者之间建立有状态的session会话。</li>
<li>缺点：除非集群中服务器的非常稳定，基本不会上下线，否则一旦有服务器上线、下线，那么通过源地址哈希算法路由到的服务器是服务器上线、下线前路由到的服务器的概率非常低，如果是session则取不到session，如果是缓存则可能引发”雪崩”；</li>
</ul>
<h3 id="加权法"><a href="#加权法" class="headerlink" title="加权法"></a>加权法</h3><p>在轮询，随机，最少链接，Hash等算法的基础上，通过加权的方式，进行负载服务器分配。</p>
<ul>
<li>优点：根据权重，调节转发服务器的请求数目；</li>
<li>缺点：使用相对复杂；</li>
</ul>
<h3 id="最小连接数（Least-Connections）法"><a href="#最小连接数（Least-Connections）法" class="headerlink" title="最小连接数（Least Connections）法"></a>最小连接数（Least Connections）法</h3><p>将请求分配到连接数最少的服务器上（目前处理请求最少的服务器）。</p>
<ul>
<li>优点：根据服务器当前的请求处理情况，动态分配；</li>
<li>缺点：算法实现相对复杂，需要监控服务器请求连接数；</li>
</ul>
<h2 id="SpringBoot如何启动"><a href="#SpringBoot如何启动" class="headerlink" title="SpringBoot如何启动"></a>SpringBoot如何启动</h2><ul>
<li>如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：<ul>
<li>根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</li>
<li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</li>
<li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</li>
<li>推断并设置main方法的定义类。</li>
</ul>
</li>
<li>SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。</li>
<li>创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</li>
<li>遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</li>
<li>如果SpringApplication的showBanner属性被设置为true，则打印banner。</li>
<li>根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</li>
<li>ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</li>
<li>遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</li>
<li>最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。</li>
<li>遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</li>
<li>调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</li>
<li>查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</li>
<li>正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）</li>
</ul>
<p>去除事件通知点后，整个流程如下：<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">ConfigurableApplicationContext</span> run(<span class="type">String</span>... args) &#123;</span><br><span class="line">    <span class="comment">// 开启定时器,统计启动时间</span></span><br><span class="line">   <span class="type">StopWatch</span> stopWatch = <span class="function"><span class="keyword">new</span> <span class="title">StopWatch</span>();</span></span><br><span class="line"><span class="function">   <span class="title">stopWatch</span>.<span class="title">start</span>();</span></span><br><span class="line"><span class="function">   <span class="title">ConfigurableApplicationContext</span> <span class="title">context</span> = <span class="title">null</span>;</span></span><br><span class="line"><span class="function">   <span class="title">Collection</span>&lt;<span class="title">SpringBootExceptionReporter</span>&gt; <span class="title">exceptionReporters</span> = <span class="title">new</span> <span class="title">ArrayList</span>&lt;&gt;();</span></span><br><span class="line"><span class="function">   <span class="title">configureHeadlessProperty</span>();</span></span><br><span class="line"><span class="function">    <span class="comment">// 获取并初始化所有RunListener</span></span></span><br><span class="line"><span class="function">   <span class="title">SpringApplicationRunListeners</span> <span class="title">listeners</span> = <span class="title">getRunListeners</span>(args);</span></span><br><span class="line"><span class="function">    <span class="comment">// 发布启动事件</span></span></span><br><span class="line"><span class="function">   <span class="title">listeners</span>.<span class="title">starting</span>();</span></span><br><span class="line"><span class="function">   <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">      <span class="title">ApplicationArguments</span> <span class="title">applicationArguments</span> = <span class="title">new</span> <span class="title">DefaultApplicationArguments</span>(</span></span><br><span class="line"><span class="function">            args);</span></span><br><span class="line"><span class="function">    <span class="comment">// 准备好环境environment,即配置文件等</span></span></span><br><span class="line"><span class="function">      <span class="title">ConfigurableEnvironment</span> <span class="title">environment</span> = <span class="title">prepareEnvironment</span>(listeners,</span></span><br><span class="line"><span class="function">            applicationArguments);</span></span><br><span class="line"><span class="function">      <span class="title">configureIgnoreBeanInfo</span>(environment);</span></span><br><span class="line"><span class="function">    <span class="comment">// 打印SpringBoot Logo</span></span></span><br><span class="line"><span class="function">      <span class="title">Banner</span> <span class="title">printedBanner</span> = <span class="title">printBanner</span>(environment);</span></span><br><span class="line"><span class="function">    <span class="comment">// 创建我们最常用的ApplicationContext</span></span></span><br><span class="line"><span class="function">      <span class="title">context</span> = <span class="title">createApplicationContext</span>();</span></span><br><span class="line"><span class="function">    <span class="comment">// 获取异常报告器,在启动发生异常的时候用友好的方式提示用户</span></span></span><br><span class="line"><span class="function">      <span class="title">exceptionReporters</span> = <span class="title">getSpringFactoriesInstances</span>(</span></span><br><span class="line"><span class="function">            <span class="type">SpringBootExceptionReporter</span>.class,</span></span><br><span class="line"><span class="function">            new <span class="type">Class</span>[] &#123; <span class="type">ConfigurableApplicationContext</span>.class &#125;, context);</span></span><br><span class="line"><span class="function">    <span class="comment">// 准备Context,加载启动类作为source</span></span></span><br><span class="line"><span class="function">      <span class="title">prepareContext</span>(context, environment, listeners, applicationArguments,</span></span><br><span class="line"><span class="function">            printedBanner);</span></span><br><span class="line"><span class="function">    <span class="comment">// Spring初始化的核心逻辑,构建整个容器</span></span></span><br><span class="line"><span class="function">      <span class="title">refreshContext</span>(context);</span></span><br><span class="line"><span class="function">      <span class="title">afterRefresh</span>(context, applicationArguments);</span></span><br><span class="line"><span class="function">    <span class="comment">// 停止计时,统计启动耗时</span></span></span><br><span class="line"><span class="function">      <span class="title">stopWatch</span>.<span class="title">stop</span>();</span></span><br><span class="line"><span class="function">      <span class="title">if</span> (this.logStartupInfo) &#123;</span></span><br><span class="line"><span class="function">         <span class="title">new</span> <span class="title">StartupInfoLogger</span>(this.mainApplicationClass)</span></span><br><span class="line"><span class="function">               .<span class="title">logStarted</span>(getApplicationLog(), <span class="title">stopWatch</span>);</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">      <span class="title">listeners</span>.<span class="title">started</span>(context);</span></span><br><span class="line"><span class="function">    <span class="comment">// 调用runner接口供应用自定义初始化</span></span></span><br><span class="line"><span class="function">      <span class="title">callRunners</span>(context, applicationArguments);</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function">   <span class="title">catch</span> (<span class="type">Throwable</span> ex) &#123;</span></span><br><span class="line"><span class="function">    <span class="comment">// 处理启动中抛出的异常,使用异常报告器输出</span></span></span><br><span class="line"><span class="function">      <span class="title">handleRunFailure</span>(context, ex, exceptionReporters, listeners);</span></span><br><span class="line"><span class="function">      <span class="title">throw</span> <span class="title">new</span> <span class="title">IllegalStateException</span>(ex);</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">      <span class="title">listeners</span>.<span class="title">running</span>(context);</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function">   <span class="title">catch</span> (<span class="type">Throwable</span> ex) &#123;</span></span><br><span class="line"><span class="function">      <span class="title">handleRunFailure</span>(context, ex, exceptionReporters, null);</span></span><br><span class="line"><span class="function">      <span class="title">throw</span> <span class="title">new</span> <span class="title">IllegalStateException</span>(ex);</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function">   <span class="title">return</span> <span class="title">context</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG992.jpeg" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG993.png" alt="image"></p>
<p><img src="http://image.tengj.top/springboot3-3.jpg" alt="image"></p>
<h2 id="什么是脑裂"><a href="#什么是脑裂" class="headerlink" title="什么是脑裂"></a>什么是脑裂</h2><h3 id="什么是脑裂-1"><a href="#什么是脑裂-1" class="headerlink" title="什么是脑裂"></a>什么是脑裂</h3><p>脑裂(split-brain)就是“大脑分裂”，也就是本来一个“大脑”被拆分了两个或多个“大脑”，我们都知道，如果一个人有多个大脑，并且相互独立的话，那么会导致人体“手舞足蹈”，“不听使唤”。</p>
<p>脑裂通常会出现在集群环境中，比如ElasticSearch、Zookeeper集群，而这些集群环境有一个统一的特点，就是它们有一个大脑，比如ElasticSearch集群中有Master节点，Zookeeper集群中有Leader节点。</p>
<p>章着重来给大家讲一下Zookeeper中的脑裂问题，以及是如果解决脑裂问题的。</p>
<h3 id="Zookeeper集群中的脑裂场景"><a href="#Zookeeper集群中的脑裂场景" class="headerlink" title="Zookeeper集群中的脑裂场景"></a>Zookeeper集群中的脑裂场景</h3><p>对于一个集群，想要提高这个集群的可用性，通常会采用多机房部署，比如现在有一个由6台zkServer所组成的一个集群，部署在了两个机房：</p>
<p>正常情况下，此集群只会有一个Leader，那么如果机房之间的网络断了之后，两个机房内的zkServer还是可以相互通信的，如果不考虑过半机制，那么就会出现每个机房内部都将选出一个Leader。 </p>
<p>这就相当于原本一个集群，被分成了两个集群，出现了两个“大脑”，这就是脑裂。</p>
<p>对于这种情况，我们也可以看出来，原本应该是统一的一个集群对外提供服务的，现在变成了两个集群同时对外提供服务，如果过了一会，断了的网络突然联通了，那么此时就会出现问题了，两个集群刚刚都对外提供服务了，数据该怎么合并，数据冲突怎么解决等等问题。</p>
<p>刚刚在说明脑裂场景时，有一个前提条件就是没有考虑过半机制，所以实际上Zookeeper集群中是不会出现脑裂问题的，而不会出现的原因就跟过半机制有关。</p>
<h3 id="过半机制"><a href="#过半机制" class="headerlink" title="过半机制"></a>过半机制</h3><p>在领导者选举的过程中，如果某台zkServer获得了超过半数的选票，则此zkServer就可以成为Leader了。</p>
<p>过半机制的源码实现其实非常简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuorumMaj</span> <span class="keyword">implements</span> <span class="title">QuorumVerifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(QuorumMaj.class);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> half;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// n表示集群中zkServer的个数（准确的说是参与者的个数，参与者不包括观察者节点）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuorumMaj</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.half = n/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证是否符合过半机制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsQuorum</span><span class="params">(Set&lt;Long&gt; set)</span></span>&#123;</span><br><span class="line">        <span class="comment">// half是在构造方法里赋值的</span></span><br><span class="line">        <span class="comment">// set.size()表示某台zkServer获得的票数</span></span><br><span class="line">        <span class="keyword">return</span> (set.size() &gt; half);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大家仔细看一下上面方法中的注释，核心代码就是下面两行：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.half = n/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">set</span>.size() &gt; half);</span><br></pre></td></tr></table></figure></p>
<p>举个简单的例子： 如果现在集群中有5台zkServer，那么half=5/2=2，那么也就是说，领导者选举的过程中至少要有三台zkServer投了同一个zkServer，才会符合过半机制，才能选出来一个Leader。</p>
<p>那么有一个问题我们想一下，选举的过程中为什么一定要有一个过半机制验证？ 因为这样不需要等待所有zkServer都投了同一个zkServer就可以选举出来一个Leader了，这样比较快，所以叫快速领导者选举算法呗。</p>
<p>那么再来想一个问题，过半机制中为什么是大于，而不是大于等于呢？</p>
<p>这就是更脑裂问题有关系了，比如回到上文出现脑裂问题的场景： </p>
<p>当机房中间的网络断掉之后，机房1内的三台服务器会进行领导者选举，但是此时过半机制的条件是set.size() &gt; 3，也就是说至少要4台zkServer才能选出来一个Leader，所以对于机房1来说它不能选出一个Leader，同样机房2也不能选出一个Leader，这种情况下整个集群当机房间的网络断掉后，整个集群将没有Leader。</p>
<p>而如果过半机制的条件是set.size() &gt;= 3，那么机房1和机房2都会选出一个Leader，这样就出现了脑裂。所以我们就知道了，为什么过半机制中是大于，而不是大于等于。就是为了防止脑裂。</p>
<p>如果假设我们现在只有5台机器，也部署在两个机房： </p>
<p>此时过半机制的条件是set.size() &gt; 2，也就是至少要3台服务器才能选出一个Leader，此时机房件的网络断开了，对于机房1来说是没有影响的，Leader依然还是Leader，对于机房2来说是选不出来Leader的，此时整个集群中只有一个Leader。</p>
<p>所以，我们可以总结得出，有了过半机制，对于一个Zookeeper集群，要么没有Leader，要没只有1个Leader，这样就避免了脑裂问题。</p>
<p>有痛点才有创新，一个技术肯定都是为了解决某个痛点才出现的。</p>
<h2 id="Saga模式与TCC的区别"><a href="#Saga模式与TCC的区别" class="headerlink" title="Saga模式与TCC的区别"></a>Saga模式与TCC的区别</h2><h3 id="各种形态的分布式事务"><a href="#各种形态的分布式事务" class="headerlink" title="各种形态的分布式事务"></a>各种形态的分布式事务</h3><p>分布式事务有多种主流形态，包括：</p>
<ul>
<li>基于消息实现的分布式事务</li>
<li>基于补偿实现的分布式事务</li>
<li>基于TCC实现的分布式事务</li>
<li>基于SAGA实现的分布式事务</li>
<li>基于2PC实现的分布式事务<br>这些形态的原理已经在很多文章中进行了剖析，用“分布式事务”关键字就能搜到对应的文章，本文不再赘述这些形态的原理，并将重点放在如何根据业务选择对应的分布式事务形态上。</li>
</ul>
<h3 id="何时选择单机事务"><a href="#何时选择单机事务" class="headerlink" title="何时选择单机事务"></a>何时选择单机事务</h3><p>这个相信大家都很清楚，在条件允许的情况下，我们应该尽可能地使用单机事务，因为单机事务里，无需额外协调其他数据源，减少了网络交互时间消耗以及协调时所需的存储IO消耗，在修改等量业务数据的情况下，单机事务将会有更高的性能。</p>
<p>但单机数据库由于 业务逻辑解耦等因素进行了数据库垂直拆分、或者由于单机数据库性能压力等因素进行了数据库水平拆分之后，数据分布于多个数据库，这时若需要对多个数据库的数据进行协调变更，则需要引入分布式事务。</p>
<p>分布式事务的模式有很多种，那究竟要怎么选择适合业务的模式呢？以下我们将从使用场景、性能、开发成本这几个方面进行分析。</p>
<h3 id="何时选择基于消息实现的事务"><a href="#何时选择基于消息实现的事务" class="headerlink" title="何时选择基于消息实现的事务"></a>何时选择基于消息实现的事务</h3><p>基于消息实现的事务适用于分布式事务的提交或回滚只取决于事务发起方的业务需求，其他数据源的数据变更跟随发起方进行的业务场景。</p>
<p>举个例子，假设存在业务规则：某笔订单成功后，为用户加一定的积分。</p>
<p>在这条规则里，管理订单数据源的服务为事务发起方，管理积分数据源的服务为事务跟随者。</p>
<p>从这个过程可以看到，基于消息队列实现的事务存在以下操作：</p>
<hr>
<p>订单服务创建订单，提交本地事务<br>订单服务发布一条消息<br>积分服务收到消息后加积分<br>我们可以看到它的整体流程是比较简单的，同时业务开发工作量也不大：</p>
<ul>
<li>编写订单服务里订单创建的逻辑</li>
<li>编写积分服务里增加积分的逻辑<br>可以看到该事务形态过程简单，性能消耗小，发起方与跟随方之间的流量峰谷可以使用队列填平，同时业务开发工作量也基本与单机事务没有差别，都不需要编写反向的业务逻辑过程。因此基于消息队列实现的事务是我们除了单机事务外最优先考虑使用的形态。</li>
</ul>
<h3 id="何时选择利用补偿实现的事务？"><a href="#何时选择利用补偿实现的事务？" class="headerlink" title="何时选择利用补偿实现的事务？"></a>何时选择利用补偿实现的事务？</h3><p>但是基于消息实现的事务并不能解决所有的业务场景，例如以下场景：某笔订单完成时，同时扣掉用户的现金。</p>
<p>这里事务发起方是管理订单库的服务，但对整个事务是否提交并不能只由订单服务决定，因为还要确保用户有足够的钱，才能完成这笔交易，而这个信息在管理现金的服务里。这里我们可以引入基于补偿实现的事务，其流程如下：</p>
<ul>
<li>创建订单数据，但暂不提交本地事务</li>
<li>订单服务发送远程调用到现金服务，以扣除对应的金额</li>
<li>上述步骤成功后提交订单库的事务<br>以上这个是正常成功的流程，异常流程需要回滚的话，将额外发送远程调用到现金服务以加上之前扣掉的金额。</li>
</ul>
<p>以上流程比基于消息队列实现的事务的流程要复杂，同时开发的工作量也更多：</p>
<ul>
<li>编写订单服务里创建订单的逻辑</li>
<li>编写现金服务里扣钱的逻辑</li>
<li>编写现金服务里补偿返还的逻辑<br>可以看到，该事务流程相对于基于消息实现的分布式事务更为复杂，需要额外开发相关的业务回滚方法，也失去了服务间流量削峰填谷的功能。但其仅仅只比基于消息的事务复杂多一点，若不能使用基于消息队列的最终一致性事务，那么可以优先考虑使用基于补偿的事务形态。</li>
</ul>
<p>（题外话：阿里GTS也是利用补偿实现，只不过补偿代码自动生成，无需业务干预，同时接管应用数据源，禁止业务修改处于全局事务状态中的记录。）</p>
<h3 id="何时选择利用TCC实现的事务"><a href="#何时选择利用TCC实现的事务" class="headerlink" title="何时选择利用TCC实现的事务"></a>何时选择利用TCC实现的事务</h3><p>然而基于补偿的事务形态也并非能实现所有的需求，如以下场景：某笔订单完成时，同时扣掉用户的现金，但交易未完成，也未被取消时，不能让客户看到钱变少了。</p>
<p>这时我们可以引入TCC，其流程如下：</p>
<ul>
<li>订单服务创建订单</li>
<li>订单服务发送远程调用到现金服务，冻结客户的现金</li>
<li>提交订单服务数据</li>
<li>订单服务发送远程调用到现金服务，扣除客户冻结的现金<br>以上是正常完成的流程，若为异常流程，则需要发送远程调用请求到现金服务，撤销冻结的金额。</li>
</ul>
<p>以上流程比基于补偿实现的事务的流程要复杂，同时开发的工作量也更多：</p>
<ul>
<li>订单服务编写创建订单的逻辑</li>
<li>现金服务编写冻结现金的逻辑</li>
<li>现金服务编写扣除现金的逻辑</li>
<li>现金服务编写解冻现金的逻辑<br>TCC实际上是最为复杂的一种情况，其能处理所有的业务场景，但无论出于性能上的考虑，还是开发复杂度上的考虑，都应该尽量避免该类事务。</li>
</ul>
<h3 id="何时选择利用SAGA实现的事务？"><a href="#何时选择利用SAGA实现的事务？" class="headerlink" title="何时选择利用SAGA实现的事务？"></a>何时选择利用SAGA实现的事务？</h3><p>saga是30年前的一篇数据库论文提到的概念。 论文中定义saga事务是一个长事务，整个事务可以由多个本地事务组成，每个本地事务有相应的执行模块和补偿模块，当saga事务中任意一个事务出错了，可以调用相关事务进行对应的补偿恢复，达到事务的最终一致性。</p>
<p>由于分布式系统中网络带来的不可靠性，saga调用服务提出了服务应该支持幂等，在服务调用超时重试情况下，不至于产生问题。</p>
<p>saga事务没有准备阶段，不具备隔离性，如果多个saga事务同时操作同一资源会遇到多线程临界资源的情况，产生数据丢失或者脏数据。</p>
<p>为解决隔离性，可以参考TCC模式，在业务层加入session及锁机制保证操作串型化，通过业务层面达到隔离效果。</p>
<p>saga在分布式架构下，采用事务驱动方式，让服务进行相关交互，业务方订阅相关领域事件即可。 通过事件方式降低系统复杂度，提升系统扩展性，但要注意事件循环依赖的问题。</p>
<p>SAGA可以看做一个异步的、利用队列实现的补偿事务。</p>
<p>其适用于无需马上返回业务发起方最终状态的场景，例如：你的请求已提交，请稍后查询或留意通知 之类。</p>
<p>将上述补偿事务的场景用SAGA改写，其流程如下：</p>
<ul>
<li>订单服务创建最终状态未知的订单记录，并提交事务</li>
<li>现金服务扣除所需的金额，并提交事务</li>
<li>订单服务更新订单状态为成功，并提交事务<br>以上为成功的流程，若现金服务扣除金额失败，那么，最后一步订单服务将会更新订单状态为失败。</li>
</ul>
<p>其业务编码工作量比补偿事务多一点，包括以下内容：</p>
<ul>
<li>订单服务创建初始订单的逻辑</li>
<li>订单服务确认订单成功的逻辑</li>
<li>订单服务确认订单失败的逻辑</li>
<li>现金服务扣除现金的逻辑</li>
<li>现金服务补偿返回现金的逻辑<br>但其相对于补偿事务形态有性能上的优势，所有的本地子事务执行过程中，都无需等待其调用的子事务执行，减少了加锁的时间，这在事务流程较多较长的业务中性能优势更为明显。同时，其利用队列进行进行通讯，具有削峰填谷的作用。</li>
</ul>
<p>因此该形式适用于不需要同步返回发起方执行最终结果、可以进行补偿、对性能要求较高、不介意额外编码的业务场景。</p>
<p>但当然SAGA也可以进行稍微改造，变成与TCC类似、可以进行资源预留的形态。</p>
<h3 id="2PC事务"><a href="#2PC事务" class="headerlink" title="2PC事务"></a>2PC事务</h3><p>其适用于参与者较少，单个本地事务执行时间较少，并且参与者自身可用性很高的场景，否则，其很可能导致性能下降严重。</p>
<h3 id="并非一种事务形态就能打遍天下"><a href="#并非一种事务形态就能打遍天下" class="headerlink" title="并非一种事务形态就能打遍天下"></a>并非一种事务形态就能打遍天下</h3><p>通过分析我们可以发现，并不存在一种事务形态能解决所有的问题，我们需要根据特定的业务场景选择合适的事务形态。甚至于有时需要混合多种事务形态才能更好的完成目标，如 上面提到的 订单、积分、钱包混合的场景：订单的成功与否需要依赖于钱包的余额，但不依赖于积分的多少，因此可以混合基于消息的事务形态以加积分 及 基于补偿的事务形态以确保扣钱成功，从而得到一个性能更好，编码量更少的形态。</p>
<p>然而目前很多框架都专注于某单一方面的事务形态，如TCC单独一个框架，可靠消息单独一个框架，SAGA单独一个框架，他们各自独立，容易导致以下问题：</p>
<ul>
<li>由于前期只采用了其中一种类型事务的框架，因为工具目前只有锤子，引入其他工具又涉及测试、阅读代码等过程，因此把所有问题都看做钉子，导致性能偏低或者实现不够优雅</li>
<li>由于不同框架管理事务的形态可能不一致，导致不能很好的协调工作，如某一个TCC框架和另一个基于消息的事务框架无法很好融合。</li>
</ul>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p><strong>Spring事务的隔离级别</strong></p>
<ol>
<li><code>ISOLATION_DEFAULT</code>： 这是一个 PlatfromTransactionManager  默认的隔离级别，使用数据库默认的事务隔离级别.</li>
</ol>
<p>另外四个与 JDBC的隔离级别相对应:</p>
<ol start="2">
<li><code>ISOLATION_READ_UNCOMMITTED</code>： 这是事务最低的隔离级别，它允许令外一个事务可以看到这个事务未提交的数据,</li>
</ol>
<p>这种隔离级别会产生脏读，不可重复读和幻像读。</p>
<ol start="3">
<li><p><code>ISOLATION_READ_COMMITTED</code>： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</p>
</li>
<li><p><code>ISOLATION_REPEATABLE_READ</code>： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</p>
</li>
<li><p><code>ISOLATION_SERIALIZABLE</code>  这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。</p>
</li>
</ol>
<p><strong>其中的一些概念的说明：</strong><br><strong>脏读</strong>:  指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一 个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p>
<p><strong>不可重复读</strong>:  指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。 那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p>
<p><strong>幻觉读</strong>:指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及 到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，就会发生操作第一个事务的用户发现表中还有 没有修改的数据行,也就是说幻像读是指同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻像读,就好象发生了幻觉一样。</p>
<h2 id="事务的传播行为和隔离级别之间有什么联系"><a href="#事务的传播行为和隔离级别之间有什么联系" class="headerlink" title="事务的传播行为和隔离级别之间有什么联系"></a>事务的传播行为和隔离级别之间有什么联系</h2><h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p>事务传播行为(为了解决业务层方法之间互相调用的事务问题): 当事务方法被另一个事务方法调用时,必须指定事务应该如何传播。例如:方法可能继续在现有事务中运行,也可能开启一个新事务,并在自己的事务中运行。在TransactionDefinition定义中包括了如下几个表示传播行为的常量:</p>
<h4 id="支持当前事务的情况"><a href="#支持当前事务的情况" class="headerlink" title="支持当前事务的情况"></a>支持当前事务的情况</h4><ul>
<li><code>TransactionDefinition.PROPAGATION_REQUIRED</code>: 如果当前存在事务,则加入该事务;如果当前没有事务,则创建一个新的事务。</li>
<li><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>: 如果当前存在事务,则加入该事务;如果当前没有事务,则以非事务的方式继续运行。</li>
<li><code>TransactionDefinition.PROPAGATION_MANDATORY</code>: 如果当前存在事务,则加入该事务;如果当前没有事务,则抛出异常。(mandatory:强制性)</li>
</ul>
<h4 id="不支持当前事务的情况"><a href="#不支持当前事务的情况" class="headerlink" title="不支持当前事务的情况"></a>不支持当前事务的情况</h4><ul>
<li><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code>: 创建一个新的事务,如果当前存在事务,则把当前事务挂起。</li>
<li><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>: 以非事务方式运行,如果当前存在事务,则把当前事务挂起。</li>
<li><code>TransactionDefinition.PROPAGATION_NEVER</code>: 以非事务方式运行,如果当前存在事务,则抛出异常。</li>
</ul>
<h4 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h4><ul>
<li><code>TransactionDefinition.PROPAGATION_NESTED</code>: 如果当前存在事务,则创建一个事务作为当前事务的嵌套事务来运行;如果当前没有事务,则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</li>
</ul>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量:</p>
<ul>
<li><code>TransactionDefinition.ISOLATION_DEFAULT</code>: 使用后端数据库默认的隔离级别,Mysql 默认采用的<code>REPEATABLE_READ</code>隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code>隔离级别。</li>
<li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>: 最低的隔离级别,允许读取尚未提交的数据变更,可能会导致脏读、幻读或不可重复读。</li>
<li><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>: 允许读取并发事务已经提交的数据,可以阻止脏读,但是幻读或不可重复读仍有可能发生。</li>
<li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>: 对同一字段的多次读取结果都是一致的,除非数据是被本身事务自己所修改,可以阻止脏读和不可重复读,但幻读仍有可能发生。</li>
<li><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>: 最高的隔离级别,完全服从ACID的隔离级别。所有的事务依次逐个执行,这样事务之间就完全不可能产生干扰,也就是说,该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1656058-20190611152652742-1944751292.png" alt="image"></p>
<h2 id="如何理解Spring中的AOP-和-IOC，以及DI，读过Spring源码没有？"><a href="#如何理解Spring中的AOP-和-IOC，以及DI，读过Spring源码没有？" class="headerlink" title="如何理解Spring中的AOP 和 IOC，以及DI，读过Spring源码没有？"></a>如何理解Spring中的AOP 和 IOC，以及DI，读过Spring源码没有？</h2><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/12942196-ccb87f486fddc550.png" alt="image"></p>
<h4 id="什么是aop"><a href="#什么是aop" class="headerlink" title="什么是aop"></a>什么是aop</h4><ul>
<li>AOP（Aspect Oriented Programming）称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待，Struts2的拦截器设计就是基于AOP的思想，是个比较经典的例子。</li>
<li>在不改变原有的逻辑的基础上，增加一些额外的功能。代理也是这个功能，读写分离也能用aop来做。</li>
<li>AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</li>
<li>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</li>
<li>使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</li>
</ul>
<h4 id="AOP的相关概念"><a href="#AOP的相关概念" class="headerlink" title="AOP的相关概念"></a>AOP的相关概念</h4><p>(1)横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</p>
<p>(2)Aspect(切面):通常是一个类，里面可以定义切入点和通知</p>
<p>(3)JointPoint(连接点):程序执行过程中明确的点，一般是方法的调用。被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p>
<p>(4)Advice(通知):AOP在特定的切入点上执行的增强处理，有before(前置),after(后置),afterReturning(最终),afterThrowing(异常),around(环绕)</p>
<p>(5)Pointcut(切入点):就是带有通知的连接点，在程序中主要体现为书写切入点表达式</p>
<p>(6)weave(织入)：将切面应用到目标对象并导致代理对象创建的过程</p>
<p>(7)introduction(引入)：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段</p>
<p>(8)AOP代理(AOP Proxy)：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类</p>
<p>(9)目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO</p>
<h4 id="Advice通知类型介绍"><a href="#Advice通知类型介绍" class="headerlink" title="Advice通知类型介绍"></a>Advice通知类型介绍</h4><p>(1)Before:在目标方法被调用之前做增强处理,@Before只需要指定切入点表达式即可</p>
<p>(2)AfterReturning:在目标方法正常完成后做增强,@AfterReturning除了指定切入点表达式后，还可以指定一个返回值形参名returning,代表目标方法的返回值</p>
<p>(3)AfterThrowing:主要用来处理程序中未处理的异常,@AfterThrowing除了指定切入点表达式后，还可以指定一个throwing的返回值形参名,可以通过该形参名</p>
<p>来访问目标方法中所抛出的异常对象</p>
<p>(4)After:在目标方法完成之后做增强，无论目标方法时候成功完成。@After可以指定一个切入点表达式</p>
<p>(5)Around:环绕通知,在目标方法完成前后做增强处理,环绕通知是最重要的通知类型,像事务,日志等都是环绕通知,注意编程中核心是一个ProceedingJoinPoint</p>
<h4 id="AOP使用场景"><a href="#AOP使用场景" class="headerlink" title="AOP使用场景"></a>AOP使用场景</h4><ul>
<li>Authentication 权限</li>
<li>Caching 缓存</li>
<li>Context passing 内容传递</li>
<li>Error handling 错误处理</li>
<li>Lazy loading　懒加载</li>
<li>Debugging　　调试</li>
<li>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</li>
<li>Performance optimization　性能优化</li>
<li>Persistence　　持久化</li>
<li>Resource pooling　资源池</li>
<li>Synchronization　同步</li>
<li>Transactions 事务</li>
</ul>
<h4 id="使用AOP的几种方式"><a href="#使用AOP的几种方式" class="headerlink" title="使用AOP的几种方式"></a>使用AOP的几种方式</h4><p>1.经典的基于代理的AOP</p>
<p>2.@AspectJ注解驱动的切面</p>
<p>3.纯POJO切面（纯粹通过<code>&lt;aop:fonfig&gt;</code>标签配置）</p>
<p>4.注入式AspectJ切面</p>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IoC 全称为 Inversion of Control，翻译为 “控制反转”，它还有一个别名为 DI（Dependency Injection）,即依赖注入。</p>
<p>如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：</p>
<ol>
<li>谁控制谁</li>
<li>控制什么</li>
<li>为何是反转</li>
<li>哪些方面反转了</li>
</ol>
<p>在回答这四个问题之前，我们先看 IOC 的定义：</p>
<blockquote>
<p>所谓 IOC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系</p>
</blockquote>
<p>上面这句话是整个 IoC 理论的核心。如何来理解这句话？我们引用一个例子来走阐述（看完该例子上面四个问题也就不是问题了）。</p>
<p>已找女朋友为例（对于程序猿来说这个值得探究的问题）。一般情况下我们是如何来找女朋友的呢？首先我们需要根据自己的需求（漂亮、身材好、性格好）找一个妹子，然后到处打听她的兴趣爱好、微信、电话号码，然后各种投其所好送其所要，最后追到手。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 年轻小伙子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungMan</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> BeautifulGirl beautifulGirl;</span><br><span class="line"></span><br><span class="line">    YoungMan()&#123;</span><br><span class="line">        <span class="comment">// 可能你比较牛逼，指腹为婚</span></span><br><span class="line">        <span class="comment">// beautifulGirl = new BeautifulGirl();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeautifulGirl</span><span class="params">(BeautifulGirl beautifulGirl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beautifulGirl = beautifulGirl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        YoungMan you = <span class="keyword">new</span> YoungMan();</span><br><span class="line">        BeautifulGirl beautifulGirl = <span class="keyword">new</span> BeautifulGirl(<span class="string">"你的各种条件"</span>);</span><br><span class="line">        beautifulGirl.setxxx(<span class="string">"各种投其所好"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后你有女票了</span></span><br><span class="line">        you.setBeautifulGirl(beautifulGirl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是我们通常做事的方式，如果我们需要某个对象，一般都是采用这种直接创建的方式(<code>new BeautifulGirl()</code>)，这个过程复杂而又繁琐，而且我们必须要面对每个环节，同时使用完成之后我们还要负责销毁它，在这种情况下我们的对象与它所依赖的对象耦合在一起。</p>
<p>其实我们需要思考一个问题？我们每次用到自己依赖的对象真的需要自己去创建吗？我们知道，我们依赖对象其实并不是依赖该对象本身，而是依赖它所提供的服务，只要在我们需要它的时候，它能够及时提供服务即可，至于它是我们主动去创建的还是别人送给我们的，其实并不是那么重要。再说了，相比于自己千辛万苦去创建它还要管理、善后而言，直接有人送过来是不是显得更加好呢？</p>
<p>这个给我们送东西的“人” 就是 IoC，在上面的例子中，它就相当于一个婚介公司，作为一个婚介公司它管理着很多男男女女的资料，当我们需要一个女朋友的时候，直接跟婚介公司提出我们的需求，婚介公司则会根据我们的需求提供一个妹子给我们，我们只需要负责谈恋爱，生猴子就行了。你看，这样是不是很简单明了。</p>
<p>诚然，作为婚介公司的 IoC 帮我们省略了找女朋友的繁杂过程，将原来的主动寻找变成了现在的被动接受（符合我们的要求），更加简洁轻便。你想啊，原来你还得鞍马前后，各种巴结，什么东西都需要自己去亲力亲为，现在好了，直接有人把现成的送过来，多么美妙的事情啊。所以，简单点说，IoC 的理念就是让别人为你服务</p>
<p>在没有引入 IoC 的时候，被注入的对象直接依赖于被依赖的对象，有了 IoC 后，两者及其他们的关系都是通过 Ioc Service Provider 来统一管理维护的。被注入的对象需要什么，直接跟 IoC Service Provider 打声招呼，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到 IOC Service Provider 为被注入对象服务的目的。所以 IoC 就是这么简单！原来是需要什么东西自己去拿，现在是需要什么东西让别人（IOC Service Provider）送过来</p>
<p>现在在看上面那四个问题，答案就显得非常明显了:</p>
<ul>
<li>谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。</li>
<li>控制什么：控制对象。</li>
<li>为何是反转：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li>
<li><p>哪些方面反转了：所依赖对象的获取被反转了。<br>妹子有了，但是如何拥有妹子呢？这也是一门学问。</p>
</li>
<li><p>可能你比较牛逼，刚刚出生的时候就指腹为婚了。</p>
</li>
<li>大多数情况我们还是会考虑自己想要什么样的妹子，所以还是需要向婚介公司打招呼的。</li>
<li>还有一种情况就是，你根本就不知道自己想要什么样的妹子，直接跟婚介公司说，我就要一个这样的妹子。<br>所以，IOC Service Provider 为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、stter方法注入、接口注入。</li>
</ul>
<h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><p>构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">YoungMan</span>(<span class="keyword">BeautifulGirl </span><span class="keyword">beautifulGirl)&#123;</span></span><br><span class="line"><span class="keyword"> </span>       this.<span class="keyword">beautifulGirl </span>= <span class="keyword">beautifulGirl;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>构造器注入方式比较直观，对象构造完毕后就可以直接使用，这就好比你出生你家里就给你指定了你媳妇。</p>
<h4 id="setter-方法注入"><a href="#setter-方法注入" class="headerlink" title="setter 方法注入"></a>setter 方法注入</h4><p>对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungMan</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> BeautifulGirl beautifulGirl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeautifulGirl</span><span class="params">(BeautifulGirl beautifulGirl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beautifulGirl = beautifulGirl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前），这就好比你可以先把自己想要的妹子想好了，然后再跟婚介公司打招呼，你可以要林志玲款式的，赵丽颖款式的，甚至凤姐哪款的，随意性较强。</p>
<h4 id="接口方式注入"><a href="#接口方式注入" class="headerlink" title="接口方式注入"></a>接口方式注入</h4><p>接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。</p>
<h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>DI（Dependency Injection）依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。</p>
<h4 id="依赖注入发生的时间"><a href="#依赖注入发生的时间" class="headerlink" title="依赖注入发生的时间"></a>依赖注入发生的时间</h4><p>当 Spring IOC 容器完成了 Bean 定义资源的定位、载入和解析注册以后，IOC 容器中已经管理类 Bean定义的相关数据，但是此时 IOC 容器还没有对所管理的 Bean 进行依赖注入，依赖注入在以下两种情况发生：<br>1)、用户第一次调用 getBean()方法时，IOC 容器触发依赖注入。<br>2)、当用户在配置文件中将<code>&lt;bean&gt;</code>元素配置了 lazy-init=false 属性，即让容器在解析注册 Bean 定义时进行预实例化，触发依赖注入。</p>
<p>BeanFactory 接口定义了 Spring IOC 容器的基本功能规范，是 Spring IOC 容器所应遵守的最底层和最基本的编程规范。BeanFactory 接口中定义了几个 getBean()方法，就是用户向 IOC 容器索取管理的Bean 的方法，我们通过分析其子类AbstractBeanFactory 的具体实现，理解 Spring IOC 容器在用户索取 Bean 时如何完成依赖注入。</p>
<p>AbstractBeanFactory 的 getBean()相关方法的源码如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取IOC容器中指定名称的Bean</span></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> getBean(<span class="keyword">String</span> name) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程</span></span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取IOC容器中指定名称和类型的Bean</span></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T getBean(<span class="keyword">String</span> name, @Nullable Class&lt;T&gt; requiredType) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程</span></span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取IOC容器中指定名称和参数的Bean</span></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> getBean(<span class="keyword">String</span> name, <span class="keyword">Object</span>... args) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程</span></span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取IOC容器中指定名称、类型和参数的Bean</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T getBean(<span class="keyword">String</span> name, @Nullable Class&lt;T&gt; requiredType, @Nullable <span class="keyword">Object</span>... args)</span><br><span class="line">        <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程</span></span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, requiredType, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="comment">//真正实现向IOC容器获取Bean的功能，也是触发依赖注入功能的地方</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T doGetBean(<span class="keyword">final</span> <span class="keyword">String</span> name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span><br><span class="line">        @Nullable <span class="keyword">final</span> <span class="keyword">Object</span>[] args, <span class="built_in">boolean</span> typeCheckOnly) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖</span></span><br><span class="line">    <span class="comment">//如果指定的是别名，将别名转换为规范的Bean名称</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span> beanName = transformedBeanName(name);</span><br><span class="line">    <span class="keyword">Object</span> bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    <span class="comment">//先从缓存中取是否已经有被创建过的单态类型的Bean</span></span><br><span class="line">    <span class="comment">//对于单例模式的Bean整个IOC容器中只创建一次，不需要重复创建</span></span><br><span class="line">    <span class="keyword">Object</span> sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="comment">//IOC容器创建单例模式Bean实例对象</span></span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="comment">//如果指定名称的Bean在容器中已有单例模式的Bean被创建</span></span><br><span class="line">            <span class="comment">//直接返回已经创建的Bean</span></span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取给定Bean的实例对象，主要是完成FactoryBean的相关处理</span></span><br><span class="line">        <span class="comment">//注意：BeanFactory是管理容器中Bean的工厂，而FactoryBean是</span></span><br><span class="line">        <span class="comment">//创建创建对象的工厂Bean，两者之间有区别</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line">        <span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line">        <span class="comment">//缓存没有正在创建的单例模式Bean</span></span><br><span class="line">        <span class="comment">//缓存中已经有已经创建的原型模式Bean</span></span><br><span class="line">        <span class="comment">//但是由于循环引用的问题导致实例化对象失败</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">        <span class="comment">//对IOC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否</span></span><br><span class="line">        <span class="comment">//能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器</span></span><br><span class="line">        <span class="comment">//的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="comment">//当前容器的父级容器存在，且当前容器中不存在指定名称的Bean</span></span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">            <span class="comment">//解析指定Bean名称的原始名称</span></span><br><span class="line">            <span class="keyword">String</span> nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                        nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="comment">//委派父级容器根据指定名称和显式的参数查找</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="comment">//委派父级容器根据指定名称和类型查找</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建的Bean是否需要进行类型验证，一般不需要</span></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            <span class="comment">//向容器标记指定的Bean已经被创建</span></span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据指定Bean名称获取其父级的Bean定义</span></span><br><span class="line">            <span class="comment">//主要解决Bean继承时子类合并父类公共属性问题</span></span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">            <span class="comment">//获取当前Bean所有依赖Bean的名称</span></span><br><span class="line">            <span class="keyword">String</span>[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="comment">//如果当前Bean有依赖Bean</span></span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">String</span> dep : dependsOn) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//递归调用getBean方法，获取当前Bean的依赖Bean</span></span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="comment">//把被依赖Bean注册给当前依赖的Bean</span></span><br><span class="line">                    getBean(dep);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create bean instance.</span></span><br><span class="line">            <span class="comment">//创建单例模式Bean的实例对象</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                <span class="comment">//这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象</span></span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//创建一个指定Bean实例对象，如果有父级继承，则合并子类和父类的定义</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                        <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                        <span class="comment">//显式地从容器单例模式Bean缓存中清除实例对象</span></span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//IOC容器创建原型模式Bean实例对象</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">                <span class="comment">//原型模式(Prototype)是每次都会创建一个新的对象</span></span><br><span class="line">                <span class="keyword">Object</span> prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//回调beforePrototypeCreation方法，默认的功能是注册当前创建的原型对象</span></span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    <span class="comment">//创建指定Bean对象实例</span></span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//回调afterPrototypeCreation方法，默认的功能告诉IOC容器指定Bean的原型对象不再创建</span></span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//要创建的Bean既不是单例模式，也不是原型模式，则根据Bean定义资源中</span></span><br><span class="line">            <span class="comment">//配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中</span></span><br><span class="line">            <span class="comment">//比较常用，如：request、session、application等生命周期</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">String</span> scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.<span class="built_in">get</span>(scopeName);</span><br><span class="line">                <span class="comment">//Bean定义资源中没有配置生命周期范围，则Bean定义不合法</span></span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例</span></span><br><span class="line">                    <span class="keyword">Object</span> scopedInstance = scope.<span class="built_in">get</span>(beanName, () -&gt; &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">//获取给定Bean的实例对象</span></span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                            <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                            <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                            ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">    <span class="comment">//对创建的Bean实例对象进行类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                        ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面对向 IOC 容器获取 Bean 方法的分析，我们可以看到在 Spring 中，如果 Bean 定义的单例模式(Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果 Bean定义的是原型模式(Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean 定义还可以通过其指定的生命周期范围来创建。</p>
<p>上面的源码只是定义了根据 Bean 定义的模式，采取的不同创建 Bean 实例对象的策略，具体的 Bean实例 对象的创 建过程 由实现了AbstractBeanFactory接口 的匿名内 部类的createBean()方法 完成，AbstractBeanFactory使 用 委 派 模 式 ， 具 体 的 Bean 实 例 创 建 过 程 交 由 其 实 现 类AbstractAutowireCapableBeanFactory 完成，我们继续分析AbstractAutowireCapableBeanFactory的 createBean()方法的源码，理解其创建 Bean 实例的具体实现过程。</p>
<h4 id="开始实例化"><a href="#开始实例化" class="headerlink" title="开始实例化"></a>开始实例化</h4><p>AbstractAutowireCapableBeanFactory 类实现了 AbstractBeanFactory接口，创建容器指定的 Bean 实例对象，同时还对创建的 Bean 实例对象进行初始化处理。其创建 Bean 实例对象的方法源码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Bean实例对象</span></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> createBean(<span class="keyword">String</span> beanName, RootBeanDefinition mbd, @Nullable <span class="keyword">Object</span>[] args)</span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">    <span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">    <span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">    <span class="comment">//判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare method overrides.</span></span><br><span class="line">    <span class="comment">//校验和准备Bean中的方法覆盖</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        <span class="comment">//如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建Bean的代理对象</span></span><br><span class="line">        <span class="keyword">Object</span> bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建Bean的入口</span></span><br><span class="line">        <span class="keyword">Object</span> beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        <span class="comment">// A previously detected exception with proper bean creation context already...</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// An IllegalStateException to be communicated up to DefaultSingletonBeanRegistry...</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正创建Bean的方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> doCreateBean(<span class="keyword">final</span> <span class="keyword">String</span> beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable <span class="keyword">Object</span>[] args)</span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    <span class="comment">//封装被创建的Bean对象</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">Object</span> bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    <span class="comment">//获取实例化对象的类型</span></span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="comment">//调用PostProcessor后置处理器</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="comment">//向容器中缓存单例模式的Bean对象，以防循环引用</span></span><br><span class="line">    <span class="built_in">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="comment">//Bean对象的初始化，依赖注入在此触发</span></span><br><span class="line">    <span class="comment">//这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean</span></span><br><span class="line">    <span class="keyword">Object</span> exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">//初始化Bean对象</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">//获取指定名称的已注册的单例模式Bean对象</span></span><br><span class="line">        <span class="keyword">Object</span> earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根据名称获取的已注册的Bean和正在实例化的Bean是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                <span class="comment">//当前实例化的Bean初始化完成</span></span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前Bean依赖其他Bean，并且当发生循环引用时不允许新创建实例对象</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                <span class="keyword">String</span>[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;<span class="keyword">String</span>&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="comment">//获取当前Bean所依赖的其他Bean</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">String</span> dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="comment">//对依赖Bean进行类型检查</span></span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.<span class="built_in">add</span>(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                            <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                            <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                            <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="comment">//注册完成依赖注入的Bean</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的源码注释，我们看到具体的依赖注入实现其实就在以下两个方法中：<br>1)、createBeanInstance()方法，生成 Bean 所包含的 java 对象实例。<br>2)、populateBean()方法，对 Bean 属性的依赖注入进行处理。<br>下面继续分析这两个方法的代码实现。</p>
<h4 id="选择-Bean-实例化策略"><a href="#选择-Bean-实例化策略" class="headerlink" title="选择 Bean 实例化策略"></a>选择 Bean 实例化策略</h4><p>在 createBeanInstance()方法中，根据指定的初始化策略，使用简单工厂、工厂方法或者容器的自动装配特性生成 Java 实例对象，创建对象的源码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Bean的实例对象</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function">BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">    <span class="comment">//检查确认Bean是可实例化的</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用工厂方法对Bean进行实例化</span></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">    <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">obtainFromSupplier</span><span class="params">(instanceSupplier, beanName)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line">        <span class="comment">//调用工厂方法实例化</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">instantiateUsingFactoryMethod</span><span class="params">(beanName, mbd, args)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">    <span class="comment">//使用容器的自动装配方法进行实例化</span></span><br><span class="line">    <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resolved = <span class="keyword">true</span>;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">        <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">            <span class="comment">//配置了自动装配属性，使用容器的自动装配实例化</span></span><br><span class="line">            <span class="comment">//容器的自动装配是根据参数类型匹配Bean的构造方法</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="title">autowireConstructor</span><span class="params">(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//使用默认的无参构造方法实例化</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="title">instantiateBean</span><span class="params">(beanName, mbd)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Need to determine the constructor...</span></span><br><span class="line">    <span class="comment">//使用Bean的构造方法进行实例化</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">        <span class="comment">//使用容器的自动装配特性，调用匹配的构造方法实例化</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">autowireConstructor</span><span class="params">(beanName, mbd, ctors, args)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">    <span class="comment">//使用默认的无参构造方法实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">instantiateBean</span><span class="params">(beanName, mbd)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认的无参构造方法实例化Bean对象</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function">BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object beanInstance;</span><br><span class="line">        <span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//获取系统的安全管理接口，JDK标准的安全管理API</span></span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//这里是一个匿名内置类，根据实例化策略创建实例对象</span></span><br><span class="line">            beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">                    getInstantiationStrategy().instantiate(mbd, beanName, parent),</span><br><span class="line">                    getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将实例化的对象封装起来</span></span><br><span class="line">            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">        &#125;</span><br><span class="line">        BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">        initBeanWrapper(bw);</span><br><span class="line">        <span class="keyword">return</span> bw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过对上面的代码分析，我们可以看出，对使用工厂方法和自动装配特性的 Bean 的实例化相当比较清楚，调用相应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作，但是对于我们最常使用的默认无参构造方法就需要使用相应的初始化策略(JDK 的反射机制或者 CGLib)来进行初始化了，在方法 getInstantiationStrategy().instantiate()中就具体实现类使用初始策略实例化对象。</p>
<h4 id="执行-Bean-实例化"><a href="#执行-Bean-实例化" class="headerlink" title="执行 Bean 实例化"></a>执行 Bean 实例化</h4><p>在使用默认的无参构造方法创建 Bean 的实例化对象时，方法 getInstantiationStrategy().instantiate()调用了 SimpleInstantiationStrategy 类中的实例化 Bean 的方法，其源码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用初始化策略实例化Bean对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Don't override the class with CGLIB if no overrides.</span></span><br><span class="line">    <span class="comment">//如果Bean定义中没有方法覆盖，则就不需要CGLIB父类类的方法</span></span><br><span class="line">    <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">        Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">        <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="comment">//获取对象的构造方法或工厂方法</span></span><br><span class="line">            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            <span class="comment">//如果没有构造方法且没有工厂方法</span></span><br><span class="line">            <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//使用JDK的反射机制，判断要实例化的Bean是否是接口</span></span><br><span class="line">                <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">                <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//这里是一个匿名内置类，使用反射机制获取Bean的构造方法</span></span><br><span class="line">                        constructorToUse = AccessController.doPrivileged(</span><br><span class="line">                                (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) () -&gt; clazz.getDeclaredConstructor());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        constructorToUse =    clazz.getDeclaredConstructor();</span><br><span class="line">                    &#125;</span><br><span class="line">                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用BeanUtils实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> BeanUtils.<span class="title">instantiateClass</span><span class="params">(constructorToUse)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line">        <span class="comment">//使用CGLIB来实例化对象</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">instantiateWithMethodInjection</span><span class="params">(bd, beanName, owner)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码分析，我们看到了如果 Bean 有方法被覆盖了，则使用 JDK 的反射机制进行实例化，否则，使用 CGLib 进行实例化。instantiateWithMethodInjection() 方 法 调 用SimpleInstantiationStrategy 的 子 类CGLibSubclassingInstantiationStrategy 使用 CGLib 来进行初始化，其源码如下：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用CGLIB进行Bean对象实例化</span></span><br><span class="line">    <span class="keyword">public</span> Object instantiate(@Nullable Constructor&lt;?&gt; ctor, @Nullable Object... args) &#123;</span><br><span class="line">        <span class="comment">//创建代理子类</span></span><br><span class="line">        Class&lt;?&gt; subclass = createEnhancedSubclass(<span class="built_in">this</span>.beanDefinition);</span><br><span class="line">        Object instance;</span><br><span class="line">        <span class="keyword">if</span> (ctor == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = BeanUtils.instantiateClass(subclass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Constructor&lt;?&gt; enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());</span><br><span class="line">                instance = enhancedSubclassConstructor.<span class="keyword">new</span><span class="type">Instance</span>(args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">BeanInstantiationException</span>(<span class="built_in">this</span>.beanDefinition.getBeanClass(),</span><br><span class="line">                        <span class="string">"Failed to invoke constructor for CGLIB enhanced subclass ["</span> + subclass.getName() + <span class="string">"]"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// SPR-10785: set callbacks directly on the instance instead of in the</span></span><br><span class="line">        <span class="comment">// enhanced class (via the Enhancer) in order to avoid memory leaks.</span></span><br><span class="line">        Factory factory = (Factory) instance;</span><br><span class="line">        factory.setCallbacks(<span class="keyword">new</span> <span class="type">Callback</span>[] &#123;NoOp.INSTANCE,</span><br><span class="line">                <span class="keyword">new</span> <span class="type">LookupOverrideMethodInterceptor</span>(<span class="built_in">this</span>.beanDefinition, <span class="built_in">this</span>.owner),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">ReplaceOverrideMethodInterceptor</span>(<span class="built_in">this</span>.beanDefinition, <span class="built_in">this</span>.owner)&#125;);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; createEnhancedSubclass(RootBeanDefinition beanDefinition) &#123;</span><br><span class="line">        <span class="comment">//CGLIB中的类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> <span class="type">Enhancer</span>();</span><br><span class="line">        <span class="comment">//将Bean本身作为其基类</span></span><br><span class="line">        enhancer.setSuperclass(beanDefinition.getBeanClass());</span><br><span class="line">        enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.owner instanceof ConfigurableBeanFactory) &#123;</span><br><span class="line">            ClassLoader cl = ((ConfigurableBeanFactory) <span class="built_in">this</span>.owner).getBeanClassLoader();</span><br><span class="line">            enhancer.setStrategy(<span class="keyword">new</span> <span class="type">ClassLoaderAwareGeneratorStrategy</span>(cl));</span><br><span class="line">        &#125;</span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> <span class="type">MethodOverrideCallbackFilter</span>(beanDefinition));</span><br><span class="line">        enhancer.setCallbackTypes(CALLBACK_TYPES);</span><br><span class="line">        <span class="comment">//使用CGLIB的createClass方法生成实例对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.createClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CGLib 是一个常用的字节码生成器的类库，它提供了一系列 API 实现 Java 字节码的生成和转换功能。JDK 的动态代理只能针对接口，如果一个类没有实现任何接口，要对其进行动态代理只能使用 CGLib。</p>
<h4 id="准备依赖注入"><a href="#准备依赖注入" class="headerlink" title="准备依赖注入"></a>准备依赖注入</h4><p>在前面的分析中我们已经了解到 Bean 的依赖注入主要分为两个步骤，首先调用 createBeanInstance()方法生成 Bean 所包含的 Java 对象实例。然后，调用 populateBean()方法，对 Bean 属性的依赖注入进行处理。<br>上面我们已经分析了容器初始化生成 Bean 所包含的 Java 实例对象的过程，现在我们继续分析生成对象后，Spring IOC 容器是如何将 Bean 的属性依赖关系注入 Bean 实例对象中并设置好的，回到AbstractAutowireCapableBeanFactory 的 populateBean()方法，对属性依赖注入的代码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Bean属性设置到生成的实例对象上</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> populateBean(<span class="keyword">String</span> beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">    <span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">    <span class="comment">// to support styles of field injection.</span></span><br><span class="line">    <span class="built_in">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                    continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值</span></span><br><span class="line">    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对依赖注入处理，首先处理autowiring自动装配的依赖注入</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">        <span class="comment">//根据Bean名称进行autowiring自动装配处理</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">        <span class="comment">//根据Bean类型进行autowiring自动装配处理</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对非autowiring的属性进行依赖注入处理</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="built_in">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                    pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                    <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">            checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//对属性进行注入</span></span><br><span class="line">        applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析并注入依赖属性的过程</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> applyPropertyValues(<span class="keyword">String</span> beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pvs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装属性值</span></span><br><span class="line">    MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">            <span class="comment">//设置安全上下文，JDK安全机制</span></span><br><span class="line">            ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">        mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">        <span class="comment">//属性值已经转换</span></span><br><span class="line">        <span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">            <span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//为实例化对象设置属性值</span></span><br><span class="line">                bw.setPropertyValues(mpvs);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                        mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取属性值对象的原始类型值</span></span><br><span class="line">        original = mpvs.getPropertyValueList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取用户自定义的类型转换</span></span><br><span class="line">    TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        converter = bw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个Bean定义属性值解析器，将Bean定义中的属性值解析为Bean实例对象的实际值</span></span><br><span class="line">    BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//为属性的解析值创建一个拷贝，将拷贝的数据注入到实例对象中</span></span><br><span class="line">    List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;&gt;(original.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">        <span class="comment">//属性值不需要转换</span></span><br><span class="line">        <span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">            deepCopy.<span class="built_in">add</span>(pv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//属性值需要转换</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">String</span> propertyName = pv.getName();</span><br><span class="line">            <span class="comment">//原始的属性值，即转换之前的属性值</span></span><br><span class="line">            <span class="keyword">Object</span> originalValue = pv.getValue();</span><br><span class="line">            <span class="comment">//转换属性值，例如将引用转换为IOC容器中实例化对象引用</span></span><br><span class="line">            <span class="keyword">Object</span> resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">            <span class="comment">//转换之后的属性值</span></span><br><span class="line">            <span class="keyword">Object</span> convertedValue = resolvedValue;</span><br><span class="line">            <span class="comment">//属性值是否可以转换</span></span><br><span class="line">            <span class="built_in">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">                    !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">            <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">                <span class="comment">//使用用户自定义的类型转换器转换属性值</span></span><br><span class="line">                convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Possibly store converted value in merged bean definition,</span></span><br><span class="line">            <span class="comment">// in order to avoid re-conversion for every created bean instance.</span></span><br><span class="line">            <span class="comment">//存储转换后的属性值，避免每次属性注入时的转换工作</span></span><br><span class="line">            <span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">                    <span class="comment">//设置属性转换之后的值</span></span><br><span class="line">                    pv.setConvertedValue(convertedValue);</span><br><span class="line">                &#125;</span><br><span class="line">                deepCopy.<span class="built_in">add</span>(pv);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//属性是可转换的，且属性原始值是字符串类型，且属性的原始类型值不是</span></span><br><span class="line">            <span class="comment">//动态生成的字符串，且属性的原始值不是集合或者数组类型</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">                    !((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">                    !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">                pv.setConvertedValue(convertedValue);</span><br><span class="line">                <span class="comment">//重新封装属性的值</span></span><br><span class="line">                deepCopy.<span class="built_in">add</span>(pv);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">                deepCopy.<span class="built_in">add</span>(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">        <span class="comment">//标记属性值已经转换过</span></span><br><span class="line">        mpvs.setConverted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set our (possibly massaged) deep copy.</span></span><br><span class="line">    <span class="comment">//进行属性依赖注入</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析上述代码，我们可以看出，对属性的注入过程分以下两种情况：<br>1)、属性值类型不需要强制转换时，不需要解析属性值，直接准备进行依赖注入。<br>2)、属性值需要进行类型强制转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。<br>对属性值的解析是在 BeanDefinitionValueResolver 类中的 resolveValueIfNecessary()方法中进行的，对属性值的依赖注入是通过 bw.setPropertyValues()方法实现的，在分析属性值的依赖注入之前，我们先分析一下对属性值的解析过程</p>
<h4 id="解析属性注入规则"><a href="#解析属性注入规则" class="headerlink" title="解析属性注入规则"></a>解析属性注入规则</h4><p>当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个 Bean实例对象的引用，则容器首先需要根据属性值解析出所引用的对象，然后才能将该引用对象注入到目标实例对象的属性上去，对属性进行解析的由 resolveValueIfNecessary()方法实现。</p>
<p>Spring IOC 容器是如何将属性的值注入到 Bean 实例对象中去的：<br>1)、对于集合类型的属性，将其属性值解析为目标类型的集合后直接赋值给属性。</p>
<p>2)、对于非集合类型的属性，大量使用了 JDK 的反射机制，通过属性的 getter()方法获取指定属性注入以前的值，同时调用属性的 setter()方法为属性设置注入后的值。看到这里相信很多人都明白了 Spring的 setter()注入原理</p>
<p>Spring DI运行时序图<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1624288-20190628135317957-1069467007.png" alt="image"></p>
<h2 id="如何理解分布式事务，为什么会出现这个问题，如何去解决，了解哪些分布式事务中间件？"><a href="#如何理解分布式事务，为什么会出现这个问题，如何去解决，了解哪些分布式事务中间件？" class="headerlink" title="如何理解分布式事务，为什么会出现这个问题，如何去解决，了解哪些分布式事务中间件？"></a>如何理解分布式事务，为什么会出现这个问题，如何去解决，了解哪些分布式事务中间件？</h2><p> 分布式中间件，我自己了解的就有</p>
<ul>
<li>seata</li>
<li>tx-lcn</li>
<li>easyTransaction</li>
<li>serviceComb</li>
</ul>
<h2 id="Dubbo有了解没有？"><a href="#Dubbo有了解没有？" class="headerlink" title="Dubbo有了解没有？"></a>Dubbo有了解没有？</h2><p>阿里开源的一款分布式框架。</p>
<h2 id="Hystrix功能和在项目中怎么使用的？Hystrix怎么检测断路器是否要开启-关闭？Hystrix实现原理？除Hystrix之外的其他熔断限流中间件有了解没有，了解多少说多少？"><a href="#Hystrix功能和在项目中怎么使用的？Hystrix怎么检测断路器是否要开启-关闭？Hystrix实现原理？除Hystrix之外的其他熔断限流中间件有了解没有，了解多少说多少？" class="headerlink" title="Hystrix功能和在项目中怎么使用的？Hystrix怎么检测断路器是否要开启/关闭？Hystrix实现原理？除Hystrix之外的其他熔断限流中间件有了解没有，了解多少说多少？"></a>Hystrix功能和在项目中怎么使用的？Hystrix怎么检测断路器是否要开启/关闭？Hystrix实现原理？除Hystrix之外的其他熔断限流中间件有了解没有，了解多少说多少？</h2><p>在一个分布式系统中，必然会有部分系统的调用会失败。Hystrix是一个通过添加超时容错和失败容错逻辑来帮助你控制这些分布式系统的交互。Hystrix通过隔离服务之间的访问，阻止他们之间的级联故障以及提供后背选项来实现这些，所有新而这些都用来提高系统的整体弹性。</p>
<p> Hystrix被设计用来解决一下几个方面</p>
<ul>
<li>通过第三方（一般来源网络）的调用，给与保护和控制延迟和失败。</li>
<li>在复杂的分布式系统中复制级联失败。</li>
<li>快速失败和修复。</li>
<li>在可能的情况下，回滚挥着优雅的失败。</li>
<li>实现几乎实时监控，警报和操作控制。</li>
</ul>
<p>复杂的分布式体系结构中的应用程序具有许多依赖关系，每个依赖关系都会在某些时候不可避免的失败。如果主机应用程序未与这些外部的故障隔离，那么可能会被这些故障拖垮。</p>
<p>例如:一个依赖30个SOA服务的系统,每个服务99.99%可用。</p>
<p>99.99%的30次方 ≈ 99.7%</p>
<p>0.3% 意味着一亿次请求 会有 3,000,00次失败</p>
<p>换算成时间大约每月有2个小时服务不稳定.</p>
<p>随着服务依赖数量的变多，服务不稳定的概率会成指数性提高.<br>而实际中可能更糟糕。</p>
<h3 id="Hystrix设计模式"><a href="#Hystrix设计模式" class="headerlink" title="Hystrix设计模式"></a>Hystrix设计模式</h3><p>设计详解（命令模式）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180719101351962.png" alt="image"><br>流程图<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/hystrix-command-flow-chart.png" alt="image"><br>流程说明</p>
<ol>
<li>构造一个HystrixCommand或者HystrixObserverCommand对象，把需要调用的依赖放在run()中</li>
<li>执行execute/queue做同步或者异步执行</li>
<li>是否做了缓存</li>
<li>熔断是否打开</li>
<li>线程池/队列/信号量是否满了</li>
<li>调用run（）或者construct（）</li>
<li>计算熔断健康度（成功，失败，拒绝，超时）的数据，上报给熔断器，用于统计从而判断熔断器状态，可以根据这些数据来决定是否进行熔断，例如：错误率在80%以上，接口等待超过预定的时间等。</li>
<li>获取Fallback，如果fallback失败，系统报错，所以要尽量防止fallback报错，当然也可以在fallback上加上一层fallback</li>
<li>返回执行结果</li>
</ol>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><h4 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h4><p>下图显示了HystrixCommand或者HystrixObserverCommand如何与HystrixCircuitBreaker及其逻辑和决策流程。包括计数器在断路器中的行为方式。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/hystrix-command-flow-chart.png" alt="image"><br>熔断行为</p>
<p>断路器打开还是关闭的步骤如下</p>
<ol>
<li>假定请求的量超过预定的阈值（circuitBreakerRequestVolumeThreshold）</li>
<li>再假定错误百分比超过了设定的百分比（circuitBreakerErrorThresholdPercentage）</li>
<li>断路器会从close状态到open状态</li>
<li>当打开的状态，会短路所有针对该断路器的请求</li>
<li>过了一定时间（circuitBreakerSleepWindowInMilliseconds（短路超过一定时间会重新去请求）），下一个请求将通过，不会被短路（当前是half-open状态）。如果这个请求失败了，则断路器在睡眠窗口期间返回open状态，如果请求成功，则断路器返回close状态，并重新回到第一步逻辑判断。</li>
</ol>
<h4 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h4><p>Hystrix使用璧仓模式来隔离彼此的依赖关系，并限制对其中任何一个的并发访问。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180719101939418.png" alt="image"></p>
<h3 id="线程和线程池"><a href="#线程和线程池" class="headerlink" title="线程和线程池"></a>线程和线程池</h3><p>客户端（第三方，网络调用等）依赖和请求线程运行在不同的线程上，这个将他们从调用线程隔离开来，这样调用者就可以从一个耗时太长的依赖中隔离。如下图所示，也可以为不同的请求开启不同的线程池，彼此之间不相互干扰。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/circuit-breaker-1280.png" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/isolation-options-12801.png" alt="image"><br>（注：上图右边表示的是信号量模式）</p>
<h4 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h4><p>1、线程隔离的好处：</p>
<ul>
<li>整个应用的即是在客户端调用失效的情况下也能健康的运行，线程池能够保证这个线程下面的失效不会影响应用其他部分的运行</li>
<li>当失效的客户端调用回复的时候，这个线程池也会被清理并且应用会立马回复健康，比tomcat那种长时间的恢复要好很多</li>
</ul>
<p>简而言之，线程隔离能够允许在不引起中断的情况下优雅的处理第三方调用的各种问题。</p>
<p>2、线程隔离的缺点</p>
<ul>
<li>主要缺点是增加了上下文切换的开销，每个明亮的执行都涉及到队列，调度和上下文切换。不过NetFix在设计这个系统的时候，已经决定接受这笔开销，以换取他的好处。</li>
</ul>
<h4 id="信号量隔离"><a href="#信号量隔离" class="headerlink" title="信号量隔离"></a>信号量隔离</h4><p>你可以使用信号量（或者计数器）来限制当前依赖调用的并发数，而不是使用线程池或者队列。如果客户端是可信的，且能快速返回，可以使用信号量来代替线程隔离，降低开销。信号量的大小可以动态调节，线程池却不行。</p>
<p>HystrixCommand和HystrixObserverCommand提供信号量隔离在下面两个地方：</p>
<ul>
<li>Fallback：当Hystrix检索fallback的时候，他心总是调用tomcat线程上执行此操作</li>
<li>如果你设置execution.isolation.strategy为SEMAPHORE的时候，Hystrix会使用信号量代替线程池去限制当前调用Command的并发数。</li>
</ul>
<h4 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h4><p>设置某个时间内的请求，合并为一个发送，例如：id和ids参数</p>
<h4 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h4><h4 id="仪表盘"><a href="#仪表盘" class="headerlink" title="仪表盘"></a>仪表盘</h4><p>Hystrix仪表盘</p>
<p>主要用来实时监控Hystrix的各项指标信息。通过Hystrix DashBoard反馈的实时信息，可以帮助我们快速防线系统中存在的问题，从而及时地采取对应措施。</p>
<p>开启仪表盘</p>
<p>1、在服务实例中新增spring-boot-starter-actuator，监控模块已开启监控相关的端点，并且映入断路器依赖：spring-cloud-starter-hystrix</p>
<p>2、确保在服务实例的主类中已经使用了@EnableCircuitBreaker注解，开启了断路器功能。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2018071910300525.png" alt="image"></p>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHystrixCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">MyHystrixCommand</span><span class="params">(String groupKey)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(groupKey)));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="function">String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//实际调用外部的地方</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"reality invoke。"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="function">String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//run抛出异常，或者调用超时之后调用fallback</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"invoke failed。"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      MyHystrixCommand hystrixCommand = <span class="keyword">new</span> MyHystrixCommand(<span class="string">"myCommand"</span>);</span><br><span class="line">      System.out.println(hystrixCommand.execute());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">reality invoke。</span><br><span class="line"></span><br><span class="line"><span class="comment">//注解方式</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"get-demo1-test"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallback"</span>, groupKey = <span class="string">"userGroup"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">String <span class="title">getDemo1Name</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">   <span class="comment">//测试重试机制</span></span><br><span class="line">   <span class="keyword">int</span> sleepTime = <span class="keyword">new</span> Random().nextInt(<span class="number">300</span>);</span><br><span class="line">   Thread.sleep(sleepTime);</span><br><span class="line">   <span class="function"><span class="keyword">return</span> demo1Service.<span class="title">getAppName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="function">String <span class="title">fallback</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"erroe: "</span> + t.getMessage());</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>几个主要的配置信息：在构造方法中通过Setter设置</p>
<p> 1.1、execution.isolation. thread.timeoutinMilliseconds: 该属性用来配 置HystrixCommand执行的超时时间， 单位为毫秒。当HystrixCommand执行 时间超过该配置值之后， Hystrix会将该执行命令标记为TIMEOUT并进入服务降级 处理逻辑。默认值1000</p>
<p> 1.2、execution.isolation.semaphore.maxConcurrentRequests:当HystrixCommand的隔离策略使用信号量的时候，该属性用来配置信号量的大小（并发请求数）。 当最大并发请求数达到该设置值时， 后续的请求将会被拒绝。默认值10</p>
<p> 1.3、circuitBreaker.requestVolumeThreshold该属性设置滚动窗口中将使断路器跳闸的最小请求数量，默认值：20</p>
<p>1.4、circuitBreaker.sleepWindowInMilliseconds 断路器跳闸后，在此值的时间的内，hystrix会拒绝新的请求，只有过了这个时间断路器才会打开闸门</p>
<p>默认值：5000</p>
<p>1.5、circuitBreaker.errorThresholdPercentage 设置失败百分比的阈值。如果失败比率超过这个值，则断路器跳闸并且进入fallback逻辑</p>
<p>默认值：50</p>
<p>1.6、metrics.rollingStats.timeInMilliseconds 滚动窗口时间大小，默认10s</p>
<h2 id="Feign了解多少说多少？"><a href="#Feign了解多少说多少？" class="headerlink" title="Feign了解多少说多少？"></a>Feign了解多少说多少？</h2><h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>feign是声明式的web service客户端，它让微服务之间的调用变得更简单了，类似controller调用service。Spring Cloud集成了Ribbon和Eureka，可在使用Feign时提供负载均衡的http客户端。</p>
<p>因为feign底层是使用了ribbon作为负载均衡的客户端，而ribbon的负载均衡也是依赖于eureka 获得各个服务的地址，所以要引入eureka-client。</p>
<h4 id="Feign原理"><a href="#Feign原理" class="headerlink" title="Feign原理"></a>Feign原理</h4><ul>
<li>启动时，程序会进行包扫描，扫描所有包下所有@FeignClient注解的类，并将这些类注入到spring的IOC容器中。当定义的Feign中的接口被调用时，通过JDK的动态代理来生成RequestTemplate。</li>
<li>RequestTemplate中包含请求的所有信息，如请求参数，请求URL等。</li>
<li>RequestTemplate声场Request，然后将Request交给client处理，这个client默认是JDK的HTTPUrlConnection，也可以是OKhttp、Apache的HTTPClient等。</li>
<li>最后client封装成LoadBaLanceClient，结合ribbon负载均衡地发起调用。</li>
</ul>
<h2 id="Zookeeper，了解多少说多少？"><a href="#Zookeeper，了解多少说多少？" class="headerlink" title="Zookeeper，了解多少说多少？"></a>Zookeeper，了解多少说多少？</h2><p>ZooKeeper是一个分布式的开源协调服务，用于分布式应用程序。它公开了一组简单的原子操作，分布式应用程序可以构建这些原子操作，以实现更高级别的服务，以实现同步，配置维护以及组和命名。<br>它的设计易于编程，并使用在熟悉的文件系统目录树结构之后设计的数据模型。它运行在Java中，并且对Java和C都有绑定。</p>
<p>周所周知，协调服务是很难做到的。它们特别容易出现诸如竞态条件和死锁等错误。ZooKeeper背后的动机是减轻分布式应用程序从头开始实施协调服务的责任。</p>
<h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><p>Zookeeper是简单的。Zookeeper允许分布式进程之间彼此协调，通过一个共享的分级命名空间，它非常像标准的文件系统。</p>
<p>ZooKeeper实现非常重视高性能，高可用性，严格有序的访问。ZooKeeper的性能方面意味着它可以在大型分布式系统中使用。<br>可靠性方面使其不会成为单点故障。严格的排序意味着可以在客户端实现复杂的同步原子操作。</p>
<p>Zookeeper是可复制的。 与它协调的分布式进程一样，ZooKeeper本身也可以在称为集合的一组主机上进行复制。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/12540413-62c81551958254dc.png" alt="image"></p>
<p>组成ZooKeeper服务的服务器必须彼此了解。它们保持状态的内存映像，以及持久存储中的事务日志和快照。只要大多数服务器可用，ZooKeeper服务就可用。<br>客户端连接到单个ZooKeeper服务器。客户端维护一个TCP连接，通过它发送请求，获取响应，获取观看事件并发送心跳。如果与服务器的TCP连接中断，则客户端将连接到其他服务器。</p>
<p><strong>Zookeeper是有序的</strong>。 ZooKeeper使用反映所有ZooKeeper事务顺序的数字标记每个更新。后续操作可以使用该顺序来实现更高级别的抽象，例如同步原子操作。</p>
<p><strong>Zookeeper是非常快的</strong>。 它在“读取主导”工作负载中速度特别快。ZooKeeper应用程序在数千台计算机上运行，并且在读取比写入更常见的情况下表现最佳，比率大约为10：1。</p>
<h3 id="数据模型和分层名称空间"><a href="#数据模型和分层名称空间" class="headerlink" title="数据模型和分层名称空间"></a>数据模型和分层名称空间</h3><p>ZooKeeper提供的名称空间非常类似于标准文件系统。名称是由斜线（/）分隔的一系列路径元素。ZooKeeper名称空间中的每个节点都由一个路径标识。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/12540413-a229d45b54a02423.png" alt="image"></p>
<h4 id="节点和临时节点"><a href="#节点和临时节点" class="headerlink" title="节点和临时节点"></a>节点和临时节点</h4><p>与标准文件系统不同的是，ZooKeeper命名空间中的每个节点都可以拥有与其相关的数据以及子级。这就像拥有一个允许文件也是目录的文件系统。（ZooKeeper旨在存储协调数据：状态信息，配置，位置信息等，因此存储在每个节点的数据通常很小，在字节到千字节范围内。）我们使用术语 znode来表明我们正在谈论ZooKeeper数据节点。</p>
<p>Znodes维护一个stat结构，包括数据更改，ACL更改和时间戳的版本号，以允许缓存验证和协调更新。每次znode的数据更改时，版本号都会增加。例如，每当客户端检索数据时，它也会收到数据的版本。</p>
<p>存储在名称空间中每个节点上的数据是以原子方式读取和写入的。读取获取与znode关联的所有数据字节，写入将替换所有数据。每个节点都有一个访问控制列表（ACL），限制谁可以做什么。</p>
<p>ZooKeeper也有临时节点的概念。只要创建znode的会话处于活动状态，就会存在这些znode。当会话结束时，znode被删除。</p>
<h4 id="有条件的更新和监视"><a href="#有条件的更新和监视" class="headerlink" title="有条件的更新和监视"></a>有条件的更新和监视</h4><p>ZooKeeper支持观察的概念。客户可以在znode上设置观察器。当znode更改时，将触发并删除观察器。</p>
<p>当观察被触发时，客户端收到一个数据包，说明znode已经改变。如果客户端和其中一个Zoo Keeper服务器之间的连接断开，客户端将收到本地通知。</p>
<h4 id="担保"><a href="#担保" class="headerlink" title="担保"></a>担保</h4><p>ZooKeeper非常快速且非常简单。但是，由于其目标是构建更复杂的服务（如同步）的基础，因此它提供了一系列保证。这些是：</p>
<ul>
<li>顺序一致性 - 客户端的更新将按照它们发送的顺序进行应用。</li>
<li>原子性 - 更新成功或失败。没有部分结果。</li>
<li>单系统映像 - 无论服务器连接到哪个服务器，客户端都会看到相同的服务视图。</li>
<li>可靠性 - 一旦应用更新，它将一直持续到客户覆盖更新为止。</li>
<li>及时性 - 系统的客户视图保证在特定时间范围内是最新的。</li>
</ul>
<h4 id="简单的API"><a href="#简单的API" class="headerlink" title="简单的API"></a>简单的API</h4><p>ZooKeeper的设计目标之一是提供一个非常简单的编程接口。因此，它仅支持以下操作：</p>
<ul>
<li>创建——在树中的某个位置创建一个节点</li>
<li>删除——删除节点</li>
<li>存在——测试某个位置是否存在节点</li>
<li>获取数据——从节点读取数据</li>
<li>设定数据——将数据写入节点</li>
<li>得到子节点——检索节点的子节点列表</li>
<li>同步——等待数据传播</li>
</ul>
<h3 id="能用zookeeper做什么"><a href="#能用zookeeper做什么" class="headerlink" title="能用zookeeper做什么"></a>能用zookeeper做什么</h3><p>1、 命名服务</p>
<p>这个似乎最简单，在zookeeper的文件系统里创建一个目录，即有唯一的path。在我们使用tborg无法确定上游程序的部署机器时即可与下游程序约定好path，通过path即能互相探索发现，不见不散了。</p>
<p>2、 配置管理</p>
<p>程序总是需要配置的，如果程序分散部署在多台机器上，要逐个改变配置就变得困难。好吧，现在把这些配置全部放到zookeeper上去，保存在 Zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中就好。</p>
<p> 3、 集群管理</p>
<p>所谓集群管理无在乎两点：是否有机器退出和加入、选举master。</p>
<p>对于第一点，所有机器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。新机器加入 也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了。</p>
<p>对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。</p>
<p>4、  分布式锁</p>
<p>有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。</p>
<p>对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /<code>distribute_lock</code> 节点，最终成功创建的那个客户端也即拥有了这把锁。厕所有言：来也冲冲，去也冲冲，用完删除掉自己创建的distribute_lock 节点就释放出锁。</p>
<p>对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。</p>
<p>5、队列管理</p>
<p>两种类型的队列：</p>
<p>1、 同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。</p>
<p>2、队列按照 FIFO 方式进行入队和出队操作。</p>
<p>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。</p>
<p>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。</p>
<p>终于了解完我们能用zookeeper做什么了，可是作为一个程序员，我们总是想狂热了解zookeeper是如何做到这一点的，单点维护一个文件系统没有什么难度，可是如果是一个集群维护一个文件系统保持数据的一致性就非常困难了。</p>
<h3 id="分布式与数据复制"><a href="#分布式与数据复制" class="headerlink" title="分布式与数据复制"></a>分布式与数据复制</h3><p>Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处：</p>
<p>1、 容错<br>一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；</p>
<p>2、提高系统的扩展能力<br>把负载分布到多个节点上，或者增加节点来提高系统的负载能力；</p>
<p>3、提高性能<br>让客户端本地访问就近的节点，提高用户访问速度。</p>
<p>从客户端读写访问的透明度来看，数据复制集群系统分下面两种：</p>
<p>1、写主(WriteMaster)<br>对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离；</p>
<p>2、写任意(Write Any)<br>对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。</p>
<p>对zookeeper来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</p>
<p>我们关注的重点还是在如何保证数据在集群所有机器的一致性，这就涉及到paxos算法。</p>
<h3 id="数据一致性与paxos算法"><a href="#数据一致性与paxos算法" class="headerlink" title="数据一致性与paxos算法"></a>数据一致性与paxos算法</h3><p>据说Paxos算法的难理解与算法的知名度一样令人敬仰，所以我们先看如何保持数据的一致性，这里有个原则就是：</p>
<p>在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。</p>
<p>Paxos算法解决的什么问题呢，解决的就是保证每个节点执行相同的操作序列。好吧，这还不简单，master维护一个全局写队列，所有写操作都必 须放入这个队列编号，那么无论我们写多少个节点，只要写操作是按编号来的，就能保证一致性。没错，就是这样，可是如果master挂了呢。</p>
<p>Paxos算法通过投票来对写操作进行全局编号，同一时刻，只有一个写操作被批准，同时并发的写操作要去争取选票，只有获得过半数选票的写操作才会 被批准（所以永远只会有一个写操作得到批准），其他的写操作竞争失败只好再发起一轮投票，就这样，在日复一日年复一年的投票中，所有写操作都被严格编号排 序。编号严格递增，当一个节点接受了一个编号为100的写操作，之后又接受到编号为99的写操作（因为网络延迟等很多不可预见原因），它马上能意识到自己 数据不一致了，自动停止对外服务并重启同步过程。任何一个节点挂掉都不会影响整个集群的数据一致性（总2n+1台，除非挂掉大于n台）。</p>
<h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h4><h5 id="角色（核心就3个角色）"><a href="#角色（核心就3个角色）" class="headerlink" title="角色（核心就3个角色）"></a>角色（核心就3个角色）</h5><p>Client：客户端，发起请求并等待返回。<br>Proposer（提案者）：处理客户端请求，将客户端的请求发送到集群中，以便决定这个值是否可以被批准。<br>Acceptor（接受者）：负责处理接收到的提议，他们的回复就是一次投票。会存储一些状态来决定是否接收一个值。<br>Learner（学习者）：当有同一个value的协议被超过一半的Acceptor采纳并发送消息给Learner时，Learner采纳该协议值。<br>Leader：一个特殊的Proposer。</p>
<h5 id="Basic-Paxos算法"><a href="#Basic-Paxos算法" class="headerlink" title="Basic-Paxos算法"></a>Basic-Paxos算法</h5><p>核心实现Paxos Instance主要包括两个阶段:</p>
<p>准备阶段(prepare phase)和提议阶段(accept phase)</p>
<p>简单来说，Basic Paxos 是一个经典两阶段提交（2PC）</p>
<p>第一阶段：</p>
<ul>
<li>1a prepare 准备: proposer向acceptors提出一个协议，这里的协议就是期望的“一致性内容”</li>
<li>1a promise 承诺: acceptor承诺只接收最大协议号的协议（包括prepare和accept），并拒绝比当前协议号N小的协议，回复proposer之前接收的所有协议值。如果当前协议号N比之前都小，那么回复拒绝。</li>
</ul>
<p>第二阶段：</p>
<ul>
<li>2a Accept Request 发起“accept”请求：proposer收到acceptor反馈的足够的承诺后，给协议设最大值，如果没回复，随便设置一个值。发送”accept”请求给选定值的acceptors.</li>
<li>2b Accepted: acceptor接受协议（该acceptor之前没有承诺过大于该协议号的协议），并通知给proposer和learner</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170519183209291-1684980050.png" alt="image"><br>其中prepare阶段的作用，如下图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170519173152510-2089061877.png" alt="image"></p>
<p>1.S1首先发起accept(1,red)，并在S1,S2和S3达成多数派，red在S1，S2，S3上持久化</p>
<p>2.随 后S5发起accept(5,blue)，在S3，S4和S5达成多数派，blue在S<br>3，S4和S5持久化</p>
<p>3.最后的结果是，S1和S2的值是red，而S4和S5的值是blue，s3存在异议，red覆盖了blue？</p>
<p>解决方案：</p>
<ul>
<li>将提议进行排序，可以为每个提议赋予一个唯一的ID，规定这个ID越大越新，很明显（5，blue）和（1，red），5比1大,所以保留blue</li>
<li>采用两阶段方法，拒绝旧提议。</li>
</ul>
<h5 id="Muti-Paxos算法"><a href="#Muti-Paxos算法" class="headerlink" title="Muti-Paxos算法"></a>Muti-Paxos算法</h5><p>很多文章有误解说Muti-Paxos是一阶段提交，那是仅限于leader稳定时。刚选出来一个新的leader时，依然是二阶段提交如下图：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170522174941023-1628898506.png" alt="image"><br>如果leader稳定，不需要prepare和promise步骤，如下图（图中Proposer就是一个Leader）：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170522175104867-87240999.png" alt="image"><br>Multi Paxos中leader用于避免活锁(例如1个leader,4个Proposer,2个提议A，2个提议B不能达成一致，导致活锁)，但leader的存在会带来其他问题，一是如何选举和保持唯一leader(虽然无leader或多leader不影响一致性，但影响决议进程progress)，二是充当leader的节点会承担更多压力，如何均衡节点的负载。Mencius[1]提出节点轮流担任leader，以达到均衡负载的目的；租约(lease)可以帮助实现唯一leader，但leader故障情况下可导致服务短期不可用。</p>
<h5 id="Muti-Paxos在google-chubby中的应用"><a href="#Muti-Paxos在google-chubby中的应用" class="headerlink" title="Muti-Paxos在google chubby中的应用"></a>Muti-Paxos在google chubby中的应用</h5><p>Google Chubby是一个高可用分布式锁服务，被设计成一个需要访问中心化节点的分布式锁服务。本文只分析chubby服务端的实现。</p>
<p> Chubby服务端的基本架构大致分为三层</p>
<p>　　① 最底层是容错日志系统（Fault-Tolerant Log），通过Paxos算法能够保证集群所有机器上的日志完全一致，同时具备较好的容错性。</p>
<p>　　② 日志层之上是Key-Value类型的容错数据库（Fault-Tolerant DB），其通过下层的日志来保证一致性和容错性。</p>
<p>　　③ 存储层之上的就是Chubby对外提供的分布式锁服务和小文件存储服务。<br>　　<img src="https://minios.strongsickcat.com/dinghuang-blog-picture/584866-20170523192819976-189903080.png" alt="image"><br>Paxos算法用于保证集群内各个副本节点的日志能够保持一致，Chubby事务日志（Transaction Log）中的每一个Value对应Paxos算法中的一个Instance（对应Proposer），由于Chubby需要对外提供不断的服务，因此事务日志会无限增长，于是在整个Chubby运行过程中，会存在多个Paxos Instance，同时，Chubby会为每个Paxos Instance都按序分配一个全局唯一的Instance编号，并将其顺序写入到事务日志中去。</p>
<p>　　在Paxos中，每一个Paxos Instance都需要进行一轮或多轮的Prepare-&gt;Promise-&gt;Propose-&gt;Accept这样完整的二阶段请求过程来完成对一个提议值的选定，为了保证正确性的前提下尽可能地提高算法运行性能，可以让多个Instance共用一套序号分配机制，并将Prepare-&gt;Promise合并为一个阶段。具体做法如下：</p>
<p>　　① 当某个副本节点通过选举成为Master后，就会使用新分配的编号N来广播一个Prepare消息，该Prepare消息会被所有未达成一致的Instance和目前还未开始的Instance共用。</p>
<p>　　② 当Acceptor接收到Prepare消息后，必须对多个Instance同时做出回应，这通常可以通过将反馈信息封装在一个数据包中来实现，假设最多允许K个Instance同时进行提议值的选定，那么：</p>
<ul>
<li>当前之多存在K个未达成一致的Instance，将这些未决的Instance各自最后接受的提议值封装进一个数据包，并作为Promise消息返回。</li>
<li>同时，判断N是否大于当前Acceptor的highestPromisedNum值（当前已经接受的最大的提议编号值），如果大于，那么就标记这些未决Instance和所有未来的Instance的highestPromisedNum的值为N，这样，这些未决Instance和所有未来Instance都不能再接受任何编号小于N的提议。</li>
</ul>
<p>　　③ Master对所有未决Instance和所有未来Instance分别执行Propose-&gt;Accept阶段的处理，如果Master能够一直稳定运行的话，那么在接下来的算法运行过程中，就不再需要进行Prepare-&gt;Promise处理了。但是，一旦Master发现Acceptor返回了一个Reject消息，说明集群中存在另一个Master并且试图使用更大的提议编号发送了Prepare消息，此时，当前Master就需要重新分配新的提议编号并再次进行Prepare-&gt;Promise阶段的处理。</p>
<p>　　可见chubby就是一个典型的Muti-Paxos算法应用，在Master稳定运行的情况下，只需要使用同一个编号来依次执行每一个Instance的Promise-&gt;Accept阶段处理。</p>
<h2 id="sentinel，了解多少说多少？"><a href="#sentinel，了解多少说多少？" class="headerlink" title="sentinel，了解多少说多少？"></a>sentinel，了解多少说多少？</h2><p>Sentinel 是阿里中间件团队开源的，面向分布式服务架构的轻量级高可用流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。</p>
<p>Sentinel 和之前常用的熔断降级库 Netflix Hystrix 有什么异同呢？Sentinel官网有一个对比的文章，这里摘抄一个总结的表格</p>
<table>
<thead>
<tr>
<th>对比内容</th>
<th>Sentinel</th>
<th>Hystrix</th>
</tr>
</thead>
<tbody>
<tr>
<td>隔离策略</td>
<td>信号量隔离</td>
<td>线程池隔离/信号量隔离</td>
</tr>
<tr>
<td>熔断降级策略</td>
<td>基于响应时间或失败比率</td>
<td>基于失败比率</td>
</tr>
<tr>
<td>实时指标实现</td>
<td>滑动窗口</td>
<td>滑动窗口（基于 RxJava）</td>
</tr>
<tr>
<td>规则配置</td>
<td>支持多种数据源</td>
<td>支持多种数据源</td>
</tr>
<tr>
<td>扩展性</td>
<td>多个扩展点</td>
<td>插件的形式</td>
</tr>
<tr>
<td>基于注解的支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>限流</td>
<td>基于 QPS，支持基于调用关系的限流</td>
<td>不支持</td>
</tr>
<tr>
<td>流量整形</td>
<td>支持慢启动、匀速器模式</td>
<td>不支持</td>
</tr>
<tr>
<td>系统负载保护</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>控制台</td>
<td>开箱即用，可配置规则、查看秒级监控、机器发现等</td>
<td>不完善</td>
</tr>
<tr>
<td>常见框架的适配</td>
<td>Servlet、Spring Cloud、Dubbo、gRPC 等</td>
<td>Servlet、Spring Cloud Netflix</td>
</tr>
</tbody>
</table>
<h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><p>感兴趣的可以看这篇<a href="https://mp.weixin.qq.com/s/g2hyp9CquEAvTe8QmPO-3g/" target="_blank" rel="noopener">文章</a></p>
<h2 id="Spring-Cloud-Alibaba，了解多少说多少？"><a href="#Spring-Cloud-Alibaba，了解多少说多少？" class="headerlink" title="Spring Cloud Alibaba，了解多少说多少？"></a>Spring Cloud Alibaba，了解多少说多少？</h2><p>Spring Cloud 是基于 Spring Boot 设计的一套微服务规范，并增强了应用上下文。Spring Cloud Alibaba 采用阿里中间件作为基础，实现了 Spring Cloud 的微服务规范。</p>
<h2 id="对XA、TCC的理解，了解哪些分布式事务框架，有什么缺点？"><a href="#对XA、TCC的理解，了解哪些分布式事务框架，有什么缺点？" class="headerlink" title="对XA、TCC的理解，了解哪些分布式事务框架，有什么缺点？"></a>对XA、TCC的理解，了解哪些分布式事务框架，有什么缺点？</h2><p>事务拥有以下四个特性，习惯上被称为 ACID 特性：</p>
<ul>
<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态是指数据库中的数据应满足完整性约束。除此之外，一致性还有另外一层语义，就是事务的中间状态不能被观察到（这层语义也有说应该属于原子性）。</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行，如同只有这一个操作在被数据库所执行一样。</li>
<li>持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。在事务结束时，此操作将不可逆转。</li>
</ul>
<h3 id="常见分布式事务模型-ACID-实现分析"><a href="#常见分布式事务模型-ACID-实现分析" class="headerlink" title="常见分布式事务模型 ACID 实现分析"></a>常见分布式事务模型 ACID 实现分析</h3><h4 id="X-Open-XA-协议"><a href="#X-Open-XA-协议" class="headerlink" title="X/Open XA 协议"></a>X/Open XA 协议</h4><p>最早的分布式事务模型是 X/Open 国际联盟提出的 X/Open Distributed Transaction Processing（DTP）模型，也就是大家常说的 X/Open XA 协议，简称XA 协议。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG265.png" alt="image"><br>DTP 模型中包含一个全局事务管理器（TM，Transaction Manager）和多个资源管理器（RM，Resource Manager）。全局事务管理器负责管理全局事务状态与参与的资源，协同资源一起提交或回滚；资源管理器则负责具体的资源操作。</p>
<p>XA 协议描述了 TM 与 RM 之间的接口，允许多个资源在同一分布式事务中访问。</p>
<p>基于 DTP 模型的分布式事务流程大致如下：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG266.png" alt="image"></p>
<ol>
<li>应用程序（AP，Application）向 TM 申请开始一个全局事务。</li>
<li>针对要操作的 RM，AP 会先向 TM 注册（TM 负责记录 AP 操作过哪些 RM，即分支事务），TM 通过 XA 接口函数通知相应 RM 开启分布式事务的子事务，接着 AP 就可以对该 RM 管理的资源进行操作。</li>
<li>当 AP 对所有 RM 操作完毕后，AP 根据执行情况通知 TM 提交或回滚该全局事务，TM 通过 XA 接口函数通知各 RM 完成操作。TM 会先要求各个 RM 做预提交，所有 RM 返回成功后，再要求各 RM 做正式提交，XA 协议要求，一旦 RM 预提交成功，则后续的正式提交也必须能成功；如果任意一个 RM 预提交失败，则 TM 通知各 RM 回滚。</li>
<li>所有 RM 提交或回滚完成后，全局事务结束。</li>
</ol>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>XA 协议使用 2PC（Two Phase Commit，两阶段提交）原子提交协议来保证分布式事务原子性。</p>
<p>两阶段提交是指将提交过程分为两个阶段，即准备阶段（投票阶段）和提交阶段（执行阶段）：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG267.png" alt="image"></p>
<ul>
<li>准备阶段</li>
</ul>
<p>TM 向每个 RM 发送准备消息。如果 RM 的本地事务操作执行成功，则返回成功；如果 RM 的本地事务操作执行失败，则返回失败。</p>
<ul>
<li>提交阶段</li>
</ul>
<p>如果 TM 收到了所有 RM 回复的成功消息，则向每个 RM 发送提交消息；否则发送回滚消息；RM 根据 TM 的指令执行提交或者回滚本地事务操作，释放所有事务处理过程中使用的锁资源。</p>
<h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><p>XA 协议中没有描述如何实现分布式事务的隔离性，但是 XA 协议要求DTP 模型中的每个 RM 都要实现本地事务，也就是说，基于 XA 协议实现的分布式事务的隔离性是由每个 RM 本地事务的隔离性来保证的，当一个分布式事务的所有子事务都是隔离的，那么这个分布式事务天然的就实现了隔离性。</p>
<p>以 MySQL 来举例，MySQL 使用 2PL（Two-Phase Locking，两阶段锁）机制来控制本地事务的并发，保证隔离性。2PL 与 2PC 类似，也是将锁操作分为加锁和解锁两个阶段，并且保证两个阶段完全不相交。加锁阶段，只加锁，不放锁。解锁阶段，只放锁，不加锁。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG268.png" alt="image"><br>如上图所示，在一个本地事务中，每执行一条更新操作之前，都会先获取对应的锁资源，只有获取锁资源成功才会执行该操作，并且一旦获取了锁资源就会持有该锁资源直到本事务执行结束。</p>
<p>MySQL 通过这种 2PL 机制，可以保证在本地事务执行过程中，其他并发事务不能操作相同资源，从而实现了事务隔离。</p>
<h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5><p>前面提到一致性有两层语义，一层是确保事务执行结束后，数据库从一个一致状态转变为另一个一致状态。另一层语义是事务执行过程中的中间状态不能被观察到。</p>
<p>前一层语义的实现很简单，通过原子性、隔离性以及 RM 自身一致性的实现就可以保证。至于后一层语义，我们先来看看单个 RM 上的本地事务是怎么实现的。还是以 MySQL 举例，MySQL 通过 MVCC（Multi Version Concurrency Control，多版本并发控制）机制，为每个一致性状态生成快照（Snapshot），每个事务看到的都是各Snapshot对应的一致性状态，从而也就保证了本地事务的中间状态不会被观察到。</p>
<p>虽然单个 RM 上实现了Snapshot，但是在分布式应用架构下，会遇到什么问题呢？<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG269.png" alt="image"><br>如上图所示，在 RM1 的本地子事务提交完毕到 RM2 的本地子事务提交完毕之间，只能读到 RM1 上子事务执行的内容，读不到 RM2 上的子事务。也就是说，虽然在单个 RM 上的本地事务是一致的，但是从全局来看，一个全局事务执行过程的中间状态被观察到了，全局一致性就被破坏了。</p>
<p>XA 协议并没有定义怎么实现全局的 Snapshot，像 MySQL 官方文档里就建议使用串行化的隔离级别来保证分布式事务一致性：</p>
<p>“As with nondistributed transactions, SERIALIZABLE may be preferred if your applications are sensitive to read phenomena. REPEATABLE READ may not be sufficient for distributed transactions.”（对于分布式事务来说，可重复读隔离级别不足以保证事务一致性，如果你的程序有全局一致性读要求，可以考虑串行化隔离级别.）</p>
<p>当然，由于串行化隔离级别的性能较差，所以很多分布式数据库都自己实现了分布式 MVCC 机制来提供全局的一致性读。一个基本思路是用一个集中式或者逻辑上单调递增的东西来控制生成全局 Snapshot，每个事务或者每条 SQL 执行时都去获取一次，从而实现不同隔离级别下的一致性。比如 Google 的 Spanner 就是用 TrueTime 来控制访问全局 Snapshot。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>XA 协议通常实现在数据库资源层，直接作用于资源管理器上。因此，基于 XA 协议实现的分布式事务产品，无论是分布式数据库，还是分布式事务框架，对业务几乎都没有侵入，就像使用普通数据库一样。</p>
<p>XA 协议严格保障事务 ACID 特性，能够满足所有业务领域的功能需求，但是，这同样是一把双刃剑。</p>
<p>由于隔离性的互斥要求，在事务执行过程中，所有的资源都被锁定，只适用于执行时间确定的短事务。同时，整个事务期间都是独占数据，对于热点数据的并发性能可能会很低，实现了分布式 MVCC 或乐观锁（optimistic locking）以后，性能可能会有所提升。    </p>
<p>同时，为了保障一致性，要求所有 RM 同等可信、可靠，要求故障恢复机制可靠、快速，在网络故障隔离的情况下，服务基本不可用。</p>
<h4 id="TCC-模型"><a href="#TCC-模型" class="headerlink" title="TCC 模型"></a>TCC 模型</h4><p>TCC（Try-Confirm-Cancel）分布式事务模型相对于 XA 等传统模型，其特征在于它不依赖资源管理器（RM）对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。</p>
<p>TCC 模型认为对于业务系统中一个特定的业务逻辑，其对外提供服务时，必须接受一些不确定性，即对业务逻辑初步操作的调用仅是一个临时性操作，调用它的主业务服务保留了后续的取消权。如果主业务服务认为全局事务应该回滚，它会要求取消之前的临时性操作，这就对应从业务服务的取消操作。而当主业务服务认为全局事务应该提交时，它会放弃之前临时性操作的取消权，这对应从业务服务的确认操作。每一个初步操作，最终都会被确认或取消。</p>
<p>因此，针对一个具体的业务服务，TCC 分布式事务模型需要业务系统提供三段业务逻辑：</p>
<ol>
<li>初步操作 Try：完成所有业务检查，预留必须的业务资源。</li>
<li>确认操作 Confirm：真正执行的业务逻辑，不作任何业务检查，只使用 Try 阶段预留的业务资源。因此，只要 Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一笔分布式事务有且只能成功一次。</li>
<li>取消操作 Cancel：释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。</li>
</ol>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG270.png" alt="image"><br>TCC 分布式事务模型包括三部分：</p>
<ul>
<li>主业务服务：主业务服务为整个业务活动的发起方，服务的编排者，负责发起并完成整个业务活动。</li>
<li>从业务服务：从业务服务是整个业务活动的参与方，负责提供 TCC 业务操作，实现初步操作（Try）、确认操作（Confirm）、取消操作（Cancel）三个接口，供主业务服务调用。</li>
<li>业务活动管理器：业务活动管理器管理控制整个业务活动，包括记录维护 TCC 全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时调用所有从业务服务的 Confirm 操作，在业务活动取消时调用所有从业务服务的 Cancel 操作。</li>
</ul>
<p>一个完整的 TCC 分布式事务流程如下：</p>
<ol>
<li><p>主业务服务首先开启本地事务；</p>
</li>
<li><p>主业务服务向业务活动管理器申请启动分布式事务主业务活动；</p>
</li>
<li><p>然后针对要调用的从业务服务，主业务活动先向业务活动管理器注册从业务活动，然后调用从业务服务的 Try 接口；</p>
</li>
<li><p>当所有从业务服务的 Try 接口调用成功，主业务服务提交本地事务；若调用失败，主业务服务回滚本地事务；</p>
</li>
<li><p>若主业务服务提交本地事务，则 TCC 模型分别调用所有从业务服务的 Confirm 接口；若主业务服务回滚本地事务，则分别调用 Cancel 接口；</p>
</li>
<li><p>所有从业务服务的 Confirm 或 Cancel 操作完成后，全局事务结束。</p>
</li>
</ol>
<h5 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h5><p>TCC 模型也使用 2PC 原子提交协议来保证事务原子性。Try 操作对应2PC 的一阶段准备（Prepare）；Confirm 对应 2PC 的二阶段提交（Commit），Cancel 对应 2PC 的二阶段回滚（Rollback），可以说 TCC 就是应用层的 2PC。</p>
<h5 id="隔离性-1"><a href="#隔离性-1" class="headerlink" title="隔离性"></a>隔离性</h5><p>TCC 分布式事务模型仅提供两阶段原子提交协议，保证分布式事务原子性。事务的隔离交给业务逻辑来实现。</p>
<p>隔离的本质是控制并发，防止并发事务操作相同资源而引起的结果错乱。</p>
<p>举个例子，比如金融行业里管理用户资金，当用户发起交易时，一般会先检查用户资金，如果资金充足，则扣除相应交易金额，增加卖家资金，完成交易。如果没有事务隔离，用户同时发起两笔交易，两笔交易的检查都认为资金充足，实际上却只够支付一笔交易，结果两笔交易都支付成功，导致资损。</p>
<p>可以发现，并发控制是业务逻辑执行正确的保证，但是像两阶段锁这样的并发访问控制技术要求一直持有数据库资源锁直到整个事务执行结束，特别是在分布式事务架构下，要求持有锁到分布式事务第二阶段执行结束，也就是说，分布式事务会加长资源锁的持有时间，导致并发性能进一步下降。</p>
<p>因此，TCC 模型的隔离性思想就是通过业务的改造，在第一阶段结束之后，从底层数据库资源层面的加锁过渡为上层业务层面的加锁，从而释放底层数据库锁资源，放宽分布式事务锁协议，提高业务并发性能。</p>
<p>还是以上面的例子举例：</p>
<ol>
<li><p>第一阶段：检查用户资金，如果资金充足，冻结用户本次交易资金，这笔资金被业务隔离，不允许除本事务之外的其它并发事务动用。</p>
</li>
<li><p>第二阶段：扣除第一阶段预冻结的用户资金，增加卖家资金，完成交易。</p>
</li>
</ol>
<p>采用业务加锁的方式，隔离用户冻结资金，在第一阶段结束后直接释放底层资源锁，该用户和卖家的其他交易都可以立刻并发执行，而不用等到整个分布式事务结束，可以获得更高的并发交易能力。</p>
<h5 id="一致性-1"><a href="#一致性-1" class="headerlink" title="一致性"></a>一致性</h5><p>再来看看 TCC 分布式事务模型下的一致性实现。与 XA 协议实现一致性第一层语义类似，通过原子性保证事务的原子提交、业务隔离性控制事务的并发访问，实现分布式事务的一致性状态转变。</p>
<p>至于第二层语义：事务的中间状态不能被观察到。我们来看看，在 SOA分布式应用环境下是否是必须的。</p>
<p>还是以账务服务举例。转账业务（用户 A  -&gt; 用户 B），由交易服务和账务服务组成分布式事务，交易服务作为主业务服务，账务服务作为从业务服务，账务服务的 Try 操作预冻结用户 A 的资金；Commit 操作扣除用户 A 的预冻结资金，增加用户 B 的可用资金；Cancel 操作解冻用户 A 的预冻结资金。</p>
<p>当账务服务执行完 Try 阶段后，交易主业务就可以 Commit 了，然后由TCC 框架调用账务的 Commit 阶段。在账务 Commit 阶段还没执行结束的时候，用户 A 可以查询到自己的余额已扣除，但是，此时用户 B 的可用资金还没增加。</p>
<p>从系统的角度来看，确实有问题与不确定性。在第一阶段执行结束到第二阶段执行结束之间，有一段时间的延时，在这段时间内，看似任何用户都不享有这笔资产。</p>
<p>但是，从用户的角度来考虑这个问题的话，这个时间间隔可能就无所谓或者根本就不存在。特别是当这个时间间隔仅仅是几秒钟，对于具体沟通资产转移的用户来讲，这个过程是隐蔽的或确实可以接受的，且保证了结果的最终一致性。</p>
<p>当然，对于这样的系统，如果确实需要查看系统的某个一致性状态，可以采用额外的方法实现。</p>
<p>一般来讲，服务之间的一致性比服务内部的一致性要更加容易弱化，这也是为什么 XA 等直接在资源层面上实现通用分布式事务的模型会注重一致性的保证，而当上升到服务层面，服务与服务之间已经实现了功能的划分，逻辑的解耦，也就更容易弱化一致性，这就是 SOA 架构下 BASE 理论的最终一致性思想。</p>
<p>BASE 理论是指 BA（Basic Availability，基本业务可用性）；S（Soft state，柔性状态）；E（Eventual consistency，最终一致性）。该理论认为为了可用性、性能与降级服务的需要，可以适当降低一点一致性的要求，即“基本可用，最终一致”。</p>
<p>业内通常把严格遵循 ACID 的事务称为刚性事务；而基于 BASE 思想实现的事务称为柔性事务。柔性事务并不是完全放弃了 ACID，仅仅是放宽了一致性要求：事务完成后的一致性严格遵循，事务中的一致性可适当放宽。</p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>TCC 分布式事务模型的业务实现特性决定了其可以跨 DB、跨服务实现资源管理，将对不同的 DB 访问、不同的业务操作通过 TCC 模型协调为一个原子操作，解决了分布式应用架构场景下的事务问题。</p>
<p>TCC 模型通过 2PC 原子提交协议保证分布式事务的的原子性，把资源层的隔离性上升到业务层，交给业务逻辑来实现。TCC 的每个操作对于资源层来说，就是单个本地事务的使用，操作结束则本地事务结束，规避了资源层在 2PC 和 2PL 下对资源占用导致的性能低下问题。</p>
<p>同时，TCC 模型也可以根据业务需要，做一些定制化的功能，比如交易异步化实现削峰填谷等。</p>
<p>但是，业务接入 TCC 模型需要拆分业务逻辑成两个阶段，并实现 Try、Confirm、Cancel 三个接口，定制化程度高，开发成本高。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文首先介绍了典型的分布式事务的架构场景。分布式事务刚开始是为解决单服务多数据库资源的场景而诞生的。随着技术的发展，特别是 SOA 分布式应用架构以及微服务时代的到来，服务变成了基本业务单元。因此，又产生了跨服务的分布式事务需求。</p>
<p>然后从 XA 和 TCC 两种常用的分布式事务模型入手，介绍了其实现机制，着重分析了各模型是如何实现分布式事务 ACID 特性的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/04/18/面试分享(一).JAVA知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/18/面试分享(一).JAVA知识/" itemprop="url">面试分享(一).JAVA知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-18T18:00:00+08:00">
                2019-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/18/面试分享(一).JAVA知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/04/18/面试分享(一).JAVA知识/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JAVA知识"><a href="#JAVA知识" class="headerlink" title="JAVA知识"></a>JAVA知识</h1><h2 id="ArrayList和LinkList有什么区别"><a href="#ArrayList和LinkList有什么区别" class="headerlink" title="ArrayList和LinkList有什么区别"></a>ArrayList和LinkList有什么区别</h2><ul>
<li>ArrayList是数组实现的集合操作，而LinkedList是链表实现的集合操作,（LinkedList是双向链表，有next也有previous）。</li>
<li>只是用List集合中的get()方法根据索引取数据的时候，ArrayList的时间复杂度为“O(1)”,而LinkedList的时间复杂度为“O(n)”(n为集合的长度)，因为LinkedList要移动指针。 </li>
<li>ArrayList在使用的时候默认的初始化数组的长度为10，如果空间不足则会采用2倍的形式进行容量的扩充，如果保存大数据的时候有可能造成垃圾的产生以及性能的下降，这个时候就可以用LinkedList子类保存。对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</li>
</ul>
<h2 id="JDK动态代理与CGLib动态代理的区别"><a href="#JDK动态代理与CGLib动态代理的区别" class="headerlink" title="JDK动态代理与CGLib动态代理的区别"></a>JDK动态代理与CGLib动态代理的区别</h2><ul>
<li>区别<ul>
<li>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</li>
<li>而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li>
<li>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP </li>
<li>如果目标对象实现了接口，可以强制使用CGLIB实现AOP </li>
<li>如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</li>
</ul>
</li>
<li>如何强制使用CGLIB实现AOP？<ul>
<li>添加CGLIB库，<code>SPRING_HOME/cglib/*.jar</code></li>
<li>在spring配置文件中加入<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code></li>
</ul>
</li>
<li><p>JDK动态代理和CGLIB字节码生成的区别</p>
<ul>
<li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法<br>因为是继承，所以该类或方法最好不要声明成final </li>
</ul>
</li>
<li><p>代码实现</p>
</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lf.shejimoshi.proxy.entity;</span><br><span class="line"><span class="comment">//用户管理接口</span></span><br><span class="line"><span class="keyword">public</span> interface UserManager &#123;</span><br><span class="line">    <span class="comment">//新增用户抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> addUser(<span class="keyword">String</span> userName,<span class="keyword">String</span> password);</span><br><span class="line">    <span class="comment">//删除用户抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> delUser(<span class="keyword">String</span> userName);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.lf.shejimoshi.proxy.entity;</span><br><span class="line"><span class="comment">//用户管理实现类,实现用户管理接口</span></span><br><span class="line"><span class="keyword">public</span> class UserManagerImpl implements UserManager&#123;</span><br><span class="line">    <span class="comment">//重写新增用户方法</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> addUser(<span class="keyword">String</span> userName, <span class="keyword">String</span> password) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"调用了新增的方法！"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"传入参数为 userName: "</span>+userName+<span class="string">" password: "</span>+password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写删除用户方法</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> delUser(<span class="keyword">String</span> userName) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"调用了删除的方法！"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"传入参数为 userName: "</span>+userName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK动态代理</span></span><br><span class="line"><span class="keyword">package</span> com.lf.shejimoshi.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lf.shejimoshi.proxy.entity.UserManager;</span><br><span class="line"><span class="keyword">import</span> com.lf.shejimoshi.proxy.entity.UserManagerImpl;</span><br><span class="line"><span class="comment">//JDK动态代理实现InvocationHandler接口</span></span><br><span class="line"><span class="keyword">public</span> class JdkProxy implements InvocationHandler &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> target ;<span class="comment">//需要代理的目标对象</span></span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Object</span> invoke(<span class="keyword">Object</span> proxy, Method method, <span class="keyword">Object</span>[] args) <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"JDK动态代理，监听开始！"</span>);</span><br><span class="line">        <span class="keyword">Object</span> result = method.invoke(target, args);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"JDK动态代理，监听结束！"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义获取代理对象方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> getJDKProxy(<span class="keyword">Object</span> targetObject)&#123;</span><br><span class="line">        <span class="comment">//为目标对象target赋值</span></span><br><span class="line">        <span class="keyword">this</span>.target = targetObject;</span><br><span class="line">        <span class="comment">//JDK动态代理只能针对实现了接口的类进行代理，newProxyInstance 函数所需参数就可看出</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        JdkProxy jdkProxy = <span class="keyword">new</span> JdkProxy();<span class="comment">//实例化JDKProxy对象</span></span><br><span class="line">        UserManager user = (UserManager) jdkProxy.getJDKProxy(<span class="keyword">new</span> UserManagerImpl());<span class="comment">//获取代理对象</span></span><br><span class="line">        user.addUser(<span class="string">"admin"</span>, <span class="string">"123123"</span>);<span class="comment">//执行新增方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Cglib动态代理（需要导入两个jar包，asm-5.2.jar,cglib-3.2.5.jar。版本自行选择）</span></span><br><span class="line"><span class="keyword">package</span> com.lf.shejimoshi.proxy.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lf.shejimoshi.proxy.entity.UserManager;</span><br><span class="line"><span class="keyword">import</span> com.lf.shejimoshi.proxy.entity.UserManagerImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Cglib动态代理，实现MethodInterceptor接口</span></span><br><span class="line"><span class="keyword">public</span> class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> target;<span class="comment">//需要代理的目标对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写拦截方法</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Object</span> intercept(<span class="keyword">Object</span> obj, Method method, <span class="keyword">Object</span>[] arr, MethodProxy proxy) <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Cglib动态代理，监听开始！"</span>);</span><br><span class="line">        <span class="keyword">Object</span> invoke = method.invoke(target, arr);<span class="comment">//方法执行，参数：target 目标对象 arr参数数组</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Cglib动态代理，监听结束！"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义获取代理对象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Object</span> getCglibProxy(<span class="keyword">Object</span> objectTarget)&#123;</span><br><span class="line">        <span class="comment">//为目标对象target赋值</span></span><br><span class="line">        <span class="keyword">this</span>.target = objectTarget;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置父类,因为Cglib是针对指定的类生成一个子类，所以需要指定父类</span></span><br><span class="line">        enhancer.setSuperclass(objectTarget.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);<span class="comment">// 设置回调 </span></span><br><span class="line">        <span class="keyword">Object</span> result = enhancer.create();<span class="comment">//创建并返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        CglibProxy cglib = <span class="keyword">new</span> CglibProxy();<span class="comment">//实例化CglibProxy对象</span></span><br><span class="line">        UserManager user =  (UserManager) cglib.getCglibProxy(<span class="keyword">new</span> UserManagerImpl());<span class="comment">//获取代理对象</span></span><br><span class="line">        user.delUser(<span class="string">"admin"</span>);<span class="comment">//执行删除方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java中序列化有哪些方式"><a href="#Java中序列化有哪些方式" class="headerlink" title="Java中序列化有哪些方式"></a>Java中序列化有哪些方式</h2><h3 id="Java原生序列化"><a href="#Java原生序列化" class="headerlink" title="Java原生序列化"></a>Java原生序列化</h3><p>Java原生序列化方法即通过Java原生流(InputStream和OutputStream之间的转化)的方式进行转化。需要注意的是JavaBean实体类必须实现Serializable接口，否则无法序列化。Java原生序列化代码示例如下所示：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package serialize<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">import <span class="keyword">java.io.BufferedInputStream;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.io.ByteArrayOutputStream;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.io.IOException;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.io.ObjectInputStream;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.io.ObjectOutputStream;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.util.ArrayList;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.util.List;</span></span><br><span class="line"><span class="keyword">/**</span></span><br><span class="line"><span class="keyword"> </span>* </span><br><span class="line"> * @author liqqc</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class <span class="keyword">JavaSerialize </span>&#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IOException &#123;</span><br><span class="line">        new <span class="keyword">JavaSerialize().start();</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line"></span><br><span class="line">    public void start() throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        User u = new User()<span class="comment">;</span></span><br><span class="line">        List&lt;User&gt; friends = new ArrayList&lt;&gt;()<span class="comment">;</span></span><br><span class="line">        u.setUserName(<span class="string">"张三"</span>)<span class="comment">;</span></span><br><span class="line">        u.setPassWord(<span class="string">"123456"</span>)<span class="comment">;</span></span><br><span class="line">        u.setUserInfo(<span class="string">"张三是一个很牛逼的人"</span>)<span class="comment">;</span></span><br><span class="line">        u.setFriends(friends)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        User f1 = new User()<span class="comment">;</span></span><br><span class="line">        f1.setUserName(<span class="string">"李四"</span>)<span class="comment">;</span></span><br><span class="line">        f1.setPassWord(<span class="string">"123456"</span>)<span class="comment">;</span></span><br><span class="line">        f1.setUserInfo(<span class="string">"李四是一个很牛逼的人"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        User f2 = new User()<span class="comment">;</span></span><br><span class="line">        f2.setUserName(<span class="string">"王五"</span>)<span class="comment">;</span></span><br><span class="line">        f2.setPassWord(<span class="string">"123456"</span>)<span class="comment">;</span></span><br><span class="line">        f2.setUserInfo(<span class="string">"王五是一个很牛逼的人"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        friends.<span class="keyword">add(f1);</span></span><br><span class="line"><span class="keyword"> </span>       friends.<span class="keyword">add(f2);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>       Long <span class="built_in">t1</span> = System.currentTimeMillis()<span class="comment">;</span></span><br><span class="line">        <span class="keyword">ByteArrayOutputStream </span>out = new <span class="keyword">ByteArrayOutputStream();</span></span><br><span class="line"><span class="keyword"> </span>       ObjectOutputStream obj = new ObjectOutputStream(out)<span class="comment">;</span></span><br><span class="line">        for(int i = <span class="number">0</span><span class="comment">; i&lt;10; i++) &#123;</span></span><br><span class="line">            obj.writeObject(u)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"java serialize: "</span> +(System.currentTimeMillis() - <span class="built_in">t1</span>) + <span class="string">"ms; 总大小："</span> + out.toByteArray().length )<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        Long <span class="built_in">t2</span> = System.currentTimeMillis()<span class="comment">;</span></span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new <span class="keyword">BufferedInputStream(new </span><span class="keyword">java.io.ByteArrayInputStream(out.toByteArray())));</span></span><br><span class="line"><span class="keyword"> </span>       User user = (User) ois.readObject()<span class="comment">;</span></span><br><span class="line">        System.out.println(<span class="string">"java deserialize: "</span> + (System.currentTimeMillis() - <span class="built_in">t2</span>) + <span class="string">"ms; User: "</span> + user)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Json序列化"><a href="#Json序列化" class="headerlink" title="Json序列化"></a>Json序列化</h3><p>Json序列化一般会使用jackson包，通过ObjectMapper类来进行一些操作，比如将对象转化为byte数组或者将json串转化为对象。现在的大多数公司都将json作为服务器端返回的数据格式。比如调用一个服务器接口，通常的请求为xxx.json?a=xxx&amp;b=xxx的形式。Json序列化示例代码如下所示：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package serialize<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">import <span class="keyword">java.io.IOException;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.util.ArrayList;</span></span><br><span class="line"><span class="keyword">import </span><span class="keyword">java.util.List;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">import </span>com.fasterxml.<span class="keyword">jackson.databind.ObjectMapper;</span></span><br><span class="line"><span class="keyword">/**</span></span><br><span class="line"><span class="keyword"> </span>* </span><br><span class="line"> * @author liqqc</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class <span class="keyword">JsonSerialize </span>&#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        new <span class="keyword">JsonSerialize().start();</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line"></span><br><span class="line">    public void start() throws IOException &#123;</span><br><span class="line">        User u = new User()<span class="comment">;</span></span><br><span class="line">        List&lt;User&gt; friends = new ArrayList&lt;&gt;()<span class="comment">;</span></span><br><span class="line">        u.setUserName(<span class="string">"张三"</span>)<span class="comment">;</span></span><br><span class="line">        u.setPassWord(<span class="string">"123456"</span>)<span class="comment">;</span></span><br><span class="line">        u.setUserInfo(<span class="string">"张三是一个很牛逼的人"</span>)<span class="comment">;</span></span><br><span class="line">        u.setFriends(friends)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        User f1 = new User()<span class="comment">;</span></span><br><span class="line">        f1.setUserName(<span class="string">"李四"</span>)<span class="comment">;</span></span><br><span class="line">        f1.setPassWord(<span class="string">"123456"</span>)<span class="comment">;</span></span><br><span class="line">        f1.setUserInfo(<span class="string">"李四是一个很牛逼的人"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        User f2 = new User()<span class="comment">;</span></span><br><span class="line">        f2.setUserName(<span class="string">"王五"</span>)<span class="comment">;</span></span><br><span class="line">        f2.setPassWord(<span class="string">"123456"</span>)<span class="comment">;</span></span><br><span class="line">        f2.setUserInfo(<span class="string">"王五是一个很牛逼的人"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        friends.<span class="keyword">add(f1);</span></span><br><span class="line"><span class="keyword"> </span>       friends.<span class="keyword">add(f2);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>       ObjectMapper mapper = new ObjectMapper()<span class="comment">;</span></span><br><span class="line">        Long <span class="built_in">t1</span> = System.currentTimeMillis()<span class="comment">;</span></span><br><span class="line">        <span class="keyword">byte[] </span>writeValueAsBytes = null<span class="comment">;</span></span><br><span class="line">        for (int i = <span class="number">0</span><span class="comment">; i &lt; 10; i++) &#123;</span></span><br><span class="line">            writeValueAsBytes = mapper.writeValueAsBytes(u)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"json serialize: "</span> + (System.currentTimeMillis() - <span class="built_in">t1</span>) + <span class="string">"ms; 总大小："</span> + writeValueAsBytes.length)<span class="comment">;</span></span><br><span class="line">        Long <span class="built_in">t2</span> = System.currentTimeMillis()<span class="comment">;</span></span><br><span class="line">        User user = mapper.readValue(writeValueAsBytes, User.class)<span class="comment">;</span></span><br><span class="line">        System.out.println(<span class="string">"json deserialize: "</span> + (System.currentTimeMillis() - <span class="built_in">t2</span>) + <span class="string">"ms; User: "</span> + user)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FastJson序列化"><a href="#FastJson序列化" class="headerlink" title="FastJson序列化"></a>FastJson序列化</h3><p>fastjson 是由阿里巴巴开发的一个性能很好的Java 语言实现的 Json解析器和生成器。特点：速度快，测试表明fastjson具有极快的性能，超越任其他的java json parser。功能强大，完全支持java bean、集合、Map、日期、Enum，支持范型和自省。无依赖，能够直接运行在Java SE 5.0以上版本<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author liqqc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class FastJsonSerialize &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">new</span> FastJsonSerialize().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> start()&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        List&lt;User&gt; friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        u.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">        u.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        u.setUserInfo(<span class="string">"张三是一个很牛逼的人"</span>);</span><br><span class="line">        u.setFriends(friends);</span><br><span class="line"></span><br><span class="line">        User f1 = <span class="keyword">new</span> User();</span><br><span class="line">        f1.setUserName(<span class="string">"李四"</span>);</span><br><span class="line">        f1.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f1.setUserInfo(<span class="string">"李四是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        User f2 = <span class="keyword">new</span> User();</span><br><span class="line">        f2.setUserName(<span class="string">"王五"</span>);</span><br><span class="line">        f2.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f2.setUserInfo(<span class="string">"王五是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        friends.<span class="built_in">add</span>(f1);</span><br><span class="line">        friends.<span class="built_in">add</span>(f2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化  </span></span><br><span class="line">        Long t1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">text</span> = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">text</span> = JSON.toJSONString(u); </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"fastJson serialize: "</span> +(System.currentTimeMillis() - t1) + <span class="string">"ms; 总大小："</span> + <span class="built_in">text</span>.getBytes().length);</span><br><span class="line">        <span class="comment">//反序列化  </span></span><br><span class="line">        Long t2 = System.currentTimeMillis();</span><br><span class="line">        User user = JSON.parseObject(<span class="built_in">text</span>, User.class);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"fastJson serialize: "</span> + (System.currentTimeMillis() -t2) + <span class="string">"ms; User: "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ProtoBuff序列化"><a href="#ProtoBuff序列化" class="headerlink" title="ProtoBuff序列化"></a>ProtoBuff序列化</h3><p>ProtocolBuffer是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化。适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p>
<ul>
<li>优点：跨语言；序列化后数据占用空间比JSON小，JSON有一定- 的格式，在数据量上还有可以压缩的空间。</li>
</ul>
<p>缺点：它以二进制的方式存储，无法直接读取编辑，除非你有 .proto 定义，否则无法直接读出 Protobuffer的任何内容。</p>
<p>其与thrift的对比：两者语法类似，都支持版本向后兼容和向前兼容，thrift侧重点是构建跨语言的可伸缩的服务，支持的语言多，同时提供了全套RPC解决方案，可以很方便的直接构建服务，不需要做太多其他的工作。 Protobuffer主要是一种序列化机制，在数据序列化上进行性能比较，Protobuffer相对较好。</p>
<p>ProtoBuff序列化对象可以很大程度上将其压缩，可以大大减少数据传输大小，提高系统性能。对于大量数据的缓存，也可以提高缓存中数据存储量。原始的ProtoBuff需要自己写.proto文件，通过编译器将其转换为java文件，显得比较繁琐。百度研发的jprotobuf框架将Google原始的protobuf进行了封装，对其进行简化，仅提供序列化和反序列化方法。其实用上也比较简洁，通过对JavaBean中的字段进行注解就行，不需要撰写.proto文件和实用编译器将其生成.java文件，百度的jprotobuf都替我们做了这些事情了。</p>
<p>一个带有jprotobuf注解的JavaBean如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.FieldType;</span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.annotation.Protobuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7890663945232864573L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.INT32, required = <span class="keyword">false</span>, order = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.STRING, required = <span class="keyword">false</span>, order = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.STRING, required = <span class="keyword">false</span>, order = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.STRING, required = <span class="keyword">false</span>, order = <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">private</span> String userInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.OBJECT, required = <span class="keyword">false</span>, order = <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; friends;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassWord</span><span class="params">(String passWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserInfo</span><span class="params">(String userInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userInfo = userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getFriends</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> friends;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFriends</span><span class="params">(List&lt;User&gt; friends)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.friends = friends;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User [userId="</span> + userId + <span class="string">", userName="</span> + userName + <span class="string">", passWord="</span> + passWord + <span class="string">", userInfo="</span> + userInfo</span><br><span class="line">                + <span class="string">", friends="</span> + friends + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.Codec;</span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.ProtobufProxy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liqqc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBuffSerialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProtoBuffSerialize().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Codec&lt;User&gt; studentClassCodec = ProtobufProxy.create(User.class, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        User u2 = <span class="keyword">new</span> User();</span><br><span class="line">        List&lt;User&gt; friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        u2.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">        u2.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        u2.setUserInfo(<span class="string">"张三是一个很牛逼的人"</span>);</span><br><span class="line">        u2.setFriends(friends);</span><br><span class="line"></span><br><span class="line">        User f1 = <span class="keyword">new</span> User();</span><br><span class="line">        f1.setUserName(<span class="string">"李四"</span>);</span><br><span class="line">        f1.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f1.setUserInfo(<span class="string">"李四是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        User f2 = <span class="keyword">new</span> User();</span><br><span class="line">        f2.setUserName(<span class="string">"王五"</span>);</span><br><span class="line">        f2.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f2.setUserInfo(<span class="string">"王五是一个很牛逼的人"</span>);</span><br><span class="line">        friends.add(f1);</span><br><span class="line">        friends.add(f2);</span><br><span class="line"></span><br><span class="line">        Long stime_jpb_encode = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            bytes = studentClassCodec.encode(u2);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"jprotobuf序列化耗时："</span> + (System.currentTimeMillis() - stime_jpb_encode) + <span class="string">"ms; 总大小："</span> + bytes.length);</span><br><span class="line"></span><br><span class="line">        Long stime_jpb_decode = System.currentTimeMillis();</span><br><span class="line">        User user = studentClassCodec.decode(bytes);</span><br><span class="line">        Long etime_jpb_decode = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"jprotobuf反序列化耗时："</span>+ (etime_jpb_decode-stime_jpb_decode) + <span class="string">"ms; User: "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="序列化底层实现"><a href="#序列化底层实现" class="headerlink" title="序列化底层实现"></a>序列化底层实现</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">	    <span class="comment">//序列化</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="string">"object.out"</span>);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> <span class="type">ObjectOutputStream</span>(fos);</span><br><span class="line">        User user1 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"xuliugen"</span>, <span class="string">"123456"</span>, <span class="string">"male"</span>);</span><br><span class="line">        oos.writeObject(user1);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">		<span class="comment">//反序列化</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"object.out"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> <span class="type">ObjectInputStream</span>(fis);</span><br><span class="line">        User user2 = (User) ois.readObject();</span><br><span class="line">        System.out.println(user2.getUserName()+ <span class="string">" "</span> + </span><br><span class="line">	        user2.getPassword() + <span class="string">" "</span> + user2.getSex());</span><br><span class="line">        <span class="comment">//反序列化的输出结果为：xuliugen 123456 male</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Serializable</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> sex;</span><br><span class="line">    <span class="comment">//全参构造方法、get和set方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>object.out文件如下<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180407130515728.png" alt="image"><br>注：上图中0000000h-000000c0h表示行号；0-f表示列；行后面的文字表示对这行16进制的解释；对上述字节码所表述的内容感兴趣的可以对照相关的资料，查阅一下每一个字符代表的含义，这里不在探讨！</p>
<p>类似于我们Java代码编译之后的.class文件，每一个字符都代表一定的含义。序列化和反序列化的过程就是生成和解析上述字符的过程！</p>
<p>序列化图示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180408163613978.jpeg" alt="image"><br>反序列化图示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180408163634701.jpeg" alt="image"></p>
<h4 id="相关注意事项"><a href="#相关注意事项" class="headerlink" title="相关注意事项"></a>相关注意事项</h4><p>1、序列化时，只对对象的状态进行保存，而不管对象的方法；</p>
<p>2、当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</p>
<p>3、当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</p>
<p>4、并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如：</p>
<p>安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；</p>
<p>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；</p>
<p>5、声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。</p>
<p>6、序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途：</p>
<p>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</p>
<p>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p>
<p>7、Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的；</p>
<p>8、如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存！这是能用序列化解决深拷贝的重要原因；</p>
<h2 id="并发编程的包，AQS和普通锁相比有什么好处"><a href="#并发编程的包，AQS和普通锁相比有什么好处" class="headerlink" title="并发编程的包，AQS和普通锁相比有什么好处"></a>并发编程的包，AQS和普通锁相比有什么好处</h2><p>队列同步器AbstractQueuedSynchronizer，是用来构建锁或者其他同步组件的基础框架，它使用一个int成员表示同步状态，通过内部的FIFO队列来完成资源获取线程的排序工作。</p>
<h3 id="AQS的设计"><a href="#AQS的设计" class="headerlink" title="AQS的设计"></a>AQS的设计</h3><p> AQS的设计是基于模板方法模式的，也就是说，使用者需要继承AQS并重写指定的方法，随后将AQS组合在自定义同步组件的实现中，并调用AQS提供的模板方法，而这些模板方法将会调用使用者重写的方法。<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile int <span class="keyword">state</span>;</span><br></pre></td></tr></table></figure></p>
<p>AQS使用一个int的成员变量来表示同步状态。<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final void <span class="built_in">set</span>State(int newState) &#123;</span><br><span class="line">    <span class="keyword">state</span> = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>setState方法用来设置同步状态<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getState方法用来获取同步状态<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, stateOffset, expect, update)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>compareAndSetState方法使用CAS操作来讲同步状态设置为给定的值</p>
<h3 id="AQS中的同步队列"><a href="#AQS中的同步队列" class="headerlink" title="AQS中的同步队列"></a>AQS中的同步队列</h3><p>最开始就提到过AQS内部维护着一个FIFO的队列。而AQS就是依赖这个同步队列来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点Node，并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<p>同步队列中节点属性<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//共享锁对应的节点</span><br><span class="line">static final <span class="keyword">Node</span> <span class="title">SHARED</span> = new <span class="keyword">Node</span><span class="title">();</span></span><br></pre></td></tr></table></figure></p>
<p> 因为如果是共享锁，线程可以被多个线程获得。所以将这个属性定义为一个常量。<br> <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//独占锁对应的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>   独占锁因为只能对一个线程获得，所以设置为null，当某个线程获得锁时，将该线程对应的赋予这个属性<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点的等待状态</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br></pre></td></tr></table></figure></p>
<p>节点的等待状态有4个</p>
<ul>
<li>CANCELLED：值为1，由于在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消等待，节点进入该状态将不会变化</li>
<li>SINGAL：值为-1，后继节点的线程处于等待状态，当前节点如果释放了同步状态，将会通知后继节点，使后继节点得以运行</li>
<li>CONDITION：值为-2，节点在等待队列中（这个在Condition的博客里会讲到），节点线程等待在Condition上，当其他线程对Condition调用了singal后，该节点会从等待队列转移到同步队列，加入到对同步状态的获取中去</li>
<li>PROPAGEATE：值为-3，表示下一次共享式同步状态获取将会无条件被传播下去<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//前驱节点，当节点加入同步队列时被设置（尾部添加）</span><br><span class="line">volatile <span class="keyword">Node</span> <span class="title">prev</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>同步队列中某个节点的前驱节点<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//后继节点</span><br><span class="line">volatile <span class="keyword">Node</span> <span class="title">next</span>;</span><br></pre></td></tr></table></figure></p>
<p>同步队列中某个节点的后继节点<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//等待队列的后继节点。如果当前节点是共享的，那么这个字段将是一个SHARED常量</span><br><span class="line"><span class="keyword">Node</span> <span class="title">nextWaiter</span>;</span><br></pre></td></tr></table></figure></p>
<p>这个是等待队列的后继节点（不是同步队列）<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取同步状态的线程</span></span><br><span class="line">volatile <span class="keyword">Thread</span> <span class="keyword">thread</span>;</span><br></pre></td></tr></table></figure></p>
<p>当前获取到同步状态的线程</p>
<p>节点时构成同步队列的基础，AQS拥有首节点和尾节点，没有成功获取到同步状态的节点会加入到同步队列的尾部，同步队列的结构如下图所示<br> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180509004159305.png" alt="image"><br> 同步器AQS包含两个节点类型的引用，一个指向头结点，一个指向尾节点。</p>
<h3 id="同步队列的操作"><a href="#同步队列的操作" class="headerlink" title="同步队列的操作"></a>同步队列的操作</h3><ul>
<li>将节点加入到同步队列：当一个线程成功获取了同步状态（或者锁），其他线程将无法获取到同步状态，转而被构造成节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全。AQS提供了一个基于CAS的设置尾节点的方法：compareAndSerTail，它需要传递当前线程认为的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180509005738767.png" alt="image"></li>
<li>将节点设置为首节点：同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180509005820225.png" alt="image"><br>设置首节点是通过成功获取同步状态的线程完成的，由于只有一个线程能成功获取到同步状态，因此设置头节点并不需要使用CAS来保证，它只需要将首节点设置为原首节点的后继节点并断开原首节点的next引用即可。</li>
</ul>
<h2 id="synchronized底层实现，加在方法上和加在同步代码块中编译后的区别、类锁、对象锁。"><a href="#synchronized底层实现，加在方法上和加在同步代码块中编译后的区别、类锁、对象锁。" class="headerlink" title="synchronized底层实现，加在方法上和加在同步代码块中编译后的区别、类锁、对象锁。"></a>synchronized底层实现，加在方法上和加在同步代码块中编译后的区别、类锁、对象锁。</h2><p><a href="https://blog.csdn.net/luoweifu/article/details/46613015" target="_blank" rel="noopener">原文链接</a></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</p>
<ul>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象。</li>
</ul>
<p>一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> SyncThread() &#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>  <span class="keyword">void</span> run() &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (count++));</span><br><span class="line">               Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> getCount() &#123;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SyncThread的调用</span></span><br><span class="line">SyncThread syncThread = <span class="keyword">new</span> SyncThread();</span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(syncThread, <span class="string">"SyncThread1"</span>);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(syncThread, <span class="string">"SyncThread2"</span>);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line"><span class="comment">//结果如下</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">0</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">1</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">2</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">3</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">4</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">5</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">6</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">7</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">8</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">9</span>*</span><br></pre></td></tr></table></figure>
<p>当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。Thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。</p>
<p>我们再把SyncThread的调用稍微改一下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SyncThread(), <span class="string">"SyncThread1"</span>);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SyncThread(), <span class="string">"SyncThread2"</span>);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line"><span class="comment">//结果如下：</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">0</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">1</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">2</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">3</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">4</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">5</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">6</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">7</span></span><br><span class="line"><span class="string">SyncThread1:</span><span class="number">8</span></span><br><span class="line"><span class="string">SyncThread2:</span><span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>不是说一个线程执行synchronized代码块时其它的线程受阻塞吗？为什么上面的例子中thread1和thread2同时在执行。这是因为synchronized只锁定对象，每个对象只有一个锁（lock）与之相关联，而上面的代码等同于下面这段代码：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SyncThread </span><span class="keyword">syncThread1 </span>= new <span class="keyword">SyncThread();</span></span><br><span class="line"><span class="keyword">SyncThread </span><span class="keyword">syncThread2 </span>= new <span class="keyword">SyncThread();</span></span><br><span class="line"><span class="keyword">Thread </span>thread1 = new Thread(<span class="keyword">syncThread1, </span><span class="string">"SyncThread1"</span>)<span class="comment">;</span></span><br><span class="line">Thread thread2 = new Thread(<span class="keyword">syncThread2, </span><span class="string">"SyncThread2"</span>)<span class="comment">;</span></span><br><span class="line">thread1.start()<span class="comment">;</span></span><br><span class="line">thread2.start()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>这时创建了两个SyncThread的对象syncThread1和syncThread2，线程thread1执行的是syncThread1对象中的synchronized代码(run)，而线程thread2执行的是syncThread2对象中的synchronized代码(run)；我们知道synchronized锁定的是对象，这时会有两把锁分别锁定syncThread1对象和syncThread2对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。</p>
<p>当一个线程访问对象的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块。</p>
<p>多个线程访问synchronized和非synchronized代码块<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Counter() &#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> countAdd() &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (count++));</span><br><span class="line">               Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//非synchronized代码块，未对count进行读写操作，所以可以不用synchronized</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> printCount() &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" count:"</span> + count);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">      String threadName = Thread.currentThread().getName();</span><br><span class="line">      <span class="keyword">if</span> (threadName.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">         countAdd();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (threadName.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">         printCount();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用代码</span></span><br><span class="line">Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(counter, <span class="string">"A"</span>);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(counter, <span class="string">"B"</span>);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line"><span class="comment">//结果如下</span></span><br><span class="line"><span class="string">A:</span><span class="number">0</span></span><br><span class="line">B <span class="string">count:</span><span class="number">1</span></span><br><span class="line"><span class="string">A:</span><span class="number">1</span></span><br><span class="line">B <span class="string">count:</span><span class="number">2</span></span><br><span class="line"><span class="string">A:</span><span class="number">2</span></span><br><span class="line">B <span class="string">count:</span><span class="number">3</span></span><br><span class="line"><span class="string">A:</span><span class="number">3</span></span><br><span class="line">B <span class="string">count:</span><span class="number">4</span></span><br><span class="line"><span class="string">A:</span><span class="number">4</span></span><br><span class="line">B <span class="string">count:</span><span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中countAdd是一个synchronized的，printCount是非synchronized的。从上面的结果中可以看出一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。</p>
<h3 id="指定要给某个对象加锁"><a href="#指定要给某个对象加锁" class="headerlink" title="指定要给某个对象加锁"></a>指定要给某个对象加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 银行账户类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">   <span class="keyword">float</span> amount;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String name, <span class="keyword">float</span> amount)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.amount = amount;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//存钱</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">float</span> amt)</span> </span>&#123;</span><br><span class="line">      amount += amt;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//取钱</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">float</span> amt)</span> </span>&#123;</span><br><span class="line">      amount -= amt;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> amount;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户操作类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountOperator</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Account account;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AccountOperator</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.account = account;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">         account.deposit(<span class="number">500</span>);</span><br><span class="line">         account.withdraw(<span class="number">500</span>);</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + account.getBalance());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用代码</span></span><br><span class="line">Account account = <span class="keyword">new</span> Account(<span class="string">"zhang san"</span>, <span class="number">10000.0f</span>);</span><br><span class="line">AccountOperator accountOperator = <span class="keyword">new</span> AccountOperator(account);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUM = <span class="number">5</span>;</span><br><span class="line">Thread threads[] = <span class="keyword">new</span> Thread[THREAD_NUM];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i ++) &#123;</span><br><span class="line">   threads[i] = <span class="keyword">new</span> Thread(accountOperator, <span class="string">"Thread"</span> + i);</span><br><span class="line">   threads[i].start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果如下</span></span><br><span class="line">Thread3:<span class="number">10000.0</span></span><br><span class="line">Thread2:<span class="number">10000.0</span></span><br><span class="line">Thread1:<span class="number">10000.0</span></span><br><span class="line">Thread4:<span class="number">10000.0</span></span><br><span class="line">Thread0:<span class="number">10000.0</span></span><br></pre></td></tr></table></figure>
<p>在AccountOperator 类中的run方法里，我们用synchronized 给account对象加了锁。这时，当一个线程访问account对象时，其他试图访问account对象的线程将会阻塞，直到该线程访问account对象结束。也就是说谁拿到那个锁谁就可以运行它所控制的那段代码。<br>当有一个明确的对象作为锁时，就可以用类似下面这样的方式写程序。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> method3(SomeObject obj)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//obj 锁定的对象</span></span><br><span class="line">   <span class="keyword">synchronized</span>(obj)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的对象来充当锁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">byte</span>[] lock = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];  <span class="comment">// 特殊的instance变量</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">         <span class="comment">// todo 同步代码块</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。</p>
<h3 id="修饰一个方法"><a href="#修饰一个方法" class="headerlink" title="修饰一个方法"></a>修饰一个方法</h3><p>Synchronized修饰一个方法很简单，就是在方法的前面加synchronized，public synchronized void method(){//todo}; synchronized修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。如将【Demo1】中的run方法改成如下的方式，实现的效果一样。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (count++));</span><br><span class="line">         Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Synchronized作用于整个方法的写法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写法一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> method()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写法二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> method()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写法一修饰的是一个方法，写法二修饰的是一个代码块，但写法一与写法二是等价的，都是锁定了整个方法时的内容。</p>
<p>在用synchronized修饰方法时要注意以下几点：</p>
<ol>
<li>synchronized关键字不能继承。<br>虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。这两种方式的例子代码如下：<br>在子类方法中加上synchronized关键字<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   public synchronized void method() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   public synchronized void method() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在子类方法中调用父类的同步方法<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   public synchronized void method() &#123;   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   public void method() &#123; <span class="keyword">super</span>.method();   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在定义接口方法时不能使用synchronized关键字。</li>
<li>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</li>
</ul>
<h3 id="修饰一个静态的方法"><a href="#修饰一个静态的方法" class="headerlink" title="修饰一个静态的方法"></a>修饰一个静态的方法</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class <span class="keyword">SyncThread </span>implements Runnable &#123;</span><br><span class="line">   private static int <span class="built_in">count</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">   public <span class="keyword">SyncThread() </span>&#123;</span><br><span class="line">      <span class="built_in">count</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public <span class="keyword">synchronized </span>static void method() &#123;</span><br><span class="line">      for (int i = <span class="number">0</span><span class="comment">; i &lt; 5; i ++) &#123;</span></span><br><span class="line">         try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (<span class="built_in">count</span>++))<span class="comment">;</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>)<span class="comment">;</span></span><br><span class="line">         &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace()<span class="comment">;</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public <span class="keyword">synchronized </span>void run() &#123;</span><br><span class="line">      method()<span class="comment">;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SyncThread </span><span class="keyword">syncThread1 </span>= new <span class="keyword">SyncThread();</span></span><br><span class="line"><span class="keyword">SyncThread </span><span class="keyword">syncThread2 </span>= new <span class="keyword">SyncThread();</span></span><br><span class="line"><span class="keyword">Thread </span>thread1 = new Thread(<span class="keyword">syncThread1, </span><span class="string">"SyncThread1"</span>)<span class="comment">;</span></span><br><span class="line">Thread thread2 = new Thread(<span class="keyword">syncThread2, </span><span class="string">"SyncThread2"</span>)<span class="comment">;</span></span><br><span class="line">thread1.start()<span class="comment">;</span></span><br><span class="line">thread2.start()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SyncThread1:0</span></span><br><span class="line"><span class="keyword">SyncThread1:1</span></span><br><span class="line"><span class="keyword">SyncThread1:2</span></span><br><span class="line"><span class="keyword">SyncThread1:3</span></span><br><span class="line"><span class="keyword">SyncThread1:4</span></span><br><span class="line"><span class="keyword">SyncThread2:5</span></span><br><span class="line"><span class="keyword">SyncThread2:6</span></span><br><span class="line"><span class="keyword">SyncThread2:7</span></span><br><span class="line"><span class="keyword">SyncThread2:8</span></span><br><span class="line"><span class="keyword">SyncThread2:9</span></span><br></pre></td></tr></table></figure>
<p>syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。这与Demo1是不同的。</p>
<h3 id="修饰一个类"><a href="#修饰一个类" class="headerlink" title="修饰一个类"></a>修饰一个类</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> SyncThread <span class="keyword">implements</span> Runnable &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> SyncThread() &#123;</span><br><span class="line">      <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> method() &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(SyncThread.<span class="keyword">class</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.<span class="keyword">println</span>(Thread.currentThread().getName() + <span class="string">":"</span> + (<span class="keyword">count</span>++));</span><br><span class="line">               Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">      method();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其效果和【Demo5】是一样的，synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。</li>
<li>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。<br>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li>
</ul>
<h2 id="锁升级的过程。"><a href="#锁升级的过程。" class="headerlink" title="锁升级的过程。"></a>锁升级的过程。</h2><ul>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象</li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象</li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象</li>
</ul>
<p>Java中提供了两种实现同步的基础语义：synchronized方法和synchronized块</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SyncTest</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncBlock</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        synchronized (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"hello block"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">syncMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当SyncTest.java被编译成class文件的时候，synchronized关键字和synchronized方法的字节码略有不同，我们可以用javap -v 命令查看class文件对应的JVM字节码信息，部分信息如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="literal">void</span> syncBlock();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      <span class="built_in">stack</span>=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter                      <span class="comment">// monitorenter指令进入同步块</span></span><br><span class="line">         <span class="number">4</span>: getstatic     #2                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">7</span>: ldc           #3                  <span class="comment">// String hello block</span></span><br><span class="line">         <span class="number">9</span>: invokevirtual #4                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">12</span>: aload_1</span><br><span class="line">        <span class="number">13</span>: monitorexit                       <span class="comment">// monitorexit指令退出同步块</span></span><br><span class="line">        <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">        <span class="number">17</span>: astore_2</span><br><span class="line">        <span class="number">18</span>: aload_1</span><br><span class="line">        <span class="number">19</span>: monitorexit                       <span class="comment">// monitorexit指令退出同步块</span></span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        <span class="number">21</span>: athrow</span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    <span class="keyword">to</span>  target <span class="keyword">type</span></span><br><span class="line">             <span class="number">4</span>    <span class="number">14</span>    <span class="number">17</span>   any</span><br><span class="line">            <span class="number">17</span>    <span class="number">20</span>    <span class="number">17</span>   any</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> synchronized <span class="literal">void</span> syncMethod();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED      <span class="comment">//添加了ACC_SYNCHRONIZED标记</span></span><br><span class="line">    Code:</span><br><span class="line">      <span class="built_in">stack</span>=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #2                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #5                  <span class="comment">// String hello method</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #4                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的中文注释处可以看到，对于<code>synchronized</code>关键字而言，javac在编译时，会生成对应的<code>monitorenter</code>和<code>monitorexit</code>指令分别对应<code>synchronized</code>同步块的进入和退出，有两个<code>monitorexit</code>指令的原因是：为了保证抛异常的情况下也能释放锁，所以javac为同步代码块添加了一个隐式的<code>try-finally</code>，在<code>finally</code>中会调用<code>monitorexit</code>命令释放锁。而对于<code>synchronized</code>方法而言，javac为其生成了一个<code>ACC_SYNCHRONIZED</code>关键字，在JVM进行方法调用时，发现调用的方法被<code>ACC_SYNCHRONIZED</code>修饰，则会先尝试获得锁。</p>
<p>在JVM底层，对于这两种synchronized语义的实现大致相同。</p>
<h3 id="锁的几种形式"><a href="#锁的几种形式" class="headerlink" title="锁的几种形式"></a>锁的几种形式</h3><p>传统的锁（也就是下文要说的重量级锁）依赖于系统的同步函数，在linux上使用<code>mutex</code>互斥锁，最底层实现依赖于<code>futex</code>，关于<code>futex</code>可以看我之前的文章，这些同步函数都涉及到用户态和内核态的切换、进程的上下文切换，成本较高。对于加了<code>synchronized</code>关键字但运行时并没有多线程竞争，或两个线程接近于交替执行的情况，使用传统锁机制无疑效率是会比较低的。</p>
<p>在JDK 1.6之前,<code>synchronized</code>只有传统的锁机制，因此给开发者留下了<code>synchronized</code>关键字相比于其他同步机制性能不好的印象。</p>
<p>在JDK 1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。</p>
<p>在看这几种锁机制的实现前，我们先来了解下对象头，它是实现多种锁机制的基础。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>因为在Java中任意对象都可以用作锁，因此必定要有一个映射关系，存储该对象以及其对应的锁信息（比如当前哪个线程持有锁，哪些线程在等待）。一种很直观的方法是，用一个全局map，来存储这个映射关系，但这样会有一些问题：需要对map做线程安全保障，不同的synchronized之间会相互影响，性能差；另外当同步对象较多时，该map可能会占用比较多的内存。</p>
<p>所以最好的办法是将这个映射关系存储在对象头中，因为对象头本身也有一些hashcode、GC相关的数据，所以如果能将锁信息与这些信息共存在对象头中就好了。</p>
<p>在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：mark word和类型指针。另外对于数组而言还会有一份记录数组长度的数据。</p>
<p>类型指针是指向该对象所属类对象的指针，<code>mark word</code>用于存储对象的<code>HashCode</code>、GC分代年龄、锁状态等信息。在32位系统上<code>mark word</code>长度为32字节，64位系统上长度为64字节。为了能在有限的空间里存储下更多的数据，其存储格式是不固定的，在32位系统上各状态的格式如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG252.png" alt="image"></p>
<p>可以看到锁信息也是存在于对象的<code>mark word</code>中的。当对象状态为偏向锁（biasable）时，<code>mark word</code>存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，<code>mark word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁是我们常说的传统意义上的锁，其利用操作系统底层的同步机制去实现Java中的线程同步。</p>
<p>重量级锁的状态下，对象的<code>mark word</code>为指向一个堆中monitor对象的指针。</p>
<p>一个monitor对象包括这么几个关键字段：cxq（下图中的ContentionList），EntryList ，WaitSet，owner。</p>
<p>其中cxq ，EntryList ，WaitSet都是由ObjectWaiter的链表结构，owner指向持有锁的线程。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG253.png" alt="image"></p>
<p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列尾部，然后暂停当前线程。当持有锁的线程释放锁前，会将cxq中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p>
<p>如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p>
<p>以上只是对重量级锁流程的一个简述，其中涉及到的很多细节，比如ObjectMonitor对象从哪来？释放锁时是将cxq中的元素移动到EntryList的尾部还是头部？notfiy时，是将ObjectWaiter移动到EntryList的尾部还是头部？</p>
<p>关于具体的细节，会在重量级锁的文章中分析。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>JVM的开发者发现在很多情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。</p>
<p>线程在执行同步块之前，JVM会先在当前的线程的栈帧中创建一个Lock Record，其包括一个用于存储对象头中的 mark word（官方称之为Displaced Mark Word）以及一个指向对象的指针。下图右边的部分就是一个Lock Record。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG254.png" alt="image"></p>
<h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><ol>
<li><p>在线程栈中创建一个Lock Record，将其obj（即上图的Object reference）字段指向锁对象。</p>
</li>
<li><p>直接通过CAS指令将Lock Record的地址存储在对象头的mark word中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。如果失败，进入到步骤3。</p>
</li>
<li><p>如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分（Displaced Mark Word）为null，起到了一个重入计数器的作用。然后结束。</p>
</li>
<li><p>走到这一步说明发生了竞争，需要膨胀为重量级锁。</p>
</li>
</ol>
<h3 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h3><ol>
<li><p>遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record。</p>
</li>
<li><p>如果Lock Record的Displaced Mark Word为null，代表这是一次重入，将obj设置为null后continue。</p>
</li>
<li><p>如果Lock Record的Displaced Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为Displaced Mark Word。如果成功，则continue，否则膨胀为重量级锁。</p>
</li>
</ol>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>Java是支持多线程的语言，因此在很多二方包、基础库中为了保证代码在多线程的情况下也能正常运行，也就是我们常说的线程安全，都会加入如synchronized这样的同步语义。但是在应用在实际运行时，很可能只有一个线程会调用相关同步方法。比如下面这个demo：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo1</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncDemo1 syncDemo1 = <span class="keyword">new</span> SyncDemo1();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            syncDemo1.addString(<span class="string">"test:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">addString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">list</span>.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个demo中为了保证对list操纵时线程安全，对addString方法加了synchronized的修饰，但实际使用时却只有一个线程调用到该方法，对于轻量级锁而言，每次调用addString时，加锁解锁都有一个CAS操作；对于重量级锁而言，加锁也会有一个或多个CAS操作（这里的’一个‘、’多个‘数量词只是针对该demo，并不适用于所有场景）。</p>
<p>在JDK1.6中为了提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能，引入了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只会执行几个简单的命令，而不是开销相对较大的CAS命令。我们来看看偏向锁是如何做的。</p>
<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>当JVM启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式（什么时候会关闭一个class的偏向模式下文会说，默认所有class的偏向模式都是是开启的），那新创建对象的mark word将是可偏向状态，此时mark word中的thread id（参见上文偏向状态下的mark word格式）为0，表示未偏向任何线程，也叫做匿名偏向(anonymously biased)。</p>
<h3 id="加锁过程-1"><a href="#加锁过程-1" class="headerlink" title="加锁过程"></a>加锁过程</h3><p>case 1：当该对象第一次被线程获得锁的时候，发现是匿名偏向状态，则会用CAS指令，将mark word中的thread id由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则，将偏向锁撤销，升级为轻量级锁。</p>
<p>case 2：当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程，在通过一些额外的检查后（细节见后面的文章），会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，synchronized关键字带来的性能开销基本可以忽略。</p>
<p>case 3.当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到撤销偏向锁的逻辑里，一般来说，会在safepoint中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的mark word改为无锁状态（unlocked），之后再升级为轻量级锁。</p>
<p>由此可见，偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p>
<h3 id="解锁过程-1"><a href="#解锁过程-1" class="headerlink" title="解锁过程"></a>解锁过程</h3><p>当有其他线程尝试获得锁时，是根据遍历偏向线程的lock record来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条lock record的obj字段设置为null。需要注意的是，偏向锁的解锁步骤中并不会修改对象头中的thread id。</p>
<p>下图展示了锁状态的转换流程：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG255.png" alt="image"></p>
<p>另外，偏向锁默认不是立即就启动的，在程序启动后，通常有几秒的延迟，可以通过命令 <code>-XX:BiasedLockingStartupDelay=0</code>来关闭延迟。</p>
<h3 id="批量重偏向与撤销"><a href="#批量重偏向与撤销" class="headerlink" title="批量重偏向与撤销"></a>批量重偏向与撤销</h3><p>从上文偏向锁的加锁解锁过程中可以看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。safe point这个词我们在GC中经常会提到，其代表了一个状态，在该状态下所有线程都是暂停的（大概这么个意思），详细可以看这篇文章。总之，偏向锁的撤销是有一定成本的，如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。</p>
<p>存在如下两种情况:</p>
<ol>
<li><p>一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</p>
</li>
<li><p>存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</p>
</li>
</ol>
<p>批量重偏向（bulk rebias）机制是为了解决第一种场景。批量撤销（bulk revoke）则是为了解决第二种场景。</p>
<p>其做法是：以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的mark word中也有该字段，其初始值为创建该对象时，class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其mark word的Thread Id 改成当前线程Id。</p>
<p>当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>
<h2 id="Java运行时区域及各个区域的作用、对GC的了解、Java内存模型及为什么要这么设计？"><a href="#Java运行时区域及各个区域的作用、对GC的了解、Java内存模型及为什么要这么设计？" class="headerlink" title="Java运行时区域及各个区域的作用、对GC的了解、Java内存模型及为什么要这么设计？"></a>Java运行时区域及各个区域的作用、对GC的了解、Java内存模型及为什么要这么设计？</h2><h3 id="Java运行时区域及各个区域的作用"><a href="#Java运行时区域及各个区域的作用" class="headerlink" title="Java运行时区域及各个区域的作用"></a>Java运行时区域及各个区域的作用</h3><p>Java虚拟机所管理的内存将会包括一下几个运行时数据区域</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1182497-20170616192740650-1039521219.png" alt="image"></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p> 程序计数器（Program Counter Register） 是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条执行字节码指令。</p>
<p>每条线程都有一个独立的程序计数器。</p>
<p>如果执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址。如果是native方法，计数器为空。此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>同样是线程私有，描述Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法对应一个栈帧。</p>
<p>局部变量表存放了各种基本类型、对象引用和returnAddress类型（指向了一条字节码指令地址）。其中64位长度long 和 double占两个局部变量空间，其他只占一个。</p>
<p>规定的异常情况有两种：1.线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；2.如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就抛出OutOfMemoryError异常。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p> 和Java虚拟机栈很类似，不同的是本地方法栈为Native方法服务。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>是Java虚拟机所管理的内存中最大的一块。由所有线程共享，在虚拟机启动时创建。堆区唯一目的就是存放对象实例。</p>
<p>堆中可细分为新生代和老年代，再细分可分为Eden空间、From Survivor空间、To Survivor空间。</p>
<p>堆无法扩展时，抛出OutOfMemoryError异常</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>所有线程共享，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>当方法区无法满足内存分配需求时，抛出OutOfMemoryError</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>它是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池（Const Pool Table），用于存放编译期生成的各种字面量和符号引用。并非预置入Class文件中常量池的内容才进入方法运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
<p>当方法区无法满足内存分配需求时，抛出OutOfMemoryError</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。</p>
<p>JDK1.4加入了NIO，引入一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。因为避免了在Java堆和Native堆中来回复制数据，提高了性能。</p>
<p>当各个内存区域总和大于物理内存限制，抛出OutOfMemoryError异常。</p>
<h3 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a>GC相关</h3><p>jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016185255493-478123409.png" alt="image"></p>
<h4 id="GC的对象"><a href="#GC的对象" class="headerlink" title="GC的对象"></a>GC的对象</h4><p>需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：引用计数和可达分析。</p>
<ul>
<li>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</li>
<li>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在Java语言中，GC <span class="keyword">Roots</span>包括：</span><br><span class="line"></span><br><span class="line">虚拟机栈中引用的对象。</span><br><span class="line"></span><br><span class="line">方法区中类静态属性实体引用的对象。</span><br><span class="line"></span><br><span class="line">方法区中常量引用的对象。</span><br><span class="line"></span><br><span class="line">本地方法栈中JNI引用的对象。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="什么时候触发GC"><a href="#什么时候触发GC" class="headerlink" title="什么时候触发GC"></a>什么时候触发GC</h4><ul>
<li>程序调用System.gc时可以触发</li>
<li>系统自身来决定GC触发的时机（根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程）</li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GC又分为 minor GC 和 <span class="keyword">Full</span> GC (也称为 Major GC )</span><br><span class="line"></span><br><span class="line">Minor GC触发条件：当Eden区满时，触发Minor GC。</span><br><span class="line"></span><br><span class="line"><span class="keyword">Full</span> GC触发条件：</span><br><span class="line"></span><br><span class="line">  a.调用System.gc时，系统建议执行<span class="keyword">Full</span> GC，但是不必然执行</span><br><span class="line"></span><br><span class="line">  b.老年代空间不足</span><br><span class="line"></span><br><span class="line">  c.方法区空间不足</span><br><span class="line"></span><br><span class="line">  d.通过Minor GC后进入老年代的平均大小大于老年代的可用内存</span><br><span class="line"></span><br><span class="line">  e.由Eden区、From <span class="keyword">Space</span>区向To <span class="keyword">Space</span>区复制时，对象大小大于To <span class="keyword">Space</span>可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</span><br></pre></td></tr></table></figure>
<h4 id="GC常用算法"><a href="#GC常用算法" class="headerlink" title="GC常用算法"></a>GC常用算法</h4><p>GC常用算法有：标记-清除算法，标记-压缩算法，复制算法，分代收集算法。<br>目前主流的JVM（HotSpot）采用的是分代收集算法。</p>
<h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p>为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 GC 操作。</p>
<ul>
<li><p>优点</p>
<p>  最大的优点是，标记—清除算法中每个活着的对象的引用只需要找到一个即可，找到一个就可以判断它为活的。此外，更重要的是，这个算法并不移动对象的位置。</p>
</li>
<li><p>缺点<br>  它的缺点就是效率比较低（递归与全堆对象遍历）。每个活着的对象都要在标记阶段遍历一遍；所有对象都要在清除阶段扫描一遍，因此算法复杂度较高。没有移动对象，导致可能出现很多碎片空间无法利用的情况。</p>
</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016192344776-1456921556.png" alt="image"></p>
<h5 id="标记-压缩算法（标记-整理）"><a href="#标记-压缩算法（标记-整理）" class="headerlink" title="标记-压缩算法（标记-整理）"></a>标记-压缩算法（标记-整理）</h5><p>标记-压缩法是标记-清除法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。</p>
<ul>
<li>优点<br>  该算法不会像标记-清除算法那样产生大量的碎片空间。</li>
<li>缺点<br>  如果存活的对象过多，整理阶段将会执行较多复制操作，导致算法效率降低。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016192808209-1144011671.png" alt="image"></li>
</ul>
<p>左边是标记阶段，右边是整理之后的状态。可以看到，该算法不会产生大量碎片内存空间。</p>
<h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。</p>
<p>注意：</p>
<p>这个算法与标记-整理算法的区别在于，该算法不是在同一个区域复制，而是将所有存活的对象复制到另一个区域内。</p>
<ul>
<li>优点<br>  实现简单；不产生内存碎片</li>
<li>缺点<br>  每次运行，总有一半内存是空的，导致可使用的内存空间只有原来的一半。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016193120797-694786115.png" alt="image"></li>
</ul>
<h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><p>现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</p>
<p> 具体过程：新生代(Young)分为Eden区，From区与To区</p>
<p> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016194033050-1554933093.png" alt="image"></p>
<p> 当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次YoungGC，也就是年轻代的垃圾回收。一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。 </p>
<p> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016194136097-936358657.png" alt="image"></p>
<p> 这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，会将Eden区与From区还在被使用的对象复制到To区， </p>
<p> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016194207606-298577682.png" alt="image"></p>
<p> 再下一次YoungGC的时候，则是将Eden区与To区中的还在被使用的对象复制到From区。</p>
<p> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016194236007-1428408352.png" alt="image"></p>
<p> 经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。 </p>
<p> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016194302974-1844734331.png" alt="image"></p>
<p> 老年代经过这么几次折腾，也就扛不住了（空间被用完），好，那就来次集体大扫除（Full GC），也就是全量回收。如果Full GC使用太频繁的话，无疑会对系统性能产生很大的影响。所以要合理设置年轻代与老年代的大小，尽量减少Full GC的操作。</p>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p>
<h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p>串行收集器是最古老，最稳定以及效率高的收集器<br>可能会产生较长的停顿，只使用一个线程去回收<br>-XX:+UseSerialGC</p>
<ul>
<li>新生代、老年代使用串行回收</li>
<li>新生代复制算法</li>
<li>老年代标记-压缩</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016195304547-1979156977.png" alt="image"></p>
<h5 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h5><ul>
<li><p>ParNew<br>-XX:+UseParNewGC（new代表新生代，所以适用于新生代）</p>
<ul>
<li>新生代并行</li>
<li>老年代串行<br>Serial收集器新生代的并行版本<br>在新生代回收时使用复制算法<br>多线程，需要多核支持</li>
</ul>
</li>
</ul>
<p>-XX:ParallelGCThreads 限制线程数量<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016195337336-1777000798.png" alt="image"></p>
<ul>
<li>Parallel收集器<br>类似ParNew<br>新生代复制算法<br>老年代标记-压缩<br>更加关注吞吐量<br>-XX:+UseParallelGC  <ul>
<li>使用Parallel收集器+ 老年代串行<br>-XX:+UseParallelOldGC </li>
<li>使用Parallel收集器+ 老年代并行</li>
</ul>
</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016195404250-2142909553.png" alt="image"></p>
<p>其他GC参数</p>
<p>-XX:MaxGCPauseMills</p>
<pre><code>- 最大停顿时间，单位毫秒
- GC尽力保证回收时间不超过设定值
</code></pre><p>-XX:GCTimeRatio </p>
<pre><code>- 0-100的取值范围
- 垃圾收集时间占总时间的比
- 默认99，即最大允许1%时间做GC
</code></pre><p>这两个参数是矛盾的。因为停顿时间和吞吐量不可能同时调优</p>
<h5 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h5><ul>
<li>Concurrent Mark Sweep 并发标记清除（应用程序线程和GC线程交替执行）</li>
<li>使用标记-清除算法</li>
<li>并发阶段会降低吞吐量（停顿时间减少，吞吐量降低）</li>
<li>老年代收集器（新生代使用ParNew）</li>
<li>-XX:+UseConcMarkSweepGC</li>
</ul>
<p>CMS运行过程比较复杂，着重实现了标记的过程，可分为</p>
<ol>
<li>初始标记（会产生全局停顿）<ul>
<li>根可以直接关联到的对象</li>
<li>速度快</li>
</ul>
</li>
<li>并发标记（和用户线程一起） <ul>
<li>主要标记过程，标记全部对象</li>
</ul>
</li>
<li>重新标记 （会产生全局停顿）<ul>
<li>由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正</li>
</ul>
</li>
<li>并发清除（和用户线程一起） <ul>
<li>基于标记结果，直接清理对象</li>
</ul>
</li>
</ol>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016195447698-597277595.png" alt="image"></p>
<p>这里就能很明显的看出，为什么CMS要使用标记清除而不是标记压缩，如果使用标记压缩，需要多对象的内存位置进行改变，这样程序就很难继续执行。但是标记清除会产生大量内存碎片，不利于内存分配。 </p>
<p>CMS收集器特点：</p>
<ul>
<li>尽可能降低停顿</li>
<li>会影响系统整体吞吐量和性能<ul>
<li>比如，在用户线程运行过程中，分一半CPU去做GC，系统性能在GC阶段，反应速度就下降一半</li>
</ul>
</li>
<li>清理不彻底 <ul>
<li>因为在清理阶段，用户线程还在运行，会产生新的垃圾，无法清理</li>
</ul>
</li>
<li>因为和用户线程一起运行，不能在空间快满时再清理（因为也许在并发GC的期间，用户线程又申请了大量内存，导致内存不够） <ul>
<li>-XX:CMSInitiatingOccupancyFraction设置触发GC的阈值</li>
<li>如果不幸内存预留空间不够，就会引起concurrent mode failure<br>一旦 concurrent mode failure产生，将使用串行收集器作为后备。</li>
</ul>
</li>
</ul>
<p>CMS也提供了整理碎片的参数：</p>
<pre><code>- -XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次整理
</code></pre><p>整理过程是独占的，会引起停顿时间变长</p>
<p>-XX:+CMSFullGCsBeforeCompaction</p>
<pre><code>- 设置进行几次Full GC后，进行一次碎片整理
</code></pre><p>-XX:ParallelCMSThreads</p>
<pre><code>- 设定CMS的线程数量（一般情况约等于可用CPU数量）
</code></pre><p>CMS的提出是想改善GC的停顿时间，在GC过程中的确做到了减少GC时间，但是同样导致产生大量内存碎片，又需要消耗大量时间去整理碎片，从本质上并没有改善时间。 </p>
<h5 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h5><p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。</p>
<p>与CMS收集器相比G1收集器有以下特点：</p>
<p>(1) 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p>
<p>(2)可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
<p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p>
<p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。</p>
<p>和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
<p>步骤：</p>
<p>(1)标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p>
<p>(2)Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p>
<p>(3)Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016195748885-635394429.png" alt="image"></p>
<p>(4)Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
<p>(5)Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016195818822-811200159.png" alt="image"></p>
<p>(6)复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p>
<h4 id="finalize-方法详解"><a href="#finalize-方法详解" class="headerlink" title="finalize()方法详解"></a>finalize()方法详解</h4><h5 id="finalize的作用"><a href="#finalize的作用" class="headerlink" title="finalize的作用"></a>finalize的作用</h5><p>(1)finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</p>
<p>(2)finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性</p>
<p>(3)不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：</p>
<p>① 清理本地对象(通过JNI创建的对象)；</p>
<p>② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法</p>
<h5 id="finalize的问题"><a href="#finalize的问题" class="headerlink" title="finalize的问题"></a>finalize的问题</h5><p>(1)一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法</p>
<p>(2)System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们</p>
<p>(3)Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行</p>
<p>(4)finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行</p>
<p>(5)对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的</p>
<p>(6)finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为)</p>
<h5 id="finalize的执行过程-生命周期"><a href="#finalize的执行过程-生命周期" class="headerlink" title="finalize的执行过程(生命周期)"></a>finalize的执行过程(生命周期)</h5><p>(1) 首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p>
<p>(2) 具体的finalize流程：<br> 对象可由两种状态，涉及到两类状态空间，一是终结状态空间 F = {unfinalized, finalizable, finalized}；二是可达状态空间 R = {reachable, finalizer-reachable, unreachable}。各状态含义如下：</p>
<ul>
<li>unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的</li>
<li>finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行</li>
<li>finalized: 表示GC已经对该对象执行过finalize方法<br>reachable: 表示GC Roots引用可达</li>
<li>finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达</li>
<li>unreachable：对象不可通过上面两种途径可达</li>
</ul>
<p>状态变迁图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/1489669-20181016201012220-784045144.png" alt="image"></p>
<p>变迁说明：</p>
<p>(1)新建对象首先处于[reachable, unfinalized]状态(A)</p>
<p>(2)随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态</p>
<p>(3)若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。</p>
<p>(4)在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N)</p>
<p>(5)处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因</p>
<p>(6)程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为</p>
<p>(7)若JVM检测到finalized状态的对象变成unreachable，回收其内存(I)</p>
<p>(8)若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O）</p>
<p>(9)注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>根据GC的工作原理，我们可以通过一些技巧和方式，让GC运行更加有效率，更加符合应用程序的要求。一些关于程序设计的几点建议：</p>
<p>1.最基本的建议就是尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域（scope）后，自动设置为 null.我们在使用这种方式时候，必须特别注意一些复杂的对象图，例如数组，队列，树，图等，这些对象之间有相互引用关系较为复杂。对于这类对象，GC 回收它们一般效率较低。如果程序允许，尽早将不用的引用对象赋为null.这样可以加速GC的工作。</p>
<p>2.尽量少用finalize函数。finalize函数是Java提供给程序员一个释放对象或资源的机会。但是，它会加大GC的工作量，因此尽量少采用finalize方式回收资源。</p>
<p>3.如果需要使用经常使用的图片，可以使用soft应用类型。它可以尽可能将图片保存在内存中，供程序调用，而不引起OutOfMemory.</p>
<p>4.注意集合数据类型，包括数组，树，图，链表等数据结构，这些数据结构对GC来说，回收更为复杂。另外，注意一些全局的变量，以及一些静态变量。这些变量往往容易引起悬挂对象（dangling reference），造成内存浪费。</p>
<p>5.当程序有一定的等待时间，程序员可以手动执行System.gc（），通知GC运行，但是Java语言规范并不保证GC一定会执行。使用增量式GC可以缩短Java程序的暂停时间。</p>
<h2 id="countDownLatch用过没有，在项目中如何使用的，对AQS的了解。"><a href="#countDownLatch用过没有，在项目中如何使用的，对AQS的了解。" class="headerlink" title="countDownLatch用过没有，在项目中如何使用的，对AQS的了解。"></a>countDownLatch用过没有，在项目中如何使用的，对AQS的了解。</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>countDownLatch是在java1.5被引入，跟它一起被引入的工具类还有CyclicBarrier、Semaphore、concurrentHashMap和BlockingQueue。</li>
<li>存在于java.util.cucurrent包下。</li>
<li>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</li>
<li>是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</li>
</ul>
<p>类中有三个方法是最重要的<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;   </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  </span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CountDownLatchTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        final CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"主线程开始执行…… ……"</span>);</span><br><span class="line">        <span class="comment">//第一个子线程执行</span></span><br><span class="line">        ExecutorService es1 = Executors.newSingleThreadExecutor();</span><br><span class="line">        es1.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"子线程："</span>+Thread.currentThread().getName()+<span class="string">"执行"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es1.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二个子线程执行</span></span><br><span class="line">        ExecutorService es2 = Executors.newSingleThreadExecutor();</span><br><span class="line">        es2.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"子线程："</span>+Thread.currentThread().getName()+<span class="string">"执行"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es2.shutdown();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"等待两个线程执行完毕…… ……"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.<span class="keyword">await</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"两个子线程都执行完毕，继续执行主线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">主线程开始执行…… ……</span><br><span class="line">等待两个线程执行完毕…… ……</span><br><span class="line">子线程：pool<span class="number">-1</span>-thread<span class="number">-1</span>执行</span><br><span class="line">子线程：pool<span class="number">-2</span>-thread<span class="number">-1</span>执行</span><br><span class="line">两个子线程都执行完毕，继续执行主线程</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟并发示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Parallellimit</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">        CountDownLatch cdl = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            CountRunnable runnable = <span class="keyword">new</span> CountRunnable(cdl);</span><br><span class="line">            pool.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title">CountRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountRunnable</span>(<span class="params">CountDownLatch countDownLatch</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            synchronized (countDownLatch) &#123;</span><br><span class="line">                <span class="comment">/*** 每次减少一个容量*/</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"thread counts = "</span> + (countDownLatch.getCount()));</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.<span class="keyword">await</span>();</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"concurrency counts = "</span> + (<span class="number">100</span> - countDownLatch.getCount()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CountDownLatch和CyclicBarrier区别："><a href="#CountDownLatch和CyclicBarrier区别：" class="headerlink" title="CountDownLatch和CyclicBarrier区别："></a>CountDownLatch和CyclicBarrier区别：</h3><ul>
<li>countDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次</li>
<li>CyclicBarrier的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供reset功能，可以多次使用</li>
</ul>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><ul>
<li>AQS的全称：AbstractQueuedSynchronizer，抽象队列同步器</li>
<li>java并发包下很多API都是基于AQS来实现的加锁和释放锁等功能的，AQS是java并发包的基础类。ReentrantLock、ReentrantReadWriteLock底层都是基于AQS来实现的。</li>
<li>看一下ReentrantLock和AQS之间的关系<br>ReentrantLock内部包含了一个AQS对象，也就是AbstractQueuedSynchronizer类型的对象。这个AQS对象就是ReentrantLock可以实现加锁和释放锁的关键性的核心组件。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190422101506890.png" alt="image"></li>
</ul>
<h4 id="ReentrantLock加锁和释放锁的底层原理"><a href="#ReentrantLock加锁和释放锁的底层原理" class="headerlink" title="ReentrantLock加锁和释放锁的底层原理"></a>ReentrantLock加锁和释放锁的底层原理</h4><ul>
<li>如果有一个线程过来尝试用ReentrantLock的lock()方法进行加锁，这个AQS对象内部有一个核心的变量叫做state，是int类型的，代表了加锁的状态。初始状态下，这个state的值是0。</li>
<li>另外，这个AQS内部还有一个关键变量，用来记录当前加锁的是哪个线程，初始化状态下，这个变量是null。</li>
<li><p>接着线程1跑过来调用ReentrantLock的lock()方法尝试进行加锁，这个加锁的过程，直接就是用CAS操作将state值从0变为1。如果之前没人加过锁，那么state的值肯定是0，此时线程1就可以加锁成功。一旦线程1加锁成功了之后，就可以设置当前加锁线程是自己。所以大家看下面的图，就是线程1跑过来加锁的一个过程。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2019042210300768.png" alt="image"><br>看到这儿，大家应该对所谓的AQS有感觉了。说白了，就是并发包里的一个核心组件，里面有state变量、加锁线程变量等核心的东西，维护了加锁状态。ReentrantLock这种东西只是一个外层的API，内核中的锁机制实现都是依赖AQS组件的。</p>
</li>
<li><p>这个ReentrantLock之所以用Reentrant打头，意思就是他是一个可重入锁。可重入锁的意思，就是你可以对一个ReentrantLock对象多次执行lock()加锁和unlock()释放锁，也就是可以对一个锁加多次，叫做可重入加锁。</p>
</li>
<li>大家看明白了那个state变量之后，就知道了如何进行可重入加锁！<br>其实每次线程1可重入加锁一次，会判断一下当前加锁线程就是自己，那么他自己就可以可重入多次加锁，每次加锁就是把state的值给累加1，别的没啥变化。</li>
<li>接着，如果线程1加锁了之后，线程2跑过来加锁会怎么样呢？<br>我们来看看锁的互斥是如何实现的？线程2跑过来一下看到，哎呀！state的值不是0啊？所以CAS操作将state从0变为1的过程会失败，因为state的值当前为1，说明已经有人加锁了！</li>
<li>接着线程2会看一下，是不是自己之前加的锁啊？当然不是了，“加锁线程”这个变量明确记录了是线程1占用了这个锁，所以线程2此时就是加锁失败。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190422104629928.png" alt="image"></li>
<li>接着，线程2会将自己放入AQS中的一个等待队列，因为自己尝试加锁失败了，此时就要将自己放入队列中来等待，等待线程1释放锁之后，自己就可以重新尝试加锁了</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190422104805138.png" alt="image"></p>
<ul>
<li><p>接着，线程1在执行完自己的业务逻辑代码之后，就会释放锁！他释放锁的过程非常的简单，就是将AQS内的state变量的值递减1，如果state值为0，则彻底释放锁，会将“加锁线程”变量也设置为null！<br>整个过程，参见下图：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190422104853687.png" alt="image"></p>
</li>
<li><p>接下来，线程1会从等待队列的队头唤醒线程2重新尝试加锁。<br>线程2现在就重新尝试加锁，这时还是用CAS操作将state从0变为1，- - 此时就会成功，成功之后代表加锁成功，就会将state设置为1；此外，还要把“加锁线程”设置为线程2自己，同时线程2自己就从等待队列中出队了。</p>
</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190422105125131.png" alt="image"></p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>其实一句话总结AQS就是一个并发包的基础组件，用来实现各种锁，各种同步组件的。它包含了state变量、加锁线程、等待队列等并发中的核心组件。</p>
<h2 id="写生产者消费者问题，考虑高并发的情况，可以使用Java-类库，白纸写代码。"><a href="#写生产者消费者问题，考虑高并发的情况，可以使用Java-类库，白纸写代码。" class="headerlink" title="写生产者消费者问题，考虑高并发的情况，可以使用Java 类库，白纸写代码。"></a>写生产者消费者问题，考虑高并发的情况，可以使用Java 类库，白纸写代码。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span></span>&#123; <span class="comment">// 定义信息类  </span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"name"</span>;<span class="comment">//定义name属性，为了与下面set的name属性区别开  </span></span><br><span class="line">    <span class="keyword">private</span> String content = <span class="string">"content"</span> ;<span class="comment">// 定义content属性，为了与下面set的content属性区别开  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span> ;   <span class="comment">// 设置标志位,初始时先生产  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name,String content)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">while</span>(!flag)&#123;  </span><br><span class="line">            <span class="keyword">try</span>&#123;  </span><br><span class="line">                <span class="keyword">super</span>.wait() ;  </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">                e.printStackTrace() ;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">this</span>.setName(name) ;    <span class="comment">// 设置名称  </span></span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            Thread.sleep(<span class="number">300</span>) ;  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">            e.printStackTrace() ;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">this</span>.setContent(content) ;  <span class="comment">// 设置内容  </span></span><br><span class="line">        flag  = <span class="keyword">false</span> ; <span class="comment">// 改变标志位，表示可以取走  </span></span><br><span class="line">        <span class="keyword">super</span>.notify();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;  </span><br><span class="line">            <span class="keyword">try</span>&#123;  </span><br><span class="line">                <span class="keyword">super</span>.wait() ;  </span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">                e.printStackTrace() ;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            Thread.sleep(<span class="number">300</span>) ;  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">            e.printStackTrace() ;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName() +   </span><br><span class="line">            <span class="string">" --&gt; "</span> + <span class="keyword">this</span>.getContent()) ;  </span><br><span class="line">        flag  = <span class="keyword">true</span> ;  <span class="comment">// 改变标志位，表示可以生产  </span></span><br><span class="line">        <span class="keyword">super</span>.notify();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.content = content ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123; <span class="comment">// 通过Runnable实现多线程  </span></span><br><span class="line">    <span class="keyword">private</span> Info info = <span class="keyword">null</span> ;      <span class="comment">// 保存Info引用  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Info info)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.info = info ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span> ;   <span class="comment">// 定义标记位  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;  </span><br><span class="line">                <span class="keyword">this</span>.info.set(<span class="string">"姓名--1"</span>,<span class="string">"内容--1"</span>) ;    <span class="comment">// 设置名称  </span></span><br><span class="line">                flag = <span class="keyword">false</span> ;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="keyword">this</span>.info.set(<span class="string">"姓名--2"</span>,<span class="string">"内容--2"</span>) ;    <span class="comment">// 设置名称  </span></span><br><span class="line">                flag = <span class="keyword">true</span> ;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Info info = <span class="keyword">null</span> ;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Info info)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.info = info ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line">            <span class="keyword">this</span>.info.get() ;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCaseDemo03</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        Info info = <span class="keyword">new</span> Info(); <span class="comment">// 实例化Info对象  </span></span><br><span class="line">        Producer pro = <span class="keyword">new</span> Producer(info) ; <span class="comment">// 生产者  </span></span><br><span class="line">        Consumer con = <span class="keyword">new</span> Consumer(info) ; <span class="comment">// 消费者  </span></span><br><span class="line">        <span class="keyword">new</span> Thread(pro).start() ;  </span><br><span class="line">        <span class="comment">//启动了生产者线程后，再启动消费者线程  </span></span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            Thread.sleep(<span class="number">500</span>) ;  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </span><br><span class="line">            e.printStackTrace() ;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">new</span> Thread(con).start() ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有没有排查过线上OOM的问题，如何排查的？"><a href="#有没有排查过线上OOM的问题，如何排查的？" class="headerlink" title="有没有排查过线上OOM的问题，如何排查的？"></a>有没有排查过线上OOM的问题，如何排查的？</h2><p>查看当前路径，oom.out文件已经生成了，该文件就是应用在发生OOM异常时自动导出的堆文件。那我们此时需要对该文件进行分析，因为其中记录了是什么对象导出了应用程OOM的发生。</p>
<p>分析OOM的工具推荐使用MAT，<a href="https://projects.eclipse.org/projects/tools.mat" target="_blank" rel="noopener">下载地址</a>，在配置好Java环境的电脑中，直接打开即可，不需要安装，然后通过MAT打开已经生成的OOM文件oom.out，出现如下提示，选择“Leak Suspects Report”执行内存泄漏检查分析：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/2018091318062115.png" alt="image"></p>
<p>点击Finish按钮后，MAT会将可疑的内存泄漏的对象都展现出来：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180913181010465.png" alt="image"></p>
<p>可以看到线程java.lang.Thread @ 0xff617e80 的main方法中，有一个本地变量占用了96.43%的堆内存，实际内存占用的是char[]数组，因而被检测出来为OOM可疑的元凶。点击红色框中的“See stacktrace”，可以直接看到该对象所在线程的堆栈信息：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180913182035623.png" alt="image"></p>
<p>直接定位到了发生OOM的代码所在位置，至此该示例分析完成，MAT工具本身还有其它许多的功能，这里就不一一细说了。</p>
<p>下一篇会写服务器由于时间戳不一致，导致有些服务器可以访问，有些服务器却不能够访问的问题，如果感兴趣，请继续观注。</p>
<h2 id="有没有使用过JVM自带的工具，如何使用的？"><a href="#有没有使用过JVM自带的工具，如何使用的？" class="headerlink" title="有没有使用过JVM自带的工具，如何使用的？"></a>有没有使用过JVM自带的工具，如何使用的？</h2><p><code>%JAVA_HOME/bin%</code>下就是安装java时为我们自带的可运行程序的文件夹。</p>
<h3 id="jps命令"><a href="#jps命令" class="headerlink" title="jps命令"></a>jps命令</h3><p>jps(java process status)：用于查看java进程。</p>
<table>
<thead>
<tr>
<th>option</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>查看java进程</td>
</tr>
<tr>
<td>-l</td>
<td>显示全类名</td>
</tr>
<tr>
<td>-m</td>
<td>带参显示</td>
</tr>
<tr>
<td>-v</td>
<td>JVM参数</td>
</tr>
</tbody>
</table>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><ul>
<li><code>jstat -gcutil pid</code></li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190401203922492.png" alt="image"></p>
<p>其中的<code>pid</code>是你关注的<code>java</code>进程号，可根据<code>jps</code>查询。<br><code>-gcutil</code>是关心的指标，更多详尽信息请参看官方文档。</p>
<ul>
<li><p><code>options</code><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190401203945843.png" alt="image"></p>
</li>
<li><p><code>description</code>(后面也有详尽的字段说明)<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190401204007393.png" alt="image"></p>
</li>
<li><p><code>jstat -option pid peroid times</code>(周期监控)<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190401204040778.png" alt="image"></p>
</li>
</ul>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p><code>jinfo</code>进行指定参数的查询。</p>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p><code>jmap</code>用于内存管理。</p>
<ul>
<li><code>jmap -histo pid</code>（类数量 / 实例数量）</li>
<li><code>jmap -dump:format=b,file=file</code>导出运行信息以便于后续线下分析。</li>
</ul>
<h3 id="jhat（JVM-Heap-Analysis-Tool）"><a href="#jhat（JVM-Heap-Analysis-Tool）" class="headerlink" title="jhat（JVM Heap Analysis Tool）"></a>jhat（JVM Heap Analysis Tool）</h3><ul>
<li><code>jhat a.bin</code>分析导出数据</li>
</ul>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><table>
<thead>
<tr>
<th>options</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>打印方法栈</td>
</tr>
<tr>
<td>-F</td>
<td>强制打印</td>
</tr>
<tr>
<td>-m</td>
<td>本地方法栈</td>
</tr>
<tr>
<td>-l</td>
<td>打印锁信息</td>
</tr>
</tbody>
</table>
<ul>
<li><code>jstack pid</code></li>
<li><code>jstack -l pid</code>(锁信息，能看见线程状态)</li>
</ul>
<h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190401204425551.png" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20190401204446766.png" alt="image"></p>
<h2 id="假设有下图所示的一个Full-GC-的图，纵向是内存使用情况，横向是时间，你如何排查这个Full-GC-的问题，怎么去解决你说出来的这些问题？"><a href="#假设有下图所示的一个Full-GC-的图，纵向是内存使用情况，横向是时间，你如何排查这个Full-GC-的问题，怎么去解决你说出来的这些问题？" class="headerlink" title="假设有下图所示的一个Full GC 的图，纵向是内存使用情况，横向是时间，你如何排查这个Full GC 的问题，怎么去解决你说出来的这些问题？"></a>假设有下图所示的一个Full GC 的图，纵向是内存使用情况，横向是时间，你如何排查这个Full GC 的问题，怎么去解决你说出来的这些问题？</h2><p> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG232.jpeg" alt="image"></p>
<h3 id="Full-GC的原因"><a href="#Full-GC的原因" class="headerlink" title="Full GC的原因"></a>Full GC的原因</h3><p>我们知道Full GC的触发条件大致情况有以下几种情况：</p>
<ol>
<li>程序执行了System.gc() //建议jvm执行fullgc，并不一定会执行</li>
<li>执行了jmap -histo:live pid命令 //这个会立即触发fullgc</li>
<li><p>在执行minor gc的时候进行的一系列检查</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行Minor GC的时候，JVM会检查老年代中最大连续可用空间是否大于了当前新生代所有对象的总大小。</span><br><span class="line">如果大于，则直接执行Minor GC（这个时候执行是没有风险的）。</span><br><span class="line">如果小于了，JVM会检查是否开启了空间分配担保机制，如果没有开启则直接改为执行<span class="literal">Full</span> GC。</span><br><span class="line">如果开启了，则JVM会检查老年代中最大连续可用空间是否大于了历次晋升到老年代中的平均大小，如果小于则执行改为执行<span class="literal">Full</span> GC。</span><br><span class="line">如果大于则会执行Minor GC，如果Minor GC执行失败则会执行<span class="literal">Full</span> GC</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用了大对象 //大对象会直接进入老年代</p>
</li>
<li>在程序中长期持有了对象的引用 //对象年龄达到指定阈值也会进入老年代</li>
</ol>
<p>对于我们的情况，可以初步排除1，2两种情况，最有可能是4和5这两种情况。为了进一步排查原因，我们在线上开启了 -XX:+HeapDumpBeforeFullGC。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">    JVM在执行dump操作的时候是会发生<span class="built_in">stop</span> <span class="keyword">the</span> <span class="built_in">word</span>事件的，也就是说此时所有的用户线程都会暂停运行。</span><br><span class="line">    为了在此期间也能对外正常提供服务，建议采用分布式部署，并采用合适的负载均衡算法</span><br></pre></td></tr></table></figure>
<h3 id="JVM参数的设置："><a href="#JVM参数的设置：" class="headerlink" title="JVM参数的设置："></a>JVM参数的设置：</h3><p>线上这个dubbo服务是分布式部署，在其中一台机子上开启了 -XX:HeapDumpBeforeFullGC，总体JVM参数如下：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">Xmx2g </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>+HeapDumpBeforeFullGC </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>HeapDumpPath=. </span></span><br><span class="line"><span class="ruby">-<span class="symbol">Xloggc:</span>gc.log </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>+PrintGC </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>+PrintGCDetails </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>+PrintGCDateStamps </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>+UseGCLogFileRotation </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>NumberOfGCLogFiles=<span class="number">10</span> </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>GCLogFileSize=<span class="number">100</span>m </span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>HeapDumpOnOutOfMemoryError</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Dump文件分析"><a href="#Dump文件分析" class="headerlink" title="Dump文件分析"></a>Dump文件分析</h3><p>dump下来的文件大约1.8g，用jvisualvm查看，发现用char[]类型的数据占用了41%内存，同时另外一个com.alibaba.druid.stat.JdbcSqlStat类型的数据占用了35%的内存，也就是说整个堆中几乎全是这两类数据。如下图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20170411171801782.png" alt="image"></p>
<p>查看char[]类型数据，发现几乎全是sql语句。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20170411171833819.png" alt="image"></p>
<p>接下来查看char[]的引用情况：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20170411171909424.png" alt="image"></p>
<p>找到了JdbcSqlStat类，在代码中查看这个类的代码，关键代码如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数只有这一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcSqlStat</span>(<span class="params">String sql</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sql = sql;</span><br><span class="line">    <span class="keyword">this</span>.id = DruidDriver.createSqlStatId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看这个函数的调用情况，找到com.alibaba.druid.stat.JdbcDataSourceStat#createSqlStat方法：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> JdbcSqlStat <span class="title">createSqlStat</span>(<span class="params">String sql</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>.writeLock().<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JdbcSqlStat sqlStat = sqlStatMap.<span class="keyword">get</span>(sql);</span><br><span class="line">        <span class="keyword">if</span> (sqlStat == <span class="literal">null</span>) &#123;</span><br><span class="line">            sqlStat = <span class="keyword">new</span> JdbcSqlStat(sql);</span><br><span class="line">            sqlStat.setDbType(<span class="keyword">this</span>.dbType);</span><br><span class="line">            sqlStat.setName(<span class="keyword">this</span>.name);</span><br><span class="line">            sqlStatMap.put(sql, sqlStat);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sqlStat;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里用了一个map来存放所有的sql语句。</span></span><br></pre></td></tr></table></figure></p>
<p>其实到这里也就知道什么原因造成了这个问题，因为我们使用的数据源是阿里巴巴的druid，这个druid提供了一个sql语句监控功能，同时我们也开启了这个功能。只需要在配置文件中把这个功能关掉应该就能消除这个问题，事实也的确如此，关掉这个功能后到目前为止线上没再触发FullGC</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p> 如果用mat工具查看，建议把 “Keep unreachable objects” 勾上，否则mat会把堆中不可达的对象去除掉，这样我们的分析也许会变得没有意义。如下图：Window–&gt;References 。另外jvisualvm对ool的支持不是很好，如果需要oql建议使用mat。<br> <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180713093200563.png" alt="image"></p>
<h2 id="说说对Java中集合类的理解，项目中用过哪些，哪个地方用的，如何使用的？"><a href="#说说对Java中集合类的理解，项目中用过哪些，哪个地方用的，如何使用的？" class="headerlink" title="说说对Java中集合类的理解，项目中用过哪些，哪个地方用的，如何使用的？"></a>说说对Java中集合类的理解，项目中用过哪些，哪个地方用的，如何使用的？</h2><p>从数据结构开始了解</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626162657335-766064343.png" alt="image"></p>
<ul>
<li>顺序存储结构(也叫顺序表)：一个线性表是n个具有相同特性的数据元素的有限序列。数据元素是一个抽象的符号，其具体含义在不同的情况下一般不同。</li>
<li>链表：链表里面节点的地址不是连续的，是通过指针连起来的。</li>
</ul>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>解释一:<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626163141411-168462787.png" alt="image"><br>哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。</p>
<p>解释二:</p>
<p>数组的特点是：寻址容易，插入和删除困难；</p>
<p>而链表的特点是：寻址困难，插入和删除容易。</p>
<p>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法——拉链法，我们可以理解为“链表的数组”，如图：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626163257503-1905188703.png" alt="image"></p>
<p>左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。</p>
<p>Hash 表的查询速度非常的快，几乎是O(1)的时间复杂度。</p>
<p>hash就是找到一种数据内容和数据存放地址之间的映射关系。</p>
<p>散列法：元素特征转变为数组下标的方法。</p>
<p>我想大家都在想一个很严重的问题：“如果两个字符串在哈希表中对应的位置相同怎么办？”,毕竟一个数组容量是有限的，这种可能性很大。解决该问题的方法很多，我首先想到的就是用“链表”。我遇到的很多算法都可以转化成链表来解决，只要在哈希表的每个入口挂一个链表，保存所有对应的字符串就OK了。</p>
<p>散列表的查找步骤 </p>
<p>当存储记录时，通过散列函数计算出记录的散列地址</p>
<p>当查找记录时，我们通过同样的是散列函数计算记录的散列地址，并按此散列地址访问该记录</p>
<p>优缺点</p>
<ul>
<li><p>优点：不论哈希表中有多少数据，查找、插入、删除（有时包括删除）只需要接近常量的时间即0(1）的时间级。实际上，这只需要几条机器指令。</p>
<p>  哈希表运算得非常快，在计算机程序中，如果需要在一秒种内查找上千条记录通常使用哈希表（例如拼写检查器)哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。</p>
<p>  如果不需要有序遍历数据，并且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。</p>
</li>
<li><p>缺点：它是基于数组的，数组创建后难于扩展，某些哈希表被基本填满时，性能下降得非常严重，所以程序员必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。</p>
</li>
</ul>
<h5 id="哈希表的原理："><a href="#哈希表的原理：" class="headerlink" title="哈希表的原理："></a>哈希表的原理：</h5><p>　　 1，对对象元素中的关键字(对象中的特有数据)，进行哈希算法的运算，并得出一个具体的算法值，这个值 称为哈希值。</p>
<p>　　2，哈希值就是这个元素的位置。</p>
<p>　　3，如果哈希值出现冲突，再次判断这个关键字对应的对象是否相同。如果对象相同，就不存储，因为元素重复。如果对象不同，就存储，在原来对象的哈希值基础 +1顺延。</p>
<p>　　4，存储哈希值的结构，我们称为哈希表。</p>
<p>　　5，既然哈希表是根据哈希值存储的，为了提高效率，最好保证对象的关键字是唯一的。</p>
<p>　　这样可以尽量少的判断关键字对应的对象是否相同，提高了哈希表的操作效率。</p>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展:"></a>扩展:</h5><p>相同的字符串如果存进去，哈希值相同并且equals方法为true，不会存入相同的</p>
<p>只要哈希值相同或者equals方法为true都成立才不会存入，只要其中一条不满足，都会储存</p>
<h5 id="哈希表存储过程："><a href="#哈希表存储过程：" class="headerlink" title="哈希表存储过程："></a>哈希表存储过程：</h5><p>1.调用对象的哈希值(通过一个函数f()得到哈希值):存储位置 = f(关键字)</p>
<p>2.集合在容器内搜索有没有重复的哈希值，如果没有，存入新元素，记录哈希值</p>
<p>3.再次存储，重复上边的过程</p>
<p>4.如果有重复的哈希值，调用后来者的equals方法，参数为前来者，结果得到true，集合判断为重复元素，不存入</p>
<h5 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h5><p>然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？</p>
<h5 id="哈希冲突的解决方案有多种"><a href="#哈希冲突的解决方案有多种" class="headerlink" title="哈希冲突的解决方案有多种:"></a>哈希冲突的解决方案有多种:</h5><p>开放定址法（发生冲突，继续寻找下一块未被占用的存储地址）</p>
<p>再散列函数法</p>
<p>链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式</p>
<p>关于hashcode和equals的一些问题，在面试中会问道：</p>
<p>1.两个对象哈希值相同，那么equals方法一定返回true吗？</p>
<p>不一定:取决于如何重写equals，如果重写固定了它返回false，结果就一定是false</p>
<p>2.equals方法返回true，那么哈希值一定相同吗？</p>
<p>一定:如果类中定义一个静态变量（static int a = 1），然后重写hashcode返回a+1，那么每一个对象的哈希值都不一样,不过java中规定：对象相等，必须具有相同的哈希码值，所以这里是一定的</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n) </p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>1.数组</p>
<ul>
<li><p>优点：(1)随机访问效率高(根据下标查询)，(2)搜索效率较高(可使用折半方法)。</p>
</li>
<li><p>缺点：(1)内存连续且固定，存储效率低。(2)插入和删除效率低(可能会进行数组拷贝或扩容)。</p>
</li>
</ul>
<p>2.链表</p>
<ul>
<li><p>优点：(1)不要求连续内存，内存利用率高，(2)插入和删除效率高(只需要改变指针指向)。</p>
</li>
<li><p>缺点：(1)不支持随机访问，(2)搜索效率低(需要遍历)。</p>
</li>
</ul>
<p>3.Hash表</p>
<ul>
<li><p>优点：(1)搜索效率高，(2)插入和删除效率较高，</p>
</li>
<li><p>缺点：(1)内存利用率低(基于数组)，(2)存在散列冲突。</p>
</li>
</ul>
<h3 id="集合类种重要概念词解释"><a href="#集合类种重要概念词解释" class="headerlink" title="集合类种重要概念词解释"></a>集合类种重要概念词解释</h3><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>java中很重要的概念, 集合里面应用很多.</p>
<p>集合的元素，可以是任意类型对象的引用，如果把某个对象放入集合，则会忽略它的类型，就会把它当做Object类型处理.</p>
<p>泛型则是规定了某个集合只可以存放特定类型的对象的引用，会在编译期间进行类型检查,可以直接指定类型来获取集合元素</p>
<p>在泛型集合中有能够存入泛型类型的对象实例还可以存入泛型的子类型的对象实例</p>
<p>注意：</p>
<p>1 泛型集合中的限定类型，不能使用基本数据类型</p>
<p>2 可以通过使用包装类限定允许存放基本数据类型</p>
<p>泛型的好处</p>
<p>1 提高了安全性（将运行期的错误转换到编译期）</p>
<p>2 省去强转的麻烦</p>
<h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p>1 就是一个十进制的整数，有操作系统随机给出</p>
<p>2 可以使用Object类中的方法hashCode获取哈希值</p>
<p>3 Object中源码: int hashCode()返回该对象的哈希码值；</p>
<p>　　源码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//native:指调用了本地操作系统的方法实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="平衡二叉树-称AVL树"><a href="#平衡二叉树-称AVL树" class="headerlink" title="平衡二叉树(称AVL树)"></a>平衡二叉树(称AVL树)</h4><p>其特点是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个子节点，其左右子树的高度都相近。</p>
<p>注意:</p>
<p>关键点是左子树和右子树的深度的绝对值不超过1</p>
<p>那什么是左子树深度和右子树深度呢?</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626163747154-56316670.png" alt="image"><br>如上图中:</p>
<p>如果插入6元素, 则8的左子树深度就为2, 右子树深度就为0,绝对值就为2, 就不是一个平很二叉树</p>
<h5 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h5><p>1若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
<p>2若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>3左、右子树也分别为二叉排序树</p>
<p>解释一:</p>
<p>现在有a[10] = {3, 2, 1, 4, 5, 6, 7, 10, 9, 8}需要构建二叉排序树。在没有学习平衡二叉树之前，根据二叉排序树的特性，通常会将它构建成如下左图。虽然完全符合二叉排序树的定义，但是对这样高度达到8的二叉树来说，查找是非常不利的。因此，更加期望构建出如下右图的样子，高度为4的二叉排序树，这样才可以提供高效的查找效率。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626163840863-763737563.png" alt="image"><br>平衡二叉树是一种二叉排序树，是一种高度平衡的二叉树，其中每个结点的左子树和右子树的高度至多等于1.意味着：要么是一棵空树，要么左右都是平衡二叉树，且左子树和右子树深度之绝对值不超过1. 将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p>
<p>平衡二叉树的前提是它是一棵二叉排序树。</p>
<h5 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h5><p>假设一颗 AVL 树的某个节点为 r，有四种操作会使 r 的左右子树高度差大于 1，从而破坏了原有 AVL 树的平衡性。使用旋转达到平衡性</p>
<p>1.对 r 的左儿子的左子树进行一次插入（左旋转 LL）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626163919941-1822754534.png" alt="image"><br>2.对 r 的左儿子的右子树进行一次插入（LR）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626164125162-953176289.png" alt="image"><br>3.对 r 的右儿子的左子树进行一次插入（RL）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626164216908-1934757880.png" alt="image"><br>4.对 r 的右儿子的右子树进行一次插入（RR）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626164301670-331612976.png" alt="image"></p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树（Red Black Tree） 是一种自平衡二叉查找树</p>
<p>(1) 检索效率O(log n)</p>
<p>(2) 红黑树的五点规定：</p>
<p>1.每个结点要么是红的要么是黑的</p>
<p>2.根结点是黑的</p>
<p>3.每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的</p>
<p>4.如果一个结点是红的，那么它的两个儿子都是黑的（反之不一定）</p>
<p>5.对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点</p>
<p>它的每个结点都额外有一个颜色的属性，颜色只有两种：红色和黑色。</p>
<p>示例:(这块难度比较大, 建议自行百度,查阅相关文档)</p>
<p>红黑树插入操作</p>
<p>如果是第一次插入,由于原树为空,所以只会违反红黑树的规则2,所以只要把根节点涂黑即可；</p>
<p>如果插入节点的父节点是黑色的，那不会违背红-黑树的规则，什么也不需要做；</p>
<p>但是遇到如下三种情况时，我们就要开始变色和旋转了：</p>
<pre><code>1. 插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色的；

2. 插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的右子节点；

3. 插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点。

下面我们先挨个分析这三种情况都需要如何操作:

对于情况1：插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色的。此时，肯定存在祖父节点，但是不知道父节点是其左子节点还是右子节点，但是由于对称性，我们只要讨论出一边的情况，另一种情况自然也与之对应。
</code></pre><p>这里考虑父节点是祖父节点的左子节点的情况(即插入一个4节点,插入的节点一般为红色,不然可能违反规则5.),如下左图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626164550259-105010205.jpg" alt="image"></p>
<p>对于这种情况，我们要做的操作有：将当前节点(4)的父节点(5)和叔叔节点(8)涂黑，将祖父节点(7)涂红，变成上右图所示的情况。再将当前节点指向其祖父节点，再次从新的当前节点开始算法。这样上右图就变成了情况2了。</p>
<p>对于情况2：插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的右子节点。我们要做的操作有：将当前节点(7)的父节点(2)作为新的节点，以新的当前节点为支点做左旋操作。完成后如左下图所示，这样左下图就变成情况3了。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626164758729-301674609.jpg" alt="image"></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626164805332-951627135.jpg" alt="image"></p>
<p>   对于情况3：插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点。我们要做的操作有：将当前节点的父节点(7)涂黑，将祖父节点(11)涂红，在祖父节点为支点做右旋操作。最后把根节点涂黑，整个红-黑树重新恢复了平衡，如右上图所示。至此，插入操作完成！</p>
<p>我们可以看出，如果是从情况1开始发生的，必然会走完情况2和3，也就是说这是一整个流程，当然咯，实际中可能不一定会从情况1发生，如果从情况2开始发生，那再走个情况3即可完成调整，如果直接只要调整情况3，那么前两种情况均不需要调整了。故变色和旋转之间的先后关系可以表示为：变色-&gt;左旋-&gt;右旋。</p>
<h5 id="红黑树删除操作"><a href="#红黑树删除操作" class="headerlink" title="红黑树删除操作"></a>红黑树删除操作</h5><p>我们现在约定：后继节点的子节点称为“当前节点”.</p>
<p>删除节点有三种情况分析：</p>
<p>a. 叶子节点；(直接删除即可)<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626164943173-2121042227.jpg" alt="image"><br>b. 仅有左或右子树的节点；（上移子树即可）<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626165004166-642012957.jpg" alt="image">　<br>c. 左右子树都有的节点。( 用删除节点的直接前驱或者直接后继来替换当前节点，调整直接前驱或者直接后继的位置)<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626165016051-1231487357.jpg" alt="image"><br>删除操作后，如果当前节点是黑色的根节点，那么不用任何操作，因为并没有破坏树的平衡性，即没有违背红-黑树的规则，这很好理解。如果当前节点是红色的，说明刚刚移走的后继节点是黑色的，那么不管后继节点的父节点是啥颜色，我们只要将当前节点涂黑就可以了，红-黑树的平衡性就可以恢复。但是如果遇到以下四种情况，我们就需要通过变色或旋转来恢复红-黑树的平衡了。</p>
<ol>
<li><p>当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）；</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的；</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点时黑色的；</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的右子节点是红色，左子节点任意颜色。</p>
</li>
</ol>
<p>以上四种情况中，我们可以看出2,3,4其实是“当前节点是黑色的，且兄弟节点是黑色的”的三种子集，等会在程序中可以体现出来。现在我们假设当前节点是左子节点（当然也可能是右子节点，跟左子节点相反即可，我们讨论一边就可以了），分别解决上面四种情况：</p>
<p>对于情况1：当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）。如左下图所示：A节点表示当前节点。针对这种情况，我们要做的操作有：将父节点（B）涂红，将兄弟节点（D）涂黑，然后将当前节点（A）的父节点（B）作为支点左旋，然后当前节点的兄弟节点就变成黑色的情况了（自然就转换成情况2，3,4的公有特征了），如右下图所示：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626165124764-1792079285.jpg" alt="image"></p>
<p>对于情况2：当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的。如左下图所示，A表示当前节点。针对这种情况，我们要做的操作有：将兄弟节点（D）涂红，将当前节点指向其父节点（B），将其父节点指向当前节点的祖父节点，继续新的算法（具体见下面的程序），不需要旋转。这样变成了右下图所示的情况：</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626165221571-2091816346.jpg" alt="image"></p>
<p>  对于情况3：当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点时黑色的。如左下图所示，A是当前节点。针对这种情况，我们要做的操作有：把当前节点的兄弟节点（D）涂红，把兄弟节点的左子节点（C）涂黑，然后以兄弟节点作为支点做右旋操作。然后兄弟节点就变成黑色的，且兄弟节点的右子节点变成红色的情况（情况4）了。如右下图：<br>  <img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626165301994-226570115.jpg" alt="image"></p>
<p>对于情况4：当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的右子节点是红色，左子节点任意颜色。如左下图所示：A为当前节点，针对这种情况，我们要做的操作有：把兄弟节点（D）涂成父节点的颜色，再把父节点（B）涂黑，把兄弟节点的右子节点（E）涂黑，然后以当前节点的父节点为支点做左旋操作。至此，删除修复算法就结束了，最后将根节点涂黑即可。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626165338024-2048461274.jpg" alt="image"><br>我们可以看出，如果是从情况1开始发生的，可能情况2，3，4中的一种：如果是情况2，就不可能再出现3和4；如果是情况3，必然会导致情况4的出现；如果2和3都不是，那必然是4。当然咯，实际中可能不一定会从情况1发生，这要看具体情况了。</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h5 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h5><p>把访问逻辑从不同类型的集合类中抽取出来，从而避免向外部暴露集合的内部结构。在java中它是一个对象，其目的是遍历并选中其中的每个元素，而使用者（客户端）无需知道里面的具体细节。</p>
<h5 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h5><p>Collection集合元素的通用获取方式：在取出元素之前先判断集合中有没有元素。如果有，就把这个元素取出来，继续再判断，如果还有就再取出来，一直把集合中的所有元素全部取出来，这种取出元素的方式专业术语称为迭代。</p>
<p>java.util.Iterator:在Java中Iterator为一个接口，它只提供了迭代的基本规则。在JDK中它是这样定义的：对Collection进行迭代的迭代器。迭代器取代了Java Collection Framework中的Enumeration。</p>
<p>Collection中有一个抽象方法iterator方法，所有的Collection子类都实现了这个方法；返回一个Iterator对象</p>
<p>定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;<span class="comment">//判断是否存在下一个对象元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;<span class="comment">//获取下一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;<span class="comment">//移除元素</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用Iterator的时候禁止对所遍历的容器进行改变其大小结构的操作。例如: 在使用Iterator进行迭代时，如果对集合进行了add、remove操作就会出现ConcurrentModificationException异常。</p>
<p>在进行集合元素取出的时候，如果集合中没有元素了，还继续使用next()方法的话，将发生NoSuchElementException没有集合元素的错误</p>
<p>修改并发异常：在迭代集合中元素的过程中，集合的长度发生改变（进行了元素增加或者元素删除的操作), 增强for的底层原理也是迭代器，所以也需要避免这种操作；</p>
<p>解决以上异常的方法:使用ListIterator</p>
<p>任何集合都有迭代器。</p>
<p>任何集合类，都必须能以某种方式存取元素，否则这个集合容器就没有任何意义。</p>
<p>迭代器，也是一种模式（也叫迭代器模式）。迭代器要足够的“轻量”——创建迭代器的代价小。</p>
<h5 id="Iterable-1-5"><a href="#Iterable-1-5" class="headerlink" title="Iterable(1.5)"></a>Iterable(1.5)</h5><p>Java中还提供了一个Iterable接口，Iterable接口实现后的功能是‘返回’一个迭代器，我们常用的实现了该接口的子接口有:<code>Collection&lt;E&gt;</code>、<code>List&lt;E&gt;</code>、<code>Set&lt;E&gt;</code>等。该接口的iterator()方法返回一个标准的Iterator实现。实现Iterable接口允许对象成为Foreach语句的目标。就可以通过foreach语句来遍历你的底层序列。</p>
<p>Iterable接口包含一个能产生Iterator对象的方法，并且Iterable被foreach用来在序列中移动。因此如果创建了实现Iterable接口的类，都可以将它用于foreach中。</p>
<p>定义:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Package java.lang; </span><br><span class="line">import java.util.Iterator; </span><br><span class="line">public<span class="built_in"> interface </span>Iterable&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; iterator(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Iterable是Java 1.5的新特性, 主要是为了支持forEach语法, 使用容器的时候, 如果不关心容器的类型, 那么就需要使用迭代器来编写代码. 使代码能够重用.</p>
<p>使用方法很简单:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">List</span>&lt;<span class="keyword">String&gt; </span><span class="keyword">strs </span>= Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)<span class="comment">; </span></span><br><span class="line"><span class="symbol">for</span> (<span class="keyword">String </span><span class="keyword">str: </span><span class="keyword">strs) </span>&#123;</span><br><span class="line">    out.println(<span class="keyword">str);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>好处：代码减少，方便遍历</li>
<li>弊端：没有索引，不能操作容器里的元素</li>
</ul>
<p>增强for循环底层也是使用了迭代器获取的，只不过获取迭代器由jvm完成，不需要我们获取迭代器而已，所以在使用增强for循环变量元素的过程中不准使用集合对象对集合的元素个数进行修改；</p>
<h5 id="forEach-1-8"><a href="#forEach-1-8" class="headerlink" title="forEach()(1.8)"></a>forEach()(1.8)</h5><p>使用接收lambda表达式的forEach方法进行快速遍历.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; strs = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>); </span><br><span class="line"><span class="comment">// 使用Java 1.8的lambda表达式 </span></span><br><span class="line">strs.forEach(out<span class="type">::println</span>);</span><br></pre></td></tr></table></figure>
<h5 id="Spliterator迭代器"><a href="#Spliterator迭代器" class="headerlink" title="Spliterator迭代器"></a>Spliterator迭代器</h5><p>Spliterator是1.8新增的迭代器,属于并行迭代器,可以将迭代任务分割交由多个线程来进行。</p>
<p>Spliterator可以理解为Iterator的Split版本（但用途要丰富很多）。使用Iterator的时候，我们可以顺序地遍历容器中的元素，使用Spliterator的时候，我们可以将元素分割成多份，分别交于不于的线程去遍历，以提高效率。使用 Spliterator 每次可以处理某个元素集合中的一个元素 — 不是从 Spliterator 中获取元素，而是使用 tryAdvance() 或 forEachRemaining() 方法对元素应用操作。但Spliterator 还可以用于估计其中保存的元素数量，而且还可以像细胞分裂一样变为一分为二。这些新增加的能力让流并行处理代码可以很方便地将工作分布到多个可用线程上完成</p>
<h5 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h5><p>ListIterator是一个更强大的Iterator子类型，能用于各种List类访问，前面说过Iterator支持单向取数据，ListIterator可以双向移动，所以能指出迭代器当前位置的前一个和后一个索引，可以用set方法替换它访问过的最后一个元素。我们可以通过调用listIterator方法产生一个指向List开始处的ListIterator，并且还可以用过重载方法listIterator(n)来创建一个指定列表索引为n的元素的ListIterator。</p>
<p>ListIterator可以往前遍历，添加元素，设置元素</p>
<p>Iterator和ListIterator的区别：</p>
<p>两者都有next()和hasNext()，可以实现向后遍历，但是ListIterator有previous()和hasPrevious()方法，即可以实现向前遍历</p>
<p>ListIterator可以定位当前位置，nextIndex()和previous()可以实现</p>
<p>ListIterator有add()方法，可以向list集合中添加数据</p>
<p>都可以实现删除操作，但是ListIterator可以实现对对象的修改，set()可以实现，Iterator仅能遍历，不能修改</p>
<h5 id="Fail-Fast"><a href="#Fail-Fast" class="headerlink" title="Fail-Fast"></a>Fail-Fast</h5><p>类中的iterator()方法和listIterator()方法返回的iterators迭代器是fail-fast的：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<p>迭代器与枚举有两点不同:</p>
<p>　　1. 迭代器在迭代期间可以从集合中移除元素。</p>
<p>　　2. 方法名得到了改进，Enumeration的方法名称都比较长。</p>
<p>迭代器的好处：屏蔽了集合之间的不同，可以使用相同的方式取出</p>
<h3 id="集合类概念"><a href="#集合类概念" class="headerlink" title="集合类概念"></a>集合类概念</h3><h4 id="集合类的作用"><a href="#集合类的作用" class="headerlink" title="集合类的作用"></a>集合类的作用</h4><p>集合类也叫做容器类，和数组一样，用于存储数据，但数组类型单一，并且长度固定，限制性很大，而集合类可以动态增加长度。</p>
<p>集合存储的元素都是对象(引用地址)，所以集合可以存储不同的数据类型，但如果是需要比较元素来排序的集合，则需要类型一致。</p>
<p>集合中提供了统一的增删改查方法，使用方便。</p>
<p>支持泛型，避免数据不一致和转换异常，还对常用的数据结构进行了封装。</p>
<p>所有的集合类的都在java.util包下。</p>
<h4 id="集合框架体系的组成"><a href="#集合框架体系的组成" class="headerlink" title="集合框架体系的组成"></a>集合框架体系的组成</h4><p>集合框架体系是由Collection、Map(映射关系)和Iterator(迭代器)组成，各部分的作用如下所示。</p>
<h5 id="Collection体系中有三种集合：Set、List、Queue"><a href="#Collection体系中有三种集合：Set、List、Queue" class="headerlink" title="Collection体系中有三种集合：Set、List、Queue"></a>Collection体系中有三种集合：Set、List、Queue</h5><p> Set(集)： 元素是无序的且不可重复。</p>
<p> List(列表)：元素是有序的且可重复。</p>
<p> Queue(队列)：封装了数据结构中的队列。</p>
<h5 id="Map体系"><a href="#Map体系" class="headerlink" title="Map体系"></a>Map体系</h5><p> Map用于保存具有映射关系的数据，即key-value(键值对)。Map集合的key是唯一的，不可重复，而value可以重复。所以一个value可以对应多个key。</p>
<p> Map体系除了常用类之外，还有Properties（属性类）也属于Map体系。</p>
<h5 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator(迭代器)"></a>Iterator(迭代器)</h5><p>请查看上面!</p>
<h4 id="Collection的由来"><a href="#Collection的由来" class="headerlink" title="Collection的由来"></a>Collection的由来</h4><p>  由于数组中存放对象，对对象操作起来不方便。java中有一类容器，专门用来存储对象。</p>
<p> 集合可以存储多个元素,但我们对多个元素也有不同的需求</p>
<p> 多个元素,不能有相同的</p>
<p> 多个元素,能够按照某个规则排序</p>
<p> 针对不同的需求：java就提供了很多集合类，多个集合类的数据结构不同。但是，结构不重要，重要  的是能够存储东西,能够判断,获取.</p>
<p>把集合共性的内容不断往上提取,最终形成集合的继承体系—-&gt;Collection</p>
<p>并且所有的Collection实现类都重写了toString()方法.</p>
<h4 id="集合和数组"><a href="#集合和数组" class="headerlink" title="集合和数组"></a>集合和数组</h4><p>集合与数组的区别：</p>
<ul>
<li>数组的长度固定的，而集合长度时可变的<br>数组只能储存同一类型的元素，而且能存基本数据类型和引用数据类型。集合可以存储不同类型的元素，只能存储引用数据类型</li>
</ul>
<p>集合类和数组不一样,数组元素既可以是基本类型的值,也可以是对象(实际上保存的是对象的引用变量);而集合只能保存对象。</p>
<p>数组和集合的主要区别包括以下几个方面：</p>
<ul>
<li>数组声明了它容纳的元素的类型，而集合不声明。这是由于集合以object形式来存储它们的元素。</li>
<li>一个数组实例具有固定的大小，不能伸缩。集合则可根据需要动态改变大小。</li>
<li>数组是一种可读/可写数据结构没有办法创建一个只读数组。然而可以使用集合提供的ReadOnly方   只读方式来使用集合。该方法将返回一个集合的只读版本。</li>
</ul>
<p>集合的作用：</p>
<p>如果一个类的内部有很多相同类型的属性，并且他们的作用与意义是一样的，比如说学生能选课学生类就有很多课程类型的属性，或者工厂类有很多机器类型的属性，我们用一个类似于容器的集合去盛装他们，这样在类的内部就变的井然有序———这就是：</p>
<ul>
<li>在类的内部，对数据进行组织的作用。</li>
<li>简单而快速的搜索查找其中的某一条元素</li>
<li>有的集合接口，提供了一系列排列有序的元素，并且可以在序列中间快速的插入或者删除有关元素。</li>
<li>有的集合接口在其内部提供了映射关系的结构，可以通过关键字(key)去快速查找对应的唯一对象，而这个关键可以是任意类型的。</li>
</ul>
<h4 id="泛型与集合的区别"><a href="#泛型与集合的区别" class="headerlink" title="泛型与集合的区别"></a>泛型与集合的区别</h4><p>泛型听起来很高深的一个词，但实际上它的作用很简单，就是提高java程序的性能。 </p>
<p>比如在计算机中经常用到一些数据结构，如队列，链表等，而其中的元素以前一般这么定义：object a=new object(); </p>
<p>这样就带来一个严重的问题，用object来表示元素没有逻辑问题，但每次拆箱、封箱就占用了大量的计算机资源，导致程序性能低下，而这部分内容恰恰一般都是程序的核心部分，如果使用object，那么程序的表现就比较糟糕。</p>
<p>而使用泛型则很好的解决这个问题，本质就是在编译阶段就告诉编译器，数据结构中元素的种类，既然编译器知道了元素的种类，自然就避免了拆箱、封箱的操作，从而显著提高java程序的性能。 </p>
<p>比如<code>List&lt;string&gt;</code>就直接使用string对象作为List的元素，而避免使用object对象带来的封箱、拆箱操作，从而提高程序性能。</p>
<h3 id="集合接口与类"><a href="#集合接口与类" class="headerlink" title="集合接口与类"></a>集合接口与类</h3><h4 id="数组和集合一般就用到下面接口和集合"><a href="#数组和集合一般就用到下面接口和集合" class="headerlink" title="数组和集合一般就用到下面接口和集合"></a>数组和集合一般就用到下面接口和集合</h4><p>Array  数组</p>
<p>Arrays  数组工具</p>
<p>Collection 最基本的集合接口</p>
<p>Collections  集合工具类</p>
<p>List  接口</p>
<p>ArrayList 一种可以动态增长和缩减的索引序列</p>
<p>LinkedList 一种可以在任何位置进行高效地插入和删除操作的有序序列</p>
<p>Vector</p>
<p>Set</p>
<p>HashSet 一种没有重复元素的无序集合</p>
<p>TreeSet 一种有序集</p>
<p>LinkHashSet 一种可以记住元素插入次序的集合</p>
<p>map</p>
<p>HashMap 一种存储key：value关联的映射</p>
<p>HashTable</p>
<p>TreeMap 一种key有序的映射</p>
<p>LinkedHashMap 一种可以记住插入次序的映射</p>
<p>Deque</p>
<p>Stack</p>
<p>ArrayDeque  一种用循环数组实现的双端队列</p>
<p>Queue</p>
<p>PriorityQueue 一种可以高效删除最小元素的集合</p>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>数组：是以一段连续内存保存数据的；随机访问是最快的,但不支持插入,删除,迭代等操作。</p>
<p>Array可以包含基本类型和对象类型</p>
<p>Array大小是固定的</p>
<p>指定数组引用为 null，则此类中的方法都会抛出 NullPointerException。</p>
<p>所创建的对象都放在堆中。</p>
<p>够对自身进行枚举(因为都实现了IEnumerable接口)。</p>
<p>具有索引(index),即可以通过index来直接获取和修改任意项。</p>
<p>Array类型的变量在声明的同时必须进行实例化(至少得初始化数组的大小)，而ArrayList可以只是先声明。</p>
<p> Array只能存储同构的对象，而ArrayList可以存储异构的对象。</p>
<p>在CLR托管对中的存放方式</p>
<p>Array是始终是连续存放的，而ArrayList的存放不一定连续。</p>
<p>Array不能够随意添加和删除其中的项，而ArrayList可以在任意位置插入和删除项。</p>
<p>采用数组存在的一些缺陷：</p>
<p>   1.数组长度固定不变，不能很好地适应元素数量动态变化的情况。</p>
<p>   2.可通过数组名.length获取数组的长度，却无法直接获取数组中真实存储的个数。</p>
<p>   3.在进行频繁插入、删除操作时同样效率低下。</p>
<h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><p>数组的工具类,里面都是操作数组的工具.</p>
<p>常用方法:</p>
<p>1、数组的排序:Arrays.sort(a);//实现了对数组从小到大的排序//注：此类中只有升序排序，而无降序排序。</p>
<p>2、数组元素的定位查找:Arrays.binarySearch(a,8);//二分查找法</p>
<p>3、数组的打印:Arrays.toString(a);//String 前的a和括号中的a均表示数组名称</p>
<p>4、 查看数组中是否有特定的值:Arrays.asList(a).contains(1);</p>
<h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><p>Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些 Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java SDK不提供直接继承自Collection的类， Java SDK提供的类都是继承自Collection的“子接口”如List和Set。</p>
<p>所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个Collection参数的构造函数用于创建一个新的 Collection，这个新的Collection与传入的Collection有相同的元素。后一个构造函数允许用户复制一个Collection。</p>
<p>如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Iterator </span><span class="keyword">it </span>= collection.<span class="keyword">iterator(); </span>// 获得一个迭代子</span><br><span class="line"></span><br><span class="line"><span class="symbol">while</span>(<span class="keyword">it.hasNext()) </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">it.next(); </span>// 得到下一个元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由Collection接口派生的两个接口是List和Set。</p>
<p>Collection返回的是Iterator迭代器接口，而List中又有它自己对应的实现–&gt;ListIterator接口 Collection。标识所含元素的序列，这里面又包含多种集合类，比如List，Set，Queue；它们都有各自的特点，比如List是按顺序插入元素，Set是不重复元素集合，Queue则是典型的FIFO结构</p>
<p>Collection接口描述：</p>
<p>　　Collection接口常用的子接口有List 接口和Set接口</p>
<p>　　List接口中常用的子类有：ArrayList类（数组列表）和LinkedList（链表）</p>
<p>　　Set接口中常用的子类有：HashSet （哈希表）和LinkedHashSet（基于链表的哈希表）</p>
<p>Collection 层次结构 中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接 实现：它提供更具体的子接口（如 Set和 List）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。（面向接口的编程思想）</p>
<h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><h5 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h5><p>Collections提供以下方法对List进行排序操作</p>
<p>void reverse(List list)：反转</p>
<p>void shuffle(List list),随机排序</p>
<p>void sort(List list),按自然排序的升序排序</p>
<p>void sort(List list, Comparator c);定制排序，由Comparator控制排序逻辑</p>
<p>void swap(List list, int i , int j),交换两个索引位置的元素</p>
<p>void rotate(List list, int distance),旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。</p>
<h5 id="查找，替换操作"><a href="#查找，替换操作" class="headerlink" title="查找，替换操作"></a>查找，替换操作</h5><p>int binarySearch(List list, Object key), 对List进行二分查找，返回索引，注意List必须是有序的</p>
<p>int max(Collection coll),根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</p>
<p>int max(Collection coll, Comparator c)，根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</p>
<p>void fill(List list, Object obj),用元素obj填充list中所有元素</p>
<p>int frequency(Collection c, Object o)，统计元素出现次数</p>
<p>int indexOfSubList(List list, List target), 统计targe在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</p>
<p>boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素。</p>
<h5 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h5><p>Collections中几乎对每个集合都定义了同步控制方法, 这些方法，来将集合包装成线程安全的集合</p>
<p> SynchronizedList(List);</p>
<p> SynchronizedSet(Set;</p>
<p>  SynchronizedMap(Map);</p>
<p>SynchronizedMap和ConcurrentHashMap 区别</p>
<p>Collections.synchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步，而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁。所以，只要要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。这样，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。同时，同步操作精确控制到桶，所以，即使在遍历map时，其他线程试图对map进行数据修改，也不会抛出ConcurrentModificationException。</p>
<p>ConcurrentHashMap从类的命名就能看出，它必然是个HashMap。而Collections.synchronizedMap()可以接收任意Map实例，实现Map的同步</p>
<p>线程安全，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hashtable，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</p>
<p>List本身是Collection接口的子接口，具备了Collection的所有方法。</p>
<p>List的特有方法都有索引，这是该集合最大的特点。</p>
<p>List集合支持对元素的增、删、改、查。</p>
<p>List中存储的元素实现类排序，而且可以重复的存储相关元素。</p>
<p>次序是List最重要的特点：它保证维护元素特定的顺序。</p>
<p>List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。</p>
<p>和下面要提到的Set不同，List允许有相同的元素。</p>
<p>除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个 ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历。</p>
<p>优点：操作读取操作效率高，基于数组实现的，可以为null值，可以允许重复元素，有序，异步。</p>
<p>缺点：由于它是由动态数组实现的，不适合频繁的对元素的插入和删除操作，因为每次插入和删除都需要移动数组中的元素。</p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList 是基于数组实现，内存中分配连续的空间，需要维护容量大小。随机访问.</p>
<p>ArrayList就是动态数组，也是一个对象。</p>
<p>ArrayList不自定义位置添加元素和LinkedList性能没啥区别，ArrayList默认元素追加到数组后面，而LinkedList只需要移动指针，所以两者性能相差无几。</p>
<p>如果ArrayList自定义位置插入元素，越靠前，需要重写排序的元素越多，性能消耗越大，LinkedList无论插入任何位置都一样，只需要创建一个新的表项节点和移动一下指针，性能消耗很低。</p>
<p>ArrayList是基于数组，所以查看任意位置元素只需要获取当前位置的下标的数组就可以，效率很高，然而LinkedList获取元素需要从最前面或者最后面遍历到当前位置元素获取，如果集合中元素很多，就会效率很低，性能消耗大。</p>
<p>频繁遍历查看元素,使用 ArrayList 集合,ArrayList 查询快，增删慢</p>
<p>ArrayList线程不安全的</p>
<p>1、ArrayList是用数组实现的，该对象存放在堆内存中，这个数组的内存是连续的，不存在相邻元素之间还隔着其他内存。底层是一个可动态扩容的数组</p>
<p>2、索引ArrayList时，速度比原生数组慢是因为你要用get方法，这是一个函数调用，而数组直接用[ ]访问，相当于直接操作内存地址，速度当然比函数调用快。</p>
<p>3、新建ArrayList的时候，JVM为其分配一个默认或指定大小的连续内存区域（封装为数组）。</p>
<p>4、每次增加元素会检查容量，不足则创建新的连续内存区域（大小等于初始大小+步长），也用数组形式封装，并将原来的内存区域数据复制到新的内存区域，然后再用ArrayList中引用原来封装的数组对象的引用变量引用到新的数组对象：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">elementData</span> = Arrays.copyOf(elementData, newCapacity);</span><br></pre></td></tr></table></figure>
<p>　　ArrayList里面的removeIf方法就接受一个Predicate参数，采用如下Lambda表达式就能把，所有null元素删除:</p>
<figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>.removeIf(e -&gt; e == <span class="literal">null</span>)；</span><br></pre></td></tr></table></figure>
<p>　　　　</p>
<p>ArrayList：每次添加元素之前会检查是否需要扩容,是按照原数组的1.5倍延长。构造一个初始容量为 10 的空列表。</p>
<p>使用for适合循环ArrayLIst以及数组，当大批量的循环LinkedList时程序将会卡死，for适合循环数组结构，通过下标去遍历。</p>
<p>get访问List内部任意元素时，ArrayList的性能要比LinkedList性能好。LinkedList中的get方法是要按照顺序从列表的一端开始检查，直到另一端。</p>
<p>在ArrayList的 中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；</p>
<p>ArrayList的空 间浪费主要体现在在list列表的结尾预留一定的容量空间</p>
<p>ArrayList只能包含对象类型。</p>
<p>ArrayList的大小是动态变化的。 </p>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量</p>
<p>够对自身进行枚举(因为实现了IEnumerable接口)。</p>
<p>具有索引(index),即可以通过index来直接获取和修改任意项。</p>
<p>ArrayList允许存放（不止一个）null元素</p>
<p>允许存放重复数据，存储时按照元素的添加顺序存储</p>
<p>ArrayList可以存放任何不同类型的数据（因为它里面存放的都是被装箱了的Object型对象，实际上ArrayList内部就是使用”object[] _items;”这样一个私有字段来封装对象的）</p>
<p>ArrayList不是一个线程安全的集合，如果集合的增删操作需要保证线程的安全性，可以考虑使用CopyOWriteArrayList或者使用collections.synchronizedList(Lise l)函数返回一个线程安全的ArrayList类。</p>
<p> 实现了RandomAccess接口，底层又是数组，get读取元素性能很好</p>
<p> 顺序添加很方便</p>
<p> 删除和插入需要复制数组 性能很差（可以使用LinkindList）</p>
<p>为什么ArrayList的elementData是用transient修饰的？</p>
<p>transient修饰的属性意味着不会被序列化，也就是说在序列化ArrayList的时候，不序列化elementData。</p>
<p>为什么要这么做呢？</p>
<p> elementData不总是满的，每次都序列化，会浪费时间和空间</p>
<p> 重写了writeObject 保证序列化的时候虽然不序列化全部 但是有的元素都序列化</p>
<p>所以说不是不序列化 而是不全部序列化。</p>
<p>elementData属性采用了transient来修饰，不使用Java默认的序列化机制来实例化，自己实现了序列化writeObject()和反序列化readObject()的方法。</p>
<p>每次对下标的操作都会进行安全性检查，如果出现数组越界就立即抛出异常。</p>
<p>如果提前知道数组元素较多，可以在添加元素前通过调用ensureCapacity()方法提前增加容量以减小后期容量自动增长的开销。</p>
<p>当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。</p>
<p>ArrayList基于数组方式实现，容量限制不大于Integer.MAX_VALUE的小大，每次扩容1.5倍。有序，可以为null,允许重复，非线程安全。</p>
<p>增加和删除会修改modCount,在迭代的时候需要保持单线程的唯一操作，如果期间进行了插入或者删除操作，就会被迭代器检查获知，从而出现运行时异常。</p>
<p>一般建议在单线程中使用ArrayList。</p>
<p> 当在index处放置一个元素的时候，会将数组index处右边的元素全部右移</p>
<p> 当在index处删除一个元素的时候，会将数组index处右边的元素全部左移</p>
<p>ArrayList底层是数组结构，因为数组有维护索引，所以查询效率高；而做插入、删除操作时，因为要判断扩容（复制一份新数组）且数组中的元素可能要大规模的后移或前移一个索引位置，所以效率差。</p>
<p>Arrays.asList()方法返回的List集合是一个固定长度的List集合，不是ArrayList实例，也不是Vector的实例</p>
<p>ArrayList也采用了快速失败(Fail-Fast机制)的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。具体介绍请参考HashMap的实现原理中的Fail-Fast机制。</p>
<h4 id="linkedList"><a href="#linkedList" class="headerlink" title="linkedList"></a>linkedList</h4><p>LinkedList 是基于循环双向链表数据结构，不需要维护容量大小。顺序访问。</p>
<p>频繁插入删除元素 使用 LinkedList 集合</p>
<p>LinkedList 线程不安全的</p>
<p>LinkedList在随机访问方面相对比较慢，但是它的特性集较ArrayList 更大。</p>
<p>LinkedList提供了大量的首尾操作</p>
<p>LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。</p>
<p>LinkedList：底层基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。链表增删快，查找慢 </p>
<p>LinkedList由双链表实现，增删由于不需要移动底层数组数据，其底层是链表实现的，只需要修改链表节点指针，对元素的插入和删除效率较高。</p>
<p>LinkedList缺点是遍历效率较低。HashMap和双链表也有关系。</p>
<p>LinkedList是一个继承于AbstractSequentialList的双向链表，它可以被当做堆栈、队列或双端队列进行操作</p>
<p>LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</p>
<p>使用foreach适合循环LinkedList，使用双链表结构实现的应当使用foreach循环。</p>
<p>LinkedList实现了List接口，允许null元素。</p>
<p>LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> <span class="built_in">list</span> = Collections.synchronizedList(<span class="literal">new</span> LinkedList(…));</span><br></pre></td></tr></table></figure>
<p>在LinkedList的中间插入或删除一个元素的开销是固定的。 </p>
<p>LinkedList不支持高效的随机元素访问。 </p>
<p>LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间 </p>
<p>LinkedList是List和Deque接口的双向链表的实现。实现了所有可选列表操作，并允许包括null值。</p>
<p> Fail-Fast机制:LinkedList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>
<p>LinkedList因为底层为链表结构，查询时需要从头节点（或尾节点）开始遍历所以查询效率差；但同时也因为是链表结构，做插入、删除操作时只要断开当前删除节点前驱、后驱引用，并将原来的前、后节点的引用链接起来，所以效率高。</p>
<p>千万不要使用普通for循环遍历LinkedList，这么做会让你崩溃！可以选择使用foreach或迭代器来进行遍历操作</p>
<p> LinedList适合用迭代遍历；</p>
<p>基于链表结构的集合 LinkedList。LinkedList 属于 java.util 包下面，也实现Iterable接口，说明可以使用迭代器遍历；LinkedList 还实现 <code>Deque&lt;E&gt;</code>，<code>Queue&lt;E&gt;</code>操作。Deque 和 Queue 是 LinkedList 的父接口，那么 LinkedList 也可以看成一种 Deque 或者 Queue；Queue表示一种队列，也是一种数据结构，它的特点是先进先出，因此在队列这个接口里面提供了一些操作队列的方法，同时LinkedList也具有这些方法；Deque(Double ended queues双端队列)，支持在两端插入或者移除元素; 那也应该具有操作双端队列的一些方法；LinkedList 是他们的子类，说明都具有他们两者的方法；LinkedList也可以充当队列，双端队列，堆栈多个角色。</p>
<h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。</p>
<p>Vector：是按照原数组的2倍延长。</p>
<p>Vector是基于线程安全的，效率低 元素有放入顺序，元素可重复 </p>
<p>Vector可以由我们自己来设置增长的大小，ArrayList没有提供相关的方法。</p>
<p>Vector相对ArrayList查询慢(线程安全的)</p>
<p>Vector相对LinkedList增删慢(数组结构)</p>
<p>以前还能见到Vector和Stack，但Vector太过古老，被ArrayList取代，所以这里不讲；而Stack已经被ArrayDeque取代。</p>
<p>对于想在迭代器迭代过程中针对集合进行增删改的，可以通过返回ListIterator来操作。</p>
<p>Vector：底层结构是数组，线程是安全的，添加删除慢，查找快，（同ArrayList）</p>
<p>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。</p>
<p>Vector 是矢量队列，它是JDK1.0版本添加的类。继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口。</p>
<p>Vector 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。</p>
<p>Vector 实现了Cloneable接口，即实现clone()函数。它能被克隆。</p>
<p>由Vector创建的Iterator，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。</p>
<p>元素无放入顺序，元素不可重复（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的）</p>
<p>Set具有与Collection完全一样的接口，因此没有任何额外的功能,只是行为不同。这是继承与多态思想的典型应用：表现不同的行为。</p>
<p>Set不保存重复的元素(至于如何判断元素相同则较为负责)</p>
<p>存入Set的每个元素都必须是唯一的，因为Set不保存重复元素,加入Set的元素必须定义equals()方法以确保对象的唯一性。</p>
<p>Set 是基于对象的值来确定归属性的。</p>
<p>Set本身有去重功能是因为String内部重写了hashCode()和equals()方法，在add里实现了去重, Set集合是不允许重复元素的，但是集合是不知道我们对象的重复的判断依据的，默认情况下判断依据是判断两者是否为同一元素（euqals方法，依据是元素==元素），如果要依据我们自己的判断来判断元素是否重复，需要重写元素的equals方法（元素比较相等时调用）hashCode()的返回值是元素的哈希码，如果两个元素的哈希码相同，那么需要进行equals判断。【所以可以自定义返回值作为哈希码】 equals()返回true代表两元素相同，返回false代表不同。</p>
<p>set集合没有索引，只能用迭代器或增强for循环遍历</p>
<p>set的底层是map集合</p>
<p>Set最多有一个null元素</p>
<p>必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。</p>
<p>Set具有与Collection完全一样的接口，没有额外的任何功能。所以把Set就是Collection，只是行为不同（这就是多态）；Set是基于对象的值来判断归属的，由于查询速度非常快速，HashSet使用了散列，HashSet维护的顺序与TreeSet或LinkedHashSet都不同，因为它们的数据结构都不同，元素存储方式自然也不同。TreeSet的数据结构是“红-黑树”，HashSet是散列函数，LinkedHashSet也用了散列函数；如果想要对结果进行排序，那么选择TreeSet代替HashSet是个不错的选择</p>
<h4 id="Hashset"><a href="#Hashset" class="headerlink" title="Hashset"></a>Hashset</h4><p>HashSet : 为快速查找设计的Set。存入HashSet的对象必须定义hashCode()。</p>
<p>Hashset实现set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set的迭代顺序,别是它不保证该顺序恒久不变。此类允许使用Null元素</p>
<p>对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet的实现比较简单，相关HashSet的操作，基本上都说调用HashMap的相关方法来实现的</p>
<p>对于HashSet中保存的对象，请注意正确重写其equals和hashCode方法，以保证放入的对象的唯一性。</p>
<p>HashSet: 哈希表结构的集合 利用哈希表结果构成的集合查找速度会很快。</p>
<p>HashSet ： 底层数据结构是哈希表，线程 是不同步的 。 无序，高效；HashSet 集合保证元素唯一性 ：通过元素的 hashCode 方法，和 equals 方法完成的。当元素的 hashCode 值相同时，才继续判断元素的 equals 是否为 true。如果为 true，那么视为相同元素，不存。如果为 false，那么存储。如果 hashCode 值不同，那么不判断 equals，从而提高对象比较的速度。</p>
<p>HashSet类直接实现了Set接口， 其底层其实是包装了一个HashMap去实现的。HashSet采用HashCode算法来存取集合中的元素，因此具有比较好的读取和查找性能。</p>
<p>元素值可以为NULL,但只能放入一个null</p>
<p>　         HashSet集合保证元素唯一性：通过元素的hashCode方法，和equals方法完成的。</p>
<p>当元素的hashCode值相同时，才继续判断元素的equals是否为true。</p>
<p>如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。</p>
<p>对于HashSet集合，判断元素是否存在，或者删除元素，底层依据的是hashCode方法和equals方法。　　</p>
<p>特点：存储取出都比较快</p>
<p>1、不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。</p>
<p>2、HashSet不是同步的，必须通过代码来保证其同步。</p>
<p>3、集合元素可以是null.</p>
<p>原理：简单说就是链表数组结合体</p>
<p>对象的哈希值：普通的一个整数,可以理解为身份证号，是hashset存储的依据</p>
<p>HashSet按Hash算法来存储集合中的元素。在存取和查找上有很好的性能。</p>
<p>当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据该hashCode值决定该hashCode值决定该对象在HashSet中存储的位置。</p>
<p>如果有两个元素通过equals()方法比较返回true,但它们的hashCode()方法返回值不相等,hashSet将会把它们存储在不同位置，依然可以添加成功。如果两个对象的hashCode()方法返回的hashCode值相同，当它们的equals()方法返回false时，会在hashCode所在位置采用链式结构保存多个对象。这样会降低hashSet的查询性能。</p>
<p>在使用HashSet中重写hashCode()方法的基本原则</p>
<p>1、在程序运行过过程中，同一个对象多次调用hashCode()方法应该返回相同的值。</p>
<p>2、当两个对象的equals()方法比较返回true时，这个两个对象的hashCode()方法返回相同的值。</p>
<p>3、对象中用作equals()方法比较标准的实例变量，都应该用于计算hashCode值。 </p>
<p>把对象内的每个意义的实例变量(即每个参与equals()方法比较标准的实例变量)计算出一个int类型的hashCode值。用第1步计算出来的多个hashCode值组合计算出一个hashCode值返回 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> f1.hashCode()+(<span class="keyword">int</span>)f2;</span><br></pre></td></tr></table></figure>
<p>为了避免直接相加产生的偶然相等(两个对象的f1、f2实例变量并不相等，但他们的hashCode的和恰好相等)，可以通过为各个实例变量的hashCode值乘以一个质数后再相加</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">return</span> <span class="built_in">f1</span>.hashCode()*<span class="number">19</span>+<span class="built_in">f2</span>.hashCode()*<span class="number">37</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>如果向HashSet中添加一个可变的对象后，后面的程序修改了该可变对想的实例变量，则可能导致它与集合中的其他元素的相同（即两个对象的equals()方法比较返回true,两个对象的hashCode值也相等），这就有可能导致HashSet中包含两个相同的对象。</p>
<h4 id="Linkedhashset"><a href="#Linkedhashset" class="headerlink" title="Linkedhashset"></a>Linkedhashset</h4><p>LinkedHashSet : 具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序</p>
<p> LinkedHashSet 综合了链表+哈希表，根据元素的hashCode值来决定元素的存储位置，它同时使用链表维护元素的次序。</p>
<p>当遍历该集合时候，LinkedHashSet 将会以元素的添加顺序访问集合的元素。</p>
<p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。</p>
<p>这个相对于HashSet来说有一个很大的不一样是LinkedHashSet是有序的。LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p>
<p>与HashSet相比，特点：</p>
<p> 对集合迭代时，按增加顺序返回元素。</p>
<p> 性能略低于HashSet，因为需要维护元素的插入顺序。但迭代访问元素时会有好性能，因为它采用链表维护内部顺序。</p>
<p>LinkedHashSet不允许元素的重复</p>
<p>存储的顺序是元素插入的顺序。</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet : 保存次序的Set, 底层为树结构。使用它可以从Set中提取有序的序列。</p>
<p>TreeSet 继承AbstractSet类，实现NavigableSet、Cloneable、Serializable接口。与HashSet是基于HashMap实现一样，TreeSet 同样是基于TreeMap 实现的。由于得到Tree 的支持，TreeSet 最大特点在于排序，它的作用是提供有序的Set集合。</p>
<p>用于对 Set 集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。</p>
<p>如果元素不具备比较性，在运行时会抛出ClassCastException 异常。 所以元素需要实现Comparable 接口 ，让元素具备可比较性， 重写 compareTo 方法 。依据 compareTo 方法的返回值，确定元素在 TreeSet 数据结构中的位置。 或者用比较器方式，将Comparator对象传递给TreeSet构造器来告诉树集使用不同的比较方法</p>
<p>　</p>
<p>TreeSet底层的数据结构就是二叉树。</p>
<ul>
<li>不能写入空数据</li>
<li>写入的数据是有序的。</li>
<li>不写入重复数据</li>
</ul>
<p>TreeSet方法保证元素唯一性的方式：就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。</p>
<p>TreeSet集合排序有两种方式，Comparable和Comparator区别：</p>
<p>1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。</p>
<p>2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。</p>
<p>TreeSet类是SortedSet接口的实现类。因为需要排序，所以性能肯定差于HashSet。与HashSet相比，额外增加的方法有：</p>
<p>first()：返回第一个元素</p>
<p>last()：返回最后一个元素</p>
<p>lower(Object o)：返回指定元素之前的元素</p>
<p>higher(Obect o)：返回指定元素之后的元素</p>
<p>subSet(fromElement, toElement)：返回子集合</p>
<p>可以定义比较器（Comparator）来实现自定义的排序。默认自然升序排序。</p>
<p>TreeSet两种排序方式：自然排序和定制排序，默认情况下，TreeSet采用自然排序</p>
<p>TreeSet会调用集合元素的compareTo(Object object)方法来比较元素之间的大小关系，然后将元素按升序排列</p>
<p>如果试图把一个元素添加到TreeSet中，则该对象必须实现Comparable接口实现Comparable接口必须实现compareTo(Object object)，两个对象即通过这个方法进行比较Comparable的典型实现</p>
<p>BigDecimal、BigInteger以及所有的数值类型对应的包装类型，按对应的数值大小进行比较</p>
<p>Character：按字符的Unicode值进行比较</p>
<p>Boolean：true对应的包装类实例大于false包装类对应的实例</p>
<p>String：按字符对应的Unicode值进行比较</p>
<p>Date、Time：后面的时间、日期比前面的时间、日期大</p>
<p>向TreeSet中添加一个元素，只有第一个不需要使用compareTo()方法，后面的都要调用该方法</p>
<p>因为只有相同类的两个实例才会比较大小，所以向TreeSet中添加的应该是同一个类的对象</p>
<p>TreeSet采用红黑树的数据结构来存储集合元素</p>
<p>对于TreeSet集合而言，它判断两个对象的是否相等的唯一标准是:两个对象的通过compareTo(Object obj)方法比较是否返回0–如果通过compareTo(Object obj)方法比较返回0，TreeSet则会认为它们相等，否则认为它们不相等。对于语句，obj1.compareTo(obj2),如果该方法返回一个正整数，则表明obj1大于obj2;如果该方法返回一个负整数，则表明obj1小于obj2.</p>
<p>在默认的compareTo方法中，需要将的两个的类型的对象的转换同一个类型，因此需要将的保证的加入到TreeSet中的数据类型是同一个类型，但是如果自己覆盖compareTo方法时，没有要求两个对象强制转换成同一个对象，是可以成功的添加treeSet中</p>
<p>如果两个对象通过CompareTo(Object obj)方法比较返回0时，但它们通过equals()方法比较返回false时，TreeSet不会让第二个元素添加进去</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map主要用于存储健值对，根据键得到值，因此不允许键重复，但允许值重复。</p>
<p>Map接口概述：Java.util.Map&lt;k,v&gt;接口：是一个双列集合</p>
<p>Map集合的特点： 是一个双列集合，有两个泛型key和value，使用的时候key和value的数据类型可以相同。也可以不同.</p>
<p> Key不允许重复的，value可以重复的；</p>
<p> 一个key只能对应一个value</p>
<p>底层是一个哈希表（数组+单向链表）：查询快，增删快, 是一个无序集合</p>
<p>Map接口中的常用方法：</p>
<p> 1.get(key)  根据key值返回对应的value值，key值不存在则返回null</p>
<p> 2.put(key , value); 往集合中添加元素（key和value）</p>
<p> 　　注意：添加的时候，如果key不存在，返回值null</p>
<p> 　　如果Key已经存在的话，就会新值替换旧值，返回旧值</p>
<ol>
<li>remove(key); 删除key值对应的键值对；如果key不存在 ，删除失败。返回值为     null，如果key存在则删除成功，返回值为删除的value</li>
</ol>
<p>Map遍历方式</p>
<p>第一种方式：通过key找value的方式：</p>
<p>　　　Map中有一个方法：</p>
<p>　　　　　　Set <k>  keySet();  返回此映射包含的键的Set 集合</k></p>
<p>　　　操作步骤:</p>
<p>  　　　1.调用Map集合的中方法keySet,把Map集合中所有的健取出来,存储到Set集合中</p>
<p>   　　   2.遍历Set集合,获取Map集合中的每一个健</p>
<p>  　　　3.通过Map集合中的方法get(key),获取value值</p>
<p>　　　  可以使用迭代器跟增强for循环遍历</p>
<p> 第二种方式：Map集合遍历键值方式</p>
<p>　　　　Map集合中的一个方法：</p>
<p>　　　　Set&lt;Map.Entry&lt;k,v&gt;&gt; entrySet(); 返回此映射中包含的映射关系的Set视图</p>
<p>　使用步骤</p>
<p> 　　　　*  1.使用Map集合中的方法entrySet,把键值对(键与值的映射关系),取出来存储到Set  集合中</p>
<p> 　　　　*  2.遍历Set集合,获取每一个Entry对象</p>
<p> 　　　　*  3.使用Entry对象中的方法getKey和getValue获取健和值</p>
<p>　　可以使用迭代器跟增强for循环遍历</p>
<p>Collection中的集合元素是孤立的，可理解为单身，是一个一个存进去的，称为单列集合</p>
<p>Map中的集合元素是成对存在的，可理解为夫妻，是一对一对存进去的，称为双列集合</p>
<p>Map中存入的是：键值对，键不可以重复，值可以重复</p>
<p>Map主要用于存储带有映射关系的数据（比如学号与学生信息的映射关系）</p>
<p>Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个 value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。</p>
<p>Map具有将对象映射到其他对象的功能，是一个K-V形式存储容器，你可以通过containsKey()和containsValue()来判断集合是否包含某个减或某个值。Map可以很容以拓展到多维（值可以是其他容器甚至是其他Map）：</p>
<p>Map&lt;Object,List<object>&gt;</object></p>
<p>Map集合的数据结构仅仅针对键有效，与值无关。</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap非线程安全，高效，支持null；</p>
<p>根据键的HashCode 来存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。</p>
<p>HashMap最多只允许一条记录的键为Null；允许多条记录的值为 Null。（不允许键重复，但允许值重复）</p>
<p>HashMap不支持线程的同步（任一时刻可以有多个线程同时写HashMap，即线程非安全），可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap() 方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。</p>
<p>Hashtable与 HashMap类似。不同的是：它不允许记录的键或者值为空；它支持线程的同步（任一时刻只有一个线程能写Hashtable，即线程安全），因此也导致了 Hashtable 在写入时会比较慢。</p>
<p>HashMap里面存入的值在取出的时候是随机的，它根据键的HashCode来存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。</p>
<p>HashMap基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>值得注意的是HashMap不是线程安全的，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap。</p>
<p>Map map = Collections.synchronizedMap(new HashMap());</p>
<p>HashMap的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。学过数据结构的同学都知道，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。</p>
<p>HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。</p>
<p>HashMap是常用的Java集合之一，是基于哈希表的Map接口的实现。与HashTable主要区别为不支持同步和允许null作为key和value。由于HashMap不是线程安全的，如果想要线程安全，可以使用ConcurrentHashMap代替。</p>
<p>HashMap的底层是哈希数组，数组元素为Entry。HashMap通过key的hashCode来计算hash值，当hashCode相同时，通过“拉链法”解决冲突</p>
<p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。原本Map.Entry接口的实现类Entry改名为了Node。转化为红黑树时改用另一种实现TreeNode。 </p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/588112-20180626171656243-895639630.jpg" alt="image"></p>
<p>1.8中最大的变化就是在一个Bucket中，如果存储节点的数量超过了8个，就会将该Bucket中原来以链表形式存储节点转换为以树的形式存储节点;而如果少于6个，就会还原成链表形式存储。</p>
<p>为什么要这样做？前面已经说过LinkedList的遍历操作不太友好，如果在节点个数比较多的情况下性能会比较差，而树的遍历效率是比较好的，主要是优化遍历，提升性能。</p>
<p>HashMap:去掉了contains(),保留了containsKey(),containsValue()</p>
<p>HashMap:key,value可以为空.null作为key只能有一个,null作为value可以存在多个</p>
<p>HashMap:使用Iterator</p>
<p>HashMap:数组初始大小为16,扩容方式为2的指数幂形式</p>
<p>HashMap:重新计算hash值</p>
<p>HashMap是基于哈希表的Map接口的实现，HashMap是一个散列表，存储的内容是键值对（key-value）映射，键值对都可为null；</p>
<p>HashMap继承自 <code>AbstractMap&lt;K, V&gt;</code> 并实现<code>Map&lt;K, V&gt;</code>, Cloneable, Serializable接口；</p>
<p>HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。底层是个数组，数组上存储的数据是<code>Entry&lt;K,V&gt;</code>类型的链表结构对象。</p>
<p>HashMap是无序的，LinkedHashMap和treeMap是有序的；</p>
<p>HashMap基于哈希原理，可以通过put和get方法存储和获取对象。当我们将键值对传递给put方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到对应的bucket位置存储键对象和值对象作为Map.Entry；如果两个对象的hashcode相同，所以对应的bucket位置是相同的，HashMap采用链表解决冲突碰撞，这个Entry（包含有键值对的Map.Entry对象）会存储到链表的下一个节点中；如果对应的hashcode和key值都相同，则修改对应的value的值。HashMap在每个链表节点中存储键值对对象。当使用get()方法获取对象时，HashMap会根据键对象的hashcode去找到对应的bucket位置，找到对应的bucket位置后会调用keys.equals()方法去找到连表中对应的正确的节点找到对象。</p>
<p> HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。</p>
<p> HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口,能被克隆。</p>
<p>HashMap存数据的过程是：</p>
<pre><code>HashMap内部维护了一个存储数据的Entry数组，HashMap采用链表解决冲突，每一个Entry本质上是一个单向链表。当准备添加一个key-value对时，首先通过hash(key)方法计算hash值，然后通过indexFor(hash,length)求该key-value对的存储位置，计算方法是先用hash&amp;0x7FFFFFFF后，再对length取模，这就保证每一个key-value对都能存入HashMap中，当计算出的位置相同时，由于存入位置是一个链表，则把这个key-value对插入链表头。
</code></pre><p>HashMap中key和value都允许为null。key为null的键值对永远都放在以table[0]为头结点的链表中。</p>
<p>HashMap内存储数据的Entry数组默认是16，如果没有对Entry扩容机制的话，当存储的数据一多，Entry内部的链表会很长，这就失去了HashMap的存储意义了。所以HasnMap内部有自己的扩容机制。HashMap内部有：</p>
<pre><code>变量size，它记录HashMap的底层数组中已用槽的数量；

变量threshold，它是HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）    

变量DEFAULT_LOAD_FACTOR = 0.75f，默认加载因子为0.75

HashMap扩容的条件是：当size大于threshold时，对HashMap进行扩容  

扩容是是新建了一个HashMap的底层数组，而后调用transfer方法，将就HashMap的全部元素添加到新的HashMap中（要重新计算元素在新的数组中的索引位置）。 很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用HashMap的时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。
</code></pre><p> 加载因子，如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），对空间造成严重浪费。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下我们是无需修改的。另外，无论我们指定的容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，且最大值不能超过2的30次方。</p>
<p>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。</p>
<p>HashMap扩容时是当前容量翻倍即:capacity<em>2，Hashtable扩容时是容量翻倍+1即:capacity</em>2+1。</p>
<p>HashMap和Hashtable的底层实现都是数组+链表结构实现。</p>
<p>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;     </span><br><span class="line"></span><br><span class="line">h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);     </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h &amp; (length<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p>HashTable线程安全，低效，不支持null ,Hashtable是同步的</p>
<p>HashTable这个类实现了哈希表从key映射到value的数据结构形式。任何非null的对象都可以作为key或者value。</p>
<p>要在hashtable中存储和检索对象，作为key的对象必须实现hashCode、equals方法。</p>
<p>一般来说，默认的加载因子（0.75）提供了一种对于空间、时间消耗比较好的权衡策略。太高的值（指加载因子loadFactor）虽然减少了空间开销但是增加了检索时间，这反应在对hashtable的很多操作中，比如get、put方法。</p>
<p>初始容量的控制也是在空间消耗和rehash操作耗时(该操作耗时较大)二者之间的权衡。 如果初始容量大于哈希表的当前最大的条目数除以加载因子，则不会发生rehash。但是，将初始容量设置过高会浪费空间。</p>
<p>如果有大量的数据需要放进hashtable，则选择设置较大的初始容量比它自动rehash更优。</p>
<p>如果不需要线程安全的实现，建议使用HashMap代替Hashtable</p>
<p>如果想要一个线程安全的高并发实现，那么建议使用java.util.concurrent.ConcurrentHashMap取代了Hashtable。</p>
<p>HashTable的父类是Dictionary</p>
<p>HashTable:线程安全,HashTable方法有synchronized修饰</p>
<p>HashTable:保留了contains(),containsKey(),containsValue()</p>
<p>HashTable:key,value都不能为空.原因是源码中方法里会遍历entry,然后用entry的key或者value调用equals(),所以要先判断key/value是否为空,如果为空就会抛出异常</p>
<p>HashTable:使用Enumeration,Iterator</p>
<p>HashTable:数组初始大小为11,扩容方式为2*old+1</p>
<p>HashTable: 直接使用hashcode()</p>
<p>Hashtable同样是基于哈希表实现的，同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。</p>
<p>Hashtable也是JDK1.0引入的类，是线程安全的，能用于多线程环境中。</p>
<p>Hashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。</p>
<p>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模：</p>
<p><code>int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length;</code></p>
<p>底层数据结构是哈希表,特点和 hashMap 是一样的</p>
<p> 　　　　Hashtable 是线程安全的集合,是单线程的,运行速度慢</p>
<p> 　　　　HashMap 是线程不安全的集合,是多线程的,运行速度快</p>
<p> 　　　　Hashtable 命运和 Vector 是一样的,从 JDK1.2 开始,被更先进的 HashMap 取代</p>
<p>　　　　 HashMap 允许存储 null 值,null 健</p>
<p> 　　　　Hashtable 不允许存储 null 值,null 健</p>
<p>　　　　 Hashtable 他的孩子,子类 Properties 依然活跃在开发舞台</p>
<p>Properties</p>
<p>Java.util.Properties 集合<code>extends Hashtable&lt;k,v&gt;</code> 集合</p>
<p>Properties 集合特点：</p>
<p>Properties集合也是一个双列集合，key跟value都已经被内置为String类型</p>
<p>Properties集合是一个唯一和IO流相结合的集合</p>
<p>可以将集合中存储的临时数据，持久化到硬盘的文件中储存</p>
<p>可以把文件中储存对的键值对，读取到集合中使用</p>
<p>Properties集合的基本操作：添加数据，遍历集合,Key和value都已经被内置为String类型。里面包含了一些和String类的相关方法</p>
<p> Object setProperty(String key ,String value) 往集合中添加键值对，调用Hashtable的方法put添加</p>
<p> String getProperty(String key ) 通过key获取value的值，相当于Map集合中的get(key) 方法</p>
<p> <code>Set&lt;String &gt;   stringPropertyNames()</code>返回此属性列表的键集。相当于Map集合中的keySet()方法；</p>
<p>Properties类的load方法：</p>
<pre><code>可以把文件中存储的键值对,读取到集合中使用
</code></pre><p>  void load(Reader reader)  </p>
<p>  void load(InputStream inStream)  </p>
<p>  参数:</p>
<p> Reader reader:字符输入流,可以使用FileReader</p>
<p> InputStream inStream:字节输入流,可以使用FileInputStream</p>
<p> 操作步骤:</p>
<p> 1.创建Properties集合对象</p>
<p> 2.创建字符输入流FileReader对象,构造方法中绑定要读取的数据源</p>
<p> 3.使用Properties集合中的方法load,把文件中存储的键值对,读取到集合中使   用</p>
<p> 4.释放资源</p>
<p> 5.遍历Properties集合</p>
<p>注意:</p>
<p> 1.流使用Reader字符流,可以读取中文数据</p>
<p> 2.流使用InputStream字节流,不能操作中文,会有乱码</p>
<p> 3.Properties集合的配置文件中,可以使用注释单行数据,使用#</p>
<p> 4.Properties集合的配置文件中,key和value默认都是字符串,不用添加””(画蛇   添足)</p>
<p> 5.Properties集合的配置文件中,key和value的连接符号可以使用=,也可以使用   空格</p>
<p>Properties类的store方法使用：</p>
<p>可以把集合中存储的临时数据,持久化都硬盘的文件中存储</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> store(Writer writer, <span class="keyword">String</span> comments)  </span><br><span class="line"></span><br><span class="line">                     <span class="keyword">void</span> store(OutputStream out, <span class="keyword">String</span> comments)</span><br></pre></td></tr></table></figure>
<p> 参数:</p>
<p> Writer writer:字符输出流,可以使用FileWriter</p>
<p> OutputStream out:字节输出流,可以使用FileOutputStream</p>
<p> String comments:注释,解释说明存储的文件,不能使用中文(乱码),默认编码格式为   Unicode编码</p>
<p>可以使用””空字符串</p>
<p> 操作步骤:</p>
<p>  1.创建Properties集合,往集合中添加数据</p>
<p>  2.创建字符输出流FileWriter对象,构造方法中绑定要写入的目的地</p>
<p>  3.调用Properties集合中的方法store,把集合中存储的临时数据,持久化都硬盘的文  件中存储</p>
<p>  4.释放资源</p>
<p>注意:</p>
<p>  1.流使用Writer字符流,可以写入中文数据的</p>
<p>  2.流使用OutputStream字节流,不能操作中文,会有乱码</p>
<p>  3.Propertie集合存储的文件,一般都以.properties结尾(程序员默认)</p>
<p>HashMap多线程put操作后，get操作导致死循环。为何出现死循环？</p>
<p>大家都知道，HashMap采用链表解决Hash冲突，具体的HashMap的分析因为是链表结构，那么就很容易形成闭合的链路，这样在循环的时候只要有线程对这个HashMap进行get操作就会产生死循环。但是，我好奇的是，这种闭合的链路是如何形成的呢。在单线程情况下，只有一个线程对HashMap的数据结构进行操作，是不可能产生闭合的回路的。那就只有在多线程并发的情况下才会出现这种情况，那就是在put操作的时候，如果size&gt;initialCapacity*loadFactor，那么这时候HashMap就会进行rehash操作，随之HashMap的结构就会发生翻天覆地的变化。很有可能就是在两个线程在这个时候同时触发了rehash操作，产生了闭合的回路。</p>
<p>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，急需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</p>
<p>HashMap存储自定义类型:使用HashMap储存自定义类形式，因为要保证key的唯一性。需要 自定义类重写  hashCode()跟equals()方法；</p>
<p>HashMap的方法基本都是Map中声明的方法</p>
<p>实现原理：实现一个哈希表，存储元素(key/value)时，用key计算hash值，如果hash值没有碰撞，则只用数组存储元素；如果hash值碰撞了，则相同的hash值的元素用链表存储；如果相同hash值超过8个，则相同的hash值的元素用红黑树存储。获取元素时，用key计算hash值，用hash值计算元素在数组中的下标，取得元素如果命中，则返回；如果不是就在红黑树或链表中找。</p>
<p>PS：存储元素的数组是有冗余的。</p>
<p>采用了Fail-Fast机制，通过一个modCount值记录修改次数，在迭代过程中，判断modCount跟初始过程记录的expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常；另外扩容过程中还有可能产生环形链表。</p>
<p>synchronized是针对整张Hash表的，即每次锁住整张表让线程独占</p>
<h4 id="LinkeHashMap"><a href="#LinkeHashMap" class="headerlink" title="LinkeHashMap"></a>LinkeHashMap</h4><p>LinkedHashMap继承自HashMap，实现了<code>Map&lt;K,V&gt;</code>接口。其内部还维护了一个双向链表，在每次插入数据，或者访问、修改数据时，会增加节点、或调整链表的节点顺序。以决定迭代时输出的顺序。</p>
<p>默认情况，遍历时的顺序是按照插入节点的顺序。这也是其与HashMap最大的区别。 </p>
<p>也可以在构造时传入accessOrder参数，使得其遍历顺序按照访问的顺序输出。</p>
<p>LinkedHashMap在实现时，就是重写override了几个方法。以满足其输出序列有序的需求。</p>
<p>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。</p>
<p>在遍历的时候会比HashMap慢，不过有种情况例外：当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢。因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和它的容量有关。</p>
<p>LinkedHashMap是HashMap的子类，保存了插入的顺序，需要输出的顺序和输入的顺序相同时可用LinkedHashMap；</p>
<p>LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现.</p>
<p>LinkedHashMap取键值对时，是按照你放入的顺序来取的。</p>
<p>LinkedHashMap由于它的插入有序特性，也是一种比较常用的Map集合。它继承了HashMap，很多方法都直接复用了父类HashMap的方法。本文将探讨LinkedHashMap的内部实现，以及它是如何保证插入元素是按插入顺序排序的。</p>
<p>在分析前可以先思考下，既然是按照插入顺序，并且以Linked-开头，就很有可能是链表实现。如果纯粹以链表实现，也不是不可以，LinkedHashMap内部维护一个链表，插入一个元素则把它封装成Entry节点，并把它插入到链表尾部。功能可以实现，但这带来的查找效率达到了O(n)，显然远远大于HashMap在没有冲突的情况下O(1)的时间复杂度。这就丝毫不能体现出Map这种数据结构随机存取快的优点。</p>
<p>所以显然，LinkedHashMap不可能只有一个链表来维护Entry节点，它极有可能维护了两种数据结构：散列表+链表。</p>
<p>　</p>
<p>LinkedHashMap的LRU特性</p>
<p>先讲一下LRU的定义：LRU(Least Recently Used),即最近最少使用算法，最初是用于内存管理中将无效的内存块腾出而用于加载数据以提高内存使用效率而发明的算法。</p>
<p>目前已经普遍用于提高缓存的命中率，如Redis、Memcached中都有使用。</p>
<p>为啥说LinkedHashMap本身就实现了LRU算法？原因就在于它额外维护的双向链表中。</p>
<p>在上面已经提到过，在做get/put操作时，LinkedHashMap会将当前访问/插入的节点移动到链表尾部，所以此时链表头部的那个节点就是 “最近最少未被访问”的节点。</p>
<p>举个例子：</p>
<p>往一个空的LinkedHashMap中插入A、B、C三个结点，那么链表会经历以下三个状态：</p>
<ol>
<li><p>A   插入A节点，此时整个链表只有这一个节点，既是头节点也是尾节点</p>
</li>
<li><p>A  -&gt;  B   插入B节点后，此时A为头节点，B为尾节点，而最近最常访问的节点就是B节点（刚被插入），而最近最少使用的节点就是A节点（相对B节点来讲，A节点已经有一段时间没有被访问过）</p>
</li>
<li><p>A  -&gt;  B  -&gt;  C  插入C节点后，此时A为头节点，C为尾节点，而最近最常访问的节点就是C节点（刚被插入），最近最少使用的节点就是A节点 （应该很好理解了吧  : )）</p>
</li>
</ol>
<p>那么对于缓存来讲，A就是我最长时间没访问过的缓存，C就是最近才访问过的缓存，所以当缓存队列满时就会从头开始替换新的缓存值进去，从而保证缓存队列中的缓存尽可能是最近一段时间访问过的缓存，提高缓存命中率。</p>
<p> LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序。</p>
<p>默认是按键的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</p>
<p>TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。</p>
<p>TreeMap是基于红黑树结构实现的一种Map，要分析TreeMap的实现首先就要对红黑树有所了解。</p>
<p>要了解什么是红黑树，就要了解它的存在主要是为了解决什么问题，对比其他数据结构比如数组，链表，Hash表等树这种结构又有什么优点。</p>
<p>treeMap实现了sortMap接口，能够把保存的数据按照键的值排序，默认是按照自然数排序也可自定义排序方式。</p>
<p>TreeMap对键进行排序了。</p>
<p>当用Iterator遍历TreeMap时，得到的记录是排过序的。</p>
<p>如果使用排序的映射，建议使用TreeMap。</p>
<p>在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
<p>  二叉树插入元素是有顺序的，TreeSet的元素是有序的。</p>
<p> 由于二叉树需要对结点排序（插入的结点位置），默认情况下没有排序方法，所以元素需要继承Comparator并重写compareTo方法来实现元素之间比较大小的功能。</p>
<p>  对于TreeSet，compareTo方法来保证元素的唯一性。【这时候可以不重写equals】</p>
<p>二叉树需要结点排序，所以元素之间比较能够比较，所以对于自定义元素对象，需要继承Comparator并重写的compareTo方法。 两个元素相等时，compareTo返回0；左大于右时，返回正整数（一般返回1）;小于时返回负整数（一般返回-1）</p>
<p>TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n)</p>
<p>TreeMap中默认的排序为升序</p>
<p>使用entrySet遍历方式要比keySet遍历方式快</p>
<p>entrySet遍历方式获取Value对象是直接从Entry对象中直接获得，时间复杂度T(n)=o(1);</p>
<p>keySet遍历获取Value对象则要从Map中重新获取，时间复杂度T(n)=o(n);keySet遍历Map方式比entrySet遍历Map方式多了一次循环，多遍历了一次table，当Map的size越大时，遍历的效率差别就越大。</p>
<p> HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。</p>
<p>在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。</p>
<p>TreeMap 底层数据结构是红黑树(一种自平衡的二叉树) ，其根据比较的返回值是否是0来保证元素唯一性， 元素的排序通过两种方式：第一种是自然排序(元素具备比较性) 即让元素所属的类实现Comparable接口，第二种是比较器排序(集合具备比较性) ，即让集合接收一个Comparator的实现类对象。</p>
<p>Comparable 和 Comparator 的区别：</p>
<p>　　Comparable 是一个比较的标准，里面有比较的方法，对象要具有比较的标准，就必须实现 Comparable 接口；类实现这个接口，就有比较的方法；把元素放到 TreeSet 里面去，就会自动的调用 CompareTo 方法；但是这个 Comparable  并不是专为 TreeSet 设计的；只是说，TreeSet 顺便利用而已；就像 HashCode 和 equals  也一样，不是专门为 HashSet 设计一样；只是你顺便利用而已。</p>
<p>　　Compartor 是个比较器，也不是专门为TreeSet设计. 就是一个第三方的比较器接口；如果对象没有比较性，自己就可以按照比较器的标准，设计一个比较器，创建一个类，实现这个接口，覆写方法。</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p> Queue用于模拟队列这种数据结构，实现“FIFO”等数据结构。即第一个放进去就是第一个拿出来的元素（从一端进去，从另一端出来）。队列常作被当作一个可靠的将对象从程序的某个区域传输到另一个区域的途径。通常，队列不允许随机访问队列中的元素。</p>
<p>Queue 接口并未定义阻塞队列的方法，而这在并发编程中是很常见的。BlockingQueue 接口定义了那些等待元素出现或等待队列中有可用空间的方法，这些方法扩展了此接口。</p>
<p> Queue 实现通常不允许插入 null 元素，尽管某些实现（如 LinkedList）并不禁止插入 null。即使在允许 null 的实现中，也不应该将 null 插入到 Queue 中，因为 null 也用作 poll 方法的一个特殊返回值，表明队列不包含元素。 </p>
<p>LinkedList提供了方法以支持队列的行为，并且实现了Queue接口。通过LinkedList向上转型（up cast）为Queue，看Queue的实现就知道相对于LinkedList，Queue添加了element、offer、peek、poll、remove方法</p>
<p>offer：在允许的情况下，将一个元素插入到队尾，或者返回false</p>
<p>peek，element：在不移除的情况下返回队头，peek在队列为空返回null，element抛异常NoSuchElementException</p>
<p>poll,remove：移除并返回队头，poll当队列为空是返回null，remove抛出NoSuchElementException异常</p>
<p>注意：queue.offer在自动包装机制会自动的把random.nextInt转化程Integer，把char转化成Character</p>
<h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><p>Deque是Queue的子接口,我们知道Queue是一种队列形式,而Deque则是双向队列,它支持从两个端点方向检索和插入元素,因此Deque既可以支持LIFO形式也可以支持LIFO形式.Deque接口是一种比Stack和Vector更为丰富的抽象数据形式,因为它同时实现了以上两者.</p>
<p>添加功能</p>
<p>void push(E) 向队列头部插入一个元素,失败时抛出异常</p>
<p>void addFirst(E) 向队列头部插入一个元素,失败时抛出异常</p>
<p>void addLast(E) 向队列尾部插入一个元素,失败时抛出异常</p>
<p>boolean offerFirst(E) 向队列头部加入一个元素,失败时返回false</p>
<p>boolean offerLast(E) 向队列尾部加入一个元素,失败时返回false</p>
<p>获取功能</p>
<p>E getFirst() 获取队列头部元素,队列为空时抛出异常</p>
<p>E getLast() 获取队列尾部元素,队列为空时抛出异常</p>
<p>E peekFirst() 获取队列头部元素,队列为空时返回null</p>
<p>E peekLast() 获取队列尾部元素,队列为空时返回null</p>
<p>删除功能</p>
<p>boolean removeFirstOccurrence(Object) 删除第一次出现的指定元素,不存在时返回false</p>
<p>boolean removeLastOccurrence(Object) 删除最后一次出现的指定元素,不存在时返回false</p>
<p>弹出功能</p>
<p>E pop() 弹出队列头部元素,队列为空时抛出异常</p>
<p>E removeFirst() 弹出队列头部元素,队列为空时抛出异常</p>
<p>E removeLast() 弹出队列尾部元素,队列为空时抛出异常</p>
<p>E pollFirst() 弹出队列头部元素,队列为空时返回null</p>
<p>E pollLast() 弹出队列尾部元素,队列为空时返回null</p>
<p>迭代器</p>
<p><code>Iterator&lt;E&gt; descendingIterator()</code> 返回队列反向迭代器</p>
<p>同Queue一样,Deque的实现也可以划分成通用实现和并发实现.</p>
<p>　　通用实现主要有两个实现类ArrayDeque和LinkedList.</p>
<p>　　ArrayDeque是个可变数组,它是在Java 6之后新添加的,而LinkedList是一种链表结构的list,LinkedList要比ArrayDeque更加灵活,因为它也实现了List接口的所有操作,并且可以插入null元素,这在ArrayDeque中是不允许的.</p>
<p>　　从效率来看,ArrayDeque要比LinkedList在两端增删元素上更为高效,因为没有在节点创建删除上的开销.最适合使用LinkedList的情况是迭代队列时删除当前迭代的元素.此外LinkedList可能是在遍历元素时最差的数据结构,并且也LinkedList占用更多的内存,因为LinkedList是通过链表连接其整个队列,它的元素在内存中是随机分布的,需要通过每个节点包含的前后节点的内存地址去访问前后元素.</p>
<p>　　总体ArrayDeque要比LinkedList更优越,在大队列的测试上有3倍与LinkedList的性能,最好的是给ArrayDeque一个较大的初始化大小,以避免底层数组扩容时数据拷贝的开销.</p>
<p>　　LinkedBlockingDeque是Deque的并发实现,在队列为空的时候,它的takeFirst,takeLast会阻塞等待队列处于可用状态</p>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得 Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p>
<p>栈，是指“LIFO”先进后出的集合容器，最后一个压入的元素是第一个出来的，就好比我们洗碗一样（或者叠罗汉）第一个摆放的碗放在最下面，自然是最后一个拿出来的。Stack是由LinkedList实现的，作为Stack的实现，下面是《java编程思想》给出基本的Stack实现：</p>
<p>peek和pop是返回T类型的对象。peek方法提供栈顶元素，但不删除栈顶，而pop是返回并删除栈顶元素;</p>
<h4 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h4><p>ArrayDeque类是双端队列的实现类，类的继承结构如下面，继承自AbastractCollection（该类实习了部分集合通用的方法，其实现了Collection接口），其实现的接口Deque接口中定义了双端队列的主要的方法，比如从头删除，从尾部删除，获取头数据，获取尾部数据等等。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ArrayDeque&lt;E&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractCollection&lt;E&gt;</span>                           <span class="title">implements</span> <span class="title">Deque&lt;E&gt;</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>ArrayDeque基本特征</p>
<p>就其实现而言，ArrayDeque采用了循环数组的方式来完成双端队列的功能。 </p>
<ol>
<li><p>无限的扩展，自动扩展队列大小的。（当然在不会内存溢出的情况下。） </p>
</li>
<li><p>非线程安全的，不支持并发访问和修改。 </p>
</li>
<li><p>支持fast-fail. </p>
</li>
<li><p>作为栈使用的话比比栈要快. </p>
</li>
<li><p>当队列使用比linklist要快。 </p>
</li>
<li><p>null元素被禁止使用。</p>
</li>
</ol>
<p>最小初始化容量限制8(必须是2的幂次)</p>
<p>扩容:之所以说该ArrayDeque容量无限制，是因为只要检测到head==tail的时候，就直接调用doubleCapacity方法进行扩容。</p>
<p>删除元素:删除元素的基本思路为确定那一侧的数据少，少的一侧移动元素位置，这样效率相对于不比较更高些，然后，判断head是跨越最大值还是为跨越最大值，继而可以分两种不同的情况进行拷贝。但是该方法比较慢，因为存在数组的拷贝。</p>
<p>获取并删除元素:这里在举个简单点的例子，中间判断是不是null，可以看出该队列不支持null,通过把其值设为null就算是将其删除了。然后head向递增的方向退一位即可。 </p>
<p>ArrayDeque和LinkedList是Deque的两个通用实现</p>
<p>ArrayDeque不是线程安全的。 </p>
<p>ArrayDeque不可以存取null元素，因为系统根据某个位置是否为null来判断元素的存在。 </p>
<p>当作为栈使用时，性能比Stack好；当作为队列使用时，性能比LinkedList好。 </p>
<p> 1.添加元素        addFirst(E e)在数组前面添加元素        addLast(E e)在数组后面添加元素        offerFirst(E e) 在数组前面添加元素，并返回是否添加成功        offerLast(E e) 在数组后天添加元素，并返回是否添加成功  </p>
<p> 2.删除元素        removeFirst()删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常        pollFirst()删除第一个元素，并返回删除元素的值，如果元素为null，将返回null           removeLast()删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常        pollLast()删除最后一个元素，并返回删除元素的值，如果为null，将返回null           removeFirstOccurrence(Object o) 删除第一次出现的指定元素        removeLastOccurrence(Object o) 删除最后一次出现的指定元素     </p>
<p> 3.获取元素        getFirst() 获取第一个元素,如果没有将抛出异常        getLast() 获取最后一个元素，如果没有将抛出异常       </p>
<p> 4.队列操作        add(E e) 在队列尾部添加一个元素        offer(E e) 在队列尾部添加一个元素，并返回是否成功        remove() 删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())           poll()  删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())           element() 获取第一个元素，如果没有将抛出异常        peek() 获取第一个元素，如果返回null          </p>
<p> 5.栈操作        push(E e) 栈顶添加一个元素        pop(E e) 移除栈顶元素,如果栈顶没有元素将抛出异常            </p>
<p> 6.其他        size() 获取队列中元素个数        isEmpty() 判断队列是否为空        iterator() 迭代器，从前向后迭代        descendingIterator() 迭代器，从后向前迭代        contain(Object o) 判断队列中是否存在该元素        toArray() 转成数组        clear() 清空队列        clone() 克隆(复制)一个新的队列</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>我们知道队列是遵循先进先出（First-In-First-Out）模式的，但有些时候需要在队列中基于优先级处理对象。举个例子，比方说我们有一个每日交易时段生成股票报告的应用程序，需要处理大量数据并且花费很多处理时间。客户向这个应用程序发送请求时，实际上就进入了队列。我们需要首先处理优先客户再处理普通用户。在这种情况下，Java的PriorityQueue(优先队列)会很有帮助。</p>
<p>PriorityQueue类在Java1.5中引入并作为 Java Collections Framework 的一部分。PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。</p>
<p>优先队列不允许空值，而且不支持non-comparable（不可比较）的对象，比如用户自定义的类。优先队列要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。</p>
<p>优先队列的头是基于自然排序或者Comparator排序的最小元素。如果有多个对象拥有同样的排序，那么就可能随机地取其中任意一个。当我们获取队列时，返回队列的头对象。</p>
<p>优先队列的大小是不受限制的，但在创建时可以指定初始大小。当我们向优先队列增加元素的时候，队列大小会自动增加。</p>
<p>PriorityQueue是非线程安全的，所以Java提供了PriorityBlockingQueue（实现BlockingQueue接口）用于Java多线程环境。</p>
<p>由于知道PriorityQueue是基于Heap的，当新的元素存储时，会调用siftUpUsingComparator方法</p>
<p>PriorityQueue的逻辑结构是一棵完全二叉树，存储结构其实是一个数组。逻辑结构层次遍历的结果刚好是一个数组。</p>
<p>PriorityQueue优先队列,它逻辑上使用堆结构（完全二叉树）实现，物理上使用动态数组实现，并非像TreeMap一样完全有序，但是如果按照指定方式出队，结果可以是有序的。</p>
<p>这里的堆是一种数据结构而非计算机内存中的堆栈。堆结构在逻辑上是完全二叉树，物理存储上是数组。</p>
<p>完全二叉树并不是堆结构，堆结构是不完全有序的完全二叉树。</p>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>Java中Queue的最重要的应用大概就是其子类BlockingQueue了。</p>
<p>考虑到生产者消费者模型，我们有多个生产者和多个消费者，生产者不断提供资源给消费者，但如果它们的生产/消费速度不匹配或者不稳定，则会造成大量的生产者闲置/消费者闲置。此时，我们需要使用一个缓冲区来存储资源，即生产者将资源置于缓冲区，而消费者不断地从缓冲区中取用资源，从而减少了闲置和阻塞。</p>
<p>BlockingQueue，阻塞队列，即可视之为一个缓冲区应用于多线程编程之中。当队列为空时，它会阻塞所有消费者线程，而当队列为满时，它会阻塞所有生产者线程。</p>
<p>在queue的基础上，BlockingQueue又添加了以下方法：</p>
<p> put：队列末尾添加一个元素，若队列已满阻塞。</p>
<p> take：移除并返回队列头部元素，若队列已空阻塞。</p>
<p> drainTo:一次性获取所有可用对象，可以用参数指定获取的个数，该操作是原子操作，不需要针对每个元素的获取加锁。</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>由一个定长数组和两个标识首尾的整型index标识组成，生产者放入数据和消费者取出数据对于ArrayBlockingQueue而言使用了同一个锁（一个私有的ReentrantLock），因而无法实现真正的并行。可以在初始化时除长度参数以外，附加一个boolean类型的变量，用于给其私有的ReentrantLock进行初始化（初始化是否为公平锁，默认为false）。</p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>LinkedBlockingQueue的最大特点是，若没有指定最大容量，其可以视为无界队列（有默认最大容量限制,往往系统资源耗尽也无法达到）。即，不对生产者的行为加以限制，只在队列为空的时候限制消费者的行为。LinkedBlockingQueue采用了读写分离的两个ReentrantLock去控制put和take，因而有了更好的性能（类似读写锁提供读写场景下更好的性能），如下：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span>    </span><br><span class="line"><span class="keyword">private</span> final ReentrantLock takeLock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>();    </span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span>   </span><br><span class="line"><span class="keyword">private</span> final Condition notEmpty = takeLock.<span class="keyword">new</span><span class="type">Condition</span>();    </span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span>   </span><br><span class="line"><span class="keyword">private</span> final ReentrantLock putLock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>();   </span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span>   </span><br><span class="line"><span class="keyword">private</span> final Condition notFull = putLock.<span class="keyword">new</span><span class="type">Condition</span>();</span><br></pre></td></tr></table></figure>
<p>ArrayBlockingQueue和LinkedBlockingQueue是最常用的两种阻塞队列。</p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>PriorityBlockingQueue是对PriorityQueue的包装，因而也是一个优先队列。其优先级默认是直接比较，大者先出队，也可以从构造器传入自定义的Comparator。由于PriorityQueue从实现上是一个无界队列，PriorityBlockingQueue同样是一个无界队列，对生产者不做限制。</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>DelayQueue是在PriorityBlockingQueue的基础上包装产生的，它用于存放Delayed对象，该队列的头部是延迟期满后保存时间最长的Delayed元素（即，以时间为优先级利用PriorityBlockingQueue），当没有元素延迟期满时，对其进行poll操作将会返回Null。take操作会阻塞。</p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>SynchronousQueue十分特殊，它没有容量——换言之，它是一个长度为0的BlockingQueue，生产者和消费者进行的是无中介的直接交易，当生产者/消费者没有找到合适的目标时，即会发生阻塞。但由于减少了环节，其整体性能在一些系统中可能更加适合。该方法同样支持在构造时确定为公平/默认的非公平模式，如果是非公平模式，有可能会导致某些生产者/消费者饥饿。</p>
<h4 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h4><p>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</p>
<h4 id="EnumSet类"><a href="#EnumSet类" class="headerlink" title="EnumSet类"></a>EnumSet类</h4><p>EnumSet是一个专门为枚举设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值，该枚举类型的创建Enumset时显示会隐式的指定。Enumset的集合元素也是有序的，EnumSet以枚举值在Enum类内定义的顺序来决定集合元素的顺序。</p>
<h4 id="使用Java8新增的Predicate操作集合"><a href="#使用Java8新增的Predicate操作集合" class="headerlink" title="使用Java8新增的Predicate操作集合"></a>使用Java8新增的Predicate操作集合</h4><p>Java 8为Collection集合新增了removeIf(Predicate filter)方法，该方法将会批量删除符合条件的filter条件的所有元素</p>
<h4 id="使用java-8-新增的Stream操作集合"><a href="#使用java-8-新增的Stream操作集合" class="headerlink" title="使用java 8 新增的Stream操作集合"></a>使用java 8 新增的Stream操作集合</h4><p>Java8新增了Stream、IntStream、LongStream、DoubleStream等流式API，这些API代表了多个支持串行和并行聚集操作的元素，其中Stream是一个通用的流接口，而IntStream、LongStream、DoubleStream则代表了类型为int，long，double的流。</p>
<p>独立使用Stream的步骤如下:</p>
<p>1、使用Stream或XxxStream的builder()类方法创建该Stream对应的Builder。</p>
<p> 2、重复调用Builder的add()方法向该流中的添加多个元素</p>
<p> 3、调用Builder的build()方法获取对应的Stream</p>
<p> 4、调用Stream的聚集方法。</p>
<p>在Stream中方法分为两类中间方法和末端方法</p>
<p>中间方法：中间操作允许流保持打开状态,并允许直接调用后续方法。上面程序中的map()方法就是中间方法。</p>
<p>末端方法：末端方法是对流的最终操作。当对某个Stream执行末端方法后，该流将会被”消耗”且不再可用。上面程序中的sum()、count()、average()等方法都是末端方法。</p>
<p>除此之外，关于流的方法还有如下特征：</p>
<p>有状态的方法：这种方法会给你流增加一些新的属性，比如元素的唯一性、元素的最大数量、保证元素的排序的方式被处理等。有状态的方法往往需要更大的性能开销</p>
<p>短路方法:短路方法可以尽早结束对流的操作，不必检查所有的元素。</p>
<h2 id="对CAS的理解，CAS带来的问题，如何解决这些问题？"><a href="#对CAS的理解，CAS带来的问题，如何解决这些问题？" class="headerlink" title="对CAS的理解，CAS带来的问题，如何解决这些问题？"></a>对CAS的理解，CAS带来的问题，如何解决这些问题？</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>回答这个问题，可以先介绍一下锁要解决的问题，以及锁机制的缺点。</p>
<p>引入锁就是为了解决多线程竞争同一个资源时，出现脏读、数据不一致问题。一般我们常用的是synchronized等排他锁，</p>
<p>这种锁存在的问题：</p>
<p>1、多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调 度延时，引起性能问题</p>
<p>2、一个线程持有锁会导致其它所有需要此锁的线程挂起直至该锁释放</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>cas是另一个无锁解决方案，更准确的是采用乐观锁技术，实现线程安全的问题。cas有三个操作数—-内存对象（V）、预期原值（A）、新值（B）。</p>
<p>CAS原理就是对v对象进行赋值时，先判断原来的值是否为A，如果为A，就把新值B赋值到V对象上面，如果原来的值不是A（代表V的值放生了变化），就不赋新值。</p>
<p>我们看一下AtomicInteger类，AtomicInteger是线程安全的，我们看一下源码</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically adds the given value to the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> unsafe.<span class="title">getAndAddInt</span><span class="params">(<span class="keyword">this</span>, valueOffset, delta)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一下unsafe源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> var6;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var6 = <span class="keyword">this</span>.getLongVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapLong(var1, var2, var6, var6 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到do while自循环，这里为什么会有自循环，就是在 判断预期原值 如果与原来的值不符合，会再循环取原值，再走CAS流程，直到能够把新值B赋值成功。</p>
<h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><p>cas这个方式也存在一定的问题：</p>
<p>1、自循环时间长，开销大</p>
<p>2、只能保证一个共享变量的原子操作</p>
<p>3、ABA问题</p>
<h4 id="什么是ABA问题？"><a href="#什么是ABA问题？" class="headerlink" title="什么是ABA问题？"></a>什么是ABA问题？</h4><p>考虑如下操作：</p>
<p>并发1（上）：获取出数据的初始值是A，后续计划实施CAS乐观锁，期望数据仍是A的时候，修改才能成功</p>
<p>并发2：将数据修改成B</p>
<p>并发3：将数据修改回A</p>
<p>并发1（下）：CAS乐观锁，检测发现初始值还是A，进行数据修改</p>
<p>上述并发环境下，并发1在修改数据时，虽然还是A，但已经不是初始条件的A了，中间发生了A变B，B又变A的变化，此A已经非彼A，数据却成功修改，可能导致错误，这就是CAS引发的所谓的ABA问题。</p>
<p>库存操作，出现ABA问题并不会对业务产生影响。<br>堆栈操作，会出现ABA的问题。</p>
<h4 id="ABA问题的优化"><a href="#ABA问题的优化" class="headerlink" title="ABA问题的优化"></a>ABA问题的优化</h4><p>ABA问题导致的原因，是CAS过程中只简单进行了“值”的校验，再有些情况下，“值”相同不会引入错误的业务逻辑（例如库存），有些情况下，“值”虽然相同，却已经不是原来的数据了。</p>
<p>优化方向：CAS不能只比对“值”，还必须确保的是原来的数据，才能修改成功。</p>
<p>常见实践：“版本号”的比对，一个数据一个版本，版本变化，即使值相同，也不应该修改成功。</p>
<h4 id="一个共享变量的原子操作问题优化"><a href="#一个共享变量的原子操作问题优化" class="headerlink" title="一个共享变量的原子操作问题优化"></a>一个共享变量的原子操作问题优化</h4><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p>
<h2 id="volatile底层、synchronized底层、锁升级的过程、MESI"><a href="#volatile底层、synchronized底层、锁升级的过程、MESI" class="headerlink" title="volatile底层、synchronized底层、锁升级的过程、MESI"></a>volatile底层、synchronized底层、锁升级的过程、MESI</h2><h3 id="volatile底层"><a href="#volatile底层" class="headerlink" title="volatile底层"></a>volatile底层</h3><p>Java语言规范对于volatile定义如下：</p>
<p>Java编程语言允许线程访问共享变量，为了确保共享变量能够被准确和一致性地更新，线程应该确保通过排它锁单独获得这个变量。</p>
<p>首先我们从定义开始入手，官方定义比较拗口。通俗来说就是一个字段被volatile修饰，Java的内存模型确保所有的线程看到的这个变量值是一致的，但是它并不能保证多线程的原子操作。这就是所谓的线程可见性。我们要知道他是不能保证原子性的。</p>
<h4 id="内存模型相关概念"><a href="#内存模型相关概念" class="headerlink" title="内存模型相关概念"></a>内存模型相关概念</h4><p>Java线程之间的通信由Java内存模型(JMM)控制，JMM决定一个线程对共享变量的修改何时对另外一个线程可见。JMM定义了线程与主内存的抽象关系：线程之间的变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存(Local Memory)保存着共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/17987782-450f4a923f40b9f4.png" alt="image"></p>
<p>如果线程A与线程B通信：</p>
<ul>
<li>线程A要先把本地内存A中更新过的共享变量刷写到主内存中。</li>
<li>线程B到主内存中读取线程A更新后的共享变量</li>
</ul>
<p>计算机在运行程序时，每条指令都是在CPU中执行的，在执行过程中势必会涉及到数据的读写。我们知道程序运行的数据是存储在主存中，这时就会有一个问题，读写主存中的数据没有CPU中执行指令的速度快，如果任何的交互都需要与主存打交道则会大大影响效率，所以就有了CPU高速缓存。CPU高速缓存为某个CPU独有，只与在该CPU运行的线程有关。</p>
<p>有了CPU高速缓存虽然解决了效率问题，但是它会带来一个新的问题：数据一致性。在程序运行中，会将运行所需要的数据复制一份到CPU高速缓存中，在进行运算时CPU不再也主存打交道，而是直接从高速缓存中读写数据，只有当运行结束后才会将数据刷新到主存中。</p>
<p>举个例子：</p>
<p><code>i++;</code></p>
<p>当线程运行这行代码时，首先会从主内存中读取i，然后复制一份到CPU高速缓存中,接着CPU执行+1的操作，再将+1后的数据写在缓存中，最后一步才是刷新到主内存中。在单线程时没有问题，多线程就有问题了。</p>
<p>如下：假如有两个线程A、B都执行这个操作（i++），按照我们正常的逻辑思维主存中的i值应该=3，但事实是这样么？</p>
<blockquote>
<p>分析如下：两个线程从主存中读取i的值（1）到各自的高速缓存中，然后线程A执行+1操作并将结果写入高速缓存中，最后写入主存中，此时主存i==2,线程B做同样的操作，主存中的i仍然=2。所以最终结果为2并不是3。这种现象就是缓存一致性问题。</p>
</blockquote>
<p>解决缓存一致性方案有两种：</p>
<p>通过在总线加LOCK#锁的方式；</p>
<p>通过缓存一致性协议。</p>
<p>但是方案1存在一个问题，它是采用一种独占的方式来实现的，即总线加LOCK#锁的话，只能有一个CPU能够运行，其他CPU都得阻塞，效率较为低下。</p>
<p>第二种方案，缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。所以JMM就解决这个问题。</p>
<h4 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h4><p>有volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令，该指令在多核处理器下会引发两件事情。</p>
<ul>
<li>将当前处理器缓存行数据刷写到系统主内存。</li>
<li>这个刷写回主内存的操作会使其他CPU缓存的该共享变量内存地址的数据无效。</li>
</ul>
<p>这样就保证了多个处理器的缓存是一致的，对应的处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器缓存行设置无效状态，当处理器对这个数据进行修改操作的时候会重新从主内存中把数据读取到缓存里。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>volatile经常用于两个场景：状态标记、double check</p>
<p>1、状态标记<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line">boolean <span class="built_in">stop</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">stop</span>)&#123;</span><br><span class="line">   doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="built_in">stop</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>但是加上volatile就没问题了。如下所示：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">   doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  </span><br><span class="line">inited = <span class="keyword">true</span>;            </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></p>
<p>2、double check<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">   private volatile static Singleton<span class="built_in"> instance </span>= <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   private Singleton() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   public static Singleton getInstance() &#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="attribute">instance</span>==null) &#123;</span><br><span class="line">           synchronized (Singleton.class) &#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="attribute">instance</span>==null)</span><br><span class="line">                  <span class="built_in"> instance </span>= new Singleton();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="synchronized底层"><a href="#synchronized底层" class="headerlink" title="synchronized底层"></a>synchronized底层</h3><p>上面有写</p>
<h3 id="锁升级的过程"><a href="#锁升级的过程" class="headerlink" title="锁升级的过程"></a>锁升级的过程</h3><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率，下文会详细分析。</p>
<h4 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h4><p>因为偏向锁，锁住对象时，会写入对象头相应的标识，我们先把对象头(官方叫法为:Mark Word)的图示如下(借用了网友的图片):</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180619193100237.jpeg" alt="image"></p>
<h4 id="偏向锁-1"><a href="#偏向锁-1" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>HotSpot [1] 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p>上文中黑体字部分，写得太简略，以致于很多初学者，对这个过程有点不明白，这个过程是怎么实现锁的升级、释放的？下面一一分析</p>
<ol>
<li>线程2来竞争锁对象;</li>
<li>判断当前对象头是否是偏向锁;</li>
<li>判断拥有偏向锁的线程1是否还存在;</li>
<li>线程1不存在,直接设置偏向锁标识为0(线程1执行完毕后,不会主动去释放偏向锁);</li>
<li>使用cas替换偏向锁线程ID为线程2,锁不升级，仍为偏向锁;</li>
<li>线程1仍然存在,暂停线程1；</li>
<li>设置锁标志位为00(变为轻量级锁),偏向锁为0;</li>
<li>从线程1的空闲monitor record中读取一条,放至线程1的当前monitor record中;</li>
<li>更新mark word，将mark word指向线程1中monitor record的指针;</li>
<li>继续执行线程1的代码;</li>
<li>锁升级为轻量级锁;</li>
<li>线程2自旋来获取锁对象;</li>
</ol>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180619200443603.png" alt="image"></p>
<h4 id="轻量级锁-1"><a href="#轻量级锁-1" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>（1）轻量级锁加锁<br>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。<br>（2）轻量级锁解锁<br>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/20180619194820999.png" alt="image"><br>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h3 id="缓存一致性和MESI"><a href="#缓存一致性和MESI" class="headerlink" title="缓存一致性和MESI"></a>缓存一致性和MESI</h3><p>缓存一致性协议给缓存行（通常为64字节）定义了个状态：独占（exclusive）、共享（share）、修改（modified）、失效（invalid），用来描述该缓存行是否被多处理器共享、是否修改。所以缓存一致性协议也称MESI协议。</p>
<ul>
<li>独占（exclusive）：仅当前处理器拥有该缓存行，并且没有修改过，是最新的值。</li>
<li>共享（share）：有多个处理器拥有该缓存行，每个处理器都没有修改过缓存，是最新的值。</li>
<li>修改（modified）：仅当前处理器拥有该缓存行，并且缓存行被修改过了，一定时间内会写回主存，会写成功状态会变为S。</li>
<li><p>失效（invalid）：缓存行被其他处理器修改过，该值不是最新的值，需要读取主存上最新的值。<br>协议协作如下：</p>
</li>
<li><p>一个处于M状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回CPU。</p>
</li>
<li>一个处于S状态的缓存行，必须时刻监听使该缓存行无效或者独享该缓存行的请求，如果监听到，则必须把其缓存行状态设置为I。</li>
<li>一个处于E状态的缓存行，必须时刻监听其他试图读取该缓存行对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S。</li>
<li>当CPU需要读取数据时，如果其缓存行的状态是I的，则需要从内存中读取，并把自己状态变成S，如果不是I，则可以直接读取缓存中的值，但在此之前，必须要等待其他CPU的监听结果，如其他CPU也有该数据的缓存且状态是M，则需要等待其把缓存更新到内存之后，再读取。</li>
<li>当CPU需要写数据时，只有在其缓存行是M或者E的时候才能执行，否则需要发出特殊的RFO指令(Read Or Ownership，这是一种总线事务)，通知其他CPU置缓存无效(I)，这种情况下会性能开销是相对较大的。在写入完成后，修改其缓存状态为M。</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/WechatIMG256.png" alt="image"></p>
<p>这个图的含义就是当一个core持有一个cacheline的状态为Y时,其它core对应的cacheline应该处于状态X, 比如地址 0x00010000 对应的cacheline在core0上为状态M, 则其它所有的core对应于0x00010000的cacheline都必须为I , 0x00010000 对应的cacheline在core0上为状态S, 则其它所有的core对应于0x00010000的cacheline 可以是S或者I ,</p>
<p>另外MESI协议为了提高性能，引入了Store Buffe和Invalidate Queues，还是有可能会引起缓存不一致，还会再引入内存屏障来确保一致性，可以参考[7]和[12]</p>
<h5 id="存储缓存-Store-Buffe）"><a href="#存储缓存-Store-Buffe）" class="headerlink" title="存储缓存(Store Buffe）"></a>存储缓存(Store Buffe）</h5><p>也就是常说的写缓存，当处理器修改缓存时，把新值放到存储缓存中，处理器就可以去干别的事了，把剩下的事交给存储缓存。</p>
<h5 id="失效队列（Invalidate-Queues）"><a href="#失效队列（Invalidate-Queues）" class="headerlink" title="失效队列（Invalidate Queues）"></a>失效队列（Invalidate Queues）</h5><p>处理失效的缓存也不是简单的，需要读取主存。并且存储缓存也不是无限大的，那么当存储缓存满的时候，处理器还是要等待失效响应的。为了解决上面两个问题，引进了失效队列（invalidate queue）。处理失效的工作如下：</p>
<p>收到失效消息时，放到失效队列中去。<br>为了不让处理器久等失效响应，收到失效消息需要马上回复失效响应。<br>为了不频繁阻塞处理器，不会马上读主存以及设置缓存为invlid，合适的时候再一块处理失效队列。</p>
<h4 id="MESI和CAS关系"><a href="#MESI和CAS关系" class="headerlink" title="MESI和CAS关系"></a>MESI和CAS关系</h4><p>在x86架构上，CAS被翻译为”lock cmpxchg…”，当两个core同时执行针对同一地址的CAS指令时,其实他们是在试图修改每个core自己持有的Cache line</p>
<blockquote>
<p>假设两个core都持有相同地址对应cacheline,且各自cacheline 状态为S, 这时如果要想成功修改,就首先需要把S转为E或者M, 则需要向其它core invalidate 这个地址的cacheline,则两个core都会向ring bus发出 invalidate这个操作, 那么在ringbus上就会根据特定的设计协议仲裁是core0,还是core1能赢得这个invalidate, 胜者完成操作, 失败者需要接受结果, invalidate自己对应的cacheline,再读取胜者修改后的值, 回到起点.</p>
</blockquote>
<p>对于我们的CAS操作来说, 其实锁并没有消失,只是转嫁到了ring bus的总线仲裁协议中. 而且大量的多核同时针对一个地址的CAS操作会引起反复的互相invalidate 同一cacheline, 造成pingpong效应, 同样会降低性能（参考[9]）。当然如果真的有性能问题，我觉得这可能会在ns级别体现了,一般的应用程序中使用CAS应该不会引起性能问题</p>
<h3 id="指令重排和内存屏障"><a href="#指令重排和内存屏障" class="headerlink" title="指令重排和内存屏障"></a>指令重排和内存屏障</h3><h4 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h4><p>现代CPU的速度越来越快，为了充分的利用CPU，在编译器和CPU执行期，都可能对指令重排。举个例子：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR </span><span class="built_in">R1</span>, [<span class="built_in">R0</span>]<span class="comment">;//操作1</span></span><br><span class="line"><span class="keyword">ADD </span><span class="built_in">R2</span>, <span class="built_in">R1</span>, <span class="built_in">R1</span><span class="comment">;//操作2</span></span><br><span class="line"><span class="keyword">ADD </span><span class="built_in">R3</span>, <span class="built_in">R4</span>, <span class="built_in">R4</span><span class="comment">;//操作3</span></span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，如果操作1如果发生cache miss，则需要等待读取内存外存。看看有没有能优先执行的指令，操作2依赖于操作1，不能被优先执行，操作3不依赖1和2，所以能优先执行操作3。<br>JVM的JSR-133规范中定义了as-if-serial语义，即compiler, runtime, and hardware三者需要保证在单线程模型下程序不会感知到指令重排的影响。</p>
<p>在并发模型下，重排序还是可能会引发问题，比较经典的就是“单例模式失效”问题（DoubleCheckedLocking）：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private static Singleton<span class="built_in"> instance </span>= <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  private Singleton() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  public static Singleton getInstance() &#123;</span><br><span class="line">     <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        synchronzied(Singleton.class) &#123;</span><br><span class="line">           <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="built_in"> instance </span>= new Singleton();  //</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，初看没问题，但是在并发模型下，可能会出错,那是因为instance= new Singleton()并非一个原子操作，它实际上下面这三个操作：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    //1：分配对象的内存空间</span><br><span class="line">ctorInstance(memory);  //2：初始化对象</span><br><span class="line">instance =memory;     //3：设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure></p>
<p>上面操作2依赖于操作1，但是操作3并不依赖于操作2，所以JVM是可以针对它们进行指令的优化重排序的，经过重排序后如下：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    //1：分配对象的内存空间</span><br><span class="line">instance =memory;     //3：instance指向刚分配的内存地址，此时对象还未初始化</span><br><span class="line">ctorInstance(memory);  //2：初始化对象</span><br></pre></td></tr></table></figure></p>
<p>可以看到指令重排之后，instance指向分配好的内存放在了前面，而这段内存的初始化被排在了后面。在多线程场景下，可能A线程执行到了3，B线程发现已经不为空就返回继续执行，就会出错。</p>
<p>在java里面volatile可以防止重排，当然还有另外一个作用即内存可见性，这个知道的人还应该比较普遍，就不说了</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。内存屏障有两个作用：</p>
<p>1.阻止屏障两侧的指令重排序；<br>2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</p>
<p>在JSR规范中定义了4种内存屏障：</p>
<ul>
<li>LoadLoad屏障：（指令Load1; LoadLoad; Load2），在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li>LoadStore屏障：（指令Load1; LoadStore; Store2），在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreStore屏障：（指令Store1; StoreStore; Store2），在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li><p>StoreLoad屏障：（指令Store1; StoreLoad; Load2），在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能<br>对于volatile关键字，按照规范会有下面的操作：</p>
</li>
<li><p>在每个volatile写入之前，插入一个StoreStore，写入之后，插入一个StoreLoad</p>
</li>
<li>在每个volatile读取之前，插入LoadLoad，之后插入LoadStore</li>
<li>具体到X86来看，其实没那么多指令，只有StoreLoad:</li>
</ul>
<p>结合上面的【一】和【二】的内容，内存屏障首先阻止了指令的重排，另外也和MESI协议结合，确保了内存的可见性</p>
<h2 id="怎么理解Java-中和-MySQL中的乐观锁、悲观锁？"><a href="#怎么理解Java-中和-MySQL中的乐观锁、悲观锁？" class="headerlink" title="怎么理解Java 中和 MySQL中的乐观锁、悲观锁？"></a>怎么理解Java 中和 MySQL中的乐观锁、悲观锁？</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<h4 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h4><p>乐观锁一般会使用版本号机制或CAS（Compare-and-Swap，即比较并替换）算法实现。</p>
<h5 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h5><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p>
<ol>
<li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li>
<li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li>
<li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li>
<li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。<br>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</li>
</ol>
<h5 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h5><p>即 compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数</p>
<p>需要读写的内存值 V<br>进行比较的值 A<br>拟写入的新值 B<br>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
<h5 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h5><p>ABA 问题是乐观锁一个常见的问题。</p>
<ol>
<li>ABA 问题</li>
</ol>
<p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</p>
<p>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<ol start="2">
<li>循环时间长开销大</li>
</ol>
<p>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<ol start="3">
<li>只能保证一个共享变量的原子操作</li>
</ol>
<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p>
<h5 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h5><p>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</p>
<ul>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。<br>补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</li>
</ul>
<h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><h4 id="悲观锁（Pessimistic-Lock）"><a href="#悲观锁（Pessimistic-Lock）" class="headerlink" title="悲观锁（Pessimistic Lock）"></a>悲观锁（Pessimistic Lock）</h4><p>悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p>
<p>这里需要注意的一点是不同的数据库对select for update的实现和支持都是有所区别的，例如oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，mysql就没有no wait这个选项。另外mysql还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在mysql中用悲观锁务必要确定走了索引，而不是全表扫描。</p>
<h4 id="乐观锁（Optimistic-Lock）"><a href="#乐观锁（Optimistic-Lock）" class="headerlink" title="乐观锁（Optimistic Lock）"></a>乐观锁（Optimistic Lock）</h4><p>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。</p>
<p>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，然后按照如下方式实现：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="keyword">SELECT</span> <span class="keyword">data</span> <span class="keyword">AS</span> old_data, <span class="keyword">version</span> <span class="keyword">AS</span> old_version <span class="keyword">FROM</span> …;</span><br><span class="line">2. 根据获取的数据进行业务操作，得到new_data和new_version</span><br><span class="line">3. <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">data</span> = new_data, <span class="keyword">version</span> = new_version <span class="keyword">WHERE</span> <span class="keyword">version</span> = old_version</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">updated</span> <span class="keyword">row</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    // 乐观锁获取成功，操作完成</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // 乐观锁获取失败，回滚并重试</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>乐观锁是否在事务中其实都是无所谓的，其底层机制是这样：在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放。因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这之间没有发生并发的修改。如果更新失败即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul>
<li>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</li>
<li>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方</li>
</ul>
<h2 id="对线程池的理解，项目中哪个地方使用了，如何使用的，用的Excutor框架中的哪个实现类，为什么用这个"><a href="#对线程池的理解，项目中哪个地方使用了，如何使用的，用的Excutor框架中的哪个实现类，为什么用这个" class="headerlink" title="对线程池的理解，项目中哪个地方使用了，如何使用的，用的Excutor框架中的哪个实现类，为什么用这个"></a>对线程池的理解，项目中哪个地方使用了，如何使用的，用的Excutor框架中的哪个实现类，为什么用这个</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h5 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h5><p>线程池作用就是限制系统中执行线程的数量。</p>
<p>根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。</p>
<h4 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h4><p>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p>
<p>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</p>
<p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。</p>
<p>比较重要的几个类：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ExecutorService</td>
<td>真正的线程池接口。</td>
</tr>
<tr>
<td>ScheduledExecutorService</td>
<td>能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</td>
</tr>
<tr>
<td>ThreadPoolExecutor</td>
<td>ExecutorService的默认实现。</td>
</tr>
<tr>
<td>ScheduledThreadPoolExecutor</td>
<td>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</td>
</tr>
</tbody>
</table>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。</p>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，</p>
<p>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<h3 id="ThreadPoolExecutor详解"><a href="#ThreadPoolExecutor详解" class="headerlink" title="ThreadPoolExecutor详解"></a>ThreadPoolExecutor详解</h3><p>ThreadPoolExecutor的完整构造方法的签名是：<code>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</code> .</p>
<ul>
<li>corePoolSize - 池中所保存的线程数，包括空闲线程。</li>
<li>maximumPoolSize-池中允许的最大线程数。</li>
<li>keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</li>
<li>unit - keepAliveTime 参数的时间单位。</li>
<li>workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute方法提交的 Runnable任务。</li>
<li>threadFactory - 执行程序创建新线程时使用的工厂。</li>
<li>handler - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。</li>
<li>ThreadPoolExecutor是Executors类的底层实现。</li>
</ul>
<p>下面介绍一下几个类的源码：</p>
<p>ExecutorService  newFixedThreadPool (int nThreads):固定大小线程池。</p>
<p>可以看到，corePoolSize和maximumPoolSize的大小是一样的（实际上，后面会介绍，如果使用无界queue的话maximumPoolSize参数是没有意义的），keepAliveTime和unit的设值表名什么？-就是该实现不想keep alive！最后的BlockingQueue选择了LinkedBlockingQueue，该queue有一个特点，他是无界的。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,<span class="number">0</span>L, TimeUnit.MILLISECONDS,   </span><br><span class="line">    <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ExecutorService  newSingleThreadExecutor()：单线程<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span> (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,   </span><br><span class="line">        <span class="number">0</span>L, TimeUnit.MILLISECONDS,   </span><br><span class="line">        <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ExecutorService newCachedThreadPool()：无界线程池，可以进行自动线程回收</p>
<p>这个实现就有意思了。首先是无界的线程池，所以我们可以发现maximumPoolSize为big big。其次BlockingQueue的选择上使用SynchronousQueue。可能对于该BlockingQueue有些陌生，简单说：该QUEUE中，每个插入操作必须等待另一个线程的对应移除操作。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;   </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,   </span><br><span class="line">       <span class="number">60</span>L, TimeUnit.SECONDS,   </span><br><span class="line">       <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先从<code>BlockingQueue&lt;Runnable&gt; workQueue</code>这个入参开始说起。在JDK中，其实已经说得很清楚了，一共有三种类型的queue。</p>
<p>所有BlockingQueue 都可用于传输和保持提交的任务。可以使用此队列与池大小进行交互：</p>
<p>如果运行的线程少于 corePoolSize，则 Executor始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于corePoolSize，则任务根本不会存放，添加到queue中，而是直接抄家伙（thread）开始运行）</p>
<p>如果运行的线程等于或多于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。</p>
<p>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。</p>
<p>queue上的三种类型。</p>
<p>排队有三种通用策略：</p>
<p><strong>直接提交</strong>。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p>
<p><strong>无界队列</strong>。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p>
<p><strong>有界队列</strong>。当使用有限的 maximumPoolSizes时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 </p>
<p><strong>BlockingQueue的选择</strong></p>
<h5 id="例子一：使用直接提交策略，也即SynchronousQueue。"><a href="#例子一：使用直接提交策略，也即SynchronousQueue。" class="headerlink" title="例子一：使用直接提交策略，也即SynchronousQueue。"></a>例子一：使用直接提交策略，也即SynchronousQueue。</h5><p>首先SynchronousQueue是无界的，也就是说他存数任务的能力是没有限制的，但是由于该Queue本身的特性，在某次添加元素后必须等待其他线程取走后才能继续添加。在这里不是核心线程便是新创建的线程，但是我们试想一样下，下面的场景。</p>
<p>我们使用一下参数构造ThreadPoolExecutor：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>( <span class="number">2</span>, <span class="number">3</span>, <span class="number">30</span>, TimeUnit.SECONDS,<span class="keyword">new</span>  <span class="type">SynchronousQueue</span>&lt;Runnable&gt;(),<span class="keyword">new</span> <span class="type">RecorderThreadFactory</span>(<span class="string">"CookieRecorderPool"</span>),<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">30</span>, TimeUnit.SECONDS,<span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;(),<span class="keyword">new</span> <span class="type">RecorderThreadFactory</span>(<span class="string">"CookieRecorderPool"</span>),<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>
<p>当核心线程已经有2个正在运行.</p>
<ol>
<li>此时继续来了一个任务（A），根据前面介绍的“如果运行的线程等于或多于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。”,所以A被添加到queue中。</li>
<li>又来了一个任务（B），且核心2个线程还没有忙完，OK，接下来首先尝试1中描述，但是由于使用的SynchronousQueue，所以一定无法加入进去。</li>
<li>此时便满足了上面提到的“如果无法将请求加入队列，则创建新的线程，除非创建此线程超出maximumPoolSize，在这种情况下，任务将被拒绝。”，所以必然会新建一个线程来运行这个任务。</li>
<li>暂时还可以，但是如果这三个任务都还没完成，连续来了两个任务，第一个添加入queue中，后一个呢？queue中无法插入，而线程数达到了maximumPoolSize，所以只好执行异常策略了。</li>
</ol>
<p>所以在使用SynchronousQueue通常要求maximumPoolSize是无界的，这样就可以避免上述情况发生（如果希望限制就直接使用有界队列）。对于使用SynchronousQueue的作用jdk中写的很清楚：此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。</p>
<p>什么意思？如果你的任务A1，A2有内部关联，A1需要先运行，那么先提交A1，再提交A2，当使用SynchronousQueue我们可以保证，A1必定先被执行，在A1么有被执行前，A2不可能添加入queue中。</p>
<h5 id="例子二：使用无界队列策略，即LinkedBlockingQueue"><a href="#例子二：使用无界队列策略，即LinkedBlockingQueue" class="headerlink" title="例子二：使用无界队列策略，即LinkedBlockingQueue"></a>例子二：使用无界队列策略，即LinkedBlockingQueue</h5><p>这个就拿newFixedThreadPool来说，根据前文提到的规则：</p>
<p>如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。那么当任务继续增加，会发生什么呢？</p>
<p>如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。OK，此时任务变加入队列之中了，那什么时候才会添加新线程呢？</p>
<p>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。这里就很有意思了，可能会出现无法加入队列吗？不像SynchronousQueue那样有其自身的特点，对于无界队列来说，总是可以加入的（资源耗尽，当然另当别论）。换句说，永远也不会触发产生新的线程！corePoolSize大小的线程数会一直运行，忙完当前的，就从队列中拿任务开始运行。所以要防止任务疯长，比如任务运行的实行比较长，而添加任务的速度远远超过处理任务的时间，而且还不断增加，不一会儿就爆了。</p>
<h5 id="例子三：有界队列，使用ArrayBlockingQueue。"><a href="#例子三：有界队列，使用ArrayBlockingQueue。" class="headerlink" title="**例子三：有界队列，使用ArrayBlockingQueue。"></a>**例子三：有界队列，使用ArrayBlockingQueue。</h5><p>这个是最为复杂的使用，所以JDK不推荐使用也有些道理。与上面的相比，最大的特点便是可以防止资源耗尽的情况发生。</p>
<p>举例来说，请看如下构造方法：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">30</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2</span>),<span class="keyword">new</span> <span class="type">RecorderThreadFactory</span>(<span class="string">"CookieRecorderPool"</span>), <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">30</span>, TimeUnit.SECONDS,<span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2</span>),<span class="keyword">new</span> <span class="type">RecorderThreadFactory</span>(<span class="string">"CookieRecorderPool"</span>),<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>
<p>假设，所有的任务都永远无法执行完。</p>
<p>对于首先来的A,B来说直接运行，接下来，如果来了C,D，他们会被放到queue中，如果接下来再来E,F，则增加线程运行E，F。但是如果再来任务，队列无法再接受了，线程数也到达最大的限制了，所以就会使用拒绝策略来处理。</p>
<h4 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h4><p>jdk中的解释是：当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</p>
<p>有点拗口，其实这个不难理解，在使用了“池”的应用中，大多都有类似的参数需要配置。比如数据库连接池，DBCP中的maxIdle，minIdle参数。</p>
<p>什么意思？接着上面的解释，后来向老板派来的工人始终是“借来的”，俗话说“有借就有还”，但这里的问题就是什么时候还了，如果借来的工人刚完成一个任务就还回去，后来发现任务还有，那岂不是又要去借？这一来一往，老板肯定头也大死了。</p>
<p>合理的策略：既然借了，那就多借一会儿。直到“某一段”时间后，发现再也用不到这些工人时，便可以还回去了。这里的某一段时间便是keepAliveTime的含义，TimeUnit为keepAliveTime值的度量。</p>
<p>RejectedExecutionHandler</p>
<p>另一种情况便是，即使向老板借了工人，但是任务还是继续过来，还是忙不过来，这时整个队伍只好拒绝接受了。</p>
<p>RejectedExecutionHandler接口提供了对于拒绝任务的处理的自定方法的机会。在ThreadPoolExecutor中已经默认包含了4中策略，因为源码非常简单，这里直接贴出来。</p>
<p>CallerRunsPolicy：线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">if</span> (!e.isShutdown()) &#123;   </span><br><span class="line">          r.run();   </span><br><span class="line">      &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个策略显然不想放弃执行任务。但是由于池中已经没有任何资源了，那么就直接使用调用该execute的线程本身来执行。</p>
<p>AbortPolicy：处理程序遭到拒绝将抛出运行时RejectedExecutionException<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 这种策略直接抛出异常，丢弃任务。</p>
<p>DiscardPolicy：不能执行的任务将被删除<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种策略和AbortPolicy几乎一样，也是丢弃任务，只不过他不抛出异常。</p>
<p>DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">rejectedExecution</span>(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">     <span class="selector-tag">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">         <span class="selector-tag">e</span><span class="selector-class">.getQueue</span>()<span class="selector-class">.poll</span>();</span><br><span class="line">         <span class="selector-tag">e</span><span class="selector-class">.execute</span>(r);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该策略就稍微复杂一些，在pool没有关闭的前提下首先丢掉缓存在队列中的最早的任务，然后重新尝试运行该任务。这个策略需要适当小心。</p>
<p>设想:如果其他线程都还在运行，那么新来任务踢掉旧任务，缓存在queue中，再来一个任务又会踢掉queue中最老任务。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>keepAliveTime和maximumPoolSize及BlockingQueue的类型均有关系。如果BlockingQueue是无界的，那么永远不会触发maximumPoolSize，自然keepAliveTime也就没有了意义。</p>
<p>反之，如果核心数较小，有界BlockingQueue数值又较小，同时keepAliveTime又设的很小，如果任务频繁，那么系统就会频繁的申请回收线程。</p>
<h2 id="怎么理解线程安全？"><a href="#怎么理解线程安全？" class="headerlink" title="怎么理解线程安全？"></a>怎么理解线程安全？</h2><p>线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。</p>
<p>线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p>
<p>安全性：<br>比如一个 ArrayList 类，在添加一个元素的时候，它可能会有两步来完成：1. 在 Items[Size] 的位置存放此元素；2. 增大 Size 的值。<br>在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；<br>而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。<br>那好，我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。</p>
<h2 id="一个final修饰的属性，定义的时候没有初始化，在无参构造函数中初始化，可以吗，为什么"><a href="#一个final修饰的属性，定义的时候没有初始化，在无参构造函数中初始化，可以吗，为什么" class="headerlink" title="一个final修饰的属性，定义的时候没有初始化，在无参构造函数中初始化，可以吗，为什么"></a>一个final修饰的属性，定义的时候没有初始化，在无参构造函数中初始化，可以吗，为什么</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol>
<li><p>static修饰一个属性字段，那么这个属性字段将成为类本身的资源，public修饰为共有的，可以在类的外部通过test.a来访问此属性；在类内部任何地方可以使用。如果被修饰为private私有，那么只能在类内部使用。</p>
</li>
<li><p>如果属性被修饰为static静态类资源，那么这个字段永远只有一个，也就是说不管你new test()多少个类的对象，操作的永远都只是属于类的那一块内存资源。</p>
</li>
</ol>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p> final 用于声明属性、方法和类，分别表示属性一旦被分配内存空间就必须初始化并且以后不可变；方法一旦定义必须有实现代码并且子类里不可被覆盖；类一旦定义不能被定义为抽象类或是接口，因为不可被继承。</p>
<p> 被final修饰而没有被static修饰的类的属性变量只能在两种情况下初始化：</p>
<ul>
<li><p>在它被定义的时候</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在构造函数里初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">　　	<span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　		a=<span class="number">0</span>;</span><br><span class="line">　　	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>同时被final和static修饰的类的属性变量只能在两种情况下初始化</p>
<ul>
<li><p>在它被定义的时候</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">　　	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">　　	<span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　		</span><br><span class="line">　　	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类的静态块里初始化</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">　　	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">　　	<span class="keyword">static</span>&#123;</span><br><span class="line">　　		a=<span class="number">0</span>;</span><br><span class="line">　　	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当类的属性被同时被修饰为static和final的时候，他属于类的资源，那么就是类在被加载进内存的时候（也就是应用程序启动的时候）就要为属性分配内存，所以此时属性已经存在，它又被final修饰，所以必须在属性定义了以后就给其初始化值。而构造函数是在当类被实例化的时候才会执行，所以不能用构造函数。而static块是类被加载的时候执行，且只执行这一次，所以在static块中可以执行初始化。</p>
<h2 id="HashMap，concurrentHashMap底实现序列化层实现"><a href="#HashMap，concurrentHashMap底实现序列化层实现" class="headerlink" title="HashMap，concurrentHashMap底实现序列化层实现"></a>HashMap，concurrentHashMap底实现序列化层实现</h2><p>实现了Serializable接口</p>
<p>Java中 Serializable 是 标示一个类是可以被 JDK 序列化和反序列化的，他只是一个接口并没有任何操作。</p>
<p>序列化，本质就是将内存里面的 Java 对象写入到流里面，还可以将流里面的Java序列化数据反序列化还原到实例对象。</p>
<p>当然，序列化的方法很多，常见的就是 JDK 序列化、JSON 序列化、还有 protobuffer 等等。</p>
<p>每一种框架，序列化和反序列化都是有一个统一的数据格式规范和算法。</p>
<h2 id="什么是红黑树，什么是B-Tree，为什么HashMap中用红黑树不用其他树？"><a href="#什么是红黑树，什么是B-Tree，为什么HashMap中用红黑树不用其他树？" class="headerlink" title="什么是红黑树，什么是B-Tree，为什么HashMap中用红黑树不用其他树？"></a>什么是红黑树，什么是B-Tree，为什么HashMap中用红黑树不用其他树？</h2><p>树的概念前面有。</p>
<p>那么很多人就有疑问为什么是使用红黑树而不是AVL树，AVL树是完全平衡二叉树阿？</p>
<p>最主要的一点是：</p>
<p>在CurrentHashMap中是加锁了的，实际上是读写锁，如果写冲突就会等待，<br>如果插入时间过长必然等待时间更长，而红黑树相对AVL树他的插入更快！</p>
<p>问题：为什么不使用AVL树而使用红黑树？<br>红黑树和AVL树都是最常用的平衡二叉搜索树，它们的查找、删除、修改都是O(lgn) time</p>
<p>AVL树和红黑树有几点比较和区别：<br>（1）AVL树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用AVL树。<br>（2）红黑树更适合于插入修改密集型任务。<br>（3）通常，AVL树的旋转比红黑树的旋转更加难以平衡和调试。</p>
<p>总结：</p>
<p>（1）AVL以及红黑树是高度平衡的树数据结构。它们非常相似，真正的区别在于在任何添加/删除操作时完成的旋转操作次数。</p>
<p>（2）两种实现都缩放为a O(lg N)，其中N是叶子的数量，但实际上AVL树在查找密集型任务上更快：利用更好的平衡，树遍历平均更短。另一方面，插入和删除方面，AVL树速度较慢：需要更高的旋转次数才能在修改时正确地重新平衡数据结构。</p>
<p>（3）在AVL树中，从根到任何叶子的最短路径和最长路径之间的差异最多为1。在红黑树中，差异可以是2倍。</p>
<p>（4）两个都给O（log n）查找，但平衡AVL树可能需要O（log n）旋转，而红黑树将需要最多两次旋转使其达到平衡（尽管可能需要检查O（log n）节点以确定旋转的位置）。旋转本身是O（1）操作，因为你只是移动指针。</p>
<h2 id="计算密集型-IO密集型任务分别如何设置线程池的核心线程数和最大线程数，为什么这么设置？"><a href="#计算密集型-IO密集型任务分别如何设置线程池的核心线程数和最大线程数，为什么这么设置？" class="headerlink" title="计算密集型/IO密集型任务分别如何设置线程池的核心线程数和最大线程数，为什么这么设置？"></a>计算密集型/IO密集型任务分别如何设置线程池的核心线程数和最大线程数，为什么这么设置？</h2><h3 id="任务类型举例"><a href="#任务类型举例" class="headerlink" title="任务类型举例:"></a>任务类型举例:</h3><h4 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型:"></a>CPU密集型:</h4><p> 例如,一般我们系统的静态资源,比如js,css等,会存在一个版本号,如 main.js?v0,每当用户访问这个资源的时候,会发送一个比对请求到服务端,比对本地静态文件版本和服务端的文件版本是否一致,不一致则更新.这种任务一般不占用大量IO,所以后台服务器可以快速处理,压力落在CPU上.</p>
<h4 id="I-O密集型"><a href="#I-O密集型" class="headerlink" title="I/O密集型:"></a>I/O密集型:</h4><p>比方说近期我们做的万科CRM系统,常有大数据量的查询和批量插入操作,此时的压力主要在I/O上.</p>
<h3 id="线程数与任务类型的关系"><a href="#线程数与任务类型的关系" class="headerlink" title="线程数与任务类型的关系:"></a>线程数与任务类型的关系:</h3><h4 id="与CPU密集型的关系"><a href="#与CPU密集型的关系" class="headerlink" title="与CPU密集型的关系:"></a>与CPU密集型的关系:</h4><p>一般情况下,CPU核心数 == 最大同时执行线程数.在这种情况下(设CPU核心数为n),大量客户端会发送请求到服务器,但是服务器最多只能同时执行n个线程.</p>
<p>设线程池工作队列长度为m,且m&gt;&gt;n,则此时会导致CPU频繁切换线程来执行(如果CPU使用的是FCFS,则不会频繁切换,如使用的是其他CPU调度算法,如时间片轮转法,最短时间优先,则可能会导致频繁的线程切换).</p>
<p>所以这种情况下,无需设置过大的线程池工作队列,(工作队列长度 = CPU核心数 || CPU核心数+1) 即可.</p>
<h4 id="与I-O密集型的关系"><a href="#与I-O密集型的关系" class="headerlink" title="与I/O密集型的关系:"></a>与I/O密集型的关系:</h4><p>1个线程对应1个方法栈,线程的生命周期与方法栈相同.</p>
<p>比如某个线程的方法栈对应的入站顺序为:controller()-&gt;service()-&gt;DAO(),由于DAO长时间的I/O操作,导致该线程一直处于工作队列,但它又不占用CPU,则此时有1个CPU是处于空闲状态的.</p>
<p>所以,这种情况下,应该加大线程池工作队列的长度(如果CPU调度算法使用的是FCFS,则无法切换),尽量不让CPU空闲下来,提高CPU利用率.</p>
<h2 id="画一下Java-线程几个状态及状态之间互相转换的图？"><a href="#画一下Java-线程几个状态及状态之间互相转换的图？" class="headerlink" title="画一下Java 线程几个状态及状态之间互相转换的图？"></a>画一下Java 线程几个状态及状态之间互相转换的图？</h2><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0and9vxv5j225607ut9t.jpg" alt="image"></p>
<p>在Java中线程的状态一共被分成6种：</p>
<h3 id="初始态：NEW"><a href="#初始态：NEW" class="headerlink" title="初始态：NEW"></a>初始态：NEW</h3><p>创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。</p>
<h3 id="运行态：RUNNABLE"><a href="#运行态：RUNNABLE" class="headerlink" title="运行态：RUNNABLE"></a>运行态：RUNNABLE</h3><p>在Java中，运行态包括就绪态 和 运行态。</p>
<ul>
<li>就绪态  <ul>
<li>该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。</li>
<li>所有就绪态的线程存放在就绪队列中。</li>
</ul>
</li>
<li>运行态  <ul>
<li>获得CPU执行权，正在执行的线程。</li>
<li>由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。</li>
</ul>
</li>
</ul>
<h3 id="阻塞态"><a href="#阻塞态" class="headerlink" title="阻塞态"></a>阻塞态</h3><ul>
<li>当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。</li>
<li>而在Java中，阻塞态专指请求锁失败时进入的状态。</li>
<li>由一个阻塞队列存放所有阻塞态的线程。</li>
<li>处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。</li>
</ul>
<p>PS：锁、IO、Socket等都资源。</p>
<h3 id="等待态"><a href="#等待态" class="headerlink" title="等待态"></a>等待态</h3><ul>
<li>当前线程中调用wait、join、park函数时，当前线程就会进入等待态。</li>
<li>也有一个等待队列存放所有等待态的线程。</li>
<li>线程处于等待态表示它需要等待其他线程的指示才能继续运行。</li>
<li>进入等待态的线程会释放CPU执行权，并释放资源（如：锁）</li>
</ul>
<h3 id="终止态"><a href="#终止态" class="headerlink" title="终止态"></a>终止态</h3><p>线程执行结束后的状态。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>wait()方法会释放CPU执行权 和 占有的锁。</li>
<li>sleep(long)方法仅释放CPU使用权，锁仍然占用；线程被放入超时等待队列，与yield相比，它会使线程较长时间得不到运行。</li>
<li>yield()方法仅释放CPU执行权，锁仍然占用，线程会被放入就绪队列，会在短时间内再次执行。</li>
<li>wait和notify必须配套使用，即必须使用同一把锁调用；</li>
<li>wait和notify必须放在一个同步块中</li>
<li>调用wait和notify的对象必须是他们所处同步块的锁对象。</li>
</ul>
<h2 id="对线程池的理解，在项目中如何使用的，多个线程之间如何共享数据，多个进程之间如何共享数据？"><a href="#对线程池的理解，在项目中如何使用的，多个线程之间如何共享数据，多个进程之间如何共享数据？" class="headerlink" title="对线程池的理解，在项目中如何使用的，多个线程之间如何共享数据，多个进程之间如何共享数据？"></a>对线程池的理解，在项目中如何使用的，多个线程之间如何共享数据，多个进程之间如何共享数据？</h2><p>首先想到的是将共享数据设置为全局变量，并且用static修饰，但是static修饰的变量是类变量，生命周期太长了，占用内存。</p>
<p>方法一：多个线程对共享数据的操作是相同的，那么创建<br>一个Runnable的子类对象，将这个对象作为参数传递给Thread的构造方法，此时因为多个线程操作的是同一个Runnable的子类对象，所以他们操作的是同一个共享数据。比如：买票系统，所以的线程的操作都是对票数减一的操作。 </p>
<p>方法二：多个线程对共享数据的操作是不同的，将共享数据和操作共享数据的方法放在同一对象中，将这个对象作为参数传递给Runnable的子类，在子类中用该对象的方法对共享数据进行操作。如：生产者消费者。</p>
<p>方法三：多个线程对共享数据的操作是不同的， 用内部类的方式去实现，创建Runnable的子类作为内部类，将共享对象作为全局变量，在Runnable的子类中对共享数据进行操作。 </p>
<p>方法四:ThreadLocal实现线程范围内数据的共享</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="怎么理解命令模式和观察者模式，手写一个观察者模式或者命令模式的代码，策略模式也行"><a href="#怎么理解命令模式和观察者模式，手写一个观察者模式或者命令模式的代码，策略模式也行" class="headerlink" title="怎么理解命令模式和观察者模式，手写一个观察者模式或者命令模式的代码，策略模式也行"></a>怎么理解命令模式和观察者模式，手写一个观察者模式或者命令模式的代码，策略模式也行</h2><ul>
<li><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
<ul>
<li>意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</li>
<li>主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</li>
<li>何时使用：在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</li>
<li>如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。</li>
<li>应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</li>
<li>优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。</li>
<li>缺点：使用命令模式可能会导致某些系统有过多的具体命令类。</li>
<li>使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。</li>
<li>注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</li>
<li>我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。Broker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo，我们的演示类使用 Broker 类来演示命令模式。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/command_pattern_uml_diagram.jpg" alt="image"><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> Order &#123;</span><br><span class="line">   <span class="keyword">void</span> execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Stock &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name = <span class="string">"ABC"</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> quantity = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> buy()&#123;</span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">"Stock [ Name: "</span>+name+<span class="string">", </span></span><br><span class="line"><span class="string">         Quantity: "</span> + quantity +<span class="string">" ] bought"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> sell()&#123;</span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">"Stock [ Name: "</span>+name+<span class="string">", </span></span><br><span class="line"><span class="string">         Quantity: "</span> + quantity +<span class="string">" ] sold"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> BuyStock implements Order &#123;</span><br><span class="line">   <span class="keyword">private</span> Stock abcStock;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> BuyStock(Stock abcStock)&#123;</span><br><span class="line">      <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> execute() &#123;</span><br><span class="line">      abcStock.buy();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> SellStock implements Order &#123;</span><br><span class="line">   <span class="keyword">private</span> Stock abcStock;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> SellStock(Stock abcStock)&#123;</span><br><span class="line">      <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> execute() &#123;</span><br><span class="line">      abcStock.sell();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Broker &#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Order&gt; orderList = <span class="keyword">new</span> ArrayList&lt;Order&gt;(); </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> takeOrder(Order order)&#123;</span><br><span class="line">      orderList.add(order);      </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> placeOrders()&#123;</span><br><span class="line">      <span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">         order.execute();</span><br><span class="line">      &#125;</span><br><span class="line">      orderList.clear();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> CommandPatternDemo &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">      Stock abcStock = <span class="keyword">new</span> Stock();</span><br><span class="line"> </span><br><span class="line">      BuyStock buyStockOrder = <span class="keyword">new</span> BuyStock(abcStock);</span><br><span class="line">      SellStock sellStockOrder = <span class="keyword">new</span> SellStock(abcStock);</span><br><span class="line"> </span><br><span class="line">      Broker broker = <span class="keyword">new</span> Broker();</span><br><span class="line">      broker.takeOrder(buyStockOrder);</span><br><span class="line">      broker.takeOrder(sellStockOrder);</span><br><span class="line"> </span><br><span class="line">      broker.placeOrders();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock [ Name: ABC, Quantity: <span class="number">10</span> ] bought</span><br><span class="line">Stock [ Name: ABC, Quantity: <span class="number">10</span> ] sold</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>观察者模式，当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。</p>
<ul>
<li>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li>
<li>主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</li>
<li>何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</li>
<li>如何解决：使用面向对象技术，可以将这种依赖关系弱化。</li>
<li>关键代码：在抽象类里有一个 ArrayList 存放观察者们。</li>
<li>应用实例：1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</li>
<li>优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</li>
<li>缺点：1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
<li>使用场景：1、一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。2、一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。3、一个对象必须通知其他对象，而并不知道这些对象是谁。4、需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
<li>实现：观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。ObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/observer_pattern_uml_diagram.jpg" alt="image"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> List&lt;Observer&gt; observers </span><br><span class="line">      = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">      notifyAllObservers();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">      observers.add(observer);      </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">         observer.update();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> Subject subject;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"Binary String: "</span> </span><br><span class="line">      + Integer.toBinaryString( subject.getState() ) ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">OctalObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println( <span class="string">"Octal String: "</span> </span><br><span class="line">     + Integer.toOctalString( subject.getState() ) ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HexaObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">"Hex String: "</span> </span><br><span class="line">      + Integer.toHexString( subject.getState() ).toUpperCase() ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">new</span> HexaObserver(subject);</span><br><span class="line">      <span class="keyword">new</span> OctalObserver(subject);</span><br><span class="line">      <span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">"First state change: 15"</span>);   </span><br><span class="line">      subject.setState(<span class="number">15</span>);</span><br><span class="line">      System.out.println(<span class="string">"Second state change: 10"</span>);  </span><br><span class="line">      subject.setState(<span class="number">10</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>策略模式:在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p>
<ul>
<li>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</li>
<li>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</li>
<li>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。</li>
<li>如何解决：将这些算法封装成一个一个的类，任意地替换。</li>
<li>应用实例：1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT中的LayoutManager。</li>
<li>优点： 1、算法可以自由切换。2、避免使用多重条件判断。3、扩展性良好。</li>
<li>缺点：1、策略类会增多。2、所有策略类都需要对外暴露。</li>
<li>使用场景：1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。2、一个系统需要动态地在几种算法中选择一种。3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
<li>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</li>
<li>实现:我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/strategy_pattern_uml_diagram.jpg" alt="image"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 - num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 * num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());    </span><br><span class="line">      System.out.println(<span class="string">"10 + 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());      </span><br><span class="line">      System.out.println(<span class="string">"10 - 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());    </span><br><span class="line">      System.out.println(<span class="string">"10 * 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="设计模式在项目中哪个地方用到了，怎么使用的，能不能画一个你熟悉的设计模式的UML图，手写单例模式，手写静态内部类实现的单例模式。"><a href="#设计模式在项目中哪个地方用到了，怎么使用的，能不能画一个你熟悉的设计模式的UML图，手写单例模式，手写静态内部类实现的单例模式。" class="headerlink" title="设计模式在项目中哪个地方用到了，怎么使用的，能不能画一个你熟悉的设计模式的UML图，手写单例模式，手写静态内部类实现的单例模式。"></a>设计模式在项目中哪个地方用到了，怎么使用的，能不能画一个你熟悉的设计模式的UML图，手写单例模式，手写静态内部类实现的单例模式。</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式"><a href="#掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式" class="headerlink" title="掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式"></a>掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式</h2><ul>
<li>设计模式：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式、适配器模式、桥接模式、过滤器模式、组合模式、装饰器模式、外观模式、享元模式、代理模式、责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、空对象模式、策略模式、模板模式、访问者模式、MVC模式、业务代表模式、组合实体模式、数据访问对象模式、前端控制器模式、拦截过滤器模式、服务定位器模式、传输对象模式。</li>
<li>线程安全的单例模式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/03/26/Spring Data Redis与Redisson对比/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/26/Spring Data Redis与Redisson对比/" itemprop="url">Spring Data Redis与Redisson对比</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-26T20:47:00+08:00">
                2019-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/26/Spring Data Redis与Redisson对比/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/03/26/Spring Data Redis与Redisson对比/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring-Data-Redis与Redisson对比"><a href="#Spring-Data-Redis与Redisson对比" class="headerlink" title="Spring Data Redis与Redisson对比"></a>Spring Data Redis与Redisson对比</h1><h2 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h2><p><a href="https://spring.io/projects/spring-data-redis" target="_blank" rel="noopener">Spring Data Redis</a>是更大的Spring Data系列的一部分，可以从Spring应用程序轻松配置和访问Redis。它提供了与商店交互的低级和高级抽象，使用户免于基础设施问题。Spring Boot 从 2.0版本开始，将默认的Redis客户端Jedis替换问Lettuce。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>连接包作为多个Redis驱动程序/连接器的低级抽象（<a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">Jedis</a>和<a href="https://github.com/mp911de/lettuce" target="_blank" rel="noopener">Lettuce</a>。不推荐支持<a href="https://github.com/alphazero/jredis" target="_blank" rel="noopener">JRedis</a>和<a href="https://github.com/spullara/redis-protocol" target="_blank" rel="noopener">SRP</a>。）</li>
<li><a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:connectors" target="_blank" rel="noopener">异常</a>转换到Spring的便携式数据访问异常层次结构Redis的驱动程序例外</li>
<li><a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:template" target="_blank" rel="noopener">RedisTemplate</a>，提供高级抽象，用于执行各种Redis操作，异常转换和序列化支持</li>
<li><a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#pubsub" target="_blank" rel="noopener">Pubsub</a>支持（例如消息驱动的POJO的MessageListenerContainer）</li>
<li><a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:sentinel" target="_blank" rel="noopener">Redis Sentinel</a>和<a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#cluster" target="_blank" rel="noopener">Redis Cluster</a>支持</li>
<li>JDK，String，JSON和Spring Object / XML映射<a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:serializer" target="_blank" rel="noopener">序列化程序</a></li>
<li>在Redis之上的JDK Collection实现</li>
<li>原子<a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:support" target="_blank" rel="noopener">计数器</a>支持classes</li>
<li>排序和流水线功能</li>
<li>专门支持SORT，SORT / GET模式和返回的批量值</li>
<li>Redis <a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:support:cache-abstraction" target="_blank" rel="noopener">实现</a>了Spring 3.1缓存抽象</li>
<li>自动实现Repository接口，包括支持自定义查找程序方法@EnableRedisRepositories</li>
<li>CDI对存储库的支持</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在<code>pom.xml</code>中加入<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>application.yml</code>中加入<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">6</span>  <span class="comment">#Redis索引0~15，默认为0</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    password:</span>  <span class="comment">#密码（默认为空）</span></span><br><span class="line"><span class="attr">    pool:</span></span><br><span class="line"><span class="attr">      max-active:</span> <span class="number">8</span>   <span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">      max-wait:</span> <span class="bullet">-1</span><span class="string">ms</span>  <span class="comment">#连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">      max-idle:</span> <span class="number">5</span>     <span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="attr">      min-idle:</span> <span class="number">0</span>     <span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">10000</span><span class="string">ms</span>    <span class="comment">#连接超时时间（毫秒）</span></span><br></pre></td></tr></table></figure></p>
<p>加入配置类<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RedisConfiguration</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RedisTemplate配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param redisConnectionFactory redisConnectionFactory</span></span><br><span class="line"><span class="comment">     * @return RedisTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    public <span class="type">RedisTemplate</span>&lt;<span class="type">String</span>, <span class="type">Object</span>&gt; redisTemplate(<span class="type">RedisConnectionFactory</span> redisConnectionFactory) &#123;</span><br><span class="line">        <span class="comment">// 配置redisTemplate</span></span><br><span class="line">        <span class="type">RedisTemplate</span>&lt;<span class="type">String</span>, <span class="type">Object</span>&gt; redisTemplate = <span class="keyword">new</span> <span class="type">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//key序列化</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="type">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">//value序列化</span></span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> <span class="type">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码使用<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> test()&#123;</span><br><span class="line">    <span class="comment">//设置键值对</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"test:set1"</span>, <span class="string">"testValue1"</span>);</span><br><span class="line">    <span class="comment">//设置键值对数组</span></span><br><span class="line">    redisTemplate.opsForSet().add(<span class="string">"test:set2"</span>, <span class="string">"asdf"</span>);</span><br><span class="line">    <span class="comment">//数据hash存入</span></span><br><span class="line">    redisTemplate.opsForHash().<span class="built_in">put</span>(<span class="string">"hash1"</span>, <span class="string">"name1"</span>, <span class="string">"lms1"</span>);</span><br><span class="line">    redisTemplate.opsForHash().<span class="built_in">put</span>(<span class="string">"hash1"</span>, <span class="string">"name2"</span>, <span class="string">"lms2"</span>);</span><br><span class="line">    redisTemplate.opsForHash().<span class="built_in">put</span>(<span class="string">"hash1"</span>, <span class="string">"name3"</span>, <span class="string">"lms3"</span>);</span><br><span class="line">    <span class="comment">//获取</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(redisTemplate.opsForValue().<span class="built_in">get</span>(<span class="string">"test:set"</span>));</span><br><span class="line">    <span class="comment">//hash获取</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(redisTemplate.opsForHash().<span class="built_in">get</span>(<span class="string">"hash1"</span>, <span class="string">"name1"</span>));</span><br><span class="line">    <span class="comment">//发布、订阅消息（更多请参考 https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/</span></span><br><span class="line">    <span class="keyword">String</span> message = <span class="string">"dinghuang123@gmail.com"</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] msg = message.getBytes();</span><br><span class="line">    <span class="keyword">byte</span>[] channel = message.getBytes();</span><br><span class="line">    redisConnectionFactory.getConnection().publish(msg, channel);</span><br><span class="line">    redisTemplate.convertAndSend(<span class="string">"hello!"</span>, <span class="string">"world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如图所示<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g1fxturm52j219e0k2ac6.jpg" alt=""></p>
<h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p><a href="https://redisson.org" target="_blank" rel="noopener">Redisson</a>是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。能够完美的在云计算环境里使用，并且支持AWS ElastiCache主备版，AWS ElastiCache集群版，Azure Redis Cache和阿里云（Aliyun）的云数据库Redis版。Redisson底层采用的是Netty 框架。支持Redis 2.8以上版本，支持Java1.6+以上版本。</p>
<p>Redisson作为独立节点 可以用于独立执行其他节点发布到分布式执行服务 和 分布式调度任务服务 里的远程任务。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g1f1ntysocj21b60ycgn7.jpg" alt=""></p>
<h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ul>
<li>复制的Redis服务器模式（还支持<a href="http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Replication.html" target="_blank" rel="noopener">AWS ElastiCache</a>和<a href="https://azure.microsoft.com/en-us/services/cache/" target="_blank" rel="noopener">Azure Redis</a>缓存）：<ul>
<li>自动主服务器更改发现</li>
</ul>
</li>
<li>群集Redis服务器模式（还支持<a href="http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Replication.html" target="_blank" rel="noopener">AWS ElastiCache</a>和<a href="https://azure.microsoft.com/en-us/services/cache/" target="_blank" rel="noopener">Azure Redis</a>缓存：<ul>
<li>自动主从服务器发现</li>
<li>自动状态和拓扑更新</li>
<li>自动插槽更改发现</li>
</ul>
</li>
<li>Sentinel Redis服务器模式：<ul>
<li>自动主，从和服务器发现</li>
<li>自动状态和拓扑更新</li>
</ul>
</li>
<li>掌握Slave Redis服务器模式</li>
<li>单Redis服务器模式</li>
<li>线程安全的实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/3.-operations-execution#32-reactive-way" target="_blank" rel="noopener">Reactive Streams</a> API</li>
<li><a href="https://github.com/redisson/redisson/wiki/3.-operations-execution#31-async-way" target="_blank" rel="noopener">异步</a> API</li>
<li>异步连接池</li>
<li>Lua脚本</li>
<li><a href="https://github.com/redisson/redisson/wiki/6.-Distributed-objects" target="_blank" rel="noopener">分布式Java对象</a><br>Object holder，Binary stream holder，Geospatial holder，BitSet，AtomicLong，AtomicDouble，PublishSubscribe，Bloom filter，HyperLogLog</li>
<li><a href="https://github.com/redisson/redisson/wiki/7.-Distributed-collections" target="_blank" rel="noopener">分布式Java集合</a><br>Map，Multimap，Set，List，SortedSet，ScoredSortedSet，LexSortedSet，Queue，Deque，Blocking Queue，Bounded Blocking Queue，Blocking Deque，Delayed Queue，Priority Queue，Priority Deque</li>
<li><a href="https://github.com/redisson/redisson/wiki/8.-Distributed-locks-and-synchronizers" target="_blank" rel="noopener">分布式Java锁和同步器</a><br>Lock，FairLock，MultiLock，RedLock，ReadWriteLock，Semaphore，PermitExpirableSemaphore，CountDownLatch</li>
<li><a href="https://github.com/redisson/redisson/wiki/9.-distributed-services" target="_blank" rel="noopener">分布式服务</a><br>远程服务，Live Object服务，Executor服务，Scheduler服务，MapReduce服务</li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration%20with%20frameworks#141-spring-framework" target="_blank" rel="noopener">Spring框架</a></li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration%20with%20frameworks/#142-spring-cache" target="_blank" rel="noopener">Spring Cache</a>实现<br>-<a href="https://github.com/redisson/redisson/wiki/14.-Integration-with-frameworks/#147-spring-transaction-manager" target="_blank" rel="noopener"> Spring Transaction API</a>实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration-with-frameworks/#148-spring-data-redis" target="_blank" rel="noopener">Spring Data Redis</a>集成</li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration-with-frameworks/#149-spring-boot-starter" target="_blank" rel="noopener">Spring Boot Starter</a>实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration%20with%20frameworks/#143-hibernate-cache" target="_blank" rel="noopener">Hibernate Cache</a>实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/10.-Additional-features#104-transactions" target="_blank" rel="noopener">Transactions API</a><br>-<a href="https://github.com/redisson/redisson/wiki/10.-additional-features/#105-xa-transactions" target="_blank" rel="noopener"> XA Transaction API</a>实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration%20with%20frameworks/#144-jcache-api-jsr-107-implementation" target="_blank" rel="noopener">JCache API（JSR-107）</a>实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration%20with%20frameworks#145-tomcat-redis-session-manager" target="_blank" rel="noopener">Tomcat会话管理器</a>实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/14.-Integration%20with%20frameworks/#146-spring-session" target="_blank" rel="noopener">Spring Session</a>实现</li>
<li><a href="https://github.com/redisson/redisson/wiki/10.-additional-features#102-execution-batches-of-commands" target="_blank" rel="noopener">Redis流水线</a>（命令批处理）</li>
<li>支持Android平台</li>
<li>支持自动重新连接</li>
<li>支持无法发送命令自动重试</li>
<li>支持OSGi</li>
<li>支持SSL</li>
<li>支持许多流行的编解码器（<a href="https://github.com/FasterXML/jackson" target="_blank" rel="noopener">Jackson JSON</a>，<a href="http://avro.apache.org/" target="_blank" rel="noopener">Avro</a>，<a href="http://wiki.fasterxml.com/SmileFormatSpec" target="_blank" rel="noopener">Smile</a>，<a href="http://cbor.io/" target="_blank" rel="noopener">CBOR</a>，<a href="http://msgpack.org/" target="_blank" rel="noopener">MsgPack</a>，<a href="https://github.com/EsotericSoftware/kryo" target="_blank" rel="noopener">Kryo</a>，<a href="https://amzn.github.io/ion-docs/" target="_blank" rel="noopener">Amazon Ion</a>，<a href="https://github.com/RuedigerMoeller/fast-serialization" target="_blank" rel="noopener">FST</a>，<a href="https://github.com/jpountz/lz4-java" target="_blank" rel="noopener">LZ4</a>，<a href="https://github.com/xerial/snappy-java" target="_blank" rel="noopener">Snappy</a>和JDK Serialization）</li>
<li>超过1800个单元测试</li>
</ul>
<h3 id="与spring-data-redis结合使用"><a href="#与spring-data-redis结合使用" class="headerlink" title="与spring-data-redis结合使用"></a>与spring-data-redis结合使用</h3><p><code>pom.xml</code>加入依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-data-21<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.10.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>resources</code>文件夹添加配置文件<code>redisson.yml</code><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Redisson配置</span></span><br><span class="line"><span class="attr">singleServerConfig:</span></span><br><span class="line"><span class="attr">  address:</span> <span class="string">"redis://127.0.0.1:6379"</span></span><br><span class="line"><span class="attr">  password:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  clientName:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  database:</span> <span class="number">7</span> <span class="comment">#选择使用哪个数据库0~15</span></span><br><span class="line"><span class="attr">  idleConnectionTimeout:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">  pingTimeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">  connectTimeout:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">  retryAttempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  retryInterval:</span> <span class="number">1500</span></span><br><span class="line"><span class="attr">  reconnectionTimeout:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">  failedAttempts:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  subscriptionsPerConnection:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  subscriptionConnectionMinimumIdleSize:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  subscriptionConnectionPoolSize:</span> <span class="number">50</span></span><br><span class="line"><span class="attr">  connectionMinimumIdleSize:</span> <span class="number">32</span></span><br><span class="line"><span class="attr">  connectionPoolSize:</span> <span class="number">64</span></span><br><span class="line"><span class="attr">  dnsMonitoringInterval:</span> <span class="number">5000</span></span><br><span class="line">  <span class="comment">#dnsMonitoring: false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">threads:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">nettyThreads:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">codec:</span></span><br><span class="line"><span class="attr">  class:</span> <span class="string">"org.redisson.codec.JsonJacksonCodec"</span></span><br><span class="line"><span class="attr">transportMode:</span> <span class="string">"NIO"</span></span><br></pre></td></tr></table></figure></p>
<p>注册<code>RedissonConnectionFactory</code><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonSpringDataConfig</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> RedissonConnectionFactory redissonConnectionFactory(RedissonClient redisson) &#123;</span><br><span class="line">       <span class="keyword">return</span> new RedissonConnectionFactory(redisson);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Bean(destroyMethod = <span class="meta-string">"shutdown"</span>)</span></span><br><span class="line">   <span class="keyword">public</span> RedissonClient redisson(<span class="meta">@Value(<span class="meta-string">"classpath:/redisson.yml"</span>)</span> Resource configFile) throws IOException &#123;</span><br><span class="line">       Config config = Config.fromYAML(configFile.getInputStream());</span><br><span class="line">       <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码使用<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//设置键值对</span></span><br><span class="line">    RBucket&lt;String&gt; keyObj = redissonClient.getBucket(<span class="string">"k1"</span>);</span><br><span class="line">    keyObj.set(<span class="string">"v1236"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>spring-data-redis 支持的基本能够满足对redis的操作，提供了2种客户端连接，也支持redis集群的模式。如果涉及到利用redis做分布式锁的话，redisson封装了更多的工具和基础原子对象进行操作，redisson是优先选择，其次redisson兼容了很多的框架，那么多star不是没有道理的= =。同时也可以通过redisson与RxJava结合，实现线程安全的异步任务等等。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/03/20/Servicecomb实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/20/Servicecomb实践/" itemprop="url">Servicecomb实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-20T15:47:00+08:00">
                2019-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/20/Servicecomb实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/03/20/Servicecomb实践/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Servicecomb实践"><a href="#Servicecomb实践" class="headerlink" title="Servicecomb实践"></a>Servicecomb实践</h1><p><a href="https://github.com/apache/servicecomb-pack/blob/master" target="_blank" rel="noopener">Git地址</a></p>
<p>Apache ServiceComb Pack 是华为开源的一个微服务应用的数据最终一致性解决方案。</p>
<h2 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h2><ul>
<li>高可用：支持高可用的集群模式部署。</li>
<li>高可靠：所有的关键事务事件都持久化存储在数据库中。</li>
<li>高性能：事务事件是通过高性能gRPC来上报的，且事务的请求和响应消息都是通过Kyro进行序列化和反序列化。</li>
<li>低侵入：仅需2-3个注解和编写对应的补偿方法即可引入分布式事务。</li>
<li>部署简单：支持通过容器（Docker）进行快速部署和交付。</li>
<li>补偿机制灵活：支持前向恢复（重试）及后向恢复（补偿）功能。</li>
<li>扩展简单：基于Pack架构很容实现多种协调协议，目前支持TCC、Saga协议，未来还可以添加其他协议支持。</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>ServiceComb Pack 架构是由 alpha 和 omega组成，其中：</p>
<ul>
<li>alpha充当协调者的角色，主要负责对事务进行管理和协调。</li>
<li>omega是微服务中内嵌的一个agent，负责对调用请求进行拦截并向alpha上报事务事件。</li>
</ul>
<p>下图展示了alpha, omega以及微服务三者的关系： </p>
<p><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16q1uo7a2j20mp07yweq.jpg" alt=""></p>
<p>基础上我们除了实现saga协调协议以外，还实现了<a href="https://github.com/apache/servicecomb-pack/blob/master/docs/design_zh.md" target="_blank" rel="noopener">TCC协调协议</a>。 详情可浏览ServiceComb Pack 设计文档。</p>
<h3 id="Omega内部运行机制"><a href="#Omega内部运行机制" class="headerlink" title="Omega内部运行机制"></a>Omega内部运行机制</h3><p>omega是微服务中内嵌的一个agent。当服务收到请求时，omega会将其拦截并从中提取请求信息中的全局事务id作为其自身的全局事务id（即Saga事件id），并提取本地事务id作为其父事务id。在预处理阶段，alpha会记录事务开始的事件；在后处理阶段，alpha会记录事务结束的事件。因此，每个成功的子事务都有一一对应的开始及结束事件。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16q8mdkrvj20wo0haaau.jpg" alt=""></p>
<h3 id="服务间通信流程"><a href="#服务间通信流程" class="headerlink" title="服务间通信流程"></a>服务间通信流程</h3><p>服务间通信的流程与Zipkin的类似。在服务生产方，omega会拦截请求中事务相关的id来提取事务的上下文。在服务消费方，omega会在请求中注入事务相关的id来传递事务的上下文。通过服务提供方和服务消费方的这种协作处理，子事务能连接起来形成一个完整的全局事务。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16q92b65tj20wi0ca74s.jpg" alt=""></p>
<h3 id="Saga-具体处理流程"><a href="#Saga-具体处理流程" class="headerlink" title="Saga 具体处理流程"></a>Saga 具体处理流程</h3><p>Saga处理场景是要求相关的子事务提供事务处理函数同时也提供补偿函数。Saga协调器alpha会根据事务的执行情况向omega发送相关的指令，确定是否向前重试或者向后恢复。</p>
<h4 id="成功场景"><a href="#成功场景" class="headerlink" title="成功场景"></a>成功场景</h4><p>成功场景下，每个事务都会有开始和有对应的结束事件。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16q9lthpvj21cw0qijsz.jpg" alt=""></p>
<h4 id="异常场景"><a href="#异常场景" class="headerlink" title="异常场景"></a>异常场景</h4><p>异常场景下，omega会向alpha上报中断事件，然后alpha会向该全局事务的其它已完成的子事务发送补偿指令，确保最终所有的子事务要么都成功，要么都回滚。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qaa8gjwj21cr0rkwg6.jpg" alt=""></p>
<h4 id="超时场景-需要调整）"><a href="#超时场景-需要调整）" class="headerlink" title="超时场景 (需要调整）"></a>超时场景 (需要调整）</h4><p>超时场景下，已超时的事件会被alpha的定期扫描器检测出来，与此同时，该超时事务对应的全局事务也会被中断。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qatqfjbj21cu0rgwfx.jpg" alt=""></p>
<h3 id="TCC-具体处理流程"><a href="#TCC-具体处理流程" class="headerlink" title="TCC 具体处理流程"></a>TCC 具体处理流程</h3><p>TCC(try-confirm-cancel)与Saga事务处理方式相比多了一个Try方法。事务调用的发起方来根据事务的执行情况协调相关各方进行提交事务或者回滚事务。</p>
<h4 id="成功场景-1"><a href="#成功场景-1" class="headerlink" title="成功场景"></a>成功场景</h4><p>成功场景下， 每个事务都会有开始和对应的结束事件<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qbrxbazj21lo0wydin.jpg" alt=""></p>
<h4 id="异常场景-1"><a href="#异常场景-1" class="headerlink" title="异常场景"></a>异常场景</h4><p>异常场景下，事务发起方会向alpha上报异常事件，然后alpha会向该全局事务的其它已完成的子事务发送补偿指令，确保最终所有的子事务要么都成功，要么都回滚。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qcdd807j21ku0vu76t.jpg" alt=""></p>
<h2 id="omega、alpha的TSL双向证书"><a href="#omega、alpha的TSL双向证书" class="headerlink" title="omega、alpha的TSL双向证书"></a>omega、alpha的TSL双向证书</h2><p>Saga 现在支持在omega和alpha服务之间采用 TLS 通信.同样客户端方面的认证（双向认证）。</p>
<h3 id="准备证书-（Certificates）"><a href="#准备证书-（Certificates）" class="headerlink" title="准备证书 （Certificates）"></a>准备证书 （Certificates）</h3><p>你可以用下面的命令去生成一个用于测试的自签名的证书。 如果你想采用双向认证的方式，只需要客户端证书。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Changes these CN's to match your hosts in your environment if needed.</span></span><br><span class="line"><span class="attribute">SERVER_CN</span>=localhost</span><br><span class="line"><span class="attribute">CLIENT_CN</span>=localhost # Used when doing mutual TLS</span><br><span class="line"></span><br><span class="line">echo Generate CA key:</span><br><span class="line">openssl genrsa -passout pass:1111 -des3 -out ca.key 4096</span><br><span class="line">echo Generate CA certificate:</span><br><span class="line"><span class="comment"># Generates ca.crt which is the trustCertCollectionFile</span></span><br><span class="line">openssl req -passin pass:1111 -new -x509 -days 365 -key ca.key -out ca.crt -subj <span class="string">"/CN=<span class="variable">$&#123;SERVER_CN&#125;</span>"</span></span><br><span class="line">echo Generate<span class="built_in"> server </span>key:</span><br><span class="line">openssl genrsa -passout pass:1111 -des3 -out server.key 4096</span><br><span class="line">echo Generate<span class="built_in"> server </span>signing request:</span><br><span class="line">openssl req -passin pass:1111 -new -key server.key -out server.csr -subj <span class="string">"/CN=<span class="variable">$&#123;SERVER_CN&#125;</span>"</span></span><br><span class="line">echo Self-signed<span class="built_in"> server </span>certificate:</span><br><span class="line"><span class="comment"># Generates server.crt which is the certChainFile for the server</span></span><br><span class="line">openssl x509 -req -passin pass:1111 -days 365 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt </span><br><span class="line">echo <span class="builtin-name">Remove</span> passphrase <span class="keyword">from</span><span class="built_in"> server </span>key:</span><br><span class="line">openssl rsa -passin pass:1111 -in server.key -out server.key</span><br><span class="line">echo Generate<span class="built_in"> client </span>key</span><br><span class="line">openssl genrsa -passout pass:1111 -des3 -out client.key 4096</span><br><span class="line">echo Generate<span class="built_in"> client </span>signing request:</span><br><span class="line">openssl req -passin pass:1111 -new -key client.key -out client.csr -subj <span class="string">"/CN=<span class="variable">$&#123;CLIENT_CN&#125;</span>"</span></span><br><span class="line">echo Self-signed<span class="built_in"> client </span>certificate:</span><br><span class="line"><span class="comment"># Generates client.crt which is the clientCertChainFile for the client (need for mutual TLS only)</span></span><br><span class="line">openssl x509 -passin pass:1111 -req -days 365 -in client.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out client.crt</span><br><span class="line">echo <span class="builtin-name">Remove</span> passphrase <span class="keyword">from</span><span class="built_in"> client </span>key:</span><br><span class="line">openssl rsa -passin pass:1111 -in client.key -out client.key</span><br><span class="line">echo Converting the private keys <span class="keyword">to</span> X.509:</span><br><span class="line"><span class="comment"># Generates client.pem which is the clientPrivateKeyFile for the Client (needed for mutual TLS only)</span></span><br><span class="line">openssl pkcs8 -topk8 -nocrypt -in client.key -out client.pem</span><br><span class="line"><span class="comment"># Generates server.pem which is the privateKeyFile for the Server</span></span><br><span class="line">openssl pkcs8 -topk8 -nocrypt -in server.key -out server.pem</span><br></pre></td></tr></table></figure>
<h3 id="TLS为Alpha服务开启TLS"><a href="#TLS为Alpha服务开启TLS" class="headerlink" title="TLS为Alpha服务开启TLS"></a>TLS为Alpha服务开启TLS</h3><p>1.为alpha-server修改application.yaml文件，在alpha.server部门增加ssl配置。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">alpha:</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    ssl:</span></span><br><span class="line"><span class="attr">      enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      cert:</span> <span class="string">server.crt</span></span><br><span class="line"><span class="attr">      key:</span> <span class="string">server.pem</span></span><br><span class="line"><span class="attr">      mutualAuth:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      clientCert:</span> <span class="string">client.crt</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>将server.crt 和 server.pem 文件放到alpha-server的root 2目录。如果你想双向认证，合并所有client证书到一个client.crt文件,并把client.crt文件放到root目录.</li>
<li>重新启动alpha服务器.</li>
</ol>
<h3 id="为Omega启用TLS"><a href="#为Omega启用TLS" class="headerlink" title="为Omega启用TLS"></a>为Omega启用TLS</h3><ol>
<li>获取CA证书串(chain), 如果你是将alpha服务运行在集群中，你可能需要去合并多个CA证书到一个文件中.</li>
<li>为客户端应用修改application.yaml文件, 在alpha.cluster 部分增加ssl配置.</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">alpha:</span></span><br><span class="line"><span class="attr">  cluster:</span></span><br><span class="line"><span class="attr">    address:</span> <span class="string">alpha-server.servicecomb.io:8080</span></span><br><span class="line"><span class="attr">    ssl:</span></span><br><span class="line"><span class="attr">      enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      certChain:</span> <span class="string">ca.crt</span></span><br><span class="line"><span class="attr">      mutualAuth:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      cert:</span> <span class="string">client.crt</span></span><br><span class="line"><span class="attr">      key:</span> <span class="string">client.pem</span></span><br></pre></td></tr></table></figure>
<ol>
<li>把ca.crt文件放到客户端应用程序的root目录 file under the client application root directory.如果你想用双向认证，仍需要把client.crt和client.pem放到root目录下.</li>
<li>重新启动客户端应用程序.</li>
</ol>
<h2 id="与Spring结合使用"><a href="#与Spring结合使用" class="headerlink" title="与Spring结合使用"></a>与Spring结合使用</h2><h3 id="Saga中的Event简介"><a href="#Saga中的Event简介" class="headerlink" title="Saga中的Event简介"></a>Saga中的Event简介</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">EventType</span> &#123;</span></span><br><span class="line">  SagaStartedEvent,</span><br><span class="line">  TxStartedEvent,</span><br><span class="line">  TxEndedEvent,</span><br><span class="line">  TxAbortedEvent,</span><br><span class="line">  TxCompensatedEvent,</span><br><span class="line">  SagaEndedEvent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SagaStartedEvent: 代表Saga事务的开始，Alpha接受到该事件会保存整个saga事务的执行上下文，其中包括多个本地事务/补偿请求</li>
<li>TxStartedEvent: 本地事务开始事件，其中包含了本地事务执行的上下文（调用方法名，以及相关调用参数）</li>
<li>TXEndedEvent: 本地事务结束事件</li>
<li>TxAbortedEvent: 本地事务执行失败事件，包含了事务执行失败的原因</li>
<li>TxCompensatedEvent: 本地事务补偿事件，Alpha会将本地事务执行的上下文传递给Omega，这样不需要Omega自己维护服务调用的状态。</li>
<li>SagaEndedEvent: 标志着saga事务请求的结束</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qo3gfn4j20x80ibn0v.jpg" alt=""><br>成功场景下，全局事务事件SagaStartedEvent对应SagaEndedEvent ，每个子事务开始的事件TxStartedEvent都会有对应的结束事件TXEndedEvent。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qof1a9kj20zc0j3dk0.jpg" alt=""><br>异常场景下，Omega会向Alpha上报中断事件TxAbortedEvent，然后Alpha会根据全局事务的执行情况， 想其它已成功的子事务(以完成TXEndedEvent)的服务发送补偿指令，以确保最终所有的子事务要么都成功，要么都回滚。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qos3fkjj20ha099abd.jpg" alt=""><br>超时场景下，已超时的事件会被alpha的定期扫描器检测出来，同时该超时事务对应的全局事务也会被中断。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g16qp1vtvlj20v00f0q4k.jpg" alt=""></p>
<ol>
<li>用户发送Request请求调用业务方法(business logic)</li>
<li>preIntercept向alpha发送TxStartedEvent</li>
<li>被AOP拦截的方法(business logic)被调用</li>
<li>当执行成功时postIntercept发送TxEndedEvent到alpha</li>
<li>最后业务方法向用户发送response</li>
</ol>
<h3 id="与Spring和Mysql结合使用"><a href="#与Spring和Mysql结合使用" class="headerlink" title="与Spring和Mysql结合使用"></a>与Spring和Mysql结合使用</h3><p><a href="https://github.com/dinghuang/servicecomb-test" target="_blank" rel="noopener">项目地址</a></p>
<p>通过源码编译，克隆代码<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/apache/servicecomb-pack.git</span><br></pre></td></tr></table></figure></p>
<p>在<code>alpha/alpha-server/pom.xml</code>文件中加入mysql依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>构建docker镜像<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">./servicecomb-pack</span></span><br><span class="line">mvn clean install -DskipTests -Pdocker</span><br></pre></td></tr></table></figure></p>
<p>成功后如图所示<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[@dinghuangMacPro:~]$ docker images</span><br><span class="line">REPOSITORY               <span class="keyword">TAG</span>                 <span class="title">IMAGE</span> ID            CREATED             SIZE</span><br><span class="line">pack-web                 <span class="number">0.3</span>.<span class="number">0</span>               <span class="number">77</span>dedfe8e865        <span class="number">15</span> seconds ago      <span class="number">131M</span>B</span><br><span class="line">alpha-server             <span class="number">0.3</span>.<span class="number">0</span>               <span class="number">3</span>a34b8cd4224        <span class="number">38</span> seconds ago      <span class="number">144M</span>B</span><br></pre></td></tr></table></figure></p>
<p>启动mysql镜像，如果本地有的话<br>创建库saga，用户saga，密码password，并执行数据库脚本<code>schema-mysql.sql</code></p>
<p>启动alpha-server<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -<span class="selector-tag">p</span> <span class="number">8080</span>:<span class="number">8080</span> -<span class="selector-tag">p</span> <span class="number">8090</span>:<span class="number">8090</span> --link mysql:mysql<span class="selector-class">.servicecomb</span><span class="selector-class">.io</span> -e JAVA_OPTS=-Dspring<span class="selector-class">.profiles</span><span class="selector-class">.active</span>=mysql -e -Dspring<span class="selector-class">.datasource</span><span class="selector-class">.url</span>=jdbc:mysql:<span class="comment">//127.0.0.1:3306/saga?useSSL=false alpha-server:0.3.0</span></span><br></pre></td></tr></table></figure></p>
<p>启动对应的3个应用，分别说shop，order，hotel</p>
<p>访问api<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8081</span><span class="regexp">/shop/u</span>serName<span class="regexp">/orderName/</span>hotelName</span><br></pre></td></tr></table></figure></p>
<h3 id="事务解析"><a href="#事务解析" class="headerlink" title="事务解析"></a>事务解析</h3><p>请求流程示意图：用户发起请求到shop，shop分别调用order和hotel。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fgy1g193ofrsu9j20q00umta3.jpg" alt=""></p>
<p>使用TCC模式，TCC原理图如图所示：<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fgy1g193pjsh7tj20nc0blq9i.jpg" alt=""></p>
<h4 id="情况一：正常事务结束"><a href="#情况一：正常事务结束" class="headerlink" title="情况一：正常事务结束"></a>情况一：正常事务结束</h4><p><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g199o8nyxcj21660e6128.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g199omza6aj21nq044goa.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g199oxaun5j21my03ctb9.jpg" alt=""><br>事务记录成功，订单酒店表都有数据。</p>
<h4 id="情况二：父事件中调用订单成功后，出现异常"><a href="#情况二：父事件中调用订单成功后，出现异常" class="headerlink" title="情况二：父事件中调用订单成功后，出现异常"></a>情况二：父事件中调用订单成功后，出现异常</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父事务</span></span><br><span class="line"><span class="meta">@TccStart</span>(timeout = <span class="number">2</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/shop_tcc/&#123;name&#125;/&#123;order&#125;/&#123;hotel&#125;"</span>)</span><br><span class="line">public <span class="built_in">String</span> shopTcc(<span class="meta">@PathVariable</span> <span class="built_in">String</span> name, <span class="meta">@PathVariable</span> <span class="built_in">String</span> order, <span class="meta">@PathVariable</span> <span class="built_in">String</span> hotel) &#123;</span><br><span class="line">        <span class="comment">//调用订单服务的请求</span></span><br><span class="line">        template.postForEntity(<span class="string">"http://127.0.0.1:8082/order_tcc/&#123;name&#125;/&#123;order&#125;"</span>,<span class="keyword">null</span>, <span class="built_in">String</span>.<span class="keyword">class</span>, name, order);</span><br><span class="line">         <span class="comment">//异常</span></span><br><span class="line">        postBooking();</span><br><span class="line">        <span class="comment">//调用酒店服务的请求</span></span><br><span class="line">        template.postForEntity(<span class="string">"http://127.0.0.1:8083/hotel_tcc/&#123;name&#125;/&#123;hotel&#125;"</span>,<span class="keyword">null</span>, <span class="built_in">String</span>.<span class="keyword">class</span>, name, hotel);</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">" order "</span> + order + <span class="string">"hotel "</span> + hotel + <span class="string">" cars OK"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订单(酒店)中的代码逻辑</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">(OrderDO orderDO)</span> </span>&#123;</span><br><span class="line">        orderRepository.deleteById(orderDO.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">confirm</span><span class="params">(OrderDO orderDO)</span> </span>&#123;</span><br><span class="line">        orderRepository.insert(orderDO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Participate</span>(confirmMethod = <span class="string">"confirm"</span>, cancelMethod = <span class="string">"cancel"</span>)</span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">orderTcc</span><span class="params">(OrderDO orderDO)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据库结果如图所示<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g199hjb9mdj213u0bowkw.jpg" alt=""><br>订单和商店的表都没有生成数据。</p>
<h4 id="情况三：父事件中调用订单和酒店成功后，出现异常"><a href="#情况三：父事件中调用订单和酒店成功后，出现异常" class="headerlink" title="情况三：父事件中调用订单和酒店成功后，出现异常"></a>情况三：父事件中调用订单和酒店成功后，出现异常</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父事务</span></span><br><span class="line"><span class="meta">@TccStart</span>(timeout = <span class="number">2</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/shop_tcc/&#123;name&#125;/&#123;order&#125;/&#123;hotel&#125;"</span>)</span><br><span class="line">public <span class="built_in">String</span> shopTcc(<span class="meta">@PathVariable</span> <span class="built_in">String</span> name, <span class="meta">@PathVariable</span> <span class="built_in">String</span> order, <span class="meta">@PathVariable</span> <span class="built_in">String</span> hotel) &#123;</span><br><span class="line">        <span class="comment">//调用订单服务的请求</span></span><br><span class="line">        template.postForEntity(<span class="string">"http://127.0.0.1:8082/order_tcc/&#123;name&#125;/&#123;order&#125;"</span>,<span class="keyword">null</span>, <span class="built_in">String</span>.<span class="keyword">class</span>, name, order);</span><br><span class="line">        <span class="comment">//调用酒店服务的请求</span></span><br><span class="line">        template.postForEntity(<span class="string">"http://127.0.0.1:8083/hotel_tcc/&#123;name&#125;/&#123;hotel&#125;"</span>,<span class="keyword">null</span>, <span class="built_in">String</span>.<span class="keyword">class</span>, name, hotel);</span><br><span class="line">         <span class="comment">//异常</span></span><br><span class="line">        postBooking();</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">" order "</span> + order + <span class="string">"hotel "</span> + hotel + <span class="string">" cars OK"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据如图所示：<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g199w48vfaj217e0ciajm.jpg" alt=""><br>订单表与酒店表都没有产生数据</p>
<h4 id="情况四：父事件超时"><a href="#情况四：父事件超时" class="headerlink" title="情况四：父事件超时"></a>情况四：父事件超时</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父事务</span></span><br><span class="line"><span class="meta">@TccStart</span>(timeout = <span class="number">2</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/shop_tcc/&#123;name&#125;/&#123;order&#125;/&#123;hotel&#125;"</span>)</span><br><span class="line">public <span class="built_in">String</span> shopTcc(<span class="meta">@PathVariable</span> <span class="built_in">String</span> name, <span class="meta">@PathVariable</span> <span class="built_in">String</span> order, <span class="meta">@PathVariable</span> <span class="built_in">String</span> hotel) throws InterruptedException &#123;</span><br><span class="line">        <span class="comment">//调用订单服务的请求</span></span><br><span class="line">        template.postForEntity(<span class="string">"http://127.0.0.1:8082/order_tcc/&#123;name&#125;/&#123;order&#125;"</span>,<span class="keyword">null</span>, <span class="built_in">String</span>.<span class="keyword">class</span>, name, order);</span><br><span class="line">        <span class="comment">//调用酒店服务的请求</span></span><br><span class="line">        template.postForEntity(<span class="string">"http://127.0.0.1:8083/hotel_tcc/&#123;name&#125;/&#123;hotel&#125;"</span>,<span class="keyword">null</span>, <span class="built_in">String</span>.<span class="keyword">class</span>, name, hotel);</span><br><span class="line">         <span class="comment">//超时</span></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">" order "</span> + order + <span class="string">"hotel "</span> + hotel + <span class="string">" cars OK"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现TCC的timeout选项好像没有作用。。。。看了下源码，的确没有用到，源码如下<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g19adzx8ahj2246138drc.jpg" alt=""><br>ServiceComb在0.3.0加入了TCC的支持，所以有些功能还待完善把。</p>
<h4 id="情况五：订单服务启动，酒店服务未启动"><a href="#情况五：订单服务启动，酒店服务未启动" class="headerlink" title="情况五：订单服务启动，酒店服务未启动"></a>情况五：订单服务启动，酒店服务未启动</h4><p>关闭hotel服务，执行后数据如下：<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fly1g19ajirqhpj215s0aiq99.jpg" alt=""><br>订单和酒店数据库都没有数据</p>
<h4 id="情况六-模拟运行过程中alpha服务挂起，订单、酒店、商店服务正常运行："><a href="#情况六-模拟运行过程中alpha服务挂起，订单、酒店、商店服务正常运行：" class="headerlink" title="情况六: 模拟运行过程中alpha服务挂起，订单、酒店、商店服务正常运行："></a>情况六: 模拟运行过程中alpha服务挂起，订单、酒店、商店服务正常运行：</h4><p>订单、酒店、商店服务后来日志显示心跳连接失效<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fgy1g19aq910axj223k0gstfo.jpg" alt=""><br>请求数据返回错误信息，数据库表均未写入数据。<br><img src="https://ws1.sinaimg.cn/large/9bc4cb9fgy1g19ap4jromj211602kwjk.jpg" alt=""></p>
<p>重新启动alpha服务，订单、酒店、商店服务重新连接到alpha，业务正常运行。</p>
<h4 id="情况七-模拟运行过程中alpha服务的mysql挂起，订单、酒店、商店服务正常运行："><a href="#情况七-模拟运行过程中alpha服务的mysql挂起，订单、酒店、商店服务正常运行：" class="headerlink" title="情况七: 模拟运行过程中alpha服务的mysql挂起，订单、酒店、商店服务正常运行："></a>情况七: 模拟运行过程中alpha服务的mysql挂起，订单、酒店、商店服务正常运行：</h4><p>请求未进入业务逻辑之前，alpha服务报错，请求未执行。<br>mysql重启成功后，alpha服务正常运行，请求数据正常执行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ServiceComb对于数据最终一致性的解决现阶段0.3.0是满足业务逻辑的，但是对于失败重试、超时等功能这一块还不支持，后期应该会扩展。ServiceComb功能比较简单，但是可以通过对omega的事物id结合调用链追踪实现业务流程与事务的追溯。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/02/22/数据库优化方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/22/数据库优化方案/" itemprop="url">数据库优化方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T11:47:00+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/22/数据库优化方案/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/02/22/数据库优化方案/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SQL优化方案"><a href="#SQL优化方案" class="headerlink" title="SQL优化方案"></a>SQL优化方案</h1><p><a href="https://mp.weixin.qq.com/s/DBeVzJyR9_PXnoAIfJiHfg" target="_blank" rel="noopener">参考博客</a></p>
<h2 id="优化的哲学"><a href="#优化的哲学" class="headerlink" title="优化的哲学"></a>优化的哲学</h2><h3 id="优化可能带来的影响"><a href="#优化可能带来的影响" class="headerlink" title="优化可能带来的影响"></a>优化可能带来的影响</h3><ul>
<li>优化不总是对一个单纯的环境进行，还很可能是一个复杂的已投产的系统；</li>
<li>优化手段本来就有很大的风险，只不过你没能力意识到和预见到；</li>
<li>任何的技术可以解决一个问题，但必然存在带来一个问题的风险；</li>
<li>对于优化来说解决问题而带来的问题，控制在可接受的范围内才是有成果；</li>
<li>保持现状或出现更差的情况都是失败！</li>
</ul>
<h3 id="优化的需求"><a href="#优化的需求" class="headerlink" title="优化的需求"></a>优化的需求</h3><ul>
<li>稳定性和业务可持续性，通常比性能更重要；</li>
<li>优化不可避免涉及到变更，变更就有风险；</li>
<li>优化使性能变好，维持和变差是等概率事件；</li>
<li>切记优化，应该是各部门协同，共同参与的工作，任何单一部门都不能对数据库进行优化！</li>
</ul>
<p>所以优化工作，是由业务需要驱使的！</p>
<h3 id="优化参与"><a href="#优化参与" class="headerlink" title="优化参与"></a>优化参与</h3><p>在进行数据库优化时，应由数据库管理员、业务部门代表、应用程序架构师、应用程序设计人员、应用程序开发人员、硬件及系统管理员、存储管理员等，业务相关人员共同参与。 </p>
<h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><h3 id="优化对象"><a href="#优化对象" class="headerlink" title="优化对象"></a>优化对象</h3><p>在数据库优化上有两个主要方面：即安全与性能。</p>
<ul>
<li>安全-&gt;数据可持续性</li>
<li>性能-&gt;数据的高性能访问</li>
</ul>
<h3 id="优化的范围"><a href="#优化的范围" class="headerlink" title="优化的范围"></a>优化的范围</h3><ul>
<li>存储、主机和操作系统方面：<ul>
<li>主机架构稳定性；</li>
<li>I/O规划及配置；</li>
<li>Swap交换分区；</li>
<li>OS内核参数和网络问题。</li>
</ul>
</li>
<li>应用程序方面：<ul>
<li>应用程序稳定性；</li>
<li>SQL语句性能；</li>
<li>串行访问资源；</li>
<li>能欠佳会话管理；</li>
<li>这个应用适不适合用MySQL。</li>
</ul>
</li>
<li>数据库优化方面：<ul>
<li>内存；</li>
<li>数据库结构（物理&amp;逻辑）；</li>
<li>实例配置。</li>
</ul>
</li>
</ul>
<blockquote>
<p>不管是设计系统、定位问题还是优化，都可以按照这个顺序执行。</p>
</blockquote>
<h3 id="优化维度"><a href="#优化维度" class="headerlink" title="优化维度"></a>优化维度</h3><p>数据库优化维度有四个：</p>
<p>硬件、系统配置、数据库表结构、SQL及索引。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0cvkxgfrpj20iw09yad5.jpg" alt=""></p>
<p>优化选择：</p>
<p>优化成本：硬件&gt;系统配置&gt;数据库表结构&gt;SQL及索引。</p>
<p>优化效果：硬件&lt;系统配置&lt;数据库表结构&lt;SQL及索引。</p>
<h2 id="优化工具"><a href="#优化工具" class="headerlink" title="优化工具"></a>优化工具</h2><h3 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h3><p>检查问题常用工具：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1）MySQL</span><br><span class="line"></span><br><span class="line">2）msyqladmin：MySQL客户端，可进行管理操作</span><br><span class="line"></span><br><span class="line">3）mysqlshow：功能强大的查看shell命令</span><br><span class="line"></span><br><span class="line">4）<span class="keyword">show</span> [<span class="keyword">SESSION</span> | <span class="keyword">GLOBAL</span>] <span class="keyword">variables</span>：查看数据库参数信息</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）<span class="keyword">SHOW</span> [<span class="keyword">SESSION</span> | <span class="keyword">GLOBAL</span>] <span class="keyword">STATUS</span>：查看数据库的状态信息</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）information_schema：获取元数据的方法</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>）<span class="keyword">SHOW</span> <span class="keyword">ENGINE</span> <span class="keyword">INNODB</span> <span class="keyword">STATUS</span>：<span class="keyword">Innodb</span>引擎的所有状态</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>）<span class="keyword">SHOW</span> <span class="keyword">PROCESSLIST</span>：查看当前所有连接<span class="keyword">session</span>状态</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>）<span class="keyword">explain</span>：获取查询语句的执行计划</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>）<span class="keyword">show</span> <span class="keyword">index</span>：查看表的索引信息</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>）slow-<span class="keyword">log</span>：记录慢查询语句</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>）mysqldumpslow：分析slowlog文件的</span><br></pre></td></tr></table></figure>
<p>不常用但好用的工具：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）Zabbix：监控主机、系统、数据库（部署zabbix监控平台）</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）pt-query-digest：分析慢日志</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）MySQL slap：分析慢日志</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）sysbench：压力测试工具</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）MySQL profiling：统计数据库整体状态工具    </span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）Performance Schema：MySQL性能状态统计的数据</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>）workbench：管理、备份、监控、分析、优化工具（比较费资源）</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="http://www.cnblogs.com/clsn/p/7885990.html" target="_blank" rel="noopener">关于Zabbix参考</a></p>
</blockquote>
<h3 id="数据库层面问题解决思路"><a href="#数据库层面问题解决思路" class="headerlink" title="数据库层面问题解决思路"></a>数据库层面问题解决思路</h3><p>一般应急调优的思路：针对突然的业务办理卡顿，无法进行正常的业务处理，需要立马解决的场景。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）show processlist；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）explain  select <span class="built_in">id</span> ,<span class="built_in">name</span> <span class="keyword">from</span> stu <span class="keyword">where</span> <span class="built_in">name</span>='clsn'; <span class="comment"># ALL  id name age  sex；</span></span><br><span class="line"></span><br><span class="line">select <span class="built_in">id</span>,<span class="built_in">name</span> <span class="keyword">from</span> stu  <span class="keyword">where</span> <span class="built_in">id</span>=<span class="number">2</span><span class="number">-1</span> 函数 结果集&gt;<span class="number">30</span>；show index <span class="keyword">from</span> table；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）通过执行计划判断，索引问题（有没有、合不合理）或者语句本身问题；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）show status  like '%lock%';    <span class="comment"># 查询锁状态</span></span><br><span class="line"></span><br><span class="line">kill SESSION_ID;   <span class="comment"># 杀掉有问题的session。</span></span><br></pre></td></tr></table></figure></p>
<p>常规调优思路：针对业务周期性的卡顿，例如在每天10-11点业务特别慢，但是还能够使用，过了这段时间就好了。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）查看slowlog，分析slowlog，分析出查询慢的语句；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）按照一定优先级，一个一个排查所有慢语句；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）分析top SQL，进行explain调试，查看语句执行时间；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）调整索引或语句本身。</span><br></pre></td></tr></table></figure></p>
<h3 id="系统层面"><a href="#系统层面" class="headerlink" title="系统层面"></a>系统层面</h3><p><strong>Cpu方面</strong><br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat、sar <span class="built_in">top</span>、htop、nmon、mpstat；</span><br></pre></td></tr></table></figure></p>
<p><strong>内存</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>、ps-aux；</span><br></pre></td></tr></table></figure></p>
<p>IO设备（磁盘、网络）<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">iostat</span>、ss、netstat、iptraf、iftop、lsof；</span><br></pre></td></tr></table></figure></p>
<p><strong>vmstat命令说明</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）Procs：r显示有多少进程正在等待CPU时间。b显示处于不可中断的休眠的进程数量。在等待I/O。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）Memory：swpd显示被交换到磁盘的数据块的数量。未被使用的数据块，用户缓冲数据块，用于操作系统的数据块的数量。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）Swap：操作系统每秒从磁盘上交换到内存和从内存交换到磁盘的数据块的数量。s1和s0最好是<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）Io：每秒从设备中读入b1的写入到设备b0的数据块的数量。反映了磁盘I/O。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）System：显示了每秒发生中断的数量（in）和上下文交换（cs）的数量。</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）Cpu：显示用于运行用户代码，系统代码，空闲，等待I/O的Cpu时间。</span><br></pre></td></tr></table></figure></p>
<p><strong>iostat命令说明</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">实例命令：iostat -dk <span class="number">1</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">　　　　   iostat -d -k -x <span class="number">5</span> （查看设备使用率（%util）和响应时间（await））</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）tps：该设备每秒的传输次数。“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）iops ：硬件出厂的时候，厂家定义的一个每秒最大的IO次数</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）<span class="string">"一次传输"</span>请求的大小是未知的。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）kB_read/s：每秒从设备（drive expressed）读取的数据量；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）KB_wrtn/s：每秒向设备（drive expressed）写入的数据量；</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）kB_read：读取的总数据量；</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>）kB_wrtn：写入的总数量数据量；这些单位都为Kilobytes。</span><br></pre></td></tr></table></figure></p>
<h3 id="系统层面问题解决办法"><a href="#系统层面问题解决办法" class="headerlink" title="系统层面问题解决办法"></a>系统层面问题解决办法</h3><p>你认为到底负载高好，还是低好呢？在实际的生产中，一般认为Cpu只要不超过90%都没什么问题。</p>
<p>当然不排除下面这些特殊情况：</p>
<p><strong>Cpu负载高，IO负载低</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）内存不够；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）磁盘性能差；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）SQL问题---&gt;去数据库层，进一步排查SQL 问题；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）IO出问题了（磁盘到临界了、raid设计不好、raid降级、锁、在单位时间内tps过高）；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）tps过高：大量的小数据IO、大量的全表扫描。</span><br></pre></td></tr></table></figure></p>
<p><strong>IO负载高，Cpu负载低</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）大量小的IO写操作：</span><br><span class="line"></span><br><span class="line">autocommit，产生大量小IO；IO/PS，磁盘的一个定值，硬件出厂的时候，厂家定义的一个每秒最大的IO次数。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）大量大的IO 写操作：SQL问题的几率比较大</span><br></pre></td></tr></table></figure></p>
<p><strong>IO和cpu负载都很高</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">硬件不够了或SQL存在问题。</span><br></pre></td></tr></table></figure></p>
<h2 id="基础优化"><a href="#基础优化" class="headerlink" title="基础优化"></a>基础优化</h2><h3 id="优化思路-1"><a href="#优化思路-1" class="headerlink" title="优化思路"></a>优化思路</h3><p><strong>定位问题点吮吸</strong>：硬件–&gt;系统–&gt;应用–&gt;数据库–&gt;架构（高可用、读写分离、分库分表）。</p>
<p><strong>处理方向</strong>：明确优化目标、性能和安全的折中、防患未然。</p>
<h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><p><strong>主机方面</strong><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">根据数据库类型，主机CPU选择、内存容量选择、磁盘选择：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）平衡内存和磁盘资源；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）随机的<span class="keyword">I</span>/<span class="keyword">O</span>和顺序的<span class="keyword">I</span>/<span class="keyword">O</span>；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）主机 RAID卡的BBU（Battery Backup Unit）关闭。</span><br></pre></td></tr></table></figure></p>
<p><strong>CPU的选择</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">CPU</span>的两个关键因素：核数、主频</span><br><span class="line"></span><br><span class="line">根据不同的业务类型进行选择：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）<span class="meta">CPU</span>密集型：计算比较多，OLTP - 主频很高的<span class="meta">cpu</span>、核数还要多</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）IO密集型：查询比较，OLAP - 核数要多，主频不一定高的</span><br></pre></td></tr></table></figure></p>
<p><strong>内存的选择</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OLAP类型数据库，需要更多内存，和数据获取量级有关。</span><br><span class="line"></span><br><span class="line">OLTP类型数据一般内存是Cpu核心数量的<span class="number">2</span>倍到<span class="number">4</span>倍，没有最佳实践。</span><br></pre></td></tr></table></figure></p>
<p><strong>存储方面</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）根据存储数据种类的不同，选择不同的存储设备；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）配置合理的RAID级别（raid5、raid10、热备盘）；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）对与操作系统来讲，不需要太特殊的选择，最好做好冗余（raid1）（ssd、sas、sata）。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）raid卡：</span><br><span class="line"></span><br><span class="line">       主机raid卡选择：</span><br><span class="line"></span><br><span class="line">           实现操作系统磁盘的冗余（raid1）；</span><br><span class="line"></span><br><span class="line">           平衡内存和磁盘资源；</span><br><span class="line"></span><br><span class="line">           随机的I/O和顺序的I/O；</span><br><span class="line"></span><br><span class="line">           主机raid卡的BBU（Battery Backup Unit）要关闭。</span><br></pre></td></tr></table></figure></p>
<p>网络设备方面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用流量支持更高的网络设备（交换机、路由器、网线、网卡、HBA卡）</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：以上这些规划应该在初始设计系统时就应该考虑好。</p>
</blockquote>
<h3 id="服务器硬件优化"><a href="#服务器硬件优化" class="headerlink" title="服务器硬件优化"></a>服务器硬件优化</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）物理状态灯</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）自带管理设备：远程控制卡（FENCE设备：ipmi ilo idarc）、开关机、硬件监控。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）第三方的监控软件、设备（snmp、agent）对物理设施进行监控。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）存储设备：自带的监控平台。EMC2（hp收购了）、 日立（hds）、IBM低端OEM hds、高端存储是自己技术，华为存储。</span><br></pre></td></tr></table></figure>
<h3 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h3><p><strong>Cpu</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本不需要调整，在硬件选择方面下功夫即可。</span><br></pre></td></tr></table></figure></p>
<p><strong>内存</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本不需要调整，在硬件选择方面下功夫即可。</span><br></pre></td></tr></table></figure></p>
<p><strong>SWAP</strong><br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MySQL尽量避免使用<span class="keyword">swap</span>。</span><br><span class="line"></span><br><span class="line">阿里云的服务器中默认<span class="keyword">swap</span>为<span class="number">0</span>。</span><br></pre></td></tr></table></figure></p>
<p><strong>IO</strong><br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raid、<span class="literal">no</span> lvm、ext4或xfs、ssd、IO调度策略。</span><br></pre></td></tr></table></figure></p>
<p><strong>Swap调整(不使用swap分区)</strong><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>swappiness的内容改成<span class="number">0</span>（临时），<span class="regexp">/etc/</span>sysctl. conf上添加vm.swappiness=<span class="number">0</span>（永久）</span><br></pre></td></tr></table></figure></p>
<p>这个参数决定了Linux是倾向于使用swap，还是倾向于释放文件系统cache。在内存紧张的情况下，数值越低越倾向于释放文件系统cache。</p>
<p>当然，这个参数只能减少使用swap的概率，并不能避免Linux使用swap。</p>
<p><strong>修改MySQL的配置参数<code>innodb_flush_ method</code>，开启O_DIRECT模式</strong>：</p>
<p>这种情况下，InnoDB的buffer pool会直接绕过文件系统cache来访问磁盘，但是redo log依旧会使用文件系统cache。</p>
<p>值得注意的是，Redo log是覆写模式的，即使使用了文件系统的cache，也不会占用太多。</p>
<p><strong>IO调度策略</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> deadline&gt;/sys/block/sda/queue/scheduler   临时修改为deadline</span></span><br></pre></td></tr></table></figure></p>
<p>永久修改<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /boot/grub/grub.conf</span><br><span class="line"></span><br><span class="line">更改到如下内容:</span><br><span class="line"></span><br><span class="line">kernel /boot/vmlinuz-2.6.18-8.el5 ro <span class="attribute">root</span>=LABEL=/ <span class="attribute">elevator</span>=deadline rhgb quiet</span><br></pre></td></tr></table></figure></p>
<h3 id="系统参数调整"><a href="#系统参数调整" class="headerlink" title="系统参数调整"></a>系统参数调整</h3><p><strong>Linux系统内核参数优化</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim/etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">net.ipv4.ip_local_port_range = <span class="number">1024</span> <span class="number">65535</span>：# 用户端口范围</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = <span class="number">4096</span> </span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_fin_timeout = <span class="number">30</span> </span><br><span class="line"></span><br><span class="line">fs.file-max=<span class="number">65535</span>：# 系统最大文件句柄，控制的是能打开文件最大数量</span><br></pre></td></tr></table></figure></p>
<p><strong>用户限制参数（MySQL可以不设置以下配置）</strong><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim/etc/security/limits.<span class="keyword">conf</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">* soft nproc 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">* hard nproc 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">* soft nofile 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">* hard nofile 65535</span></span><br></pre></td></tr></table></figure></p>
<h3 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h3><p>业务应用和数据库应用独立；</p>
<p><strong>防火墙</strong>：iptables、selinux等其他无用服务（关闭）：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">chkconfig</span> --level <span class="number">23456</span> acpid <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> anacron <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> autofs <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> avahi-daemon <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> bluetooth <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> cups <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> firstboot <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> haldaemon <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> hplip <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> ip6tables <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> iptables  <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> isdn <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> pcscd <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> sendmail  <span class="literal">off</span></span><br><span class="line"></span><br><span class="line">chkconfig --level <span class="number">23456</span> yum-updatesd  <span class="literal">off</span></span><br></pre></td></tr></table></figure></p>
<p>安装图形界面的服务器不要启动图形界面runlevel 3。 </p>
<p>另外，思考将来我们的业务是否真的需要MySQL，还是使用其他种类的数据库。用数据库的最高境界就是不用数据库。</p>
<h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><p>SQL优化方向：执行计划、索引、SQL改写。</p>
<p>架构优化方向：高可用架构、高性能架构、分库分表。</p>
<h3 id="数据库参数优化"><a href="#数据库参数优化" class="headerlink" title="数据库参数优化"></a>数据库参数优化</h3><p><strong>调整</strong></p>
<p>实例整体（高级优化，扩展）：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thread_concurrency：# 并发线程数量个数</span><br><span class="line"></span><br><span class="line">sort_buffer_size：# 排序缓存</span><br><span class="line"></span><br><span class="line">read_buffer_size：# 顺序读取缓存</span><br><span class="line"></span><br><span class="line">read_rnd_buffer_size：# 随机读取缓存</span><br><span class="line"></span><br><span class="line">key_buffer_size：# 索引缓存</span><br><span class="line"></span><br><span class="line">thread_cache_size：# (<span class="number">1</span>G—&gt;<span class="number">8</span>, <span class="number">2</span>G—&gt;<span class="number">16</span>, <span class="number">3</span>G—&gt;<span class="number">32</span>, &gt;<span class="number">3</span>G—&gt;<span class="number">64</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>连接层（基础优化）</strong><br>设置合理的连接客户和连接方式：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">max_connections           <span class="comment"># 最大连接数，看交易笔数设置    </span></span><br><span class="line"></span><br><span class="line">max_<span class="keyword">connect</span>_errors        <span class="comment"># 最大错误连接数，能大则大</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">connect</span>_timeout           <span class="comment"># 连接超时</span></span><br><span class="line"></span><br><span class="line">max_user_connections      <span class="comment"># 最大用户连接数</span></span><br><span class="line"></span><br><span class="line">skip-name-resolve         <span class="comment"># 跳过域名解析</span></span><br><span class="line"></span><br><span class="line">wait_timeout              <span class="comment"># 等待超时</span></span><br><span class="line"></span><br><span class="line">back_log                  <span class="comment"># 可以在堆栈中的连接数量</span></span><br></pre></td></tr></table></figure></p>
<p><strong>SQL层（基础优化）</strong><br>query_cache_size： 查询缓存  &gt;&gt;&gt;  OLAP类型数据库,需要重点加大此内存缓存，但是一般不会超过GB。</p>
<p>对于经常被修改的数据，缓存会立马失效。</p>
<p>我们可以实用内存数据库（redis、memecache），替代他的功能。</p>
<p><strong>存储引擎层（innodb基础优化参数）</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">default</span>-storage-engine</span><br><span class="line"></span><br><span class="line">innodb_buffer_pool_size       # 没有固定大小，<span class="number">50</span>%测试值，看看情况再微调。但是尽量设置不要超过物理内存<span class="number">70</span>%</span><br><span class="line"></span><br><span class="line">innodb_file_per_table=(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">innodb_flush_log_at_trx_commit=(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>) # <span class="number">1</span>是最安全的，<span class="number">0</span>是性能最高，<span class="number">2</span>折中</span><br><span class="line"></span><br><span class="line">binlog_sync</span><br><span class="line"></span><br><span class="line">Innodb_flush_method=(O_DIRECT, fdatasync)</span><br><span class="line"></span><br><span class="line">innodb_log_buffer_size           # <span class="number">100</span>M以下</span><br><span class="line"></span><br><span class="line">innodb_log_file_size               # <span class="number">100</span>M 以下</span><br><span class="line"></span><br><span class="line">innodb_log_files_in_group       # <span class="number">5</span>个成员以下,一般<span class="number">2</span><span class="number">-3</span>个够用（iblogfile0-N）</span><br><span class="line"></span><br><span class="line">innodb_max_dirty_pages_pct   # 达到百分之<span class="number">75</span>的时候刷写 内存脏页到磁盘。</span><br><span class="line"></span><br><span class="line">log_bin</span><br><span class="line"></span><br><span class="line">max_binlog_cache_size                     # 可以不设置</span><br><span class="line"></span><br><span class="line">max_binlog_size                               # 可以不设置</span><br><span class="line"></span><br><span class="line">innodb_additional_mem_pool_size     #小于<span class="number">2</span>G内存的机器，推荐值是<span class="number">20</span>M。<span class="number">32</span>G内存以上<span class="number">100</span>M</span><br></pre></td></tr></table></figure></p>
<h2 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h2><p><a href="https://juejin.im/post/5aa7703c6fb9a028c8128739" target="_blank" rel="noopener">原文博客</a></p>
<ol>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以在 num 上设置默认值 0,确保表中 num 列没有 null 值，然后这样查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li>
<li>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以这样查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span>;</span><br></pre></td></tr></table></figure></p>
<ol start="5">
<li>in 和 not in 也要慎用，否则会导致全表扫描，如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对于连续的数值，能用 between 就不要用 in 了：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<ol start="6">
<li>下面的查询也将导致全表扫描：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%c%'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>若要提高效率，可以考虑<a href="https://www.jianshu.com/p/c48106149b6a" target="_blank" rel="noopener">全文检索</a>。</p>
<ol start="7">
<li>如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优 化程序不能将访问计划的选择推迟到运行时;它必须在编译时进行选择。然 而，如果在编译时建立访问计 划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span> ;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以改为强制查询使用索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">with</span>(<span class="keyword">index</span>(索引名)) <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span> ;</span><br></pre></td></tr></table></figure></p>
<ol start="8">
<li>应尽量避免在 where 子句中对字段进行表达式操作， 这将导致引擎放弃使用索引而进行全表扫描。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以这样查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<ol start="9">
<li>应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="title">substring</span>(<span class="params">name,<span class="number">1</span>,<span class="number">3</span></span>)</span>=<span class="string">'abc'</span>;<span class="meta">#name 以 abc 开头的 id</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>应改为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'abc%'</span>;</span><br></pre></td></tr></table></figure></p>
<ol start="10">
<li>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用 索引。</li>
<li>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件 时才能保证系统使用该索引， 否则该索引将不会 被使用， 并且应尽可能的让字段顺序与索引顺序相一致。</li>
<li>不要写一些没有意义的查询，如需要生成一个空表结构：<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">into</span> #t <span class="keyword">from</span> t <span class="keyword">where</span> <span class="number">1</span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<br><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table <span class="function"><span class="keyword">#</span><span class="title">t</span><span class="params">(…)</span></span>;</span><br></pre></td></tr></table></figure></p>
<ol start="13">
<li>很多时候用 exists 代替 in 是一个好的选择：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> b);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>用下面的语句替换：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> b <span class="keyword">where</span> <span class="keyword">num</span>=a.num);</span><br></pre></td></tr></table></figure></p>
<ol start="14">
<li>并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时， SQL 查询可能不会去利用索引，如一表中有字段 sex,male、female 几乎各一半，那么即使在 sex 上建 了索引也对查询效率起不了作用。</li>
<li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li>
<li>应尽可能的避免更新 clustered 索引数据列， 因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</li>
<li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并 会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言 只需要比较一次就够了。</li>
<li>尽可能的使用 <code>varchar/nvarchar</code> 代替 <code>char/nchar</code> , 因为首先变长字段存储空间小， 可以节省存储空间， 其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</li>
<li>任何地方都不要使用 <code>select * from t</code> ,用具体的字段列表代替“*”,不要返回用不到的任何字段。</li>
<li>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限(只有主键索引)。</li>
<li>避免频繁创建和删除临时表，以减少系统表资源的消耗。</li>
<li>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用。 表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</li>
<li>在新建临时表时，如果一次性插入数据量很大，那么可以使用 <code>select into</code> 代替 <code>create table</code>,避免造成大量 log ,以提高速度;如果数据量不大，为了缓和系统表的资源，应先 <code>create table</code>,然后 <code>insert</code>。</li>
<li>如果使用到了临时表， 在存储过程的最后务必将所有的临时表显式删除， 先 <code>truncate table</code> ,然后 <code>drop table</code> ,这样可以避免系统表的较长时间锁定。</li>
<li>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。</li>
<li>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</li>
<li>与临时表一样，游标并不是不可使用。对小型数据集使用 <code>FAST_FORWARD</code> 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</li>
<li>在所有的存储过程和触发器的开始处设置 <code>SET NOCOUNT ON</code>,在结束时设置 <code>SET NOCOUNT OFF</code> .无需在执行存储过程和触发器的每个语句后向客户端发送<code>DONE_IN_PROC</code>消息。</li>
<li><p>尽量避免大事务操作，提高系统并发能力。 sql 优化方法使用索引来更快地遍历表。 缺省情况下建立的索引是非群集索引，但有时它并不是最佳的。在非群集索引下，数据在物理上随机存放在数据页上。合理的索引设计要建立在对各种查询的分析和预测上。一般来说：</p>
<ul>
<li>有大量重复值、且经常有范围查询( &gt; ,&lt; ,&gt; =,&lt; =)和 order by、group by 发生的列，可考虑建立集群索引;</li>
<li>经常同时存取多列，且每列都含有重复值可考虑建立组合索引;</li>
<li>组合索引要尽量使关键查询形成索引覆盖，其前导列一定是使用最频繁的列。索引虽有助于提高性能但 不是索引越多越好，恰好相反过多的索引会导致系统低效。用户在表中每加进一个索引，维护索引集合就 要做相应的更新工作。</li>
</ul>
</li>
<li>定期分析表和检查表<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分析表的语法：<span class="keyword">ANALYZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> tb1_name[, tbl_name]...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上语句用于分析和存储表的关键字分布，分析的结果将可以使得系统得到准确的统计信息，使得SQL能够生成正确的执行计划。如果用户感觉实际执行计划并不是预期的执行计划，执行一次分析表可能会解决问题。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM，DBD和InnoDB表有作用。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如分析一个数据表：<span class="keyword">analyze</span> <span class="keyword">table</span> table_name</span><br><span class="line"></span><br><span class="line">检查表的语法：<span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tb1_name[,tbl_name]...[<span class="keyword">option</span>]...option = &#123;<span class="keyword">QUICK</span> | <span class="keyword">FAST</span> | <span class="keyword">MEDIUM</span> | <span class="keyword">EXTENDED</span> | <span class="keyword">CHANGED</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>检查表的作用是检查一个或多个表是否有错误，CHECK TABLE 对MyISAM 和 InnoDB表有作用，对于MyISAM表，关键字统计数据被更新</p>
<p>CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表不存在。</p>
<ol start="31">
<li>定期优化表。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">优化表的语法：<span class="keyword">OPTIMIZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> tb1_name [,tbl_name]...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果删除了表的一大部分，或者如果已经对含有可变长度行的表(含有 VARCHAR、BLOB或TEXT列的表)进行更多更改，则应使用OPTIMIZE TABLE命令来进行表优化。这个命令可以将表中的空间碎片进行合并，并且可以消除由于删除或者更新造成的空间浪费，但OPTIMIZE TABLE 命令只对MyISAM、 BDB 和InnoDB表起作用。</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如： optimize <span class="keyword">table</span> table_name</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： analyze、check、optimize执行期间将对表进行锁定，因此一定注意要在MySQL数据库不繁忙的时候执行相关的操作。</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>在海量查询时尽量少用格式转换。</li>
<li>ORDER BY 和 GROPU BY:使用 ORDER BY 和 GROUP BY 短语，任何一种索引都有助于 SELECT 的性能提高。</li>
<li>任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边。</li>
<li>IN、OR 子句常会使用工作表，使索引失效。如果不产生大量重复值，可以考虑把子句拆开。拆开的子 句中应该包含索引。</li>
<li>只要能满足你的需求，应尽可能使用更小的数据类型：例如使用 MEDIUMINT 代替 INT</li>
<li>尽量把所有的列设置为 NOT NULL,如果你要保存 NULL,手动去设置它，而不是把它设为默认值。</li>
<li>尽量少用 VARCHAR、TEXT、BLOB 类型</li>
<li>如果你的数据只有你所知的少量的几个。最好使用 ENUM 类型</li>
<li>正如 graymice 所讲的那样，建立索引。</li>
<li>合理用运分表与分区表提高数据存放和提取速度。</li>
</ol>
<h2 id="亿级数据下的分库分表方案"><a href="#亿级数据下的分库分表方案" class="headerlink" title="亿级数据下的分库分表方案"></a>亿级数据下的分库分表方案</h2><p><a href="https://www.tuicool.com/articles/2EzuQr7" target="_blank" rel="noopener">原文</a></p>
<h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>项目背景是企业级的统一消息处理平台，客户数据在5千万加，每分钟处理消息流水1千万，每天消息流水1亿左右。 虽说Mysql单表可以存储10亿级的数据，但这个时候性能非常差，项目中大量的实验证明，Mysql单表容量在500万左右，性能处于最佳状态，此时，Mysql的BTREE索引树高在3～5之间。既然一张表无法搞定，那么就想办法将数据放到多个地方来解决问题吧，于是，数据库分库分表的方案便产生了，目前比较普遍的方案有三个： 分区，分库分表，NoSql/NewSql 。</p>
<p>在实际的项目中，往往是这三种方案的结合来解决问题，目前绝大部分系统的核心数据都是以RDBMS存储为主，NoSql/NewSql存储为辅。</p>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>首先来了解一下分区方案。</p>
<p>分区表是由多个相关的底层表实现，这些底层表也是由句柄对象表示，所以我们也可以直接访问各个分区，存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），分区表的索引只是在各个底层表上各自加上一个相同的索引，从存储引擎的角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。这个方案也不错，它对用户屏蔽了sharding的细节，即使查询条件没有sharding column，它也能正常工作（只是这时候性能一般）。不过它的缺点很明显：很多的资源都受到单机的限制，例如连接数，网络吞吐等。如何进行分区，在实际应用中是一个非常关键的要素之一。在我们的项目中，以客户信息为例，客户数据量5000万加，项目背景要求保存客户的银行卡绑定关系，客户的证件绑定关系，以及客户绑定的业务信息。此业务背景下，该如何设计数据库呢。项目一期的时候，我们建立了一张客户业务绑定关系表，里面冗余了每一位客户绑定的业务信息。基本结构大致如下：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1086caaj20fa06m761.jpg" alt=""><br>查询时，对银行卡做索引，业务编号做索引，证件号做索引。随着需求大增多，这张表的索引会达到10个以上。而且客户解约再签约，里面会保存两条数据，只是绑定的状态不同。假设我们有5千万的客户，5个业务类型，每位客户平均2张卡，那么这张表的数据量将会达到惊人的5亿，事实上我们系统用户量还没有过百万时就已经不行了。mysql数据库中的数据是以文件的形势存在磁盘上的，默认放在/mysql/data下面（可以通过my.cnf中的datadir来查看）， 一张表主要对应着三个文件，一个是frm存放表结构的，一个是myd存放表数据的，一个是myi存表索引的。这三个文件都非常的庞大，尤其是.myd文件，快5个G了。 下面进行第一次分区优化 ，Mysql支持的分区方式有四种：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e11m0q1wj20fa066tbt.jpg" alt=""><br>在我们的项目中，range分区和list分区没有使用场景，如果基于绑定编号做range或者list分区，绑定编号没有实际的业务含义，无法通过它进行查询，因此，我们就剩下 HASH 分区和 KEY 分区了， HASH 分区仅支持int类型列的分区，且是其中的一列。看看我们的库表结构，发现没有哪一列是int类型的，如何做分区呢？可以增加一列，绑定时间列，将此列设置为int类型，然后按照绑定时间进行分区，将每一天绑定的用户分到同一个区里面去。这次优化之后，我们的插入快了许多，但是查询依然很慢，为什么，因为在做查询的时候，我们也只是根据银行卡或者证件号进行查询，并没有根据时间查询，相当于每次查询，mysql都会将所有的分区表查询一遍。</p>
<p>然后进行第二次方案优化，既然hash分区和key分区要求其中的一列必须是int类型的，那么创造出一个int类型的列出来分区是否可以。分析发现，银行卡的那串数字有秘密。银行卡一般是16位到19位不等的数字串，我们取其中的某一位拿出来作为表分区是否可行呢，通过分析发现，在这串数字中，其中确实有一位是0到9随机生成的，不同的卡串长度，这一位不同，绝不是最后一位，最后位数字一般都是校验位，不具有随机性。我们新设计的方案，基于银行卡号+随机位进行KEY分区，每次查询的时候，通过计算截取出这位随机位数字，再加上卡号，联合查询，达到了分区查询的目的，需要说明的是，分区后，建立的索引，也必须是分区列，否则的话，Mysql还是会在所有的分区表中查询数据。那么通过银行卡号查询绑定关系的问题解决了，那么证件号呢，如何通过证件号来查询绑定关系。前面已经讲过，做索引一定是要在分区健上进行，否则会引起全表扫描。我们再创建了一张新表，保存客户的证件号绑定关系，每位客户的证件号都是唯一的，新的证件号绑定关系表里，证件号作为了主键，那么如何来计算这个分区健呢，客户的证件信息比较庞杂，有身份证号，港澳台通行证，机动车驾驶证等等，如何在无序的证件号里找到分区健。为了解决这个问题，我们将证件号绑定关系表一分为二，其中的一张表专用于保存身份证类型的证件号，另一张表则保存其他证件类型的证件号，在身份证类型的证件绑定关系表中，我们将身份证号中的月数拆分出来作为了分区健，将同一个月出生的客户证件号保存在同一个区，这样分成了12个区，其他证件类型的证件号，数据量不超过10万，就没有必要进行分区了。这样每次查询时，首先通过证件类型确定要去查询哪张表，再计算分区健进行查询。</p>
<p>作了分区设计之后，保存2000万用户数据的时候，银行卡表的数据保存文件就分成了10个小文件，证件表的数据保存文件分成了12个小文件，解决了这两个查询的问题，还剩下一个问题就是，业务编号呢，怎么办，一个客户有多个签约业务，如何进行保存，这时候，采用分区的方案就不太合适了，它需要用到分表的方案。</p>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>如何进行分库分表，目前互联网上有许多的版本，比较知名的一些方案：</p>
<ul>
<li>阿里的<a href="https://github.com/alibaba/tb_tddl" target="_blank" rel="noopener">TDDL</a>，<a href="https://cn.aliyun.com/product/drds" target="_blank" rel="noopener">DRDS</a>和<a href="https://github.com/alibaba/cobar" target="_blank" rel="noopener">cobar</a></li>
<li><a href="https://yq.aliyun.com/articles/658786" target="_blank" rel="noopener">京东金融的sharding-jdbc</a></li>
<li>民间组织的<a href="https://github.com/MyCATApache/Mycat-Server" target="_blank" rel="noopener">MyCAT</a></li>
<li>360的<a href="https://github.com/Qihoo360/Atlas" target="_blank" rel="noopener">Atlas</a></li>
<li>美团的<a href="https://github.com/Meituan-Dianping/Zebra" target="_blank" rel="noopener">zebra</a></li>
</ul>
<p>其他比如网易，58，京东等公司都有自研的中间件。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0f0ubx3knj20oc0fd45s.jpg" alt=""><br>百花齐放的景象。但是这么多的分库分表中间件方案，归总起来，就两类： client模式和proxy模式 。</p>
<p><strong>client模式</strong><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1osp6e3j20fa0c2ta5.jpg" alt=""></p>
<p><strong>proxy模式</strong><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e1v26i8nj20fa0gxmyt.jpg" alt=""></p>
<p>无论是client模式，还是proxy模式，几个核心的步骤是一样的：SQL解析，重写，路由，执行，结果归并。个人比较倾向于采用client模式，它架构简单，性能损耗也比较小，运维成本低。如果在项目中引入mycat或者cobar，他们的单机模式无法保证可靠性，一旦宕机则服务就变得不可用，你又不得不引入HAProxy来实现它的高可用集群部署方案， 为了解决HAProxy的高可用问题，又需要采用Keepalived来实现。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e2eu3bjvj20fa0gy0zk.jpg" alt=""></p>
<p>我们在项目中放弃了这个方案，采用了shardingjdbc的方式。回到刚才的业务问题，如何对业务类型进行分库分表。分库分表第一步也是最重要的一步，即sharding column的选取，sharding column选择的好坏将直接决定整个分库分表方案最终是否成功。而sharding column的选取跟业务强相关。在我们的项目场景中，sharding column无疑最好的选择是业务编号。通过业务编号，将客户不同的绑定签约业务保存到不同的表里面去，查询时，根据业务编号路由到相应的表中进行查询，达到进一步优化sql的目的。</p>
<p>前面我们讲到了基于客户签约绑定业务场景的数据库优化，下面我们再聊一聊，对于海量数据的保存方案。</p>
<h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h4><p>也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。</p>
<h4 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h4><p>垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。如下图：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ezns2ifaj20bf08kgml.jpg" alt=""><br><strong>优点</strong></p>
<p>数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于 Web 和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破 IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。</p>
<p><strong>缺点</strong></p>
<ul>
<li>跨库 join 的问题</li>
<li>跨库事务（分布式事务）的问题</li>
</ul>
<p><strong>解决方式</strong></p>
<ul>
<li>全局表 <ul>
<li>所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库 join 查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。</li>
</ul>
</li>
<li>字段冗余 <ul>
<li>这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免 join 查询。</li>
</ul>
</li>
<li>数据同步<ul>
<li>定时 A 库中的 tab_a 表和 B 库中 tbl_b 有关联，可以定时将指定的表做同步。当然，同步本来会对数据库带来一定的影响，需要性能影响和数据时效性中取得一个平衡。这样来避免复杂的跨库查询。例如ETL工具。</li>
</ul>
</li>
<li>系统层组装<ul>
<li>在系统层面，通过调用不同模块的组件或者服务，获取到数据并进行字段拼装。说起来很容易，但实践起来可真没有这么简单，尤其是数据库设计上存在问题但又无法轻易调整的时候。</li>
</ul>
</li>
</ul>
<p>对于每分钟要处理近1000万的流水，每天流水近1亿的量，如何高效的写入和查询，是一项比较大的挑战。还是老办法，分库分表分区，读写分离，只不过这一次，我们先分表，再分库，最后分区。我们将消息流水按照不同的业务类型进行分表，相同业务的消息流水进入同一张表，分表完成之后，再进行分库。我们将流水相关的数据单独保存到一个库里面去，这些数据，写入要求高，查询和更新到要求低，将它们和那些更新频繁的数据区分开。分库之后，再进行分区。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e30hgeqaj20fa06c75g.jpg" alt=""><br>这是基于业务垂直度进行的分库操作，垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库，以达到系统资源的饱和利用率。这样的分库方案结合应用的微服务治理，每个微服务系统使用独立的一个数据库。将不同模块的数据分库存储，模块间不能进行相互关联查询，如果有，要么通过数据冗余解决，要么通过应用代码进行二次加工进行解决。若不能杜绝跨库关联查询，则将小表到数据冗余到大数据量大库里去。假如，流水大表中查询需要关联获得渠道信息，渠道信息在基础管理库里面，那么，要么在查询时，代码里二次查询基础管理库中的渠道信息表，要么将渠道信息表冗余到流水大表中。</p>
<p>将每天过亿的流水数据分离出去之后，流水库中单表的数据量还是太庞大，我们将单张流水表继续分区，按照一定的业务规则，（一般是查询索引列）将单表进行分区，一个表编程N个表，当然这些变化对应用层是无法感知的。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0e5r0z2zoj20fa0lgjw2.jpg" alt=""><br>分区表的设置，一般是以查询索引列进行分区，例如，对于流水表A，查询需要根据手机号和批次号进行查询，所以我们在创建分区的时候，就选择以手机号和批次号进行分区，这样设置后，查询都会走索引，每次查询Mysql都会根据查询条件计算出来，数据会落在那个分区里面，直接到对应的分区表中检索即可，避免了全表扫描。</p>
<p>对于每天流水过亿的数据，当然是要做历史表进行数据迁移的工作了。客户要求流水数据需要保存半年的时间，有的关键流水需要保存一年。删数据是不可能的了，也跑不了路，虽然当时非常有想删数据跑路的冲动。其实即时是删数据也是不太可能的了，delete的拙劣表演先淘汰了，truncate也快不了多少，我们采用了一种比较巧妙方法，具体步骤如下：</p>
<ol>
<li>创建一个原表一模一样的临时表1 <code>create table test_a_serial_1 like test_a_serial</code>;</li>
<li>将原表命名为临时表2 <code>alter table test_a_serial rename test_a_serial_{date}</code>;</li>
<li>将临时表1改为原表 <code>alter table able test_a_serial_1 rename able test_a_serial</code>; 此时，当日流水表就是一张新的空表了，继续保存当日的流水，而临时表2则保存的是昨天的数据和部分今天的数据，临时表2到名字中的date时间是通过计算获得的昨日的日期；每天会产生一张带有昨日日期的临时表2，每个表内的数据大约是有1000万。</li>
<li>将当日表中的历史数据迁移到昨日流水表中去 这样的操作都是用的定时任务进行处理，定时任务触发一般会选择凌晨12点以后，这个操作即时是几秒内完成，也有可能会有几条数据落入到当日表中去。因此我们最后还需要将当日表内的历史流水数据插入到昨日表内； <code>insert into test_a_serial_{date}(cloumn1,cloumn2….) select(cloumn1,cloumn2….) from test_a_serial where LEFT(create_time,8) &gt; CONCAT(date); commit</code>;</li>
</ol>
<p>如此，便完成了流水数据的迁移；</p>
<p>根据业务需要，有些业务数据需要保存半年，超过半年的进行删除,在进行删除的时候，就可以根据表名中的_{date}筛选出大于半年的流水直接删表；</p>
<p>半年的时间，对于一个业务流水表大约就会有180多张表，每张表又有20个分区表，那么如何进实时计算统计行查询呢？由于我们的项目对于流水的查询实时性要求不是特别高，因此我们在做查询时，进行了根据查询时间区间段进行路由查询的做法。大致做法时，根据客户选择的时间区间段，带上查询条件，分别去时间区间段内的每一张表内查询，将查询结果保存到一张临时表内，然后，再去查询临时表获得最终的查询结果。</p>
<p>半年的时间，对于一个业务流水表大约就会有180多张表，每张表又有20个分区表，那么如何进行查询呢？由于我们的项目对于流水的查询实时性要求不是特别高，因此我们在做查询时，进行了根据查询时间区间段进行路由查询的做法。大致做法时，根据客户选择的时间区间段，带上查询条件，分别去时间区间段内的每一张表内查询，将查询结果保存到一张临时表内，然后，再去查询临时表获得最终的查询结果。</p>
<p>以上便是我们面对大数据量的场景下，数据库层面做的相应的优化，一张每天一亿的表，经过拆分后，每个表分区内的数据在500万左右。</p>
<h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><h4 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h4><p>针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ezurxr0cj20bk07hwhl.jpg" alt=""><br>某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破 IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。</p>
<h4 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h4><p>将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。</p>
<p><strong>水平分库分表切分规则</strong></p>
<ul>
<li>RANGE<ul>
<li>从0到10000一个表，10001到20000一个表；</li>
</ul>
</li>
<li><a href="http://www.uml.org.cn/sjjm/201412301.asp?artid=15741" target="_blank" rel="noopener">HASH取模</a><ul>
<li>一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 取用户id，然后hash取模，分配到不同的数据库上。</li>
</ul>
</li>
<li>地理区域<ul>
<li>比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。</li>
</ul>
</li>
<li>时间<ul>
<li>按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。</li>
</ul>
</li>
</ul>
<h2 id="唯一ID方案"><a href="#唯一ID方案" class="headerlink" title="唯一ID方案"></a>唯一ID方案</h2><p>这个方案也很多，主流的有那么几种:</p>
<ul>
<li>利用数据库自增ID<ul>
<li>优点：最简单。 </li>
<li>缺点：单点风险、单机性能瓶颈。</li>
</ul>
</li>
<li>利用数据库集群并设置相应的步长（Flickr方案）<ul>
<li>优点：高可用、ID较简洁。 </li>
<li>缺点：需要单独的数据库集群。</li>
</ul>
</li>
<li>Twitter Snowflake<ul>
<li>优点：高性能高可用、易拓展。</li>
<li>缺点：需要独立的集群以及ZK。</li>
</ul>
</li>
<li>一大波GUID、Random算法<ul>
<li>优点：简单。 </li>
<li>缺点：生成ID较长，有重复几率。</li>
</ul>
</li>
<li>带有业务属性的方案： &gt; 时间戳+用户标识码+随机数<ul>
<li>优点：方便、成本低。基本无重复的可能。自带分库规则，这里的用户标识码即为用户ID的后四位，在查询的场景下，只需要订单号就可以匹配到相应的库表而无需用户ID，只取四位是希望订单号尽可能的短一些，并且评估下来四位已经足够。可排序，因为时间戳在最前面。</li>
<li>缺点：比如长度稍长，性能要比int/bigint的稍差等。</li>
</ul>
</li>
</ul>
<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><p>数据库拆分一般是业务发展到一定规模后的优化和重构，为了支持业务快速上线，很难一开始就分库分表，垂直拆分还好办，改改数据源就搞定了，一旦开始水平拆分，数据清洗就是个大问题，为此，我们经历了以下几个阶段。</p>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0f15jmuu7j20j80ibgmv.jpg" alt=""></p>
<ul>
<li>数据库双写（事务成功以老模型为准），查询走老模型。</li>
<li>每日job数据对账（通过DW），并将差异补平。</li>
<li>通过job导历史数据。</li>
</ul>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0f164jbhbj20j80ewgmg.jpg" alt=""><br>历史数据导入完毕并且数据对账无误。<br>依然是数据库双写，但是事务成功与否以新模型为准，在线查询切新模型。<br>每日job数据对账，将差异补平。</p>
<h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0f16or9y7j20j80ibtam.jpg" alt=""></p>
<ul>
<li>老模型不再同步写入，仅当订单有终态时才会异步补上。</li>
<li>此阶段只有离线数据依然依赖老的模型，并且下游的依赖非常多，待DW改造完就可以完全废除老模型了。</li>
</ul>
<h2 id="报表统计"><a href="#报表统计" class="headerlink" title="报表统计"></a>报表统计</h2><p>待我后续更新。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/02/18/分布式应用监控/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/分布式应用监控/" itemprop="url">分布式应用监控</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T15:47:00+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/18/分布式应用监控/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/02/18/分布式应用监控/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式应用监控"><a href="#分布式应用监控" class="headerlink" title="分布式应用监控"></a>分布式应用监控</h1><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ankzojyuj20my0dqgqa.jpg" alt="image"><br>分布式系统已经诞生了很长时间，现代互联网公司规模都变得异常庞大，系统也变得越来越复杂，给监控工作带来了极大的难度：海量日志数据如何处理，服务如何追踪，如何高效定位故障缩短故障时常，常见的监控手段可以分为集中式日志系统（Logging），集中式度量系统（Metrics）和分布式追踪系统（Tracing）。</p>
<h2 id="集中式日志系统"><a href="#集中式日志系统" class="headerlink" title="集中式日志系统"></a>集中式日志系统</h2><p>集中式日志系统，选取了最具代表性的<a href="https://www.elastic.co/elk-stack" target="_blank" rel="noopener">ELK</a><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anmng640j20t20u0qb9.jpg" alt="image"></p>
<h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><p>Elasticsearch是个开源的分布式搜索引擎，提供搜索、分析、存储数据三大功能。它的特点有：分布式、自动发现、索引自动分片、索引副本机制、RESTful 风格接口、多数据源以及自动搜索负载等。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anngzbwsj20ge06cmxi.jpg" alt="image"></p>
<h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><p>Logstash 是一个开源的动态数据收集处理管道，它可以同时从多个源中提取数据，对其进行转换，并且拥有可扩展的插件生态系统，能够与 Elasticsearch 产生强大的协同作用。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ano9kvhpj20ae0fidh8.jpg" alt="image"></p>
<h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><p>Kibana是一个开源的分析与可视化平台，设计出来用于和Elasticsearch一起使用的。你可以用kibana搜索、查看存放在Elasticsearch中的数据。Kibana与Elasticsearch的交互方式是各种不同的图表、表格、地图等，直观的展示数据，从而达到高级的数据分析与可视化的目的。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anos2ri4j20u00ioaoe.jpg" alt="image"></p>
<h3 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h3><p>Beats 是 ELK Stack 技术栈中负责单一用途数据采集并推送给 Logstash 或 Elasticsearch 的轻量级产品。包括：</p>
<ul>
<li>Filebeats：应用于日志收集场景的实现。</li>
<li>Metricbeat：轻量级的系统级性能指标监控工具。</li>
<li>Packetbeat：轻量级的网络数据包分析工具。</li>
<li>Winlogbeat：轻量级的 Windows 事件日志收集工具。</li>
<li>Heartbeat：心跳检测工具，主要监控服务的可用性。</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anqgzyihj20rs0jkq8b.jpg" alt="image"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>修改虚拟机的内存限制<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vi</span> /etc/sysctl.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure></p>
<p>加入<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="attribute">max_map_count</span>=262144</span><br></pre></td></tr></table></figure></p>
<p><code>sysctl -p</code>查看设置</p>
<p>docker安装ELK<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull sebp/elk</span><br><span class="line">docker <span class="builtin-name">run</span> -p 5601:5601 -p 9200:9200 -p 5044:5044 -e <span class="attribute">ES_MIN_MEM</span>=128m  -e <span class="attribute">ES_MAX_MEM</span>=1024m -it --name elk sebp/elk</span><br></pre></td></tr></table></figure></p>
<p>输入网址<code>http://&lt;your-host&gt;:5601</code>可以看到下面的界面，则说明安装成功<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anujxybgj22la1ac7e1.jpg" alt="image"></p>
<h4 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -<span class="keyword">it</span> &lt;container-<span class="built_in">name</span>&gt; /bin/bash</span><br></pre></td></tr></table></figure>
<p>进入容器，执行命令<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/opt/</span>logstash<span class="regexp">/bin/</span>logstash -e <span class="string">'input &#123; stdin &#123; &#125; &#125; output &#123; elasticsearch &#123; hosts =&gt; ["localhost"] &#125; &#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>如果有错误信息<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service logstash <span class="built_in">stop</span></span><br></pre></td></tr></table></figure></p>
<p>当命令成功被执行后，看到：<code>Successfully started Logstash API endpoint {:port=&gt;9600}</code>信息后，输入：<code>this is a dummy entry</code>然后回车，模拟一条日志进行测试。</p>
<p>打开浏览器<code>http://&lt;your-host&gt;:9200/_search?pretty</code>，如图所示<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anxotbydj22k419y475.jpg" alt="image"></p>
<p>打开浏览器，输入：<code>http://&lt;your-host&gt;:5601</code> 点击创建<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anykdlefj20yn0maacx.jpg" alt="image"></p>
<p>看到如下界面，到此安装结束。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0anujxybgj22la1ac7e1%20%281%29.jpg" alt="image"></p>
<p>与java应用结合的日志分析系统可以通过Beats的Filebeats来实现，通过log4j将运行日志输出在文件中，通过Filebeats插件利用Logstash过滤并导入到Elasticsearch中，最后通过Kibana展示。</p>
<h2 id="集中式度量系统"><a href="#集中式度量系统" class="headerlink" title="集中式度量系统"></a>集中式度量系统</h2><h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p><a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a>是一个基于时间序列的数值数据的监控解决方案，这是一个开源项目，由前Google员工在SoundCloud启动，他们希望监控一个高度动态的容器环境，因为对传统的监控工具不甚满意，所以开发出Prometheus，并在上面进行工作。Prometheus解决了Devs如何监控高动态容器环境的问题。</p>
<p>例如我们想要获取所有的服务器上node_exporter暴露出来的数据，就必须有个程序去定时访问这些接口，如果想要增加或者修改这些接口，那么就需要有个配置文件来记录这些服务器的地址，如果想要访问历史的某个时间点的数据，那么就必须按照时间顺序存储获取到的指标和值。而如果想要将值绘制成图，也需要有代码去查询、计算和渲染。最后你可能还希望当服务器的某个指标超过一定的阈值时，向指定的接口发出告警信息。一切的一切其实都可以使用Prometheus来解决。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ao1npp86j20z00kc0wk.jpg" alt="image"></p>
<h3 id="Prometheus检测mysql相关指标"><a href="#Prometheus检测mysql相关指标" class="headerlink" title="Prometheus检测mysql相关指标"></a>Prometheus检测mysql相关指标</h3><p>前提：本地安装了mysql</p>
<h4 id="安装node-exporter"><a href="#安装node-exporter" class="headerlink" title="安装node-exporter"></a>安装node-exporter</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull <span class="keyword">node</span><span class="title">-exporter</span></span><br><span class="line">docker run -d -p <span class="number">9100</span>:<span class="number">9100</span> --cap-add SYS_TIME --<span class="attr">net=</span><span class="string">"host"</span> --<span class="attr">pid=</span><span class="string">"host"</span> -v <span class="string">"/:/host:ro,rslave"</span>quay.io/prometheus/<span class="keyword">node</span><span class="title">-exporter</span> --<span class="attr">cap-add=</span>SYS_TIME --path.rootfs /host</span><br></pre></td></tr></table></figure>
<h4 id="安装mysqld-exporter"><a href="#安装mysqld-exporter" class="headerlink" title="安装mysqld-exporter"></a>安装mysqld-exporter</h4><p>通过mysql命令界面创建相应角色并赋予权限<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'mysql_monitor'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'XXXXXXXX'</span> <span class="keyword">WITH</span> MAX_USER_CONNECTIONS <span class="number">3</span>;</span><br><span class="line"><span class="keyword">GRANT</span> PROCESS, <span class="keyword">REPLICATION</span> <span class="keyword">CLIENT</span>, <span class="keyword">SELECT</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'mysql_monitor'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure></p>
<p>docker安装<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysqld-exporter</span><br><span class="line">docker <span class="builtin-name">run</span> -d -p 9104:9104 -e <span class="attribute">DATA_SOURCE_NAME</span>=<span class="string">"mysql_monitor:root@(127.0.0.1:3306)/"</span> prom/mysqld-exporter</span><br></pre></td></tr></table></figure></p>
<h4 id="安装Prometheus"><a href="#安装Prometheus" class="headerlink" title="安装Prometheus"></a>安装Prometheus</h4><p>创建文件<code>prometheus.yml</code><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">global</span>:</span><br><span class="line">  <span class="attribute">scrape_interval</span>:     <span class="number">60s</span></span><br><span class="line">  <span class="attribute">evaluation_interval</span>: <span class="number">60s</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">scrape_configs</span>:</span><br><span class="line">  - <span class="attribute">job_name</span>: prometheus</span><br><span class="line">    <span class="attribute">static_configs</span>:</span><br><span class="line">      - <span class="attribute">targets</span>: [<span class="string">'106.15.226.184:9090'</span>]</span><br><span class="line">        <span class="attribute">labels</span>:</span><br><span class="line">          <span class="attribute">instance</span>: prometheus</span><br><span class="line"></span><br><span class="line">  - <span class="attribute">job_name</span>: linux</span><br><span class="line">    <span class="attribute">static_configs</span>:</span><br><span class="line">      - <span class="attribute">targets</span>: [<span class="string">'106.15.226.184:9100'</span>]</span><br><span class="line">        <span class="attribute">labels</span>:</span><br><span class="line">          <span class="attribute">instance</span>: db1</span><br><span class="line"></span><br><span class="line">  - <span class="attribute">job_name</span>: mysql</span><br><span class="line">    <span class="attribute">static_configs</span>:</span><br><span class="line">      - <span class="attribute">targets</span>: [<span class="string">'106.15.226.184:9104'</span>]</span><br><span class="line">        <span class="attribute">labels</span>:</span><br><span class="line">          <span class="attribute">instance</span>: db1</span><br></pre></td></tr></table></figure></p>
<p>docker启动<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull prometheus</span><br><span class="line">sudo docker run -d -p <span class="number">9090</span>:<span class="number">9090</span> -v <span class="regexp">/root/</span>conf<span class="regexp">/prometheus.yml:/u</span>sr<span class="regexp">/local/</span>src<span class="regexp">/file/</span>prometheus.yml quay.io<span class="regexp">/prometheus/</span>prometheus --config.<span class="keyword">file</span>=<span class="regexp">/usr/</span>local<span class="regexp">/src/</span><span class="keyword">file</span><span class="regexp">/prometheus.yml</span></span><br></pre></td></tr></table></figure></p>
<h4 id="安装Grafana"><a href="#安装Grafana" class="headerlink" title="安装Grafana"></a>安装Grafana</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull grafana/grafana</span><br><span class="line">docker <span class="builtin-name">run</span> -d <span class="attribute">--name</span>=grafana -p 3000:3000 grafana/grafana</span><br></pre></td></tr></table></figure>
<p>打开<code>http:x.x.x.x:9090</code><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aocmau0ej22l812ogqo.jpg" alt="image"><br>如图所示，说明数据源管道agent启动成功</p>
<p>打开<code>http://x.x.x.x:3000</code>，配置Prometheus数据源<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aoe1u94dj20pp0qv78x.jpg" alt="image"></p>
<p>配置好数据源后，下载<a href="https://codeload.github.com/percona/grafana-dashboards/zip/v1.17.0" target="_blank" rel="noopener">mysql监控模板</a>，<br>解压后，找到mysql开头的模板，导入，最后如图所示：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aog1imivj22jc19e46g.jpg" alt="image"></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aogngitwj22ki19g11f.jpg" alt="image"></p>
<h3 id="Cat"><a href="#Cat" class="headerlink" title="Cat"></a>Cat</h3><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aoibi3egj20qo0eujsb.jpg" alt="image"><br><a href="https://github.com/dianping/cat" target="_blank" rel="noopener">CAT</a>（Central Application Tracking）是一个实时和接近全量的监控系统，它侧重于对Java应用的监控，基本接入了美团上海侧所有核心应用。目前在中间件（MVC、RPC、数据库、缓存等）框架中得到广泛应用，为美团各业务线提供系统的性能指标、健康状况、监控告警等。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aoim0nuwj20zy0lwk41.jpg" alt="image"></p>
<p>监控整体要求就是快速发现故障、快速定位故障以及辅助进行程序性能优化。为了做到这些，我们对监控系统的一些非功能做了如下的要求：</p>
<p>实时处理：信息的价值会随时间锐减，尤其是事故处理过程中。<br>全量数据：最开始的设计目标就是全量采集，全量的好处有很多。<br>高可用：所有应用都倒下了，需要监控还站着，并告诉工程师发生了什么，做到故障还原和问题定位。<br>故障容忍：CAT本身故障不应该影响业务正常运转，CAT挂了，应用不该受影响，只是监控能力暂时减弱。<br>高吞吐：要想还原真相，需要全方位地监控和度量，必须要有超强的处理吞吐能力。<br>可扩展：支持分布式、跨IDC部署，横向扩展的监控系统。<br>不保证可靠：允许消息丢失，这是一个很重要的trade-off，目前CAT服务端可以做到4个9的可靠性，可靠系统和不可靠性系统的设计差别非常大。<br>CAT从开发至今，一直秉承着简单的架构就是最好的架构原则，主要分为三个模块：CAT-client、CAT-consumer、CAT-home。</p>
<p>Cat-client 提供给业务以及中间层埋点的底层SDK。<br>Cat-consumer 用于实时分析从客户端提供的数据。<br>Cat-home 作为用户给用户提供展示的控制端。<br>在实际开发和部署中，Cat-consumer和Cat-home是部署在一个JVM内部，每个CAT服务端都可以作为consumer也可以作为home，这样既能减少整个层级结构，也可以增加系统稳定性。<br>上图是CAT目前多机房的整体结构图，图中可见：</p>
<p>路由中心是根据应用所在机房信息来决定客户端上报的CAT服务端地址，目前美团有广州、北京、上海三地机房。<br>每个机房内部都有独立的原始信息存储集群HDFS。<br>CAT-home可以部署在一个机房也可以部署在多个机房，在最后做展示的时候，home会从consumer中进行跨机房的调用，将所有的数据合并展示给用户。<br>实际过程中，consumer、home以及路由中心都是部署在一起的，每个服务端节点都可以充当任何一个角色。</p>
<h4 id="安装使用Cat"><a href="#安装使用Cat" class="headerlink" title="安装使用Cat"></a>安装使用Cat</h4><p>本文演示单机集群安装部署<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/dianping/<span class="keyword">cat</span>.git</span><br><span class="line"><span class="keyword">cd</span> docker</span><br><span class="line">docker-compose <span class="keyword">up</span></span><br></pre></td></tr></table></figure></p>
<p>第一次运行以后，数据库中没有表结构，需要通过下面的命令创建表：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> exec &lt;container_id&gt; <span class="keyword">bash </span>-c <span class="string">"mysql -uroot -Dcat &lt; /init.sql"</span></span><br></pre></td></tr></table></figure></p>
<p>依赖配置说明</p>
<ul>
<li>datasources.xml<ul>
<li>CAT数据库配置，默认配置是mysql镜像，可以按需替换</li>
</ul>
</li>
<li>docker-compose.yml<ul>
<li>通过docker-compose启动的编排文件，文件中包含cat和mysql。可以屏蔽掉mysql的部分，并且修改cat的环境变量，改为真实的mysql连接信息。</li>
</ul>
</li>
<li>client.xml<ul>
<li>CAT 初始化默认的路由列表，配置此文件可以将客户端数据上报指向到不同环境。</li>
</ul>
</li>
<li>datasources.sh<ul>
<li>辅助脚本，脚本作用时修改datasources.xml，使用环境变量中制定的mysql连接信息。（通过sed命令替换）</li>
</ul>
</li>
</ul>
<h4 id="Java-应用的集成"><a href="#Java-应用的集成" class="headerlink" title="Java 应用的集成"></a>Java 应用的集成</h4><p><a href="https://blog.csdn.net/kefengwang/article/details/81213031" target="_blank" rel="noopener">参考博客</a><br>需要指定 cat 专用的远程仓库<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- %MAVEN_HOME%\conf\settings.xml --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>unidal.nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://unidal.org/nexus/content/repositories/releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>加入依赖(pom.xml)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dianping.cat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cat-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>添加过滤器 CatFilter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatFilterConfigure</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">catFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        registration.setFilter(<span class="keyword">new</span> CatFilter());</span><br><span class="line">        registration.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        registration.setName(<span class="string">"cat-filter"</span>);</span><br><span class="line">        registration.setOrder(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加注解<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CatCacheTransaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="meta">@CatHttpRequestTransaction</span>(type = <span class="string">"URL"</span>, name = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aoqxnurij20qp0d3k4h.jpg" alt="image"></p>
<p>更多集成<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aos0a6q6j20rl0fdwvn.jpg" alt="image"></p>
<h5 id="管理平台的使用"><a href="#管理平台的使用" class="headerlink" title="管理平台的使用"></a>管理平台的使用</h5><p>控制台<br><a href="http://192.168.126.101:8080/cat" target="_blank" rel="noopener">http://192.168.126.101:8080/cat</a><br>帐号/密码: catadmin/catadmin</p>
<p>项目配置<br><a href="http://192.168.126.101:8080/cat/s/config?op=projects" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/s/config?op=projects</a></p>
<p>相关文档<br>部署文档: <a href="http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=deploy" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=deploy</a><br>用户文档：<a href="http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=user" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=user</a><br>告警文档：<a href="http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=alert" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=alert</a><br>集成文档：<a href="http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=integration" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=integration</a><br>开发文档：<a href="http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=develop" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=develop</a><br>设计文档：<a href="http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=design" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=design</a><br>常见问题：<a href="http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=problem" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/home?op=view&amp;docName=problem</a></p>
<p>实时查看<br><a href="http://192.168.126.101:8080/cat/r/t" target="_blank" rel="noopener">http://192.168.126.101:8080/cat/r/t</a><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aov6vr6mj21gw0o8147.jpg" alt="image"></p>
<h2 id="分布式追踪系统"><a href="#分布式追踪系统" class="headerlink" title="分布式追踪系统"></a>分布式追踪系统</h2><h3 id="Zipkin"><a href="#Zipkin" class="headerlink" title="Zipkin"></a>Zipkin</h3><p><a href="https://zipkin.io/" target="_blank" rel="noopener">Zipkin</a>是一种分布式跟踪系统。它有助于收集解决微服务架构中的延迟问题所需的时序数据。它管理这些数据的收集和查找。Zipkin的设计基于Google Dapper论文。<br>应用程序用于向Zipkin报告时序数据。Zipkin UI还提供了一个依赖关系图，显示了每个应用程序通过的跟踪请求数。如果要解决延迟问题或错误，可以根据应用程序，跟踪长度，注释或时间戳对所有跟踪进行筛选或排序。选择跟踪后，您可以看到每个跨度所需的总跟踪时间百分比，从而可以识别问题应用程序。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aox97889j20u20ewn0o.jpg" alt="image"></p>
<p>共有四个组件构成了 Zipkin：</p>
<ul>
<li>collector</li>
<li>storage</li>
<li>search</li>
<li>web UI</li>
</ul>
<p><strong>Zipkin Collector</strong></p>
<p>一旦追踪数据抵达 Zipkin Collector 守护进程，Zipkin Collector 为了查询，会对其进行校验、存储和索引。</p>
<p><strong>Storage</strong></p>
<p>Zipkin 最初是构建在将数据存储在 Cassandra 中，因为 Cassandra 易跨站，支持灵活的 schema，并且在 Twitter 内部被大规模使用。然而，我们将这个组件做成了可插拔式的。在 Cassandra 之外，我们原生支持 ElasticSearch 和 MySQL。可作为第三方扩展提供给其它后端。</p>
<p><strong>Zipkin 查询服务</strong></p>
<p>一旦数据被存储索引，我们就需要一种方式提取它。查询守护进程提供了一个简单的 JSON API 查询和获取追踪数据。API 的主要消费者就是 Web UI。</p>
<p><strong>Web UI</strong></p>
<p>我们创建了一个用户图形界面为追踪数据提供了一个漂亮的视图。Web UI 提供了基于服务、时间和标记（annotation）查看追中数据的方法。注意：UI 没有内置的身份认证功能。</p>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0bpyewjhlj20id0e0acc.jpg" alt="image"></p>
<h5 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h5><p><a href="https://www.linzepeng.com/2018/06/21/zipkin-node/" target="_blank" rel="noopener">参考</a><br>前提条件：已经安装好ElasticSearch</p>
<p>安装zookeeper和kafka<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> pull wurstmeister/zookeeper  </span><br><span class="line"> </span><br><span class="line">docker pull wurstmeister/kafka</span><br></pre></td></tr></table></figure></p>
<p>启动镜像<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d <span class="params">--name</span> zookeeper <span class="params">--publish</span> 2181<span class="function">:2181</span> <span class="params">--volume</span> <span class="string">/etc/localtime</span>:<span class="string">/etc/localtime</span> zookeeper<span class="function">:latest</span></span><br><span class="line">docker run -d <span class="params">--name</span> kafka <span class="params">--publish</span> 9092<span class="function">:9092</span> <span class="params">--link</span> zookeeper <span class="params">--env</span> KAFKA_ZOOKEEPER_CONNECT=zookeeper<span class="function">:2181</span> </span><br><span class="line"><span class="params">--env</span> KAFKA_ADVERTISED_HOST_NAME=kafka所在宿主机的IP <span class="params">--env</span> KAFKA_ADVERTISED_PORT=9092 <span class="params">--volume</span> <span class="string">/etc/localtime</span>:<span class="string">/etc/localtime</span> </span><br><span class="line">wurstmeister/kafka<span class="function">:latest</span></span><br><span class="line">docker run -d <span class="params">--name</span> zipkin-server -p 9411<span class="function">:9411</span> -e <span class="string">"KAFKA_BOOTSTRAP_SERVERS=your-kafka-address"</span> -e <span class="string">"STORAGE_TYPE=elasticsearch"</span> -e <span class="string">"ES_HOSTS=your-es-host"</span> -e <span class="string">"ES_INDEX=zipkin"</span> -e <span class="string">"ES_INDEX_SHARDS=1"</span> -e <span class="string">"ES_INDEX_REPLICAS=1"</span> zipkin<span class="function">:latest</span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>用maven新建springboot项目<br>引入依赖，包括Spring Cloud Sleuth和Kafka传输的支持依赖Spring Stream Kafak以及web依赖。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>配置<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">service-producer</span> <span class="comment"># 配置应用名称</span></span><br><span class="line"><span class="attr">  kafka:</span></span><br><span class="line"><span class="attr">    bootstrap-servers:</span> <span class="attr">localhost:9092</span> <span class="comment"># 缓冲kafka地址</span></span><br><span class="line"><span class="attr">  sleuth:</span></span><br><span class="line"><span class="attr">    sampler:</span></span><br><span class="line"><span class="attr">      percentage:</span> <span class="number">1</span> <span class="comment"># 设置采样频率，默认为0.1，设置为全采样，便于观测，实际项目中根据具体情况设置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p>
<p>类似的方法再新建一个项目然后写一个接口进行2个服务之间的通讯，触发调用链，可以在<code>http://localhost:9411</code>查看如下效果图：<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0bqg7veq9j218o0bu40c.jpg" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0bqgjj4w0j219009a75y.jpg" alt="image"><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0bqgvdbznj218o0jrq7g.jpg" alt="image"><br>需要注意的是，我们使用的存储模块是ES，所以一段时间内的服务调用关系图是无法直接得到的（使用内存存储可以直接得到）。我们需要使用Zipkin官方提供的zipkin-dependencies来生成依赖关系图。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ex to run the job to process yesterday's traces on OS/X</span></span><br><span class="line">$ <span class="attribute">STORAGE_TYPE</span>=elasticsearch <span class="attribute">ES_HOSTS</span>=your-es-host <span class="attribute">ES_INDEX</span>=zipkin <span class="attribute">ES_NODES_WAN_ONLY</span>=<span class="literal">true</span> java -jar zipkin-dependencies.jar `date -uv-1d +%F`</span><br></pre></td></tr></table></figure></p>
<h3 id="Pinpoint"><a href="#Pinpoint" class="headerlink" title="Pinpoint"></a>Pinpoint</h3><p><a href="https://naver.github.io/pinpoint/" target="_blank" rel="noopener">Pinpoint</a>是一个开源的APM监控工具，我们可以通过pinpoint实时跟踪应用之间的调用、程序的响应时间以及服务器资源使用状态，可以在分布式环境中为没个调用生成代码级别的可视图并定位瓶颈点和失败点。Pinpoint的设计也是基于Google Dapper论文<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aoyo8a04j20ru0ietcq.jpg" alt="image"></p>
<h4 id="安装部署-1"><a href="#安装部署-1" class="headerlink" title="安装部署"></a>安装部署</h4><p><a href="https://blog.csdn.net/qq_21816375/article/details/80455681" target="_blank" rel="noopener">参考</a><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/naver/pinpoint-docker.git</span><br><span class="line"><span class="keyword">cd</span> Pinpoint-Docker</span><br><span class="line">docker-compose pull &amp;&amp; docker-compose <span class="keyword">up</span> -d</span><br></pre></td></tr></table></figure></p>
<p>如有问题，请修改相对路径为绝对路径<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> volumes:</span><br><span class="line">      -<span class="ruby"> /home/pinpoint/hbase</span></span><br><span class="line"><span class="ruby">      - <span class="regexp">/home/pinpoint</span><span class="regexp">/zookeeper</span></span></span><br><span class="line"><span class="ruby">...</span></span><br></pre></td></tr></table></figure></p>
<p>启动镜像,访问<code>http://x.x.x.x:8079/</code><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0br3dxdetj21hg0rqtds.jpg" alt="image"><br>hbase页面 <code>http://x.x.x.x:16010/</code><br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0br4jwwxyj21h20s2wk3.jpg" alt="image"></p>
<h3 id="Skywalking"><a href="#Skywalking" class="headerlink" title="Skywalking"></a>Skywalking</h3><p><a href="http://skywalking.apache.org/" target="_blank" rel="noopener">Skywalking</a>是一款优秀的国产 APM 工具，包括了分布式追踪、性能指标分析、应用和服务依赖分析等。通过在应用程序中添加 SkyWalking Agent，就可以将接口、服务、数据库、MQ等进行追踪，将追踪结果通过 HTTP 或 gRPC 发送到 SkyWalking Collecter，SkyWalking Collecter 经过分析和聚合，将结果存储到 Elasticsearch 或 H2，SkyWalking 同时提供了一个 SkyWalking UI 的可视化界面，UI 以 GraphQL + HTTP 方式获取存储数据进行展示。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0aozn4exyj20uk0f6wif.jpg" alt="image"></p>
<h4 id="安装部署-2"><a href="#安装部署-2" class="headerlink" title="安装部署"></a>安装部署</h4><p><a href="https://www.jianshu.com/p/6fc29924f495" target="_blank" rel="noopener">参考博客</a></p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>拷贝apache-skywalking-apm-incubating目录下的agent目录到应用程序位置，探针包含整个目录，请不要改变目录结构</p>
<p>java程序启动时，增加JVM启动参数，<code>-javaagent:/path/to/agent/skywalking-agent.jar</code>。参数值为<code>skywalking-agent.jar</code>的绝对路径</p>
<p>agent探针配置，简单修改下<code>agent.application_code</code>即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前的应用编码，最终会显示在webui上。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建议一个应用的多个实例，使用有相同的application_code。请使用英文</span></span><br><span class="line">agent.application_code=Your_ApplicationName</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每三秒采样的Trace数量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认为负数，代表在保证不超过内存Buffer区的前提下，采集所有的Trace</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> agent.sample_n_per_3_secs=-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置需要忽略的请求地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认配置如下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> agent.ignore_suffix=.jpg,.jpeg,.js,.css,.png,.bmp,.gif,.ico,.mp3,.mp4,.html,.svg</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 探针调试开关，如果设置为<span class="literal">true</span>，探针会将所有操作字节码的类输出到/debugging目录下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> skywalking团队可能在调试，需要此文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> agent.is_open_debugging_class = <span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对应Collector的config/application.yml配置文件中 agent_server/jetty/port 配置内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单节点配置：SERVERS=<span class="string">"127.0.0.1:8080"</span> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群配置：SERVERS=<span class="string">"10.2.45.126:8080,10.2.45.127:7600"</span> </span></span><br><span class="line">collector.servers=127.0.0.1:10800</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件名称前缀</span></span><br><span class="line">logging.file_name=skywalking-agent.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件最大大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果超过此大小，则会生成新文件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认为300M</span></span><br><span class="line">logging.max_file_size=314572800</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志级别，默认为DEBUG。</span></span><br><span class="line">logging.level=DEBUG</span><br></pre></td></tr></table></figure></p>
<p>一切正常的话，稍后就可以在skywalking ui看到了。<br><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0bs6hyznoj21gg0pldjo.jpg" alt="image"></p>
<h3 id="Jaeger"><a href="#Jaeger" class="headerlink" title="Jaeger"></a>Jaeger</h3><p>Uber开源的<a href="https://www.jaegertracing.io/" target="_blank" rel="noopener">Jaeger</a>用于监控和排除基于微服务的分布式系统，包括：</p>
<ul>
<li>分布式上下文传播</li>
<li>分布式事务监控</li>
<li>根本原因分析</li>
<li>服务依赖性分析</li>
<li>性能/延迟优化</li>
</ul>
<p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0ap1ca1x2j20um0gi78o.jpg" alt="image"></p>
<h4 id="安装部署-3"><a href="#安装部署-3" class="headerlink" title="安装部署"></a>安装部署</h4><p>all-in-one 是Uber官方打包好的镜像，可以直接部署使用，但是只能用于测试环境，不能用于线上，因为它把数据放入了内存。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -e COLLECTOR_ZIPKIN_HTTP_PORT=<span class="number">9411</span> -<span class="string">p5775:</span><span class="number">5775</span><span class="regexp">/udp -p6831:6831/</span>udp -<span class="string">p6832:</span><span class="number">6832</span>/udp \</span><br><span class="line">  -<span class="string">p5778:</span><span class="number">5778</span> -<span class="string">p16686:</span><span class="number">16686</span> -<span class="string">p14268:</span><span class="number">14268</span> -<span class="string">p9411:</span><span class="number">9411</span> jaegertracing/all-<span class="keyword">in</span>-<span class="string">one:</span>latest</span><br></pre></td></tr></table></figure>
<p>通过 <a href="http://localhost:16686" target="_blank" rel="noopener">http://localhost:16686</a> 可以在浏览器查看 Jaeger的后台</p>
<p>正常安装<a href="https://blog.yeeef.com/post/uber_jaeger/" target="_blank" rel="noopener">参考</a></p>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p><a href="https://medium.com/opentracing/take-opentracing-for-a-hotrod-ride-f6e3141f7941" target="_blank" rel="noopener">参考</a></p>
<h3 id="分布式链路追踪技术对比"><a href="#分布式链路追踪技术对比" class="headerlink" title="分布式链路追踪技术对比"></a>分布式链路追踪技术对比</h3><p><a href="https://blog.csdn.net/u012394095/article/details/79700200" target="_blank" rel="noopener">来自博文</a></p>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>由大众点评开源，基于Java开发的实时应用监控平台，包括实时应用监控，业务监控 。 集成方案是通过</p>
<p>代码埋点的方式来实现监控，比如： 拦截器，注解，过滤器等。   对代码的侵入性很大，集成成本较高。<br>支持技术栈： </p>
<ul>
<li>dubbo</li>
<li>spring mvc ,spring aop ,springmvc-url</li>
<li>spring boot</li>
<li>mybatis</li>
<li>log4j , logback</li>
<li>playframework</li>
<li>http请求</li>
</ul>
<p>风险较大。 </p>
<h4 id="zipkin"><a href="#zipkin" class="headerlink" title="zipkin"></a>zipkin</h4><p>由Twitter团队开源， Zipkin是一个分布式的跟踪系统。它有助于收集数据需要解决潜在的问题在市微服架构的时机。它管理数据的收集和查找 .</p>
<p>该产品结合spring-cloud-sleuth使用较为简单， 集成很方便。 但是功能较简单。</p>
<p>支持技术栈：</p>
<ul>
<li>spring cloud</li>
</ul>
<p>以上是结合spring-cloud-sleuth支持的技术栈</p>
<h4 id="pinpoint"><a href="#pinpoint" class="headerlink" title="pinpoint"></a>pinpoint</h4><p>由韩国团队naver团队开源，针对大规模分布式系统用链路监控，使用java写的工具。灵感来自短小精悍，帮助分析系统的总</p>
<p>体结构和内部组件如何被调用在分布式应用提供了一个很好的解决方案。</p>
<p>使用java探针字节码增加技术，实现对整个应用的监控 。 对应用零侵入</p>
<p>支持技术栈： </p>
<ul>
<li>Tomcat 6+,Jetty 8/9,JBoss 6,Resin 4,Websphere 6+,Vertx 3.3+</li>
<li>Spring, Spring Boot (Embedded Tomcat, Jetty)</li>
<li>HTTP Client 3.x/4.x, HttpConnector, GoogleHttpClient, OkHttpClient, NingAsyncHttpClient</li>
<li>Thrift, Dubbo</li>
<li>mysql, oracle, mssql, cubrid,PostgreSQL, maria</li>
<li>arcus, memcached, redis, cassandra</li>
<li>MyBatis</li>
<li>DBCP, DBCP2, HIKARICP</li>
<li>gson, Jackson, Json Lib</li>
<li>log4j, Logback</li>
</ul>
<h4 id="skywalking"><a href="#skywalking" class="headerlink" title="skywalking"></a>skywalking</h4><p>2015年由个人吴晟（华为开发者）开源 ， 2017年加入Apache孵化器。</p>
<p>针对分布式系统的应用性能监控系统，特别针对微服务、cloud native和容器化(Docker, Kubernetes, Mesos)架构， 其核心是个分布式追踪系统。</p>
<p>使用java探针字节码增加技术，实现对整个应用的监控 。对应用零侵入</p>
<p>支持技术栈</p>
<ul>
<li>Tomcat7+ , resin3+, jetty</li>
<li>spring boot ,spring mvc</li>
<li>strtuts2</li>
<li>spring RestTemplete ,spring-cloud-feign</li>
<li>okhttp , httpClient</li>
<li>msyql ,oracle , H2 , sharding-jdbc,PostgreSQL</li>
<li>dubbo,dubbox ,motan, gRpc ,</li>
<li>rocketMq , kafla</li>
<li>redis, mongoDB,memcached ,</li>
<li>elastic-job , Netflix Eureka , Hystric</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>模拟了三种并发用户：500，750，1000。使用jmeter测试，每个线程发送30个请求，设置思考时间为10ms。使用的采样率为1，即100%，这边与生产可能有差别。</p>
<p>pinpoint默认的采样率为20，即50%，通过设置agent的配置文件改为100%。zipkin默认也是1。组合起来，一共有12种。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/01/24/TestNG测试框架与rest-assured结合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/24/TestNG测试框架与rest-assured结合/" itemprop="url">TestNG测试框架与rest-assured结合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-24T09:47:00+08:00">
                2019-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/24/TestNG测试框架与rest-assured结合/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/01/24/TestNG测试框架与rest-assured结合/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://testng.org/doc/index.html" target="_blank" rel="noopener">TestNG官网</a></p>
<h1 id="TestNG简介"><a href="#TestNG简介" class="headerlink" title="TestNG简介"></a>TestNG简介</h1><p><img src="https://minios.strongsickcat.com/dinghuang-blog-picture/9bc4cb9fgy1g0apgqmzy2j206o06odhi.jpg" alt="image"></p>
<p>TestNG是一个受JUnit和NUnit启发的测试框架，但引入了一些新功能，使其功能更强大，相对于JUnit来说，xml的配置使的testNG对于不同测试之间的依赖程度有更好的把控性。</p>
<h1 id="rest-assured简介"><a href="#rest-assured简介" class="headerlink" title="rest-assured简介"></a>rest-assured简介</h1><p>在Java中测试和验证REST服务比在Ruby和Groovy等动态语言中更难。REST <a href="http://rest-assured.io/" target="_blank" rel="noopener">Assured</a>将使用这些语言的简单性带入了Java域。</p>
<h1 id="TestNG测试框架与rest-assured结合"><a href="#TestNG测试框架与rest-assured结合" class="headerlink" title="TestNG测试框架与rest-assured结合"></a>TestNG测试框架与rest-assured结合</h1><p>项目地址：<br><a href="https://github.com/dinghuang/testNGExample" target="_blank" rel="noopener">https://github.com/dinghuang/testNGExample</a></p>
<p>上面实现了模拟用户登录以及rest-assured的高级用法，同时可以通过命令行直接生成报告，报告中对http请求增加了过滤，会在报告中展示请求信息，可以通过xml解析直接获取，还实现了多个suit通过mvn命令直接运行。目前在Choerodon中已经增加了TestNG的支持，用户可以直接推到gitlab，gitlab中的runner会在ci中打包并运行测试jar包，把报告解析并提取请求信息生成测试用例。</p>
<p>项目的关键代码就不一一说了，项目中有注释，不懂的+我VX:742041978</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/01/12/Kubernetes学习（一）之认识Kubernetes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/12/Kubernetes学习（一）之认识Kubernetes/" itemprop="url">Kubernetes学习（一）之认识Kubernetes</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-12T15:47:00+08:00">
                2019-01-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/12/Kubernetes学习（一）之认识Kubernetes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/01/12/Kubernetes学习（一）之认识Kubernetes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Kubernetes学习（一）之认识Kubernetes"><a href="#Kubernetes学习（一）之认识Kubernetes" class="headerlink" title="Kubernetes学习（一）之认识Kubernetes"></a>Kubernetes学习（一）之认识Kubernetes</h1><h2 id="Kubernetes概念"><a href="#Kubernetes概念" class="headerlink" title="Kubernetes概念"></a>Kubernetes概念</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://kubernetes.io" target="_blank" rel="noopener">Kubernetes</a>是一个跨主机集群的 开源的容器调度平台，它可以自动化应用容器的部署、扩展和操作 , 提供以容器为中心的基础架构。结合<code>docker</code>可以提供持续开发，持续部署的功能，我现在所从事开发的<a href="https://choerodon.io/zh/" target="_blank" rel="noopener">Choerodon</a>就是基于这一套架构开发的企业级数字服务平台，具有敏捷化的应用交付和自动化的运营管理的特点。这里介绍的版本是<code>v1.13</code></p>
<p><img src="https://d33wubrfki0l68.cloudfront.net/e7b766e0175f30ae37f7e0e349b87cfe2034a1ae/3e391/images/docs/why_containers.svg" alt="image"></p>
<p>新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能快速部署，由于容器与底层设施、机器文件系统解耦的，所以它能在不同云、不同版本操作系统间进行迁移。</p>
<p>容器占用资源少、部署快，每个应用可以被打包成一个容器镜像，每个应用与容器间成一对一关系也使容器有更大优势，使用容器可以在build或release 的阶段，为应用创建容器镜像，因为每个应用不需要与其余的应用堆栈组合，也不依赖于生产环境基础结构，这使得从研发到测试、生产能提供一致环境。类似地，容器比虚机轻量、更“透明”，这更便于监控和管理。</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LDAOok5ngY4pc1lEDes%2F-LM_rqip-tinVoiFZE0I%2F-LM_sFnwCik1PPfAm7xB%2Farchitecture.png?generation=1537160056980734&amp;alt=media" alt="image"></p>
<h4 id="Master组件"><a href="#Master组件" class="headerlink" title="Master组件"></a>Master组件</h4><p>Kubernetes 主要由以下几个核心（Master）组件组成，Master组件提供集群的管理控制中心。Master组件可以在集群中任何节点上运行。但是为了简单起见，通常在一台VM/机器上启动所有Master组件，并且不会在此VM/机器上运行用户容器。请参考<a href="https://kubernetes.io/docs/admin/high-availability/" target="_blank" rel="noopener">构建高可用群集以来构建multi-master-VM</a>。</p>
<h5 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h5><p><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/用于暴露Kubernetes API。任何的资源请求/调用操作都是通过kube-apiserver提供的接口进行，并提供认证、授权、访问控制、API 注册和发现等机制。例如kubectl CLI命令行就是与kube-apiserver通讯查询节点信息的。请参阅[构建高可用群集](https://kubernetes.io/docs/admin/high-availability/" target="_blank" rel="noopener">kube-apiserver</a>。</p>
<h5 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h5><p><a href="https://github.com/coreos/etcd/blob/master/Documentation/docs.md" target="_blank" rel="noopener">etcd</a>是Kubernetes提供默认的存储系统，保存所有集群数据，使用时需要为etcd数据提供备份计划。</p>
<h5 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h5><p>主服务器上的组件，用于监视未创建节点的新创建的pod，并选择一个节点供其运行。 调度决策所考虑的因素包括个人和集体资源需求，硬件/软件/策略约束，亲和力和反亲和性规范，数据位置，工作负载间干扰和最后期限。</p>
<h5 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h5><p><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/" target="_blank" rel="noopener">kube-controller-manager</a>运行管理控制器，它们是集群中处理常规任务的后台线程。逻辑上，每个控制器是一个单独的进程，但为了降低复杂性，它们都被编译成单个二进制文件，并在单个进程中运行。负责维护集群的状态，比如故障检测、自动扩展、滚动更新等。</p>
<p>这些控制器包括：</p>
<ul>
<li><a href="http://docs.kubernetes.org.cn/304.html" target="_blank" rel="noopener">节点（Node</a>）控制器。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" target="_blank" rel="noopener">副本（Replication）控制器</a>：负责维护系统中每个副本中的pod。</li>
<li>端点（Endpoints）控制器：填充Endpoints对象（即连接Services＆Pods）。<br>-<a href="http://docs.kubernetes.org.cn/84.html" target="_blank" rel="noopener"> Service Account</a>和Token控制器：为新的<a href="http://docs.kubernetes.org.cn/242.html" target="_blank" rel="noopener">Namespace</a> 创建默认帐户访问API Token。</li>
</ul>
<h5 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud-controller-manager"></a>cloud-controller-manager</h5><p><a href="https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/" target="_blank" rel="noopener">云控制器管理器</a>负责与底层云提供商的平台交互。云控制器管理器是Kubernetes版本1.6中引入的，目前还是Alpha的功能。</p>
<p>云控制器管理器仅运行云提供商特定的（controller loops）控制器循环。可以通过将<code>--cloud-provider</code> flag设置为<code>external</code>启动kube-controller-manager ，来禁用控制器循环。</p>
<p>cloud-controller-manager 具体功能：</p>
<ul>
<li>节点（Node）控制器</li>
<li>路由（Route）控制器</li>
<li>Service控制器</li>
<li>卷（Volume）控制器</li>
</ul>
<h4 id="节点（Node）组件"><a href="#节点（Node）组件" class="headerlink" title="节点（Node）组件"></a>节点（Node）组件</h4><p>节点组件运行在<a href="http://docs.kubernetes.org.cn/304.html" target="_blank" rel="noopener">Node</a>，提供Kubernetes运行时环境，以及维护Pod。</p>
<h5 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h5><p>kubelet是主要的节点代理，它会监视已分配给节点的pod，负责维护容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理，具体功能：</p>
<ul>
<li>安装Pod所需的volume。</li>
<li>下载Pod的Secrets。</li>
<li>Pod中运行的 docker（或experimentally，rkt）容器。</li>
<li>定期执行容器健康检查。</li>
<li>通过在必要时创建镜像pod，将pod状态报告回系统的其余部分。</li>
<li>将节点的状态返回到系统的其余部分。</li>
</ul>
<h5 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h5><p><a href="https://kubernetes.io/docs/admin/kube-proxy/" target="_blank" rel="noopener">kube-proxy</a>通过在主机上维护网络规则并执行连接转发来实现Kubernetes服务抽象。负责为 Service 提供 cluster 内部的服务发现和负载均衡。</p>
<h5 id="Container-Runtime"><a href="#Container-Runtime" class="headerlink" title="Container Runtime"></a>Container Runtime</h5><p>容器运行时是负责运行容器的软件。 Kubernetes支持多种运行时：<a href="http://www.docker.com/" target="_blank" rel="noopener">Docker</a>，<a href="https://coreos.com/rkt/" target="_blank" rel="noopener">rkt</a>，<a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runc</a>和任何OCI运行时规范实现。</p>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>插件（addon）是实现集群pod和Services功能的 。PodDeployments，ReplicationController等进行管理。Namespace 插件对象是在<code>kube-system</code> Namespace中创建。有关可用插件的扩展列表，请参阅<a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">插件</a>。</p>
<h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p>虽然不严格要求使用插件，但Kubernetes集群都应该具有<a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noopener">DNS集群</a>。<br>群集 DNS是一个DNS服务器，能够为 Kubernetes services提供 DNS记录。<br>由Kubernetes启动的容器自动将这个DNS服务器包含在他们的DNS searches中。</p>
<h5 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h5><p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="noopener">仪表板</a>是Kubernetes集群的基于Web的通用UI。它允许用户管理和解决群集中运行的应用程序以及群集本身。</p>
<h5 id="容器资源监测"><a href="#容器资源监测" class="headerlink" title="容器资源监测"></a>容器资源监测</h5><p><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/" target="_blank" rel="noopener">容器资源监控</a>提供一个UI浏览监控数据。</p>
<h5 id="Cluster-level-Logging"><a href="#Cluster-level-Logging" class="headerlink" title="Cluster-level Logging"></a>Cluster-level Logging</h5><p><a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/" target="_blank" rel="noopener">Cluster-level logging</a>，负责保存容器日志，搜索/查看日志。</p>
<h5 id="supervisord"><a href="#supervisord" class="headerlink" title="supervisord"></a>supervisord</h5><p>supervisord是一个轻量级的监控系统，用于保障kubelet和docker运行。</p>
<h5 id="fluentd"><a href="#fluentd" class="headerlink" title="fluentd"></a>fluentd</h5><p>fluentd是一个守护进程，可提供<a href="https://kubernetes.io/docs/concepts/overview/components/#cluster-level-logging" target="_blank" rel="noopener">cluster-level logging</a>。</p>
<h3 id="The-Kubernetes-API"><a href="#The-Kubernetes-API" class="headerlink" title="The Kubernetes API"></a>The Kubernetes API</h3><p><a href="https://git.k8s.io/community/contributors/devel/api-conventions.md" target="_blank" rel="noopener">API约定文档</a>中描述了总体API约定</p>
<p><a href="https://kubernetes.io/docs/reference" target="_blank" rel="noopener">API参考</a>中描述了API端点，资源类型和示例。</p>
<p><a href="https://kubernetes.io/docs/reference/access-authn-authz/controlling-access/" target="_blank" rel="noopener">Controlling API Access</a>文档中讨论了对API的远程访问。</p>
<p>Kubernetes API还可用作系统声明性配置架构的基础。 kubectl命令行工具可用于创建，更新，删除和获取API对象。</p>
<p>Kubernetes还根据API资源存储其序列化状态（当前在<a href="https://coreos.com/docs/distributed-configuration/getting-started-with-etcd/" target="_blank" rel="noopener">etcd</a>中）。</p>
<p>Kubernetes本身被分解为多个组件，通过其API进行交互。</p>
<ul>
<li>API更改 </li>
<li>OpenAPI和Swagger定义 </li>
<li>API版本控制</li>
<li>API组 </li>
<li>启用API组 </li>
<li>启用组中的资源</li>
</ul>
<h4 id="API更改"><a href="#API更改" class="headerlink" title="API更改"></a>API更改</h4><p>根据我们的经验，任何成功的系统都需要随着新用例的出现或现有用例的变化而增长和变化。因此，我们希望Kubernetes API能够不断变化和发展。但是，我们打算在很长一段时间内不破坏与现有客户端的兼容性。通常，可以预期频繁添加新的API资源和新的资源字段。消除资源或字段将需要遵循<a href="https://kubernetes.io/docs/reference/using-api/deprecation-policy/" target="_blank" rel="noopener">API弃用策略</a>。</p>
<h4 id="OpenAPI和Swagger定义"><a href="#OpenAPI和Swagger定义" class="headerlink" title="OpenAPI和Swagger定义"></a>OpenAPI和Swagger定义</h4><p>使用<a href="https://www.openapis.org/" target="_blank" rel="noopener">OpenAPI</a>记录完整的API详细信息。 从Kubernetes 1.10开始，Kubernetes API服务器通过<code>/openapi/ v2</code>端点提供OpenAPI规范。通过设置HTTP标头指定请求的格式：</p>
<table>
<thead>
<tr>
<th>Header</th>
<th>Possible Values</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>application/json, <a href="mailto:application/com.github.proto-openapi.spec.v2@v1.0" target="_blank" rel="noopener">application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf (the default content-type is application/json for <em>/</em> or not passing this header)</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>gzip (not passing this header is acceptable)</td>
</tr>
</tbody>
</table>
<p>在1.14之前，格式分离的端点（<code>/swagger.json</code>,<code>/swagger-2.0.0.json</code>,<code>/swagger-2.0.0.pb-v1</code>,<code>/swagger-2.0.0.pb-v1.gz</code>）为OpenAPI提供服务不同格式的规范。这些端点已弃用，将在Kubernetes 1.14中删除。</p>
<p>获取OpenAPI规范的示例：</p>
<table>
<thead>
<tr>
<th>Before 1.10</th>
<th>Starting with Kubernetes 1.10</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET /swagger.json</td>
<td>GET /openapi/v2 Accept: application/json</td>
</tr>
<tr>
<td>GET /swagger-2.0.0.pb-v1</td>
<td>GET /openapi/v2 Accept: <a href="mailto:application/com.github.proto-openapi.spec.v2@v1.0" target="_blank" rel="noopener">application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf</td>
</tr>
<tr>
<td>GET /swagger-2.0.0.pb-v1.gz</td>
<td>GET /openapi/v2 Accept: <a href="mailto:application/com.github.proto-openapi.spec.v2@v1.0" target="_blank" rel="noopener">application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf Accept-Encoding: gzip</td>
</tr>
</tbody>
</table>
<p>Kubernetes为API实现了另一种基于Protobuf的序列化格式，主要用于集群内通信，在<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md" target="_blank" rel="noopener">设计提案</a>中有记录，每个模式的IDL文件都位于定义API对象的Go包中。</p>
<p>在1.14之前，Kubernetes apiserver还公开了一个API，可用于检索/ swaggerapi上的<a href="http://swagger.io/" target="_blank" rel="noopener">Swagger v1.2</a> Kubernetes API规范。该端点已弃用，将在Kubernetes 1.14中删除。</p>
<h4 id="API版本控制"><a href="#API版本控制" class="headerlink" title="API版本控制"></a>API版本控制</h4><p>为了更容易消除字段或重构资源表示，Kubernetes支持多个API版本，每个API版本位于不同的API路径，例如<code>/api/v1</code>或<code>/apis/extensions/v1beta1</code>。</p>
<p>我们选择在API级别而不是在资源或字段级别进行版本化，以确保API提供清晰，一致的系统资源和行为视图，并允许控制对生命末端和/或实验API的访问。 JSON和Protobuf序列化模式遵循相同的模式更改指南 - 以下所有描述都涵盖两种格式。</p>
<p>请注意，API版本控制和软件版本控制仅间接相关。 <a href="https://git.k8s.io/community/contributors/design-proposals/release/versioning.md" target="_blank" rel="noopener">API和发布版本控制提议</a>描述了API版本控制和软件版本控制之间的关系。</p>
<p>不同的API版本意味着不同级别的稳定性和支持。 <a href="https://git.k8s.io/community/contributors/devel/api_changes.md#alpha-beta-and-stable-versions" target="_blank" rel="noopener">API更改文档</a>中更详细地描述了每个级别的标准。他们总结在这里：</p>
<h5 id="Alpha-level"><a href="#Alpha-level" class="headerlink" title="Alpha level:"></a>Alpha level:</h5><ul>
<li>版本名称包含alpha（例如v1alpha1）。</li>
<li>可能是马车。启用该功能可能会暴露错误。默认情况下禁用。</li>
<li>可随时删除对功能的支持，恕不另行通知。</li>
<li>API可能会在以后的软件版本中以不兼容的方式更改，恕不另行通知。</li>
<li>由于错误风险增加和缺乏长期支持，建议仅在短期测试集群中使用。</li>
</ul>
<h5 id="Beta-level"><a href="#Beta-level" class="headerlink" title="Beta level::"></a>Beta level::</h5><ul>
<li>版本名称包含beta（例如v2beta3）。</li>
<li>代码经过了充分测试。启用该功能被认为是安全的。默认情况下启用。</li>
<li>虽然细节可能会有所变化，但不会删除对整体功能的支持。</li>
<li>在随后的beta版或稳定版中，对象的模式和/或语义可能以不兼容的方式发生变化。发生这种情况时，我们将提供迁移到下一版本的说明。这可能需要删除，编辑和重新创建API对象。编辑过程可能需要一些思考。对于依赖该功能的应用程序，这可能需要停机时间。</li>
<li>建议仅用于非关键业务用途，因为后续版本中可能存在不兼容的更改。如果您有多个可以独立升级的群集，您可以放宽此限制。</li>
<li>请尝试我们的测试版功能并提供反馈！一旦他们退出测试版，我们可能无法进行更多更改。</li>
</ul>
<h5 id="Stable-level"><a href="#Stable-level" class="headerlink" title="Stable level:"></a>Stable level:</h5><ul>
<li>该版本名称是vX这里X是一个整数。</li>
<li>许多后续版本的已发布软件中将出现稳定版本的功能。</li>
</ul>
<h4 id="API组"><a href="#API组" class="headerlink" title="API组"></a>API组</h4><p>为了更容易扩展Kubernetes API，我们实现了<a href="https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md" target="_blank" rel="noopener">API组</a>。API组在REST路径和<code>apiVersion</code>序列化对象的字段中指定。</p>
<p>目前有几个API组正在使用中：</p>
<ol>
<li>核心组，常常被称为遗留组，是在REST路径<code>/api/v1</code>和用途<code>apiVersion: v1</code>。</li>
<li>命名组处于REST路径<code>/apis/$GROUP_NAME/$VERSION</code>，并使用<code>apiVersion: $GROUP_NAME/$VERSION</code> （例如<code>apiVersion: batch/v1</code>）。在<a href="https://kubernetes.io/docs/reference/" target="_blank" rel="noopener">Kubernetes API参考</a>中可以看到支持的API组的完整列表。</li>
</ol>
<p>使用<a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/" target="_blank" rel="noopener">自定义资源</a>扩展API有两种受支持的路径：</p>
<ol>
<li><a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/" target="_blank" rel="noopener">CustomResourceDefinition</a> 适用于具有非常基本CRUD需求的用户。</li>
<li>需要完整Kubernetes API语义的用户可以实现自己的apiserver并使用<a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/configure-aggregation-layer/" target="_blank" rel="noopener">聚合器</a> 使其无缝地为客户端。</li>
</ol>
<h4 id="启用API组"><a href="#启用API组" class="headerlink" title="启用API组"></a>启用API组</h4><p>默认情况下启用某些资源和API组。可以通过设置<code>--runtime-config apiserver</code> 来启用或禁用它们。<code>--runtime-config</code>接受逗号分隔值。例如：要禁用批处理/ v1，请设置 <code>--runtime-config=batch/v1=false</code>，以启用批处理/ v2alpha1，设置<code>--runtime-config=batch/v2alpha1</code>。该标志接受逗号分隔的一组key = value对，描述了apiserver的运行时配置。</p>
<p>重要信息：启用或禁用组或资源需要重新启动apiserver和controller-manager以获取<code>--runtime-config</code>更改。</p>
<h4 id="启用组中的资源"><a href="#启用组中的资源" class="headerlink" title="启用组中的资源"></a>启用组中的资源</h4><p>默认情况下启用DaemonSet，Deployments，HorizontalPodAutoscalers，Ingresses，Jobs和ReplicaSet。可以通过设置<code>--runtime-configapiserver</code> 来启用其他扩展资源。<code>--runtime-config</code>接受逗号分隔值。例如：要禁用部署和入口，请设置 <code>--runtime-config=extensions/v1beta1/deployments=false,extensions/v1beta1/ingresses=false</code></p>
<h3 id="与Kubernetes对象一起工作"><a href="#与Kubernetes对象一起工作" class="headerlink" title="与Kubernetes对象一起工作"></a>与Kubernetes对象一起工作</h3><h4 id="了解Kubernetes对象"><a href="#了解Kubernetes对象" class="headerlink" title="了解Kubernetes对象"></a><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/" target="_blank" rel="noopener">了解Kubernetes对象</a></h4><h5 id="了解Kubernetes对象-1"><a href="#了解Kubernetes对象-1" class="headerlink" title="了解Kubernetes对象"></a>了解Kubernetes对象</h5><p>Kubernetes对象是Kubernetes系统中的持久实体。Kubernetes使用这些实体来表示集群的状态。具体来说，他们可以描述：</p>
<ul>
<li>容器化应用正在运行(以及在哪些节点上)</li>
<li>这些应用可用的资源</li>
<li>关于这些应用如何运行的策略，如重新策略，升级和容错<br>Kubernetes对象是“record of intent”，一旦创建了对象，Kubernetes系统会确保对象存在。通过创建对象，可以有效地告诉Kubernetes系统你希望集群的工作负载是什么样的。</li>
</ul>
<p>要使用Kubernetes对象（无论是创建，修改还是删除），都需要使用<a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" target="_blank" rel="noopener">Kubernetes API</a>。例如，当使用<a href="http://docs.kubernetes.org.cn/61.html" target="_blank" rel="noopener">kubectl命令管理工具</a>时，CLI会为提供Kubernetes API调用。你也可以直接在自己的程序中使用Kubernetes API，您还可以使用其中一个<a href="https://kubernetes.io/docs/reference/using-api/client-libraries/" target="_blank" rel="noopener">客户端库</a>在您自己的程序中直接使用Kubernetes API。</p>
<h5 id="对象（Object）规范和状态"><a href="#对象（Object）规范和状态" class="headerlink" title="对象（Object）规范和状态"></a>对象（Object）规范和状态</h5><p>每个Kubernetes对象都包含两个嵌套对象字段，用于管理Object的配置：Object Spec和Object Status。Spec描述了对象所需的状态 - 希望Object具有的特性，Status描述了对象的实际状态，并由Kubernetes系统提供和更新。</p>
<p>例如，通过Kubernetes Deployment 来表示在集群上运行的应用的对象。创建Deployment时，可以设置Deployment Spec，来指定要运行应用的三个副本。Kubernetes系统将读取Deployment Spec，并启动你想要的三个应用实例 - 来更新状态以符合之前设置的Spec。如果这些实例中有任何一个失败（状态更改），Kuberentes系统将响应Spec和当前状态之间差异来调整，这种情况下，将会开始替代实例。</p>
<p>有关object spec、status和metadata更多信息，请参考<a href="https://git.k8s.io/community/contributors/devel/api-conventions.md" target="_blank" rel="noopener">“Kubernetes API Conventions”</a>。</p>
<h5 id="描述Kubernetes对象"><a href="#描述Kubernetes对象" class="headerlink" title="描述Kubernetes对象"></a>描述Kubernetes对象</h5><p>在Kubernetes中创建对象时，必须提供描述其所需Status的对象Spec，以及关于对象（如name）的一些基本信息。当使用Kubernetes API创建对象（直接或通过kubectl）时，该API请求必须将该信息作为JSON包含在请求body中。通常，可以将信息提供给kubectl .yaml文件，在进行API请求时，kubectl将信息转换为JSON。</p>
<p>以下示例是一个.yaml文件，显示Kubernetes Deployment所需的字段和对象Spec：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application/deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># for versions before 1.9.0 use apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span> <span class="comment"># tells deployment to run 2 pods matching the template</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>使用上述.yaml文件创建Deployment，是通过在kubectl中使用<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#create" target="_blank" rel="noopener">kubectl create</a>命令来实现。将该.yaml文件作为参数传递。如下例子：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>kubectl create -f <span class="symbol">https:</span>/<span class="regexp">/k8s.io/examples</span><span class="regexp">/application/deployment</span>.yaml --record</span><br><span class="line">deployment.apps/nginx-deployment created</span><br></pre></td></tr></table></figure></p>
<h5 id="必填字段"><a href="#必填字段" class="headerlink" title="必填字段"></a>必填字段</h5><p>对于要创建的Kubernetes对象的yaml文件，需要为以下字段设置值：</p>
<ul>
<li>apiVersion - 创建对象的Kubernetes API 版本</li>
<li>kind - 要创建什么样的对象？</li>
<li>metadata- 具有唯一标示对象的数据，包括 name（字符串）、UID和Namespace（可选项）<br>您还需要提供对象规范字段。对象规范的精确格式对于每个Kubernetes对象都是不同的，并且包含特定于该对象的嵌套字段。 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/" target="_blank" rel="noopener">Kubernetes API Reference</a>可以帮助您找到可以使用Kubernetes创建的所有对象的规范格式。例如，可以在<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#podspec-v1-core" target="_blank" rel="noopener">此处</a>找到Pod对象的spec格式，可以在<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#deploymentspec-v1-apps" target="_blank" rel="noopener">此处</a>找到Deployment对象的spec格式。</li>
</ul>
<h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>Kubernetes REST API中的所有对象都由Name和UID明确标识。</p>
<p>对于非唯一的用户提供的属性，Kubernetes提供<a href="https://kubernetes.io/docs/user-guide/labels" target="_blank" rel="noopener">标签</a>和<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/" target="_blank" rel="noopener">注释</a>。</p>
<p>有关名称和UID的精确语法规则，请参阅<a href="https://git.k8s.io/community/contributors/design-proposals/architecture/identifiers.md" target="_blank" rel="noopener">标识符设计文档</a>。</p>
<ul>
<li>Names</li>
<li>UIDs</li>
</ul>
<h5 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h5><p>客户端提供的字符串，用于引用资源URL中的对象，例如<code>/api/v1/pods/some-name</code>。</p>
<p>只有给定类型的一个对象一次可以有一个给定的名称。但是，如果删除该对象，则可以创建具有相同名称的新对象。</p>
<p>按照惯例，Kubernetes资源的名称应最多为253个字符，并且由小写字母数字字符组成-，并且.，但某些资源具有更具体的限制。</p>
<h5 id="UIDs"><a href="#UIDs" class="headerlink" title="UIDs"></a>UIDs</h5><p>Kubernetes系统生成的字符串，用于唯一标识对象。</p>
<p>在Kubernetes集群的整个生命周期中创建的每个对象都具有不同的UID。它旨在区分类似实体的历史事件。</p>
<h4 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h4><p>Kubernetes支持由同一物理集群支持的多个虚拟集群。这些虚拟集群称为名称空间。</p>
<ul>
<li>何时使用多个命名空间</li>
<li>使用命名空间</li>
<li>命名空间和DNS</li>
<li>并非所有对象都在命名空间中</li>
</ul>
<h5 id="何时使用多个命名空间"><a href="#何时使用多个命名空间" class="headerlink" title="何时使用多个命名空间"></a>何时使用多个命名空间</h5><p>命名空间旨在用于多个用户分布在多个团队或项目中的环境中。对于具有几个到几十个用户的集群，您根本不需要创建或考虑名称空间。当您需要它们提供的功能时，请开始使用命名空间。</p>
<p>命名空间提供名称范围。资源名称在名称空间中必须是唯一的，而不是跨名称空间。</p>
<p>命名空间是一种在多个用户之间划分群集资源的方法（通过<a href="https://kubernetes.io/docs/concepts/policy/resource-quotas/" target="_blank" rel="noopener">资源配额</a>）。</p>
<p>在Kubernetes的未来版本中，默认情况下，同一名称空间中的对象将具有相同的访问控制策略。</p>
<p>没有必要使用多个名称空间来分隔略有不同的资源，例如同一软件的不同版本：使用<a href="https://kubernetes.io/docs/user-guide/labels" target="_blank" rel="noopener">标签</a>来区分同一名称空间中的资源。</p>
<h5 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h5><p>名称空间的<a href="https://kubernetes.io/docs/admin/namespaces" target="_blank" rel="noopener">管理指南文档</a>中描述了名称空间的创建和删除。</p>
<h6 id="查看名称空间"><a href="#查看名称空间" class="headerlink" title="查看名称空间"></a>查看名称空间</h6><p>您可以使用以下命令列出集群中的当前名称空间：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">get</span> namespaces</span><br><span class="line">NAME          STATUS    AGE</span><br><span class="line">default       Active    1d</span><br><span class="line">kube-system   Active    1d</span><br><span class="line">kube-public   Active    1d</span><br></pre></td></tr></table></figure></p>
<p>Kubernetes以三个初始名称空间开头：</p>
<ul>
<li><code>default</code> 没有其他命名空间的对象的默认命名空间</li>
<li><code>kube-system</code> Kubernetes系统创建的对象的命名空间</li>
<li><code>kube-public</code>此命名空间是自动创建的，并且所有用户（包括未经过身份验证的用户）都可以读取。此命名空间主要用于群集使用，以防某些资源在整个群集中可见且可公开读取。此命名空间的公共方面只是一个约定，而不是一个要求。</li>
</ul>
<h6 id="设置请求的命名空间"><a href="#设置请求的命名空间" class="headerlink" title="设置请求的命名空间"></a>设置请求的命名空间</h6><p>要临时设置请求的命名空间，请使用该<code>--namespace</code>标志。</p>
<p>例如：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="attribute">--namespace</span>=&lt;insert-namespace-name-here&gt; <span class="builtin-name">run</span> nginx <span class="attribute">--image</span>=nginx</span><br><span class="line">$ kubectl <span class="attribute">--namespace</span>=&lt;insert-namespace-name-here&gt; <span class="builtin-name">get</span> pods</span><br></pre></td></tr></table></figure></p>
<h6 id="设置命名空间首选项"><a href="#设置命名空间首选项" class="headerlink" title="设置命名空间首选项"></a>设置命名空间首选项</h6><p>您可以在该上下文中为所有后续kubectl命令永久保存命名空间。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl<span class="built_in"> config </span>set-context $(kubectl<span class="built_in"> config </span>current-context) <span class="attribute">--namespace</span>=&lt;insert-namespace-name-here&gt;</span><br><span class="line"><span class="comment"># Validate it</span></span><br><span class="line">$ kubectl<span class="built_in"> config </span>view | grep namespace:</span><br></pre></td></tr></table></figure>
<h5 id="命名空间和DNS"><a href="#命名空间和DNS" class="headerlink" title="命名空间和DNS"></a>命名空间和DNS</h5><p>创建<a href="https://kubernetes.io/docs/user-guide/services" target="_blank" rel="noopener">服务</a>时，它会创建相应的<a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noopener">DNS条目</a>。此条目是表单<code>&lt;service-name&gt;.&lt;namespace-name&gt;.svc.cluster.local</code>，这意味着如果容器只是使用<code>&lt;service-name&gt;</code>，它将解析为命名空间本地的服务。这对于在多个名称空间（如开发，分段和生产）中使用相同的配置非常有用。如果要跨命名空间访问，则需要使用完全限定的域名（FQDN）。</p>
<h5 id="并非所有对象都在命名空间中"><a href="#并非所有对象都在命名空间中" class="headerlink" title="并非所有对象都在命名空间中"></a>并非所有对象都在命名空间中</h5><p>大多数Kubernetes资源（例如pod，服务，复制控制器等）都在某些名称空间中。但是，命名空间资源本身并不在命名空间中。并且低级资源（例如节点和persistentVolumes）不在任何名称空间中。</p>
<p>要查看哪些Kubernetes资源在命名空间中，哪些不在：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> In a namespace</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl api-resources --namespaced=<span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Not <span class="keyword">in</span> a namespace</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl api-resources --namespaced=<span class="literal">false</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="Labels-and-Selectors"><a href="#Labels-and-Selectors" class="headerlink" title="Labels and Selectors"></a>Labels and Selectors</h4><p>标签是附加到对象（例如pod）的键/值对。标签旨在用于指定对用户有意义且相关的对象的标识属性，但不直接暗示核心系统的语义。标签可用于组织和选择对象的子集。标签可以在创建时附加到对象，随后可以随时添加和修改。每个对象都可以定义一组键/值标签。每个Key对于给定对象必须是唯一的。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"metadata"</span>: &#123;</span><br><span class="line">  <span class="string">"labels"</span>: &#123;</span><br><span class="line">    <span class="string">"key1"</span> : <span class="string">"value1"</span>,</span><br><span class="line">    <span class="string">"key2"</span> : <span class="string">"value2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>标签允许高效的查询和监视，非常适合在UI和CLI中使用。应使用<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/" target="_blank" rel="noopener">注释</a>记录非识别信息。</p>
<ul>
<li>动机</li>
<li>语法和字符集</li>
<li>标签选择器</li>
<li>API</li>
</ul>
<h5 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h5><p>标签使用户能够以松散耦合的方式将他们自己的组织结构映射到系统对象，而无需客户端存储这些映射。</p>
<p>服务部署和批处理流水线通常是多维实体（例如，多个分区或部署，多个释放轨道，多个层，每层多个微服务）。管理通常需要交叉操作，这打破了严格的层次表示的封装，特别是由基础设施而不是用户确定的严格的层次结构。</p>
<p>示例标签：</p>
<ul>
<li><code>&quot;release&quot; : &quot;stable&quot;</code>，<code>&quot;release&quot; : &quot;canary&quot;</code></li>
<li><code>&quot;environment&quot; : &quot;dev&quot;</code>，<code>&quot;environment&quot; : &quot;qa&quot;</code>，<code>&quot;environment&quot; : &quot;production&quot;</code></li>
<li><code>&quot;tier&quot; : &quot;frontend&quot;</code>，<code>&quot;tier&quot; : &quot;backend&quot;</code>，<code>&quot;tier&quot; : &quot;cache&quot;</code></li>
<li><code>&quot;partition&quot; : &quot;customerA&quot;</code>， <code>&quot;partition&quot; : &quot;customerB&quot;</code></li>
<li><code>&quot;track&quot; : &quot;daily&quot;</code>， <code>&quot;track&quot; : &quot;weekly&quot;</code><br>这些只是常用标签的例子; 你可以自由地制定自己的约定。请记住，标签Key对于给定对象必须是唯一的。</li>
</ul>
<h5 id="语法和字符集"><a href="#语法和字符集" class="headerlink" title="语法和字符集"></a>语法和字符集</h5><p>标签是键/值对。有效标签键有两个段：可选前缀和名称，用斜杠（<code>/</code>）分隔。名称段是必需的，必须是63个字符或更少，以字母数字字符（<code>[a-z0-9A-Z]</code>）开头和结尾，带有破折号（<code>-</code>），下划线（<code>_</code>），点（<code>.</code>）和字母数字之间。前缀是可选的。如果指定，前缀必须是DNS子域：由点（<code>.</code>）分隔的一系列DNS标签，总共不超过253个字符，后跟斜杠（<code>/</code>）。</p>
<p>如果省略前缀，则假定标签Key对用户是私有的。自动化系统组件（例如<code>kube-scheduler</code>，<code>kube-controller-manager</code>，<code>kube-apiserver</code>，<code>kubectl</code>，或其他第三方自动化），它添加标签终端用户对象都必须指定一个前缀。</p>
<p>在<code>kubernetes.io/</code>和<code>k8s.io/</code>前缀保留给Kubernetes核心组件。</p>
<p>有效标签值必须为63个字符或更少，并且必须为空或以字母数字字符（<code>[a-z0-9A-Z]</code>）开头和结尾，并带有短划线（<code>-</code>），下划线（<code>_</code>），点（<code>.</code>）和字母数字。</p>
<h5 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h5><p>与名称和UID不同，标签不提供唯一性。通常，我们希望许多对象携带相同的标签。</p>
<p>通过标签选择器，客户端/用户可以识别一组对象。标签选择器是Kubernetes中的核心分组原语。</p>
<p>目前，API支持两种类型的选择：基于平等，和基于集的。标签选择器可以由逗号分隔的多个要求组成。在多个要求的情况下，必须满足所有要求，因此逗号分隔符充当逻辑AND（<code>&amp;&amp;</code>）运算符。</p>
<p>空或非指定选择器的语义取决于上下文，使用选择器的API类型应记录它们的有效性和含义。</p>
<blockquote>
<p>注意：对于某些API类型（例如ReplicaSet），两个实例的标签选择器不得在命名空间内重叠，或者控制器可以将其视为冲突的指令，并且无法确定应存在多少副本。</p>
</blockquote>
<h6 id="基于平等的要求"><a href="#基于平等的要求" class="headerlink" title="基于平等的要求"></a>基于平等的要求</h6><p>基于平等或不平等的要求允许按标签键和值进行过滤。匹配对象必须满足所有指定的标签约束，尽管它们也可能有其他标签。三种操作都承认<code>=</code>，<code>==</code>，<code>!=</code>。前两个代表平等（简单地说是同义词），而后者代表不平等。例如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">environment = production</span><br><span class="line">tier != frontend</span><br></pre></td></tr></table></figure></p>
<p>前者选择密钥等于<code>environment</code>和值等于的所有资源<code>production</code>。后者选择密钥等于<code>tier</code>和值不同的<code>frontend</code>所有资源，以及没有带<code>tier</code>密钥标签的所有资源。可以过滤使用逗号运算符<code>production</code>排除的资源<code>frontend</code>：<code>environment=production,tier!=frontend</code></p>
<p>基于等同的标签要求的一种使用场景是Pods指定节点选择标准。例如，下面的示例Pod选择标签为“ <code>accelerator=nvidia-tesla-p100</code>”的节点。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: v1</span><br><span class="line"><span class="attribute">kind</span>: Pod</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">name</span>: cuda-test</span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">containers</span>:</span><br><span class="line">    - <span class="attribute">name</span>: cuda-test</span><br><span class="line">      <span class="attribute">image</span>: <span class="string">"k8s.gcr.io/cuda-vector-add:v0.1"</span></span><br><span class="line">      <span class="attribute">resources</span>:</span><br><span class="line">        <span class="attribute">limits</span>:</span><br><span class="line">          nvidia.com/<span class="attribute">gpu</span>: <span class="number">1</span></span><br><span class="line">  <span class="attribute">nodeSelector</span>:</span><br><span class="line">    <span class="attribute">accelerator</span>: nvidia-tesla-p100</span><br></pre></td></tr></table></figure></p>
<h6 id="基于集合的要求"><a href="#基于集合的要求" class="headerlink" title="基于集合的要求"></a>基于集合的要求</h6><p>基于集合的标签要求允许根据一组值过滤密钥。三种操作的支持：<code>in</code>，<code>notin</code>和<code>exists</code>（仅密钥标识符）。例如：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">environment <span class="keyword">in</span> (production, qa)</span><br><span class="line">tier notin (frontend, backend)</span><br><span class="line"><span class="built_in">partition</span></span><br><span class="line">!<span class="built_in">partition</span></span><br></pre></td></tr></table></figure></p>
<p>第一个示例选择键等于<code>environment</code>和值等于<code>production</code>或的所有资源<code>qa</code>。第二个示例选择密钥等于<code>tier</code>和除了<code>frontend</code>和之外的值的<code>backend</code>所有资源，以及没有带<code>tier</code>密钥标签的所有资源。第三个例子选择所有资源，包括带密钥的标签<code>partition</code>; 没有检查值。第四个示例选择没有带键的标签的所有资源<code>partition</code>; 没有检查值。类似地，逗号分隔符充当AND运算符。因此，使用<code>partition</code>密钥（无论值）和<code>environment</code>不同的  过滤资源<code>qa</code>都可以实现<code>partition</code>,<code>environment notin (qa)</code>。基于集合标签选择器是一种平等的一般形式，因为<code>environment=production</code>它等同于<code>environment in (production)</code>; 同样的<code>!=</code>和<code>notin</code>。</p>
<p>基于集合的需求可以与基于相等的需求相结合。例如：<code>partition in (customerA, customerB),environment!=qa</code>。</p>
<h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><h6 id="LIST和WATCH过滤"><a href="#LIST和WATCH过滤" class="headerlink" title="LIST和WATCH过滤"></a>LIST和WATCH过滤</h6><p>LIST和WATCH操作可以指定标签选择器来过滤使用查询参数返回的对象集。这两个要求都是允许的（在此处显示为出现在URL查询字符串中）：</p>
<ul>
<li>基于平等的要求：<code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li>
<li>基于集合的要求：<code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li>
</ul>
<p>两种标签选择器样式都可用于通过REST客户端列出或查看资源。例如，靶向<code>apiserver</code>与<code>kubectl</code>和使用基于平等-一个可写：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">get</span> pods -l <span class="attribute">environment</span>=production,tier=frontend</span><br></pre></td></tr></table></figure></p>
<p>或使用基于集合的要求：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -l <span class="symbol">'environment</span> <span class="keyword">in</span> (production),tier <span class="keyword">in</span> (frontend)'</span><br></pre></td></tr></table></figure></p>
<p>如前所述，基于集合的要求更具表现力。例如，他们可以在值上实现OR运算符：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l <span class="string">'environment in (production, qa)'</span></span></span><br></pre></td></tr></table></figure></p>
<p>或限制负匹配通过存在操作者：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l <span class="string">'environment,environment notin (frontend)'</span></span></span><br></pre></td></tr></table></figure></p>
<p>在API对象中设置引用</p>
<p>某些Kubernetes对象（例如<a href="https://kubernetes.io/docs/user-guide/services" target="_blank" rel="noopener">services</a>和<a href="https://kubernetes.io/docs/user-guide/replication-controller" target="_blank" rel="noopener">replicationcontrollers</a>）也使用标签选择器来指定其他资源集，例如<a href="https://kubernetes.io/docs/user-guide/pods" target="_blank" rel="noopener">pod</a>。</p>
<h5 id="服务和ReplicationController"><a href="#服务和ReplicationController" class="headerlink" title="服务和ReplicationController"></a>服务和ReplicationController</h5><p><code>service</code>使用标签选择器定义目标的一组pod 。类似地<code>，replicationcontroller</code>应该管理的pod的数量也用标签选择器定义。</p>
<p>两个对象的标签选择器在使用映射定义<code>json</code>或<code>yaml</code>文件中定义，并且仅支持基于等同的需求选择器：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"selector"</span>: &#123;</span><br><span class="line">    <span class="string">"component"</span> : <span class="string">"redis"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要么<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">selector:</span></span><br><span class="line"><span class="symbol">    component:</span> redis</span><br></pre></td></tr></table></figure></p>
<p>这个选择器（分别以<code>json</code>或<code>yaml</code>格式）相当于<code>component=redis</code>或<code>component in (redis)</code>。</p>
<h5 id="支持基于集合的需求的资源"><a href="#支持基于集合的需求的资源" class="headerlink" title="支持基于集合的需求的资源"></a>支持基于集合的需求的资源</h5><p>较新的资源，如<a href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/" target="_blank" rel="noopener">Job</a>，<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployment</a>，<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">Replica Set</a>，和<a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">Daemon Set</a>，支持基于集合的要求也是如此。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">selector</span>:</span><br><span class="line">  <span class="attribute">matchLabels</span>:</span><br><span class="line">    <span class="attribute">component</span>: redis</span><br><span class="line">  <span class="attribute">matchExpressions</span>:</span><br><span class="line">    - &#123;<span class="attribute">key</span>: tier, <span class="attribute">operator</span>: In, <span class="attribute">values</span>: [cache]&#125;</span><br><span class="line">    <span class="selector-tag">-</span> &#123;<span class="attribute">key</span>: environment, <span class="attribute">operator</span>: NotIn, <span class="attribute">values</span>: [dev]&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>matchLabels</code>是对的地图<code>{key,value}</code>。一个单一的<code>{key,value}</code>在<code>matchLabels</code>地图相当于一个元件<code>matchExpressions</code>，其key字段是“key”，则<code>operator</code>是“In”和values阵列仅包含“value”。<code>matchExpressions</code>是一个pod选择器要求列表。有效的运算符包括In，NotIn，Exists和DoesNotExist。在In和NotIn的情况下，设置的值必须是非空的。所有的要求，从两者<code>matchLabels</code>和<code>matchExpressionsAND</code>一起 - 他们必须满足，以匹配。</p>
<h5 id="选择节点集"><a href="#选择节点集" class="headerlink" title="选择节点集"></a>选择节点集</h5><p>用于选择标签的一个用例是约束pod可以调度的节点集。有关更多信息，请参阅有关节点选择的文档。</p>
<h4 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h4><p>您可以使用Kubernetes注释将任意非标识元数据附加到对象。工具和库等客户端可以检索此元数据。</p>
<ul>
<li>将元数据附加到对象</li>
<li>语法和字符集</li>
</ul>
<h5 id="将元数据附加到对象"><a href="#将元数据附加到对象" class="headerlink" title="将元数据附加到对象"></a>将元数据附加到对象</h5><p>您可以使用标签或注释将元数据附加到Kubernetes对象。标签可用于选择对象和查找满足特定条件的对象集合。相反，注释不用于识别和选择对象。注释中的元数据可以是小的或大的，结构化的或非结构化的，并且可以包括标签不允许的字符。</p>
<p>注释（如标签）是键/值映射<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"metadata"</span>: &#123;</span><br><span class="line">  <span class="string">"annotations"</span>: &#123;</span><br><span class="line">    <span class="string">"key1"</span> : <span class="string">"value1"</span>,</span><br><span class="line">    <span class="string">"key2"</span> : <span class="string">"value2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是可以在注释中记录的一些信息示例：</p>
<ul>
<li>由声明性配置层管理的字段。将这些字段作为注释附加，可以将它们与客户端或服务器设置的默认值以及自动生成的字段和自动调整大小或自动调整系统设置的字段区分开来。</li>
<li>构建，发布或映像信息，如时间戳，版本ID，git分支，PR编号，镜像哈希和仓库地址。</li>
<li>指向日志记录，监视，分析或审计存储库的指针。</li>
<li>可用于调试目的的客户端库或工具信息：例如，名称，版本和构建信息。</li>
<li>用户或工具/系统出处信息，例如来自其他生态系统组件的相关对象的URL。</li>
<li>轻量推出工具元数据：例如，配置或检查点。</li>
<li>负责人的电话或寻呼机号码，或指定可在何处找到该信息的目录条目，例如团队网站。</li>
<li>从最终用户到实现的指令，用于修改行为或使用非标准功能。</li>
</ul>
<p>您可以将此类信息存储在外部数据库或目录中，而不是使用注释，但这会使生成用于部署，管理，内省等的共享客户端库和工具变得更加困难。</p>
<h5 id="语法和字符集-1"><a href="#语法和字符集-1" class="headerlink" title="语法和字符集"></a>语法和字符集</h5><p>注释是键/值对。有效的注释键有两个段：可选的前缀和名称，用斜杠（<code>/</code>）分隔。名称段是必需的，必须是63个字符或更少，以字母数字字符（<code>[a-z0-9A-Z]</code>）开头和结尾，带有破折号（<code>-</code>），下划线（<code>_</code>），点（<code>.</code>）和字母数字之间。前缀是可选的。如果指定，前缀必须是DNS子域：由点（<code>.</code>）分隔的一系列DNS标签，总共不超过253个字符，后跟斜杠（<code>/</code>）。</p>
<p>如果省略前缀，则假定注释密钥对用户是私有的。自动化系统组件（例如<code>kube-scheduler</code>，<code>kube-controller-manager</code>，<code>kube-apiserver</code>，<code>kubectl</code>，或其他第三方自动化）的添加注释到最终用户的对象都必须指定一个前缀。</p>
<p>在<code>kubernetes.io/</code>和<code>k8s.io/</code>前缀保留给Kubernetes核心组件。</p>
<h4 id="Field-Selectors"><a href="#Field-Selectors" class="headerlink" title="Field Selectors"></a>Field Selectors</h4><ul>
<li>支持的字段</li>
<li>支持操作</li>
<li>链式选择器</li>
<li>多种资源类型</li>
</ul>
<p>字段选择器允许您根据一个或多个资源字段的值<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects" target="_blank" rel="noopener">选择Kubernetes资源</a>。以下是一些示例字段选择器查询：</p>
<ul>
<li><code>metadata.name=my-service</code></li>
<li><code>metadata.namespace!=default</code></li>
<li><code>status.phase=Pending</code>  </li>
</ul>
<p>此<code>kubectl</code>命令选择<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase" target="_blank" rel="noopener">status.phase</a>字段值为的所有Pod <code>Running</code>：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">get</span> pods --field-selector status.<span class="attribute">phase</span>=Running</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：<br>字段选择器本质上是资源过滤器。默认情况下，不应用选择器/过滤器，这意味着将选择指定类型的所有资源。这使以下kubectl查询等效：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="meta">get</span> pods</span><br><span class="line">$ kubectl <span class="meta">get</span> pods --<span class="meta">field</span>-<span class="keyword">selector </span><span class="string">""</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="支持的字段"><a href="#支持的字段" class="headerlink" title="支持的字段"></a>支持的字段</h5><p>支持的字段选择器因Kubernetes资源类型而异。所有资源类型都支持<code>metadata.name</code>和<code>metadata.namespace</code>字段。使用不受支持的字段选择器会产生错误。例如：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">get</span> ingress --field-selector foo.<span class="attribute">bar</span>=baz</span><br><span class="line"><span class="builtin-name">Error</span> <span class="keyword">from</span><span class="built_in"> server </span>(BadRequest): Unable <span class="keyword">to</span> <span class="builtin-name">find</span> <span class="string">"ingresses"</span> that match label selector <span class="string">""</span>, field selector <span class="string">"foo.bar=baz"</span>: <span class="string">"foo.bar"</span> is <span class="keyword">not</span> a known field selector: only <span class="string">"metadata.name"</span>, <span class="string">"metadata.namespace"</span></span><br></pre></td></tr></table></figure></p>
<h5 id="支持操作"><a href="#支持操作" class="headerlink" title="支持操作"></a>支持操作</h5><p>您可以使用<code>=</code>，<code>==</code>以及<code>!=</code>与现场选择操作（<code>=</code>和<code>==</code>意思是一样的）。<code>kubectl</code>例如，此命令选择不在<code>default</code>命名空间中的所有Kubernetes服务：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">get</span> services --field-selector metadata.<span class="keyword">namespace</span>!=<span class="built_in">default</span></span><br></pre></td></tr></table></figure></p>
<h5 id="链式选择器"><a href="#链式选择器" class="headerlink" title="链式选择器"></a>链式选择器</h5><p>与<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels" target="_blank" rel="noopener">标签</a>和其他选择器一样，字段选择器可以作为逗号分隔列表链接在一起。此<code>kubectl</code>命令选择<code>status.phase</code>不相等<code>Running</code>且<code>spec.restartPolicy</code>字段等于的所有Pod <code>Always</code>：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">get</span> pods <span class="attribute">--field-selector</span>=status.phase!=Running,spec.restartPolicy=Always</span><br></pre></td></tr></table></figure></p>
<h5 id="多种资源类型"><a href="#多种资源类型" class="headerlink" title="多种资源类型"></a>多种资源类型</h5><p>您可以跨多种资源类型使用字段选择器。此<code>kubectl</code>命令选择不在<code>default</code>命名空间中的所有Statefulsets和Services ：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">get</span> statefulsets,services --field-selector metadata.<span class="keyword">namespace</span>!=<span class="built_in">default</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Recommended-Labels"><a href="#Recommended-Labels" class="headerlink" title="Recommended Labels"></a>Recommended Labels</h4><p>您可以使用比kubectl和仪表板更多的工具来可视化和管理Kubernetes对象。一组通用的标签允许工具以互操作的方式工作，以所有工具都能理解的通用方式描述对象。</p>
<p>除支持工具外，推荐标签还以可查询的方式描述应用程序。</p>
<ul>
<li>标签</li>
<li>应用程序和应用程序实例</li>
<li>例子<br>元数据围绕应用程序的概念进行组织。Kubernetes不是一个服务平台（PaaS），也没有或强制执行正式的应用程序概念。相反，应用程序是非正式的，并使用元数据进 应用程序包含的内容的定义是松散的。</li>
</ul>
<blockquote>
<p>注意：这些是推荐标签。它们使管理应用程序变得更容易，但对于任何核心工具都不是必需的。</p>
</blockquote>
<p>共享标签和注释共享一个共同的前缀：<code>app.kubernetes.io</code>。没有前缀的标签对用户是私有的。共享前缀可确保共享标签不会干扰自定义用户标签。</p>
<h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><p>为了充分利用这些标签，应将它们应用于每个资源对象。</p>
<table>
<thead>
<tr>
<th>键</th>
<th>描述</th>
<th>例</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>app.kubernetes.io/name</td>
<td>应用程序的名称</td>
<td>string</td>
<td>mysql</td>
</tr>
<tr>
<td>app.kubernetes.io/instance</td>
<td>标识应用程序实例的唯一名称</td>
<td>string</td>
<td>wordpress-abcxzy</td>
</tr>
<tr>
<td>app.kubernetes.io/version</td>
<td>应用程序的当前版本（例如，语义版本，修订版哈希等）</td>
<td>string</td>
<td>5.7.21</td>
</tr>
<tr>
<td>app.kubernetes.io/component</td>
<td>架构中的组件</td>
<td>string</td>
<td>database</td>
</tr>
<tr>
<td>app.kubernetes.io/part-of</td>
<td>此级别的更高级别应用程序的名称</td>
<td>string</td>
<td>wordpress</td>
</tr>
<tr>
<td>app.kubernetes.io/managed-by</td>
<td>该工具用于管理应用程序的操作</td>
<td>string</td>
<td>helm</td>
</tr>
</tbody>
</table>
<p>要说明这些标签的运行情况，请考虑以下StatefulSet对象：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/name: mysql</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/instance: wordpress-abcxzy</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/version: <span class="string">"5.7.21"</span></span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/component: database</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/part-of: wordpress</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/managed-by: helm</span><br></pre></td></tr></table></figure></p>
<h5 id="应用程序和应用程序实例"><a href="#应用程序和应用程序实例" class="headerlink" title="应用程序和应用程序实例"></a>应用程序和应用程序实例</h5><p>应用程序可以一次或多次安装到Kubernetes集群中，在某些情况下，可以安装在同一名称空间中。例如，<code>wordpress</code>可以不止一次安装，其中不同的网站是<code>wordpress</code>的不同安装。</p>
<p>应用程序的名称和实例名称分别记录。例如，在WordPress具有<code>app.kubernetes.io/name</code>的<code>wordpress</code>，同时它有一个实例名，被表示为<code>app.kubernetes.io/instance</code>具有值 <code>wordpress-abcxzy</code>。这使得应用程序的应用程序和实例可以识别。应用程序的每个实例都必须具有唯一的名称。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>为了说明使用这些标签的不同方式，以下示例具有不同的复杂性。</p>
<h6 id="一种简单的无状态服务"><a href="#一种简单的无状态服务" class="headerlink" title="一种简单的无状态服务"></a>一种简单的无状态服务</h6><p>考虑使用<code>Deployment</code>和<code>Service</code>对象部署的简单无状态服务的情况。以下两个代码段表示如何以最简单的形式使用标签。</p>
<p>本<code>Deployment</code>是用来监督运行应用程序本身的豆荚。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: apps/v1</span><br><span class="line"><span class="attribute">kind</span>: Deployment</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">labels</span>:</span><br><span class="line">    app.kubernetes.io/<span class="attribute">name</span>: myservice</span><br><span class="line">    app.kubernetes.io/<span class="attribute">instance</span>: myservice-abcxzy</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>将<code>Service</code>用于公开应用程序。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: myservice</span><br><span class="line">    app.kubernetes.io/instance: myservice-abcxzy</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure></p>
<h6 id="使用数据库的Web应用程序"><a href="#使用数据库的Web应用程序" class="headerlink" title="使用数据库的Web应用程序"></a>使用数据库的Web应用程序</h6><p>考虑一个稍微复杂的应用程序：使用Helm安装的使用数据库（MySQL）的Web应用程序（WordPress）。以下代码段说明了用于部署此应用程序的对象的开始。</p>
<p>以下<code>Deployment</code>内容用于WordPress：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/name: wordpress</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/instance: wordpress-abcxzy</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/version: <span class="string">"4.9.4"</span></span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/managed-by: helm</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/component: server</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/part-of: wordpress</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>将<code>Service</code>用于公开WordPress的：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: wordpress</span><br><span class="line">    app.kubernetes.io/instance: wordpress-abcxzy</span><br><span class="line">    app.kubernetes.io/version: <span class="string">"4.9.4"</span></span><br><span class="line">    app.kubernetes.io/managed-by: helm</span><br><span class="line">    app.kubernetes.io/component: server</span><br><span class="line">    app.kubernetes.io/part-of: wordpress</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure></p>
<p>MySQL作为一个<code>StatefulSet</code>包含它的元数据和它所属的更大的应用程序公开：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/name: mysql</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/instance: wordpress-abcxzy</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/managed-by: helm</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/component: database</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/part-of: wordpress</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/version: <span class="string">"5.7.21"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>将<code>Service</code>用于公开MySQL作为WordPress的部分：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/name: mysql</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/instance: wordpress-abcxzy</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/managed-by: helm</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/component: database</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/part-of: wordpress</span><br><span class="line">    app<span class="selector-class">.kubernetes</span><span class="selector-class">.io</span>/version: <span class="string">"5.7.21"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>使用MySQL <code>StatefulSet</code>，<code>Service</code>您会注意到有关MySQL和Wordpress的信息，包括更广泛的应用程序。</p>
<h3 id="对象管理使用kubectl"><a href="#对象管理使用kubectl" class="headerlink" title="对象管理使用kubectl"></a>对象管理使用kubectl</h3><h4 id="Kubernetes对象管理"><a href="#Kubernetes对象管理" class="headerlink" title="Kubernetes对象管理"></a>Kubernetes对象管理</h4><p>该<code>kubectl</code>命令行工具支持多种不同的方法来创建和管理Kubernetes对象。本文档概述了不同的方法。</p>
<ul>
<li>管理技巧</li>
<li>命令式命令</li>
<li>势在必行的对象配置</li>
<li>声明性对象配置</li>
</ul>
<h5 id="管理技巧"><a href="#管理技巧" class="headerlink" title="管理技巧"></a>管理技巧</h5><blockquote>
<p>警告：应仅使用一种技术管理Kubernetes对象。对同一对象的混合和匹配技术会导致未定义的行为。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Management technique</th>
<th>操作</th>
<th>推荐环境</th>
<th>Supported writers</th>
<th>Learning curve</th>
</tr>
</thead>
<tbody>
<tr>
<td>Imperative commands</td>
<td>Live objects</td>
<td>Development projects</td>
<td>1+</td>
<td>Lowest</td>
</tr>
<tr>
<td>Imperative object configuration</td>
<td>Individual files</td>
<td>Production projects</td>
<td>1</td>
<td>Moderate</td>
</tr>
<tr>
<td>Declarative object configuration</td>
<td>Directories of files</td>
<td>Production projects</td>
<td>1+</td>
<td>Highest</td>
</tr>
</tbody>
</table>
<h5 id="命令式命令"><a href="#命令式命令" class="headerlink" title="命令式命令"></a>命令式命令</h5><p>使用命令性命令时，用户直接在群集中的活动对象上操作。用户将<code>kubectl</code>命令的操作作为参数或标志提供。</p>
<p>这是在集群中启动或运行一次性任务的最简单方法。由于此技术直接在活动对象上运行，因此它不提供先前配置的历史记录。</p>
<h6 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h6><p>通过创建Deployment对象来运行nginx容器的实例：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">run</span> nginx <span class="comment">--image nginx</span></span><br></pre></td></tr></table></figure></p>
<p>使用不同的语法执行相同的操作：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">create</span> deployment nginx <span class="comment">--image nginx</span></span><br></pre></td></tr></table></figure></p>
<h6 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h6><p>与对象配置相比的优点：</p>
<ul>
<li>命令简单易学，易记。</li>
<li>命令只需要一个步骤即可对集群进行更改。</li>
</ul>
<p>与对象配置相比的缺点：</p>
<ul>
<li>命令不与更改审核过程集成。</li>
<li>命令不提供与更改关联的审计跟踪。</li>
<li>除了活动之外，命令不提供记录源。</li>
<li>命令不提供用于创建新对象的模板。</li>
</ul>
<h5 id="势在必行的对象配置"><a href="#势在必行的对象配置" class="headerlink" title="势在必行的对象配置"></a>势在必行的对象配置</h5><p>在命令式对象配置中，kubectl命令指定操作（创建，替换等），可选标志和至少一个文件名。指定的文件必须包含YAML或JSON格式的对象的完整定义。</p>
<p>有关 对象定义的更多详细信息，请参阅<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/" target="_blank" rel="noopener">API参考</a>。</p>
<blockquote>
<p>警告：<code>replace</code>命令式命令将现有规范替换为新提供的规范，删除对配置文件中缺少的对象的所有更改。此方法不应与其配置文件独立更新的资源类型一起使用。<code>LoadBalancer</code>例如，类型的服务使其<code>externalIPs</code>字段独立于群集的配置而更新。</p>
</blockquote>
<h6 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h6><p>创建配置文件中定义的对象：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">kubectl</span> <span class="selector-tag">create</span> <span class="selector-tag">-f</span> <span class="selector-tag">nginx</span><span class="selector-class">.yaml</span></span><br></pre></td></tr></table></figure></p>
<p>删除两个配置文件中定义的对象：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">kubectl</span> <span class="selector-tag">delete</span> <span class="selector-tag">-f</span> <span class="selector-tag">nginx</span><span class="selector-class">.yaml</span> <span class="selector-tag">-f</span> <span class="selector-tag">redis</span><span class="selector-class">.yaml</span></span><br></pre></td></tr></table></figure></p>
<p>通过覆盖实时配置来更新配置文件中定义的对象：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">replace</span> -f nginx.yaml</span><br></pre></td></tr></table></figure></p>
<h6 id="权衡-1"><a href="#权衡-1" class="headerlink" title="权衡"></a>权衡</h6><p>与命令式命令相比的优点：</p>
<ul>
<li>对象配置可以存储在诸如Git的源控制系统中。</li>
<li>对象配置可以与进程集成，例如在推送和审计跟踪之前查看更改。</li>
<li>对象配置提供了用于创建新对象的模板。</li>
</ul>
<p>与命令式命令相比的缺点：</p>
<ul>
<li>对象配置需要对对象模式有基本的了解。</li>
<li>对象配置需要编写YAML文件的附加步骤。</li>
</ul>
<p>与声明对象配置相比的优点：</p>
<ul>
<li>命令式对象配置行为更简单，更易于理解。</li>
<li>从Kubernetes 1.5版开始，命令式对象配置更加成熟。</li>
</ul>
<p>与声明对象配置相比的缺点：</p>
<ul>
<li>命令对象配置最适合文件，而不是目录。</li>
<li>活动对象的更新必须反映在配置文件中，否则在下次更换时会丢失。</li>
</ul>
<h5 id="声明性对象配置"><a href="#声明性对象配置" class="headerlink" title="声明性对象配置"></a>声明性对象配置</h5><p>使用声明性对象配置时，用户对本地存储的对象配置文件进行操作，但是用户不定义要对文件执行的操作。每个对象自动检测创建，更新和删除操作<code>kubectl</code>。这使得能够处理目录，其中可能需要不同对象的不同操作。</p>
<blockquote>
<p>注意：声明性对象配置保留其他编写者所做的更改，即使更改未合并回对象配置文件也是如此。这可以通过使用<code>patch</code>API操作来仅写入观察到的差异，而不是使用<code>replace</code> API操作来替换整个对象配置。</p>
</blockquote>
<h6 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h6><p>处理目录中的所有对象配置文件<code>configs</code>，并创建或修补活动对象。您可以先<code>diff</code>查看要进行的更改，然后应用：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">diff</span> -f configs/</span><br><span class="line">kubectl <span class="built_in">apply</span> -f configs/</span><br></pre></td></tr></table></figure>
<p>递归处理目录：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">diff</span> -R -f configs/</span><br><span class="line">kubectl <span class="built_in">apply</span> -R -f configs/</span><br></pre></td></tr></table></figure></p>
<h6 id="权衡-2"><a href="#权衡-2" class="headerlink" title="权衡"></a>权衡</h6><p>与命令式对象配置相比的优点：</p>
<ul>
<li>即使它们未合并回配置文件，也会保留直接对活动对象所做的更改。</li>
<li>声明性对象配置更好地支持对目录进行操作并自动检测每个对象的操作类型（创建，修补，删除）。</li>
</ul>
<p>与命令式对象配置相比的缺点：</p>
<ul>
<li>声明性对象配置更难以调试，并在意外时理解结果。</li>
<li>使用diff的部分更新会创建复杂的合并和修补操作。</li>
</ul>
<h4 id="使用命令式命令管理Kubernetes对象"><a href="#使用命令式命令管理Kubernetes对象" class="headerlink" title="使用命令式命令管理Kubernetes对象"></a>使用命令式命令管理Kubernetes对象</h4><p>可以使用命令<code>kubectl</code>行工具中内置的命令性命令直接创建，更新和删除Kubernetes对象。本文档说明了如何组织这些命令以及如何使用它们来管理实时对象。</p>
<ul>
<li>权衡</li>
<li>如何创建对象</li>
<li>如何更新对象</li>
<li>如何删除对象</li>
<li>如何查看对象</li>
<li>使用set命令在创建之前修改对象</li>
<li>使用–edit修改之前创建的对象</li>
</ul>
<h5 id="权衡-3"><a href="#权衡-3" class="headerlink" title="权衡"></a>权衡</h5><p>该<code>kubectl</code>工具支持三种对象管理：</p>
<ul>
<li>命令式命令</li>
<li>势在必行的对象配置</li>
<li>声明性对象配置</li>
</ul>
<p>有关<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">每种对象管理</a> 的优缺点的讨论，请参阅<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">Kubernetes</a>对象管理。</p>
<h5 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h5><p>该<code>kubectl</code>工具支持动词驱动的命令，用于创建一些最常见的对象类型。这些命令被命名为不熟悉Kubernetes对象类型的用户可识别。</p>
<ul>
<li><code>run</code>：创建一个新的Deployment对象以在一个或多个Pod中运行Container。</li>
<li><code>expose</code>：创建一个新的服务对象，以跨Pod调整流量负载。</li>
<li><code>autoscale</code>：创建新的Autoscaler对象以自动水平扩展控制器，例如部署。</li>
</ul>
<p>该<code>kubectl</code>工具还支持由对象类型驱动的创建命令。这些命令支持更多对象类型，并且更明确地表达了它们的意图，但要求用户知道他们打算创建的对象的类型。</p>
<ul>
<li><code>create &lt;objecttype&gt; [&lt;subtype&gt;] &lt;instancename&gt;</code></li>
</ul>
<p>某些对象类型具有您可以在<code>create</code>命令中指定的子类型。例如，Service对象有几个子类型，包括ClusterIP，LoadBalancer和NodePort。这是一个使用子类型NodePort创建服务的示例：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create<span class="built_in"> service </span>nodeport &lt;myservicename&gt;</span><br></pre></td></tr></table></figure></p>
<p>在前面的示例中，该<code>create service nodeport</code>命令称为命令的子<code>create service</code>命令。</p>
<p>您可以使用该<code>-h</code>标志来查找子命令支持的参数和标志：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create<span class="built_in"> service </span>nodeport -h</span><br></pre></td></tr></table></figure></p>
<h5 id="如何更新对象"><a href="#如何更新对象" class="headerlink" title="如何更新对象"></a>如何更新对象</h5><p>该<code>kubectl</code>命令支持一些常见更新操作的动词驱动命令。命名这些命令是为了使不熟悉Kubernetes对象的用户能够在不知道必须设置的特定字段的情况下执行更新：</p>
<ul>
<li><code>scale</code>：通过更新控制器的副本计数，水平缩放控制器以添加或删除Pod。</li>
<li><code>annotate</code>：在对象中添加或删除注释。</li>
<li><code>label</code>：在对象中添加或删除标签。</li>
</ul>
<p>该<code>kubectl</code>命令还支持由对象的一个方面驱动的更新命令。设置此方面可以为不同的对象类型设置不同的字段：</p>
<ul>
<li>set ：设置对象的一个方面。</li>
</ul>
<blockquote>
<p>注意：在Kubernetes 1.5版中，并非每个动词驱动的命令都有一个关联的方面驱动命令。</p>
</blockquote>
<p>该<code>kubectl</code>工具支持这些直接更新实时对象的其他方法，但是它们需要更好地理解Kubernetes对象模式。</p>
<ul>
<li><code>edit</code>：通过在编辑器中打开其配置，直接编辑活动对象的原始配置。</li>
<li><code>patch</code>：使用补丁字符串直接修改活动对象的特定字段。有关修补程序字符串的更多详细信息，请参阅API约定中的修补程序部分 。</li>
</ul>
<h5 id="如何删除对象"><a href="#如何删除对象" class="headerlink" title="如何删除对象"></a>如何删除对象</h5><p>您可以使用该<code>delete</code>命令从群集中删除对象：</p>
<ul>
<li><code>delete &lt;type&gt;/&lt;name&gt;</code></li>
</ul>
<blockquote>
<p>注意：您可以使用<code>kubectl delete</code>命令式命令和命令式对象配置。不同之处在于传递给命令的参数。要 <code>kubectl delete</code>用作命令性命令，请将要删除的对象作为参数传递。这是一个传递名为nginx的Deployment对象的示例：</p>
</blockquote>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">delete</span> deployment/nginx</span><br></pre></td></tr></table></figure>
<h5 id="如何查看对象"><a href="#如何查看对象" class="headerlink" title="如何查看对象"></a>如何查看对象</h5><p>有几个命令用于打印有关对象的信息：</p>
<ul>
<li><code>get</code>：打印有关匹配对象的基本信息。使用<code>get -h</code>查看选项列表。</li>
<li><code>describe</code>：打印有关匹配对象的聚合详细信息。</li>
<li><code>logs</code>：为在Pod中运行的容器打印stdout和stderr。</li>
</ul>
<h5 id="使用set命令在创建之前修改对象"><a href="#使用set命令在创建之前修改对象" class="headerlink" title="使用set命令在创建之前修改对象"></a>使用set命令在创建之前修改对象</h5><p>有些对象字段没有可在<code>create</code>命令中使用的标志。在一些案件中，可以使用的组合 <code>set</code>并<code>create</code>指定对象创建前场的值。这是通过将<code>create</code>命令的输出传递给 <code>set</code>命令，然后返回到<code>create</code>命令来完成的。这是一个例子：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create service clusterip my-svc --clusterip=<span class="string">"None"</span> -o yaml --dry-<span class="keyword">run</span><span class="bash"> | kubectl <span class="built_in">set</span> selector --<span class="built_in">local</span> -f - <span class="string">'environment=qa'</span> -o yaml | kubectl create -f -</span></span><br></pre></td></tr></table></figure>
<ol>
<li>该<code>kubectl create service -o yaml --dry-run</code>命令为服务创建配置，但将其作为YAML打印到stdout，而不是将其发送到Kubernetes API服务器。</li>
<li>该<code>kubectl set selector --local -f - -o yaml</code>命令从stdin读取配置，并将更新的配置作为YAML写入stdout。</li>
<li>该<code>kubectl create -f -</code>命令使用stdin提供的配置创建对象。</li>
</ol>
<h5 id="使用–edit修改之前创建的对象"><a href="#使用–edit修改之前创建的对象" class="headerlink" title="使用–edit修改之前创建的对象"></a>使用–edit修改之前创建的对象</h5><p>您可以<code>kubectl create --edit</code>在创建对象之前对其进行任意更改。这是一个例子：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create<span class="built_in"> service </span>clusterip my-svc <span class="attribute">--clusterip</span>=<span class="string">"None"</span> -o yaml --dry-<span class="builtin-name">run</span> &gt; /tmp/srv.yaml</span><br><span class="line">kubectl create --<span class="builtin-name">edit</span> -f /tmp/srv.yaml</span><br></pre></td></tr></table></figure></p>
<p>该<code>kubectl create service</code>命令为服务创建配置并将其保存到<code>/tmp/srv.yaml</code>。<br>该<code>kubectl create --edit</code>命令在创建对象之前打开配置文件以进行编辑。</p>
<h4 id="使用配置文件管理Kubernetes对象"><a href="#使用配置文件管理Kubernetes对象" class="headerlink" title="使用配置文件管理Kubernetes对象"></a>使用配置文件管理Kubernetes对象</h4><p>可以使用<code>kubectl</code> 命令行工具以及使用YAML或JSON编写的对象配置文件来创建，更新和删除Kubernetes对象。本文档介绍了如何使用配置文件定义和管理对象。</p>
<ul>
<li>权衡</li>
<li>如何创建对象</li>
<li>如何更新对象</li>
<li>如何删除对象</li>
<li>如何查看对象</li>
<li>限制</li>
<li>在不保存配置的情况下从URL创建和编辑对象</li>
<li>从命令式命令迁移到命令式对象配置</li>
<li>定义控制器选择器和PodTemplate标签</li>
</ul>
<h5 id="权衡-4"><a href="#权衡-4" class="headerlink" title="权衡"></a>权衡</h5><p>该<code>kubectl</code>工具支持三种对象管理：</p>
<ul>
<li>命令式命令</li>
<li>势在必行的对象配置</li>
<li>声明性对象配置</li>
</ul>
<p>有关<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">每种对象管理</a> 的优缺点的讨论，请参阅<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">Kubernetes</a>对象管理。</p>
<h5 id="如何创建对象-1"><a href="#如何创建对象-1" class="headerlink" title="如何创建对象"></a>如何创建对象</h5><p>您可以使用<code>kubectl create -f</code>从配置文件创建对象。 有关详细信息，请参阅<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/" target="_blank" rel="noopener">kubernetes API参考</a>。</p>
<ul>
<li><code>kubectl create -f &lt;filename|url&gt;</code></li>
</ul>
<h5 id="如何更新对象-1"><a href="#如何更新对象-1" class="headerlink" title="如何更新对象"></a>如何更新对象</h5><blockquote>
<p>警告：使用该<code>replace</code>命令更新对象会删除配置文件中未指定的规范的所有部分。这不应该与规范部分由集群管理的对象一起使用，例如类型服务<code>LoadBalancer</code>，其中<code>externalIPs</code>字段独立于配置文件进行管理。必须将独立管理的字段复制到配置文件中以防止<code>replace</code>丢弃它们。</p>
</blockquote>
<p>您可以使用<code>kubectl replace -f</code>根据配置文件更新活动对象。</p>
<ul>
<li><code>kubectl replace -f &lt;filename|url&gt;</code></li>
</ul>
<h5 id="如何删除对象-1"><a href="#如何删除对象-1" class="headerlink" title="如何删除对象"></a>如何删除对象</h5><p>您可以使用<code>kubectl delete -f</code>删除配置文件中描述的对象。</p>
<ul>
<li><code>kubectl delete -f &lt;filename|url&gt;</code></li>
</ul>
<h5 id="如何查看对象-1"><a href="#如何查看对象-1" class="headerlink" title="如何查看对象"></a>如何查看对象</h5><p>您可以使用它<code>kubectl get -f</code>来查看有关配置文件中描述的对象的信息。</p>
<ul>
<li><code>kubectl get -f &lt;filename|url&gt; -o yaml</code></li>
</ul>
<p>该<code>-o yaml</code>标志指定打印完整对象配置。使用<code>kubectl get -h</code>查看选项列表。</p>
<h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><p><code>create</code>，<code>replace</code>和<code>delete</code>命令工作得很好，当每个对象的配置完全确定并记录在它的配置文件。但是，当更新活动对象并且更新未合并到其配置文件中时，更新将在下次<code>replace</code> 执行时丢失。如果控制器（例如HorizontalPodAutoscaler）直接对活动对象进行更新，则会发生这种情况。这是一个例子：</p>
<ol>
<li>您可以从配置文件创建对象。</li>
<li>另一个源通过更改某个字段来更新对象。</li>
<li>您从配置文件中替换该对象。步骤2中其他来源所做的更改将丢失。</li>
</ol>
<p>如果需要支持同一对象的多个编写器，则可以使用它<code>kubectl apply</code>来管理对象。</p>
<h5 id="在不保存配置的情况下从URL创建和编辑对象"><a href="#在不保存配置的情况下从URL创建和编辑对象" class="headerlink" title="在不保存配置的情况下从URL创建和编辑对象"></a>在不保存配置的情况下从URL创建和编辑对象</h5><p>假设您具有对象配置文件的URL。您可以 <code>kubectl create --edit</code>在创建对象之前用于更改配置。这对于指向可由读者修改的配置文件的教程和任务特别有用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">create</span> -f &lt;<span class="keyword">url</span>&gt; <span class="comment">--edit</span></span><br></pre></td></tr></table></figure>
<h5 id="从命令式命令迁移到命令式对象配置"><a href="#从命令式命令迁移到命令式对象配置" class="headerlink" title="从命令式命令迁移到命令式对象配置"></a>从命令式命令迁移到命令式对象配置</h5><ol>
<li>从命令式命令迁移到命令式对象配置涉及几个手动步骤。<br>将活动对象导出到本地对象配置文件：</li>
</ol>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">get</span> <span class="symbol">&lt;kind&gt;</span>/<span class="symbol">&lt;name&gt;</span> -<span class="keyword">o</span> yaml --export &gt; <span class="symbol">&lt;kind&gt;</span>_<span class="symbol">&lt;name&gt;</span>.yaml</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>从对象配置文件中手动删除状态字段。</p>
</li>
<li><p>对于后续对象管理，请<code>replace</code>专门使用。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl replace -f <span class="tag">&lt;<span class="name">kind</span>&gt;</span>_<span class="tag">&lt;<span class="name">name</span>&gt;</span>.yaml</span><br></pre></td></tr></table></figure>
<h5 id="定义控制器选择器和PodTemplate标签"><a href="#定义控制器选择器和PodTemplate标签" class="headerlink" title="定义控制器选择器和PodTemplate标签"></a>定义控制器选择器和PodTemplate标签</h5><blockquote>
<p>警告：强烈建议不要更新控制器上的选择器。</p>
</blockquote>
<p>推荐的方法是定义一个仅由控制器选择器使用的单个不可变PodTemplate标签，没有其他语义含义。</p>
<p>示例标签：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">selector</span>:</span><br><span class="line">  <span class="attribute">matchLabels</span>:</span><br><span class="line">      <span class="attribute">controller-selector</span>: <span class="string">"extensions/v1beta1/deployment/nginx"</span></span><br><span class="line"><span class="attribute">template</span>:</span><br><span class="line">  <span class="attribute">metadata</span>:</span><br><span class="line">    <span class="attribute">labels</span>:</span><br><span class="line">      <span class="attribute">controller-selector</span>: <span class="string">"extensions/v1beta1/deployment/nginx"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用配置文件声明管理Kubernetes对象"><a href="#使用配置文件声明管理Kubernetes对象" class="headerlink" title="使用配置文件声明管理Kubernetes对象"></a>使用配置文件声明管理Kubernetes对象</h4><p>可以通过在目录中存储多个对象配置文件并使用<code>kubectl apply</code>根据需要递归创建和更新这些对象来创建，更新和删除Kubernetes对象。此方法保留对活动对象的写入，而不将更改合并回对象配置文件。<code>kubectl diff</code>还可以预览<code>apply</code>将要进行的更改。</p>
<ul>
<li>权衡</li>
<li>在你开始之前</li>
<li>如何创建对象</li>
<li>如何更新对象</li>
<li>如何删除对象</li>
<li>如何查看对象</li>
<li>如何应用计算差异并合并更改</li>
<li>默认字段值</li>
<li>如何更改配置文件和直接命令式编写器之间字段的所有权</li>
<li>改变管理方法</li>
<li>定义控制器选择器和PodTemplate标签</li>
</ul>
<h5 id="权衡-5"><a href="#权衡-5" class="headerlink" title="权衡"></a>权衡</h5><p>该<code>kubectl</code>工具支持三种对象管理：</p>
<ul>
<li>命令式命令</li>
<li>势在必行的对象配置</li>
<li>声明性对象配置</li>
</ul>
<p>有关<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">每种对象管理</a> 的优缺点的讨论，请参阅<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">Kubernetes</a>对象管理。</p>
<h5 id="在你开始之前"><a href="#在你开始之前" class="headerlink" title="在你开始之前"></a>在你开始之前</h5><p>声明性对象配置需要牢固地理解Kubernetes对象定义和配置。如果您还没有阅读并填写以下文件：</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/imperative-command/" target="_blank" rel="noopener">使用命令式命令管理Kubernetes对象</a></li>
<li><a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/imperative-config/" target="_blank" rel="noopener">使用配置文件管理Kubernetes对象</a></li>
</ul>
<p>以下是本文档中使用的术语的定义：</p>
<ul>
<li>对象配置文件/配置文件：定义Kubernetes对象配置的文件。本主题说明如何将配置文件传递给<code>kubectl apply</code>。配置文件通常存储在源代码管理中，例如Git。</li>
<li>实时对象配置/实时配置：Kubernetes集群观察到的对象的实时配置值。这些保存在Kubernetes集群存储中，通常是etcd。</li>
<li>声明性配置writer / declarative writer：对活动对象进行更新的人员或软件组件。本主题中提到的实时编写器会更改对象配置文件并运行<code>kubectl apply</code>以编写更改。</li>
</ul>
<h5 id="如何创建对象-2"><a href="#如何创建对象-2" class="headerlink" title="如何创建对象"></a>如何创建对象</h5><p>使用<code>kubectl apply</code>创建的所有对象，除了那些已经存在，通过配置文件在指定的目录中定义：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f &lt;<span class="built_in">directory</span>&gt;/</span><br></pre></td></tr></table></figure></p>
<p>这将<code>kubectl.kubernetes.io/last-applied-configuration: &#39;{...}&#39;</code>在每个对象上设置注释。注释包含用于创建对象的对象配置文件的内容。</p>
<blockquote>
<p>注意：添加-R标志以递归处理目录。</p>
</blockquote>
<p>以下是对象配置文件的示例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application/simple_deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>运行<code>kubectl diff</code>以打印将要创建的对象：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl diff -f https:<span class="regexp">//</span>k8s.io<span class="regexp">/examples/</span>application<span class="regexp">/simple_deployment.yaml</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：<code>diff</code>使用服务器端干运行，需要启用<code>kube-apiserver</code>。</p>
</blockquote>
<p>使用<code>kubectl apply</code>以下方法创建对象<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https:<span class="regexp">//</span>k8s.io<span class="regexp">/examples/</span>application<span class="regexp">/simple_deployment.yaml</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>kubectl get</code>以下方式打印实时配置<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> -f https:<span class="comment">//k8s.io/examples/application/simple_deployment.yaml -o yaml</span></span><br></pre></td></tr></table></figure></p>
<p>输出显示<code>kubectl.kubernetes.io/last-applied-configuration</code>注释已写入实时配置，并且与配置文件匹配：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">kind:</span> Deployment</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  annotations:</span></span><br><span class="line">    <span class="meta"># ...</span></span><br><span class="line">    <span class="meta"># This is the json representation of simple_deployment.yaml</span></span><br><span class="line">    <span class="meta"># It was written by kubectl apply when the object was created</span></span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;<span class="string">"apiVersion"</span>:<span class="string">"apps/v1"</span>,<span class="string">"kind"</span>:<span class="string">"Deployment"</span>,</span><br><span class="line">      <span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"nginx-deployment"</span>,<span class="string">"namespace"</span>:<span class="string">"default"</span>&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"minReadySeconds"</span>:<span class="number">5</span>,<span class="string">"selector"</span>:&#123;<span class="string">"matchLabels"</span>:&#123;<span class="string">"app"</span>:nginx&#125;&#125;,<span class="string">"template"</span>:&#123;<span class="string">"metadata"</span>:&#123;<span class="string">"labels"</span>:&#123;<span class="string">"app"</span>:<span class="string">"nginx"</span>&#125;&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"containers"</span>:[&#123;<span class="string">"image"</span>:<span class="string">"nginx:1.7.9"</span>,<span class="string">"name"</span>:<span class="string">"nginx"</span>,</span><br><span class="line">      <span class="string">"ports"</span>:[&#123;<span class="string">"containerPort"</span>:<span class="number">80</span>&#125;]&#125;]&#125;&#125;&#125;&#125;</span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">  selector:</span></span><br><span class="line"><span class="symbol">    matchLabels:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      app:</span> nginx</span><br><span class="line"><span class="symbol">  template:</span></span><br><span class="line"><span class="symbol">    metadata:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      labels:</span></span><br><span class="line"><span class="symbol">        app:</span> nginx</span><br><span class="line"><span class="symbol">    spec:</span></span><br><span class="line"><span class="symbol">      containers:</span></span><br><span class="line">      - image: nginx:<span class="number">1.7</span><span class="number">.9</span></span><br><span class="line">        <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">        name:</span> nginx</span><br><span class="line"><span class="symbol">        ports:</span></span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">        <span class="meta"># ...</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line">    <span class="meta"># ...</span></span><br><span class="line">  <span class="meta"># ...</span></span><br></pre></td></tr></table></figure></p>
<h5 id="如何更新对象-2"><a href="#如何更新对象-2" class="headerlink" title="如何更新对象"></a>如何更新对象</h5><p>您还可以使用<code>kubectl apply</code>更新目录中定义的所有对象，即使这些对象已存在。此方法可实现以下目标：</p>
<ol>
<li>设置实时配置中配置文件中显示的字段。</li>
<li>清除实时配置中从配置文件中删除的字段。</li>
</ol>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">diff</span> -f &lt;<span class="built_in">directory</span>&gt;/</span><br><span class="line">kubectl <span class="built_in">apply</span> -f &lt;<span class="built_in">directory</span>&gt;/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：添加-R标志以递归处理目录。</p>
</blockquote>
<p>这是一个示例配置文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application/simple_deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>kubectl apply</code>以下方法创建对象<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https:<span class="regexp">//</span>k8s.io<span class="regexp">/examples/</span>application<span class="regexp">/simple_deployment.yaml</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：出于说明的目的，上述命令引用单个配置文件而不是目录。</p>
</blockquote>
<p>使用<code>kubectl get</code>以下方式打印实时配置<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> -f https:<span class="comment">//k8s.io/examples/application/simple_deployment.yaml -o yaml</span></span><br></pre></td></tr></table></figure></p>
<p>输出显示<code>kubectl.kubernetes.io/last-applied-configuration</code>注释已写入实时配置，并且与配置文件匹配：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">kind:</span> Deployment</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  annotations:</span></span><br><span class="line">    <span class="meta"># ...</span></span><br><span class="line">    <span class="meta"># This is the json representation of simple_deployment.yaml</span></span><br><span class="line">    <span class="meta"># It was written by kubectl apply when the object was created</span></span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;<span class="string">"apiVersion"</span>:<span class="string">"apps/v1"</span>,<span class="string">"kind"</span>:<span class="string">"Deployment"</span>,</span><br><span class="line">      <span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"nginx-deployment"</span>,<span class="string">"namespace"</span>:<span class="string">"default"</span>&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"minReadySeconds"</span>:<span class="number">5</span>,<span class="string">"selector"</span>:&#123;<span class="string">"matchLabels"</span>:&#123;<span class="string">"app"</span>:nginx&#125;&#125;,<span class="string">"template"</span>:&#123;<span class="string">"metadata"</span>:&#123;<span class="string">"labels"</span>:&#123;<span class="string">"app"</span>:<span class="string">"nginx"</span>&#125;&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"containers"</span>:[&#123;<span class="string">"image"</span>:<span class="string">"nginx:1.7.9"</span>,<span class="string">"name"</span>:<span class="string">"nginx"</span>,</span><br><span class="line">      <span class="string">"ports"</span>:[&#123;<span class="string">"containerPort"</span>:<span class="number">80</span>&#125;]&#125;]&#125;&#125;&#125;&#125;</span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">  selector:</span></span><br><span class="line"><span class="symbol">    matchLabels:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      app:</span> nginx</span><br><span class="line"><span class="symbol">  template:</span></span><br><span class="line"><span class="symbol">    metadata:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      labels:</span></span><br><span class="line"><span class="symbol">        app:</span> nginx</span><br><span class="line"><span class="symbol">    spec:</span></span><br><span class="line"><span class="symbol">      containers:</span></span><br><span class="line">      - image: nginx:<span class="number">1.7</span><span class="number">.9</span></span><br><span class="line">        <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">        name:</span> nginx</span><br><span class="line"><span class="symbol">        ports:</span></span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">        <span class="meta"># ...</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line">    <span class="meta"># ...</span></span><br><span class="line">  <span class="meta"># ...</span></span><br></pre></td></tr></table></figure></p>
<p>使用，直接更新<code>replicas</code>实时配置中的字段<code>kubectl scale</code>。这不使用<code>kubectl apply</code>：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployment/nginx-deployment <span class="attribute">--replicas</span>=2</span><br></pre></td></tr></table></figure></p>
<p>使用<code>kubectl get</code>以下方式打印实时配置<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> -f https:<span class="comment">//k8s.io/examples/application/simple_deployment.yaml -o yaml</span></span><br></pre></td></tr></table></figure></p>
<p>输出显示该<code>replicas</code>字段已设置为2，并且<code>last-applied-configuration</code>注释不包含<code>replicas</code>字段：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">apiVersion:</span> apps/v1</span><br><span class="line"><span class="symbol">kind:</span> Deployment</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  annotations:</span></span><br><span class="line">    <span class="meta"># ...</span></span><br><span class="line">    <span class="meta"># note that the annotation does not contain replicas</span></span><br><span class="line">    <span class="meta"># because it was not updated through apply</span></span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;<span class="string">"apiVersion"</span>:<span class="string">"apps/v1"</span>,<span class="string">"kind"</span>:<span class="string">"Deployment"</span>,</span><br><span class="line">      <span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"nginx-deployment"</span>,<span class="string">"namespace"</span>:<span class="string">"default"</span>&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"minReadySeconds"</span>:<span class="number">5</span>,<span class="string">"selector"</span>:&#123;<span class="string">"matchLabels"</span>:&#123;<span class="string">"app"</span>:nginx&#125;&#125;,<span class="string">"template"</span>:&#123;<span class="string">"metadata"</span>:&#123;<span class="string">"labels"</span>:&#123;<span class="string">"app"</span>:<span class="string">"nginx"</span>&#125;&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"containers"</span>:[&#123;<span class="string">"image"</span>:<span class="string">"nginx:1.7.9"</span>,<span class="string">"name"</span>:<span class="string">"nginx"</span>,</span><br><span class="line">      <span class="string">"ports"</span>:[&#123;<span class="string">"containerPort"</span>:<span class="number">80</span>&#125;]&#125;]&#125;&#125;&#125;&#125;</span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  replicas:</span> <span class="number">2</span> <span class="meta"># written by scale</span></span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">  selector:</span></span><br><span class="line"><span class="symbol">    matchLabels:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      app:</span> nginx</span><br><span class="line"><span class="symbol">  template:</span></span><br><span class="line"><span class="symbol">    metadata:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      labels:</span></span><br><span class="line"><span class="symbol">        app:</span> nginx</span><br><span class="line"><span class="symbol">    spec:</span></span><br><span class="line"><span class="symbol">      containers:</span></span><br><span class="line">      - image: nginx:<span class="number">1.7</span><span class="number">.9</span></span><br><span class="line">        <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">        name:</span> nginx</span><br><span class="line"><span class="symbol">        ports:</span></span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">      <span class="meta"># ...</span></span><br></pre></td></tr></table></figure></p>
<p>更新<code>simple_deployment.yaml</code>配置文件以将映像更改 <code>nginx:1.7.9</code>为<code>nginx:1.11.9</code>，并删除该<code>minReadySeconds</code>字段：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application/update_deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.11.9</span> <span class="comment"># update the image</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>应用对配置文件所做的更改：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl diff -f <span class="symbol">https:</span>/<span class="regexp">/k8s.io/examples</span><span class="regexp">/application/update</span>_deployment.yaml</span><br><span class="line">kubectl apply -f <span class="symbol">https:</span>/<span class="regexp">/k8s.io/examples</span><span class="regexp">/application/update</span>_deployment.yaml</span><br></pre></td></tr></table></figure></p>
<p>使用<code>kubectl get</code>以下方式打印实时配置<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> -f https:<span class="comment">//k8s.io/examples/application/simple_deployment.yaml -o yaml</span></span><br></pre></td></tr></table></figure></p>
<p>输出显示实时配置的以下更改：</p>
<p>该<code>replicas</code>字段保留2的值<code>kubectl scale</code>。这是可能的，因为它从配置文件中省略。<br>该<code>image</code>场已被更新，以<code>nginx:1.11.9</code>从<code>nginx:1.7.9</code>。<br>该<code>last-applied-configuration</code>批注已经更新了新的形象。<br>该<code>minReadySeconds</code>领域已被清除。<br>该<code>last-applied-configuration</code>注释不再包含<code>minReadySeconds</code>字段。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    # ...</span><br><span class="line">    # The annotation contains the updated image to nginx <span class="number">1.11</span><span class="number">.9</span>,</span><br><span class="line">    # but does not contain the updated replicas to <span class="number">2</span></span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;<span class="string">"apiVersion"</span>:<span class="string">"apps/v1"</span>,<span class="string">"kind"</span>:<span class="string">"Deployment"</span>,</span><br><span class="line">      <span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"nginx-deployment"</span>,<span class="string">"namespace"</span>:<span class="string">"default"</span>&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"selector"</span>:&#123;<span class="string">"matchLabels"</span>:&#123;<span class="string">"app"</span>:nginx&#125;&#125;,<span class="string">"template"</span>:&#123;<span class="string">"metadata"</span>:&#123;<span class="string">"labels"</span>:&#123;<span class="string">"app"</span>:<span class="string">"nginx"</span>&#125;&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"containers"</span>:[&#123;<span class="string">"image"</span>:<span class="string">"nginx:1.11.9"</span>,<span class="string">"name"</span>:<span class="string">"nginx"</span>,</span><br><span class="line">      <span class="string">"ports"</span>:[&#123;<span class="string">"containerPort"</span>:<span class="number">80</span>&#125;]&#125;]&#125;&#125;&#125;&#125;</span><br><span class="line">    # ...</span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">2</span> # Set by `kubectl scale`.  Ignored by `kubectl apply`.</span><br><span class="line">  # minReadySeconds cleared by `kubectl apply`</span><br><span class="line">  # ...</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      # ...</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      # ...</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx:<span class="number">1.11</span><span class="number">.9</span> # Set by `kubectl apply`</span><br><span class="line">        # ...</span><br><span class="line">        name: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">        # ...</span><br><span class="line">      # ...</span><br><span class="line">    # ...</span><br><span class="line">  # ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告：混合<code>kubectl apply</code>与势在必行对象配置命令 <code>create</code>和<code>replace</code>不支持。这是因为<code>create</code> 并<code>replace</code>没有保留<code>kubectl.kubernetes.io/last-applied-configuration</code> 的是<code>kubectl apply</code>用来计算更新。</p>
</blockquote>
<h5 id="如何删除对象-2"><a href="#如何删除对象-2" class="headerlink" title="如何删除对象"></a>如何删除对象</h5><p>删除管理对象有两种方法<code>kubectl apply</code>。</p>
<h6 id="推荐的：-kubectl-delete-f-lt-filename-gt"><a href="#推荐的：-kubectl-delete-f-lt-filename-gt" class="headerlink" title="推荐的： kubectl delete -f &lt;filename&gt;"></a>推荐的： <code>kubectl delete -f &lt;filename&gt;</code></h6><p>建议的方法是使用命令式命令手动删除对象，因为它更明确地删除了什么，并且不太可能导致用户无意中删除了某些内容<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">delete</span> -<span class="keyword">f</span> <span class="symbol">&lt;filename&gt;</span></span><br></pre></td></tr></table></figure></p>
<h6 id="替代方案：-kubectl-apply-f-lt-directory-gt-prune-l-your-label"><a href="#替代方案：-kubectl-apply-f-lt-directory-gt-prune-l-your-label" class="headerlink" title="替代方案： kubectl apply -f &lt;directory/&gt; --prune -l your=label"></a>替代方案： <code>kubectl apply -f &lt;directory/&gt; --prune -l your=label</code></h6><p>只有在你知道自己在做什么的情况下才能使用它。</p>
<blockquote>
<p>警告： <code>kubectl apply --prune</code>处于alpha状态，后续版本中可能会引入向后不兼容的更改。</p>
</blockquote>
<blockquote>
<p>警告：使用此命令时必须小心，以免意外删除对象。</p>
</blockquote>
<p>作为替代方法<code>kubectl delete</code>，您可以使用它<code>kubectl apply</code>来识别从目录中删除配置文件后要删除的对象。<code>--prune</code> 对API服务器应用查询以匹配一组标签的所有对象，并尝试将返回的活动对象配置与对象配置文件进行匹配。如果对象与查询匹配，并且目录中没有配置文件，并且它具有<code>last-applied-configuration</code>注释，则会将其删除。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f &lt;<span class="built_in">directory</span>/&gt; --prune -l &lt;<span class="built_in">labels</span>&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>警告：只应对包含对象配置文件的根目录运行prune。如果对象被指定的标签选择器查询返回-l <labels>并且未出现在子目录中，则对子目录运行会导致无意中删除对象。</labels></p>
</blockquote>
<h5 id="如何查看对象-2"><a href="#如何查看对象-2" class="headerlink" title="如何查看对象"></a>如何查看对象</h5><p>您可以使用<code>kubectl getwith -o yaml</code>来查看活动对象的配置：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="builtin-name">get</span> -f &lt;filename|url&gt; -o yaml</span><br></pre></td></tr></table></figure>
<h5 id="如何应用计算差异并合并更改"><a href="#如何应用计算差异并合并更改" class="headerlink" title="如何应用计算差异并合并更改"></a>如何应用计算差异并合并更改</h5><blockquote>
<p>注意：补丁是一种更新操作，其范围限定为对象的特定字段而不是整个对象。这样可以仅更新对象上的特定字段集，而无需先读取对象。</p>
</blockquote>
<p>当<code>kubectl apply</code>一个对象更新实时配置，它通过发送补丁请求API服务器这样做。该补丁定义了作用于活动对象配置的特定字段的更新。该<code>kubectl apply</code>命令使用配置文件，实时配置和实时配置中<code>last-applied-configuration</code>存储的注释来计算此修补程序请求 。</p>
<h6 id="合并补丁计算"><a href="#合并补丁计算" class="headerlink" title="合并补丁计算"></a>合并补丁计算</h6><p>该<code>kubectl apply</code>命令将配置文件的内容写入 <code>kubectl.kubernetes.io/last-applied-configuration</code>注释。这用于标识已从配置文件中删除的字段，需要从实时配置中清除。以下是用于计算应删除或设置哪些字段的步骤：</p>
<ol>
<li>计算要删除的字段。这些是<code>last-applied-configuration</code>配置文件中存在和丢失的字段。</li>
<li>计算要添加或设置的字段。这些是配置文件中存在的字段，其值与实时配置不匹配。</li>
</ol>
<p>这是一个例子。假设这是Deployment对象的配置文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application/update_deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.11.9</span> <span class="comment"># update the image</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>另外，假设这是同一Deployment对象的实时配置：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">apiVersion:</span> apps/v1</span><br><span class="line"><span class="symbol">kind:</span> Deployment</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  annotations:</span></span><br><span class="line">    <span class="meta"># ...</span></span><br><span class="line">    <span class="meta"># note that the annotation does not contain replicas</span></span><br><span class="line">    <span class="meta"># because it was not updated through apply</span></span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;<span class="string">"apiVersion"</span>:<span class="string">"apps/v1"</span>,<span class="string">"kind"</span>:<span class="string">"Deployment"</span>,</span><br><span class="line">      <span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"nginx-deployment"</span>,<span class="string">"namespace"</span>:<span class="string">"default"</span>&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"minReadySeconds"</span>:<span class="number">5</span>,<span class="string">"selector"</span>:&#123;<span class="string">"matchLabels"</span>:&#123;<span class="string">"app"</span>:nginx&#125;&#125;,<span class="string">"template"</span>:&#123;<span class="string">"metadata"</span>:&#123;<span class="string">"labels"</span>:&#123;<span class="string">"app"</span>:<span class="string">"nginx"</span>&#125;&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"containers"</span>:[&#123;<span class="string">"image"</span>:<span class="string">"nginx:1.7.9"</span>,<span class="string">"name"</span>:<span class="string">"nginx"</span>,</span><br><span class="line">      <span class="string">"ports"</span>:[&#123;<span class="string">"containerPort"</span>:<span class="number">80</span>&#125;]&#125;]&#125;&#125;&#125;&#125;</span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  replicas:</span> <span class="number">2</span> <span class="meta"># written by scale</span></span><br><span class="line">  <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">  selector:</span></span><br><span class="line"><span class="symbol">    matchLabels:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      app:</span> nginx</span><br><span class="line"><span class="symbol">  template:</span></span><br><span class="line"><span class="symbol">    metadata:</span></span><br><span class="line">      <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">      labels:</span></span><br><span class="line"><span class="symbol">        app:</span> nginx</span><br><span class="line"><span class="symbol">    spec:</span></span><br><span class="line"><span class="symbol">      containers:</span></span><br><span class="line">      - image: nginx:<span class="number">1.7</span><span class="number">.9</span></span><br><span class="line">        <span class="meta"># ...</span></span><br><span class="line"><span class="symbol">        name:</span> nginx</span><br><span class="line"><span class="symbol">        ports:</span></span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">      <span class="meta"># ...</span></span><br></pre></td></tr></table></figure></p>
<p>以下是将通过以下方式执行的合并计算<code>kubectl apply</code>：</p>
<ol>
<li>通过读取值<code>last-applied-configuration</code>并将它们与配置文件中的值进行比较来计算要删除的字段 。清除字段在本地对象配置文件中显式设置为null，无论它们是否出现在<code>last-applied-configuration</code>。在此示例中，<code>minReadySeconds</code>出现在 <code>last-applied-configuration</code>注释中，但未出现在配置文件中。 <strong>Action</strong>：<code>minReadySeconds`</code>从实时配置中清除。</li>
<li>通过从配置文件中读取值并将它们与实时配置中的值进行比较来计算要设置的字段。在此示例中，<code>image</code>配置文件中的值与实时配置中的值不匹配。<strong>Action</strong>：设置image实时配置中的值。</li>
<li>设置<code>last-applied-configuration</code>注释以匹配配置文件的值。</li>
<li>将来自1,2,3的结果合并到API服务器的单个补丁请求中。</li>
</ol>
<p>以下是合并的实时配置：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    # ...</span><br><span class="line">    # The annotation contains the updated image to nginx <span class="number">1.11</span><span class="number">.9</span>,</span><br><span class="line">    # but does not contain the updated replicas to <span class="number">2</span></span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;<span class="string">"apiVersion"</span>:<span class="string">"apps/v1"</span>,<span class="string">"kind"</span>:<span class="string">"Deployment"</span>,</span><br><span class="line">      <span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"nginx-deployment"</span>,<span class="string">"namespace"</span>:<span class="string">"default"</span>&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"selector"</span>:&#123;<span class="string">"matchLabels"</span>:&#123;<span class="string">"app"</span>:nginx&#125;&#125;,<span class="string">"template"</span>:&#123;<span class="string">"metadata"</span>:&#123;<span class="string">"labels"</span>:&#123;<span class="string">"app"</span>:<span class="string">"nginx"</span>&#125;&#125;,</span><br><span class="line">      <span class="string">"spec"</span>:&#123;<span class="string">"containers"</span>:[&#123;<span class="string">"image"</span>:<span class="string">"nginx:1.11.9"</span>,<span class="string">"name"</span>:<span class="string">"nginx"</span>,</span><br><span class="line">      <span class="string">"ports"</span>:[&#123;<span class="string">"containerPort"</span>:<span class="number">80</span>&#125;]&#125;]&#125;&#125;&#125;&#125;</span><br><span class="line">    # ...</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      # ...</span><br><span class="line">      app: nginx</span><br><span class="line">  replicas: <span class="number">2</span> # Set by `kubectl scale`.  Ignored by `kubectl apply`.</span><br><span class="line">  # minReadySeconds cleared by `kubectl apply`</span><br><span class="line">  # ...</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      # ...</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx:<span class="number">1.11</span><span class="number">.9</span> # Set by `kubectl apply`</span><br><span class="line">        # ...</span><br><span class="line">        name: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">80</span></span><br><span class="line">        # ...</span><br><span class="line">      # ...</span><br><span class="line">    # ...</span><br><span class="line">  # ...</span><br></pre></td></tr></table></figure></p>
<h6 id="如何合并不同类型的字段"><a href="#如何合并不同类型的字段" class="headerlink" title="如何合并不同类型的字段"></a>如何合并不同类型的字段</h6><p>配置文件中的特定字段如何与实时配置合并取决于字段的类型。有几种类型的字段：</p>
<ul>
<li>primitive：字符串，整数或布尔类型的字段。例如，<code>image</code>和<code>replicas</code>是原始字段。行动：替换。</li>
<li>map，也称为object：类型为map的字段或包含子字段的复杂类型。例如<code>labels</code>， <code>annotations</code>，<code>spec</code>并且<code>metadata</code>是所有map。<strong>Action</strong>：合并元素或子字段。</li>
<li>list：包含可以是基本类型或映射的项列表的字段。例如<code>containers</code>，<code>ports</code>和<code>args</code>是列表。行动：变化。</li>
</ul>
<p>当<code>kubectl apply</code>更新map或列表字段，它通常不更换整个领域，而是更新各个子元素。例如，在合并<code>spec</code>部署时，<code>spec</code>不会替换整个部署。相反，比较和合并<code>spec</code>诸如的子字段<code>replicas</code>。</p>
<h6 id="将更改合并到基本字段"><a href="#将更改合并到基本字段" class="headerlink" title="将更改合并到基本字段"></a>将更改合并到基本字段</h6><p>将更改合并到基本字段</p>
<blockquote>
<p>注意： -用于“不适用”，因为未使用该值。</p>
</blockquote>
<table>
<thead>
<tr>
<th>对象配置文件中的字段</th>
<th>实时对象配置中的字段</th>
<th>最后应用配置中的字段</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td>是</td>
<td>是</td>
<td>-</td>
<td>设置为配置文件值。</td>
</tr>
<tr>
<td>是</td>
<td>没有</td>
<td>-</td>
<td>将实时设置为本地配置。</td>
</tr>
<tr>
<td>没有</td>
<td>-</td>
<td>-</td>
<td>从实时配置中清除。</td>
</tr>
<tr>
<td>没有</td>
<td>-</td>
<td>没有</td>
<td>没做什么。保持实时价值。</td>
</tr>
</tbody>
</table>
<h6 id="合并对地图字段的更改"><a href="#合并对地图字段的更改" class="headerlink" title="合并对地图字段的更改"></a>合并对地图字段的更改</h6><p>通过比较地图的每个子字段或元素来合并表示地图的字段：</p>
<blockquote>
<p>注意： -用于“不适用”，因为未使用该值。</p>
</blockquote>
<table>
<thead>
<tr>
<th>键入对象配置文件</th>
<th>键入实时对象配置</th>
<th>最后应用配置中的字段</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td>是</td>
<td>是</td>
<td>-</td>
<td>比较子字段值。</td>
</tr>
<tr>
<td>是</td>
<td>没有</td>
<td>-</td>
<td>将实时设置为本地配置。</td>
</tr>
<tr>
<td>没有</td>
<td>-</td>
<td>是</td>
<td>从实时配置中删除。</td>
</tr>
<tr>
<td>没有</td>
<td>-</td>
<td>没有</td>
<td>没做什么。保持实时价值。</td>
</tr>
</tbody>
</table>
<h6 id="合并类型列表字段的更改"><a href="#合并类型列表字段的更改" class="headerlink" title="合并类型列表字段的更改"></a>合并类型列表字段的更改</h6><p>将更改合并到列表使用以下三种策略之一：</p>
<ul>
<li>替换列表。</li>
<li>合并复杂元素列表中的各个元素。</li>
<li>合并原始元素列表。</li>
</ul>
<p>战略的选择是基于每个领域。</p>
<h5 id="替换列表"><a href="#替换列表" class="headerlink" title="替换列表"></a>替换列表</h5><p>将列表视为与原始字段相同。替换或删除整个列表。这保留了订购。</p>
<p><strong>例如</strong>：使用<code>kubectl apply</code>更新<code>args</code>一个pod里的一个Container的field。这会将<code>args</code>实时配置中的值设置为配置文件中的值。<code>args</code>之前已添加到实时配置的任何元素都将丢失。<code>args</code>配置文件中定义的元素的顺序将保留在实时配置中。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># last-applied-configuration value</span></span><br><span class="line"><span class="symbol">    args:</span> [<span class="string">"a"</span>, <span class="string">"b"</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta"># configuration file value</span></span><br><span class="line"><span class="symbol">    args:</span> [<span class="string">"a"</span>, <span class="string">"c"</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta"># live configuration</span></span><br><span class="line"><span class="symbol">    args:</span> [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta"># result after merge</span></span><br><span class="line"><span class="symbol">    args:</span> [<span class="string">"a"</span>, <span class="string">"c"</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>说明</strong>：合并使用配置文件值作为新列表值。</p>
<h5 id="合并复杂元素列表中的各个元素："><a href="#合并复杂元素列表中的各个元素：" class="headerlink" title="合并复杂元素列表中的各个元素："></a>合并复杂元素列表中的各个元素：</h5><p>将列表视为映射，并将每个元素的特定字段视为键。添加，删除或更新单个元素。这不会保留排序。</p>
<p>此合并策略在每个字段上使用一个名为a的特殊标记<code>patchMergeKey</code>。<code>patchMergeKey</code>是在Kubernetes源代码中的每个字段中定义： <a href="https://github.com/kubernetes/api/blob/d04500c8c3dda9c980b668c57abc2ca61efcf5c4/core/v1/types.go#L2747" target="_blank" rel="noopener">types.go</a> 当合并映射的列表，指定的字段作为<code>patchMergeKey</code>对于给定的元素被用于像该元素的映射键。</p>
<p><strong>例如</strong>：使用<code>kubectl apply</code>更新<code>containers一PodSpec</code>的field。这将列表合并为好像是每个元素都被键入的映射<code>name</code>。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># last-applied-configuration value</span></span><br><span class="line"><span class="attr">    containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">nginx:1.10</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-a</span> <span class="comment"># key: nginx-helper-a; will be deleted in result</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-b</span> <span class="comment"># key: nginx-helper-b; will be retained</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># configuration file value</span></span><br><span class="line"><span class="attr">    containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">nginx:1.10</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-b</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-c</span> <span class="comment"># key: nginx-helper-c; will be added in result</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># live configuration</span></span><br><span class="line"><span class="attr">    containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">nginx:1.10</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-a</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-b</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"><span class="attr">      args:</span> <span class="string">["run"]</span> <span class="comment"># Field will be retained</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-d</span> <span class="comment"># key: nginx-helper-d; will be retained</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># result after merge</span></span><br><span class="line"><span class="attr">    containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">nginx:1.10</span></span><br><span class="line">      <span class="comment"># Element nginx-helper-a was deleted</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-b</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"><span class="attr">      args:</span> <span class="string">["run"]</span> <span class="comment"># Field was retained</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-c</span> <span class="comment"># Element was added</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx-helper-d</span> <span class="comment"># Element was ignored</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">helper:1.3</span></span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ul>
<li>名为“nginx-helper-a”的容器已删除，因为配置文件中没有出现名为“nginx-helper-a”的容器。</li>
<li>名为“nginx-helper-b”的容器保留<code>args</code> 了实时配置中的更改。<code>kubectl apply</code>能够识别实时配置中的“nginx-helper-b”与配置文件中的“nginx-helper-b”相同，即使它们的字段具有不同的值（<code>args</code>配置文件中没有）。这是因为<code>patchMergeKey</code>字段值（名称）在两者中都是相同的。</li>
<li>添加了名为“nginx-helper-c”的容器，因为实时配置中没有出现具有该名称的容器，但配置文件中出现了具有该名称的容器。</li>
<li>保留名为“nginx-helper-d”的容器，因为在最后应用的配置中没有出现具有该名称的元素。</li>
</ul>
<h5 id="合并原始元素列表"><a href="#合并原始元素列表" class="headerlink" title="合并原始元素列表"></a>合并原始元素列表</h5><p>从Kubernetes 1.5开始，不支持合并原始元素列表。</p>
<blockquote>
<p>注意：为给定字段选择的上述策略中的哪一个由<a href="https://github.com/kubernetes/api/blob/d04500c8c3dda9c980b668c57abc2ca61efcf5c4/core/v1/types.go#L2748" target="_blank" rel="noopener">types.go</a>中的<code>patchStrategy</code>标记控制。如果没有为类型列表的字段指<code>定patchStrategy</code>，则替换列表。</p>
</blockquote>
<h5 id="默认字段值"><a href="#默认字段值" class="headerlink" title="默认字段值"></a>默认字段值</h5><p>如果在创建对象时未指定某些字段，则API服务器会将某些字段设置为实时配置中的默认值。</p>
<p>这是部署的配置文件。该文件未指定<code>strategy</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application/simple_deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>kubectl apply</code>以下方法创建对象<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https:<span class="regexp">//</span>k8s.io<span class="regexp">/examples/</span>application<span class="regexp">/simple_deployment.yaml</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>kubectl get</code>以下方式打印实时配置<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> -f https:<span class="comment">//k8s.io/examples/application/simple_deployment.yaml -o yaml</span></span><br></pre></td></tr></table></figure></p>
<p>输出显示API服务器在实时配置中将多个字段设置为默认值。配置文件中未指定这些字段。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  minReadySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    rollingUpdate:</span> <span class="comment"># defaulted by apiserver - derived from strategy.type</span></span><br><span class="line"><span class="attr">      maxSurge:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      maxUnavailable:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">RollingUpdate</span> <span class="comment"># defaulted apiserver</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">        resources:</span> <span class="string">&#123;&#125;</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">        terminationMessagePath:</span> <span class="string">/dev/termination-log</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">      dnsPolicy:</span> <span class="string">ClusterFirst</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">Always</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">      securityContext:</span> <span class="string">&#123;&#125;</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="attr">      terminationGracePeriodSeconds:</span> <span class="number">30</span> <span class="comment"># defaulted by apiserver</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p>
<p>在修补程序请求中，默认字段不会被重新默认，除非它们作为修补程序请求的一部分被明确清除。这可能会导致基于其他字段的值默认的字段出现意外行为。稍后更改其他字段时，除非明确清除，否则不会更新默认值。</p>
<p>因此，建议在配置文件中显式定义服务器默认的某些字段，即使所需的值与服务器默认值匹配也是如此。这样可以更轻松地识别不会被服务器重新默认的冲突值。</p>
<p>例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># last-applied-configuration</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># configuration file</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Recreate</span> <span class="comment"># updated value</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># live configuration</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">RollingUpdate</span> <span class="comment"># defaulted value</span></span><br><span class="line"><span class="attr">    rollingUpdate:</span> <span class="comment"># defaulted value derived from type</span></span><br><span class="line">      <span class="string">maxSurge</span> <span class="string">:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      maxUnavailable:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># result after merge - ERROR!</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Recreate</span> <span class="comment"># updated value: incompatible with rollingUpdate</span></span><br><span class="line"><span class="attr">    rollingUpdate:</span> <span class="comment"># defaulted value: incompatible with "type: Recreate"</span></span><br><span class="line">      <span class="string">maxSurge</span> <span class="string">:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      maxUnavailable:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ol>
<li>用户无需定义即可创建部署<code>strategy.type</code>。</li>
<li>服务器默认<code>strategy.type</code>为<code>RollingUpdate</code>默认 <code>strategy.rollingUpdate</code>值。</li>
<li>用户更改<code>strategy.type</code>为<code>Recreate</code>。该<code>strategy.rollingUpdate</code>值保持在其默认的值，但服务器期望他们被清除。如果<code>strategy.rollingUpdate</code>最初在配置文件中定义了值，则更清楚的是它们需要被删除。</li>
<li>应用失败，因为<code>strategy.rollingUpdate</code>未清除。该<code>strategy.rollingupdate</code> 字段不能与被定义<code>strategy.type的Recreate</code>。</li>
</ol>
<p>建议：应在对象配置文件中明确定义这些字段：</p>
<ul>
<li>工作负载上的选择器和PodTemplate标签，例如Deployment，StatefulSet，Job，DaemonSet，ReplicaSet和ReplicationController</li>
<li>部署部署策略</li>
</ul>
<h6 id="如何清除其他编写者设置的服务器默认字段或字段"><a href="#如何清除其他编写者设置的服务器默认字段或字段" class="headerlink" title="如何清除其他编写者设置的服务器默认字段或字段"></a>如何清除其他编写者设置的服务器默认字段或字段</h6><p>可以通过将其值设置为<code>null</code>然后应用配置文件来清除未出现在配置文件中的字段。对于服务器默认的字段，这会触发重新默认值。</p>
<h5 id="如何更改配置文件和直接命令式编写器之间字段的所有权"><a href="#如何更改配置文件和直接命令式编写器之间字段的所有权" class="headerlink" title="如何更改配置文件和直接命令式编写器之间字段的所有权"></a>如何更改配置文件和直接命令式编写器之间字段的所有权</h5><p>这些是您应该用来更改单个对象字段的唯一方法：</p>
<ul>
<li>使用<code>kubectl apply</code>。</li>
<li>直接写入实时配置而不修改配置文件：例如，使用<code>kubectl scale</code>。</li>
</ul>
<h6 id="将所有者从直接命令式编写器更改为配置文件"><a href="#将所有者从直接命令式编写器更改为配置文件" class="headerlink" title="将所有者从直接命令式编写器更改为配置文件"></a>将所有者从直接命令式编写器更改为配置文件</h6><p>将该字段添加到配置文件中。对于现场，停止对未经过的实时配置的直接更新<code>kubectl apply</code>。</p>
<h6 id="将所有者从配置文件更改为直接命令式编写器"><a href="#将所有者从配置文件更改为直接命令式编写器" class="headerlink" title="将所有者从配置文件更改为直接命令式编写器"></a>将所有者从配置文件更改为直接命令式编写器</h6><p>从Kubernetes 1.5开始，将字段的所有权从配置文件更改为命令式编写器需要手动步骤：</p>
<ul>
<li>从配置文件中删除该字段。</li>
<li>从<code>kubectl.kubernetes.io/last-applied-configuration</code>活动对象上的注释中删除该字段。</li>
</ul>
<h5 id="改变管理方法"><a href="#改变管理方法" class="headerlink" title="改变管理方法"></a>改变管理方法</h5><p>应该一次只使用一种方法管理Kubernetes对象。可以从一种方法切换到另一种方法，但这是一种手动过程。</p>
<blockquote>
<p>注意：使用命令式删除和声明式管理是可以的。</p>
</blockquote>
<h6 id="从命令式命令管理迁移到声明性对象配置"><a href="#从命令式命令管理迁移到声明性对象配置" class="headerlink" title="从命令式命令管理迁移到声明性对象配置"></a>从命令式命令管理迁移到声明性对象配置</h6><p>从命令式命令管理迁移到声明性对象配置涉及几个手动步骤：</p>
<ol>
<li><p>将活动对象导出到本地配置文件：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">get</span> <span class="symbol">&lt;kind&gt;</span>/<span class="symbol">&lt;name&gt;</span> -<span class="keyword">o</span> yaml --export &gt; <span class="symbol">&lt;kind&gt;</span>_<span class="symbol">&lt;name&gt;</span>.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>status</code>从配置文件中手动删除该字段。</p>
</li>
</ol>
<blockquote>
<p>注意：此步骤是可选的，因为<code>kubectl apply</code>不会更新状态字段 即使它存在于配置文件中。</p>
</blockquote>
<ol start="3">
<li><p><code>kubectl.kubernetes.io/last-applied-configuration</code>在对象上设置注释：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl replace --<span class="keyword">save</span>-config -f &lt;<span class="keyword">kind</span>&gt;_&lt;<span class="keyword">name</span>&gt;.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改<code>kubectl apply</code>用于专门管理对象的进程。</p>
</li>
</ol>
<h6 id="从命令式对象配置迁移到声明性对象配置"><a href="#从命令式对象配置迁移到声明性对象配置" class="headerlink" title="从命令式对象配置迁移到声明性对象配置"></a>从命令式对象配置迁移到声明性对象配置</h6><ol>
<li><p><code>kubectl.kubernetes.io/last-applied-configuration</code>在对象上设置注释：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl replace --<span class="keyword">save</span>-config -f &lt;<span class="keyword">kind</span>&gt;_&lt;<span class="keyword">name</span>&gt;.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改<code>kubectl apply</code>用于专门管理对象的进程。</p>
</li>
</ol>
<h5 id="定义控制器选择器和PodTemplate标签-1"><a href="#定义控制器选择器和PodTemplate标签-1" class="headerlink" title="定义控制器选择器和PodTemplate标签"></a>定义控制器选择器和PodTemplate标签</h5><blockquote>
<p>警告：强烈建议不要更新控制器上的选择器。</p>
</blockquote>
<p>推荐的方法是定义一个仅由控制器选择器使用的单个不可变PodTemplate标签，没有其他语义含义。</p>
<p>例：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">selector</span>:</span><br><span class="line">  <span class="attribute">matchLabels</span>:</span><br><span class="line">      <span class="attribute">controller-selector</span>: <span class="string">"extensions/v1beta1/deployment/nginx"</span></span><br><span class="line"><span class="attribute">template</span>:</span><br><span class="line">  <span class="attribute">metadata</span>:</span><br><span class="line">    <span class="attribute">labels</span>:</span><br><span class="line">      <span class="attribute">controller-selector</span>: <span class="string">"extensions/v1beta1/deployment/nginx"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Kubernetes-Architecture"><a href="#Kubernetes-Architecture" class="headerlink" title="Kubernetes Architecture"></a>Kubernetes Architecture</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>节点是Kubernetes中的工作机器，以前称为一个 <code>minion</code>。节点可以是VM或物理机，具体取决于集群。每个节点都包含运行<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="noopener">pods</a>所需的服务，并由主组件管理。节点上的服务包括<a href="https://kubernetes.io/docs/concepts/overview/components/#node-components" target="_blank" rel="noopener">container runtime</a>，kubelet和kube-proxy。有关更多详细信息，请参阅 体系结构设计文档中的<a href="https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node" target="_blank" rel="noopener">Kubernetes节点部分</a>。</p>
<ul>
<li>节点状态</li>
<li>管理</li>
<li>API对象</li>
</ul>
<h4 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h4><p>节点的状态包含以下信息：</p>
<ul>
<li>地址</li>
<li>条件</li>
<li>容量</li>
<li>信息</li>
</ul>
<p>下面详细描述每个部分。</p>
<h5 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h5><p>这些字段的使用取决于您的云提供商或裸机配置。</p>
<ul>
<li>HostName：节点内核报告的主机名。可以通过kubelet<code>--hostname-override</code>参数覆盖。</li>
<li>ExternalIP：通常是可从外部路由的节点的IP地址（可从群集外部获得）。</li>
<li>InternalIP：通常仅在群集内可路由的节点的IP地址。</li>
</ul>
<h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><p>该<code>conditions</code>字段描述了所有<code>Running</code>节点的状态。</p>
<table>
<thead>
<tr>
<th>节点条件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OutOfDisk</code></td>
<td><code>True</code> 如果节点上的可用空间不足以添加新的pod，否则 <code>False</code></td>
</tr>
<tr>
<td><code>Ready</code></td>
<td><code>True</code>如果节点是健康的并准备好接受pod，<code>False</code>如果节点不健康且不接受pod，并且<code>Unknown</code>节点控制器在最后一次没有从节点听到<code>node-monitor-grace-period</code>（默认为40秒）</td>
</tr>
<tr>
<td><code>MemoryPressure</code></td>
<td><code>True</code>如果节点存储器上存在压力 - 即节点存储器是否为低; 除此以外<code>False</code></td>
</tr>
<tr>
<td><code>PIDPressure</code></td>
<td><code>True</code>如果进程存在压力 - 也就是说，如果节点上有太多进程; 除此以外<code>False</code></td>
</tr>
<tr>
<td><code>DiskPressure</code></td>
<td><code>True</code>如果磁盘大小存在压力 - 即磁盘容量低; 除此以外<code>False</code></td>
</tr>
<tr>
<td><code>NetworkUnavailable</code></td>
<td><code>True</code> 如果没有正确配置节点的网络，否则 <code>False</code></td>
</tr>
</tbody>
</table>
<p>节点条件表示为JSON对象。例如，以下响应描述了健康节点。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"conditions"</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"Ready"</span>,</span><br><span class="line">    <span class="string">"status"</span>: <span class="string">"True"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>如果就绪状态的状态保持<code>Unknown</code>或<code>False</code>超过<code>pod-eviction-timeout</code>，则会将参数传递给<a href="https://kubernetes.io/docs/admin/kube-controller-manager/" target="_blank" rel="noopener">kube-controller-manager</a>，并且节点控制器会调度节点上的所有Pod以进行删除。默认逐出超时持续时间为<strong>五分钟</strong>。在某些情况下，当节点无法访问时，apiserver无法与节点上的kubelet通信。在重新建立与apiserver的通信之前，不能将删除pod的决定传送到kubelet。同时，计划删除的pod可以继续在分区节点上运行。</p>
<p>在1.5之前的Kubernetes版本中，节点控制器会从apiserver中<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/#force-deletion-of-pods" target="_blank" rel="noopener">强制删除</a>这些无法访问的pod。但是，在1.5及更高版本中，节点控制器不会强制删除容器，直到确认它们已停止在群集中运行。您可以看到可能在无法访问的节点上运行的Pod处于<code>Terminating</code>或<code>Unknown</code>状态。如果节点永久离开群集，如果Kubernetes无法从底层基础架构推断出，则群集管理员可能需要手动删除节点对象。从Kubernetes中删除节点对象会导致节点上运行的所有Pod对象从apiserver中删除，并释放它们的名称。</p>
<p>在版本1.12中，<code>TaintNodesByCondition</code>功能被提升为beta版，因此节点生命周期控制器会自动创建表示条件的<a href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/" target="_blank" rel="noopener"> taints</a> 。类似地，调度程序在考虑节点时忽略条件;相反，它会查看Node的污点和Pod的容忍度。 现在，用户可以在旧的调度模型和更灵活的新调度模型之间进行选择。根据旧型号，可以安排没有任何容忍度的Pod。但是可以在该节点上安排容忍特定节点的污点的Pod。</p>
<blockquote>
<p>警告：启用此功能会在观察到条件和创建污点之间产生一个小延迟。此延迟通常小于一秒，但它可以增加成功安排但被kubelet拒绝的Pod的数量。</p>
</blockquote>
<h5 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h5><p>描述节点上可用的资源：CPU，内存以及可以在节点上调度的最大pod数。</p>
<h5 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h5><p>有关节点的一般信息，例如内核版本，Kubernetes版本（kubelet和kube-proxy版本），Docker版本（如果使用），操作系统名称。信息由Kubelet从节点收集。</p>
<h4 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h4><p>与<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="noopener">pod</a>和<a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">服务</a>不同，Kubernetes本身并不创建节点：它由Google Compute Engine等云提供商在外部创建，或者存在于物理或虚拟机池中。因此，当Kubernetes创建节点时，它会创建一个表示节点的对象。创建后，Kubernetes会检查节点是否有效。例如，如果您尝试从以下内容创建节点：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"kind"</span>: <span class="string">"Node"</span>,</span><br><span class="line">  <span class="attr">"apiVersion"</span>: <span class="string">"v1"</span>,</span><br><span class="line">  <span class="attr">"metadata"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"10.240.79.157"</span>,</span><br><span class="line">    <span class="attr">"labels"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"my-first-k8s-node"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Kubernetes在内部创建节点对象（表示），并通过基于<code>metadata.name</code>字段的运行状况检查来验证节点。如果节点有效 - 即，如果所有必需的服务都在运行 - 它有资格运行pod。否则，对于任何群集活动，它将被忽略，直到它变为有效。</p>
<blockquote>
<p>注意： Kubernetes保留无效节点的对象，并不断检查它是否有效。您必须显式删除Node对象才能停止此过程。</p>
</blockquote>
<p>目前，有三个组件与Kubernetes节点接口交互：节点控制器，kubelet和kubectl。</p>
<h5 id="节点控制器"><a href="#节点控制器" class="headerlink" title="节点控制器"></a>节点控制器</h5><p>节点控制器是Kubernetes主组件，它管理节点的各个方面。</p>
<p>节点控制器在节点的生命周期中具有多个角色。第一种是在注册时为节点分配CIDR块（如果打开了CIDR分配）。</p>
<p>第二个是使节点控制器的内部节点列表与云提供商的可用计算机列表保持同步。在云环境中运行时，只要节点不健康，节点控制器就会询问云提供商该节点的VM是否仍然可用。如果不是，则节点控制器从其节点列表中删除该节点。</p>
<p>第三是监测节点的健康状况。节点控制器负责在节点变得无法访问时将NodeStatus的NodeReady条件更新为ConditionUnknown（即节点控制器由于某种原因停止接收心跳，例如由于节点关闭），然后从节点中驱逐所有pod （如果节点仍然无法访问，则使用正常终止）。（默认超时为40 <code>--node-monitor-period</code>秒，开始报告ConditionUnknown，之后5米开始驱逐pod。）节点控制器每秒检查每个节点的状态。</p>
<p>在1.13之前的Kubernetes版本中，NodeStatus是节点的心跳。从Kubernetes 1.13开始，节点租用功能作为alpha功能引入（功能门<code>NodeLease</code>， <a href="https://github.com/kubernetes/community/blob/master/keps/sig-node/0009-node-heartbeat.md" target="_blank" rel="noopener">KEP-0009</a>）。启用节点租用功能时，每个节点都有一个关联的<code>Lease</code>对象 <code>kube-node-lease</code>由节点定期更新的命名空间，NodeStatus和节点租约都被视为来自节点的心跳。节点租约经常更新，而NodeStatus仅在有一些更改或经过足够时间时从节点报告为主节点（默认值为1分钟，这比不可达节点的默认超时40秒）。由于节点租约比NodeStatus轻得多，因此从可伸缩性和性能角度来看，此功能使节点心跳显着降低。</p>
<p>在Kubernetes 1.4中，我们更新了节点控制器的逻辑，以便在大量节点到达主站时遇到问题时更好地处理案例（例如，因为主站有网络问题）。从1.4开始，节点控制器在决定pod驱逐时查看集群中所有节点的状态。</p>
<p>在大多数情况下，节点控制器将驱逐率限制为每秒 <code>--node-eviction-rate</code>（默认值0.1），这意味着它不会每10秒从多个节点驱逐pod。</p>
<p>当给定可用区中的节点变得不健康时，节点逐出行为会发生变化。节点控制器同时检查区域中节点的百分比是否不健康（NodeReady条件是ConditionUnknown或ConditionFalse）。如果不健康节点的比例至少为 <code>--unhealthy-zone-threshold</code>（默认为0.55），则驱逐率降低：如果群集较小（即小于或等于<code>--large-cluster-size-threshold</code>节点 - 默认为50）则停止驱逐，否则驱逐率降低为 <code>--secondary-node-eviction-rate</code>（默认0.01）每秒。每个可用区域实施这些策略的原因是因为一个可用区域可能从主服务器分区而其他可用区域保持连接。如果您的群集未跨越多个云提供商可用区域，则只有一个可用区域（整个群集）。</p>
<p>在可用区域之间传播节点的一个关键原因是，当整个区域出现故障时，工作负载可以转移到健康区域。因此，如果区域中的所有节点都不健康，则节点控制器以正常速率驱逐<code>--node-eviction-rate</code>。角落情况是所有区域完全不健康（即群集中没有健康的节点）。在这种情况下，节点控制器假定主连接存在一些问题，并在某些连接恢复之前停止所有驱逐。</p>
<p>从Kubernetes 1.6开始，NodeController还负责驱逐在具有<code>NoExecute</code>污点的节点上运行的pod，当pod不能容忍taints时。此外，作为默认禁用的alpha功能，NodeController负责添加与节点无法访问或未就绪等节点问题相对应的污点。 有关污点和alpha功能的详细信息，请参阅<a href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/" target="_blank" rel="noopener">此文档</a><code>NoExecute</code>。</p>
<p>从版本1.8开始，节点控制器可以负责创建表示节点条件的污点。这是1.8版的alpha功能。</p>
<h5 id="节点自注册"><a href="#节点自注册" class="headerlink" title="节点自注册"></a>节点自注册</h5><p>当kubelet标志<code>--register-node</code>为true（默认值）时，kubelet将尝试向API服务器注册自己。这是大多数发行版使用的首选模式。</p>
<p>对于自行注册，可以使用以下选项启动kubelet：</p>
<ul>
<li><code>--kubeconfig</code> - 凭证路径，以向apiserver验证自身。</li>
<li><code>--cloud-provider</code> - 如何与云提供商交谈以阅读有关自身的元数据。</li>
<li><code>--register-node</code> - 自动注册API服务器。</li>
<li><code>--register-with-taints</code>- 使用给定的taints列表注册节点（以逗号分隔<code>&lt;key&gt;=&lt;value&gt;:&lt;effect&gt;</code>）。No-op如果<code>register-node</code>是假的。</li>
<li><code>--node-ip</code> - 节点的IP地址。</li>
<li><code>--node-labels</code>- 在群集中注册节点时添加的标签（请参阅<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction" target="_blank" rel="noopener">1.13+中NodeRestriction准入插件</a>强制执行的标签限制）。</li>
<li><code>--node-status-update-frequency</code> - 指定kubelet将节点状态发布到master的频率。</li>
</ul>
<p>当<a href="https://kubernetes.io/docs/reference/access-authn-authz/node/" target="_blank" rel="noopener">节点授权模式</a>和 <a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction/" target="_blank" rel="noopener">NodeRestriction</a>录取插件的启用，kubelets仅被授权创建/修改自己的节点资源。</p>
<h4 id="手动节点管理"><a href="#手动节点管理" class="headerlink" title="手动节点管理"></a>手动节点管理</h4><p>集群管理员可以创建和修改节点对象。</p>
<p>如果管理员希望手动创建节点对象，请设置kubelet标志 <code>--register-node=false</code>。</p>
<p>管理员可以修改节点资源（无论设置如何<code>--register-node</code>）。修改包括在节点上设置标签并将其标记为不可调度。</p>
<p>节点上的标签可以与pod上的节点选择器结合使用以控制调度，例如，将pod限制为仅有资格在节点的子集上运行。</p>
<p>将节点标记为不可调度可防止将新pod调度到该节点，但不会影响节点上的任何现有pod。这在节点重启等之前作为准备步骤很有用。例如，要标记节点不可调度，请运行以下命令：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">kubectl</span> cordon <span class="variable">$NODENAME</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：由DaemonSet控制器创建的Pod绕过Kubernetes调度程序，不遵守节点上的不可调度属性。这假设守护进程属于机器，即使它在准备重新启动时正在耗尽应用程序。</p>
</blockquote>
<h5 id="节点容量"><a href="#节点容量" class="headerlink" title="节点容量"></a>节点容量</h5><p>节点的容量（cpus的数量和内存量）是节点对象的一部分。通常，节点在创建节点对象时注册自己并报告其容量。如果您正在进行<a href="https://kubernetes.io/docs/concepts/architecture/nodes/#manual-node-administration" target="_blank" rel="noopener">手动节点管理</a>，则需要在添加节点时设置节点容量。</p>
<p>Kubernetes调度程序确保节点上的所有pod都有足够的资源。它检查节点上容器请求的总和不大于节点容量。它包括由kubelet启动的所有容器，但不包括由<a href="https://kubernetes.io/docs/concepts/overview/components/#node-components" target="_blank" rel="noopener">容器运行时</a>直接启动的<a href="https://kubernetes.io/docs/concepts/overview/components/#node-components" target="_blank" rel="noopener">容器</a>，也不包括在容器外部运行的任何进程。</p>
<p>如果要为非Pod进程显式保留资源，请按照<a href="https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved" target="_blank" rel="noopener">本教程</a> 为系统守护程序保留资源。</p>
<h4 id="API对象"><a href="#API对象" class="headerlink" title="API对象"></a>API对象</h4><p>Node是Kubernetes REST API中的顶级资源。有关API对象的更多详细信息，请参见： <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#node-v1-core" target="_blank" rel="noopener">Node API对象</a>。</p>
<h3 id="主节点通信"><a href="#主节点通信" class="headerlink" title="主节点通信"></a>主节点通信</h3><p>本文档对master（实际上是apiserver）和Kubernetes集群之间的通信路径进行了编目。目的是允许用户自定义其安装以强化网络配置，以便群集可以在不受信任的网络（或云提供商上的完全公共IP）上运行。</p>
<ul>
<li>群集到Master</li>
<li>掌握群集</li>
</ul>
<h4 id="群集到Master"><a href="#群集到Master" class="headerlink" title="群集到Master"></a>群集到Master</h4><p>从集群到主服务器的所有通信路径都在apiserver处终止（其他主服务器组件均未设计为公开远程服务）。在典型部署中，apiserver被配置为在安全HTTPS端口（443）上侦听远程连接，其中启用了一种或多种形式的客户端<a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/" target="_blank" rel="noopener">认证</a>。 应启用一种或多种<a href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/" target="_blank" rel="noopener">授权</a>形式，尤其是 在允许<a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#anonymous-requests" target="_blank" rel="noopener">匿名请求</a> 或<a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#service-account-tokens" target="_blank" rel="noopener">服务帐户令牌</a>的情况下。</p>
<p>应为节点配置群集的公共根证书，以便它们可以安全地连接到apiserver以及有效的客户端凭据。例如，在默认GKE部署中，提供给kubelet的客户端凭证采用客户端证书的形式。请参阅 <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/" target="_blank" rel="noopener">kubelet TLS bootstrapping</a> 以自动配置kubelet客户端证书。</p>
<p>希望连接到apiserver的Pod可以通过利用服务帐户安全地执行此操作，以便Kubernetes在实例化时自动将公共根证书和有效的承载令牌注入到pod中。该<code>kubernetes</code>服务（在所有名称空间中）配置有虚拟IP地址，该地址被重定向（通过kube-proxy）到apiserver上的HTTPS端点。</p>
<p>主组件还通过安全端口与群集服务器通信。</p>
<p>因此，默认情况下，从群集（节点和节点上运行的节点）到主节点的连接的默认操作模式是安全的，可以在不受信任和/或公共网络上运行。</p>
<h4 id="掌握群集"><a href="#掌握群集" class="headerlink" title="掌握群集"></a>掌握群集</h4><p>从主服务器（apiserver）到集群有两条主要通信路径。第一个是从apiserver到kubelet进程，它在集群中的每个节点上运行。第二种是通过apiserver的代理功能从apiserver到任何节点，pod或服务。</p>
<h5 id="kubelet的保护者"><a href="#kubelet的保护者" class="headerlink" title="kubelet的保护者"></a>kubelet的保护者</h5><p>从apiserver到kubelet的连接用于：</p>
<ul>
<li>获取pod的日志。</li>
<li>附加（通过kubectl）到运行的pod。</li>
<li>提供kubelet的端口转发功能。</li>
</ul>
<p>这些连接终止于kubelet的HTTPS端点。默认情况下，apiserver不会验证kubelet的服务证书，这会使连接受到中间人攻击，并且 <strong>不安全</strong>地运行在不受信任的和/或公共网络上。</p>
<p>要验证此连接，请使用该<code>--kubelet-certificate-authority</code>标志为apiserver提供根证书包，以用于验证kubelet的服务证书。</p>
<p>如果无法做到这一点，请 在apiserver和kubelet之间使用<a href="https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/" target="_blank" rel="noopener">SSH隧道</a>，以避免连接不受信任或公共网络。</p>
<p>最后， 应启用<a href="https://kubernetes.io/docs/admin/kubelet-authentication-authorization/" target="_blank" rel="noopener">Kubelet身份验证和/或授权</a>以保护kubelet API。</p>
<h5 id="节点，pod和服务的apiserver"><a href="#节点，pod和服务的apiserver" class="headerlink" title="节点，pod和服务的apiserver"></a>节点，pod和服务的apiserver</h5><p>从apiserver到节点，pod或服务的连接默认为纯HTTP连接，因此既未经过身份验证也未加密。它们可以通过前缀https:到API URL中的节点，pod或服务名称在安全HTTPS连接上运行，但它们不会验证HTTPS端点提供的证书，也不会提供客户端凭据，因此在连接将被加密时，它不会提供任何诚信保证。这些连接<strong>目前</strong>在不受信任和/或公共网络上运行<strong>是不安全的</strong>。</p>
<h3 id="云控制器管理器的基础概念"><a href="#云控制器管理器的基础概念" class="headerlink" title="云控制器管理器的基础概念"></a>云控制器管理器的基础概念</h3><p>最初创建云控制器管理器（CCM）概念（不要与二进制混淆），以允许特定于云的供应商代码和Kubernetes核心彼此独立地发展。云控制器管理器与其他主组件（如Kubernetes控制器管理器，API服务器和调度程序）一起运行。它也可以作为Kubernetes插件启动，在这种情况下它运行在Kubernetes之上。</p>
<p>云控制器管理器的设计基于一种插件机制，允许新的云提供商通过使用插件轻松地与Kubernetes集成。有计划在Kubernetes上加入新的云提供商，以及将云提供商从旧模型迁移到新的CCM模型。</p>
<p>本文档讨论了云控制器管理器背后的概念，并提供了有关其相关功能的详细信息。</p>
<p>这是没有云控制器管理器的Kubernetes集群的架构：</p>
<p><img src="https://d33wubrfki0l68.cloudfront.net/e298a92e2454520dddefc3b4df28ad68f9b91c6f/70d52/images/docs/pre-ccm-arch.png" alt="image"></p>
<ul>
<li>设计</li>
<li>CCM的组成部分</li>
<li>CCM的功能</li>
<li>插件机制</li>
<li>授权</li>
<li>供应商实施</li>
<li>群集管理</li>
</ul>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>在上图中，Kubernetes和云提供商通过几个不同的组件集成：</p>
<ul>
<li>Kubelet</li>
<li>Kubernetes控制器经理</li>
<li>Kubernetes API服务器</li>
</ul>
<p>CCM整合了前三个组件中的所有依赖于云的逻辑，以创建与云的单一集成点。CCM的新架构如下所示：<br><img src="https://d33wubrfki0l68.cloudfront.net/518e18713c865fe67a5f23fc64260806d72b38f5/61d75/images/docs/post-ccm-arch.png" alt="image"></p>
<h4 id="CCM的组成部分"><a href="#CCM的组成部分" class="headerlink" title="CCM的组成部分"></a>CCM的组成部分</h4><p>CCM打破了Kubernetes控制器管理器（KCM）的一些功能，并将其作为一个单独的进程运行。具体来说，它打破了KCM中依赖于云的控制器。KCM具有以下依赖于云的控制器循环：</p>
<ul>
<li>节点控制器</li>
<li>音量控制器</li>
<li>路线控制器</li>
<li>服务控制器</li>
</ul>
<p>在1.9版中，CCM运行前面列表中的以下控制器：</p>
<ul>
<li>节点控制器</li>
<li>路线控制器</li>
<li>服务控制器</li>
</ul>
<p>此外，它还运行另一个名为PersistentVolumeLabels控制器的控制器。此控制器负责在GCP和AWS云中创建的PersistentVolumes上设置区域和区域标签。</p>
<blockquote>
<p>注意：故意选择音量控制器不属于CCM。由于涉及复杂性并且由于现有的努力抽象出供应商特定的卷逻辑，因此决定不将卷控制器移动到CCM。</p>
</blockquote>
<p>使用CCM支持卷的最初计划是使用Flex卷来支持可插拔卷。然而，正在计划一项名为CSI的竞争性工作来取代Flex。</p>
<p>考虑到这些动态，我们决定在CSI准备好之前进行中间止差测量。</p>
<h4 id="CCM的功能"><a href="#CCM的功能" class="headerlink" title="CCM的功能"></a>CCM的功能</h4><p>CCM从依赖于云提供商的Kubernetes组件继承其功能。本节基于这些组件构建。</p>
<h5 id="1-Kubernetes控制器经理"><a href="#1-Kubernetes控制器经理" class="headerlink" title="1. Kubernetes控制器经理"></a>1. Kubernetes控制器经理</h5><p>CCM的大部分功能来自KCM。如上一节所述，CCM运行以下控制循环：</p>
<ul>
<li>节点控制器</li>
<li>路线控制器</li>
<li>服务控制器</li>
<li>PersistentVolumeLabels控制器</li>
</ul>
<h6 id="节点控制器-1"><a href="#节点控制器-1" class="headerlink" title="节点控制器"></a>节点控制器</h6><p>节点控制器负责通过从云提供商获取有关在集群中运行的节点的信息来初始化节点。节点控制器执行以下功能：</p>
<ol>
<li>使用特定于云的区域/区域标签初始化节点。</li>
<li>使用特定于云的实例详细信息初始化节点，例如，类型和大小。</li>
<li>获取节点的网络地址和主机名。</li>
<li>如果节点无响应，请检查云以查看该节点是否已从云中删除。如果已从云中删除该节点，请删除Kubernetes Node对象。</li>
</ol>
<h6 id="路线控制器"><a href="#路线控制器" class="headerlink" title="路线控制器"></a>路线控制器</h6><p>Route控制器负责适当地配置云中的路由，以便Kubernetes集群中不同节点上的容器可以相互通信。路径控制器仅适用于Google Compute Engine群集。</p>
<h6 id="服务控制器"><a href="#服务控制器" class="headerlink" title="服务控制器"></a>服务控制器</h6><p>服务控制器负责监听服务创建，更新和删除事件。根据Kubernetes中当前的服务状态，它配置云负载均衡器（如ELB或Google LB）以反映Kubernetes中的服务状态。此外，它还确保云负载平衡器的服务后端是最新的。</p>
<h6 id="PersistentVolumeLabels控制器"><a href="#PersistentVolumeLabels控制器" class="headerlink" title="PersistentVolumeLabels控制器"></a>PersistentVolumeLabels控制器</h6><p>PersistentVolumeLabels控制器在创建AWS EBS / GCE PD卷时应用标签。这消除了用户手动设置这些卷上的标签的需要。</p>
<p>这些标签对于pod的计划至关重要，因为这些卷仅限于在它们所在的区域/区域内工作。使用这些卷的任何Pod都需要在同一区域/区域中进行调度。</p>
<p>PersistentVolumeLabels控制器专门为CCM创建; 也就是说，在创建CCM之前它不存在。这样做是为了将Kubernetes API服务器（它是一个许可控制器）中的PV标记逻辑移动到CCM。它不在KCM上运行。</p>
<h5 id="2-Kubelet"><a href="#2-Kubelet" class="headerlink" title="2. Kubelet"></a>2. Kubelet</h5><p>节点控制器包含kubelet的依赖于云的功能。在引入CCM之前，kubelet负责使用特定于云的详细信息（如IP地址，区域/区域标签和实例类型信息）初始化节点。CCM的引入已将此初始化操作从kubelet转移到CCM。</p>
<p>在这个新模型中，kubelet初始化一个没有特定于云的信息的节点。但是，它会为新创建的节点添加污点，使节点不可调度，直到CCM使用特定于云的信息初始化节点。然后它消除了这种污点。</p>
<h5 id="3-Kubernetes-API服务器"><a href="#3-Kubernetes-API服务器" class="headerlink" title="3. Kubernetes API服务器"></a>3. Kubernetes API服务器</h5><p>PersistentVolumeLabels控制器将Kubernetes API服务器的依赖于云的功能移动到CCM，如前面部分所述。</p>
<h4 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h4><p>云控制器管理器使用Go接口允许插入任何云的实现。具体来说，它使用<a href="https://github.com/kubernetes/cloud-provider/blob/9b77dc1c384685cb732b3025ed5689dd597a5971/cloud.go#L42-L62" target="_blank" rel="noopener">此处</a>定义的CloudProvider接口。</p>
<p>上面突出显示的四个共享控制器的实现，以及一些脚手架以及共享的cloudprovider接口，将保留在Kubernetes核心中。特定于云提供商的实现将在核心之外构建，并实现核心中定义的接口。</p>
<p>有关开发插件的更多信息，请参阅<a href="https://kubernetes.io/docs/tasks/administer-cluster/developing-cloud-controller-manager/" target="_blank" rel="noopener">开发Cloud Controller Manager</a>。</p>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>本节分解了CCM执行其操作时各种API对象所需的访问权限。</p>
<h5 id="节点控制器-2"><a href="#节点控制器-2" class="headerlink" title="节点控制器"></a>节点控制器</h5><p>Node控制器仅适用于Node对象。它需要完全访问get，list，create，update，patch，watch和delete Node对象。</p>
<p>V1 /节点：</p>
<ul>
<li>Get</li>
<li>List</li>
<li>Create</li>
<li>Update</li>
<li>Patch</li>
<li>Watch</li>
<li>Delete</li>
</ul>
<h5 id="路线控制器-1"><a href="#路线控制器-1" class="headerlink" title="路线控制器"></a>路线控制器</h5><p>路由控制器侦听Node对象创建并适当地配置路由。它需要访问Node对象。</p>
<p>V1 /节点：</p>
<ul>
<li>Get</li>
</ul>
<h5 id="服务控制器-1"><a href="#服务控制器-1" class="headerlink" title="服务控制器"></a>服务控制器</h5><p>服务控制器侦听Service对象创建，更新和删除事件，然后适当地为这些服务配置端点。</p>
<p>要访问服务，它需要列表和监视访问权限。要更新服务，它需要修补和更新访问权限。</p>
<p>要为服务设置端点，需要访问create，list，get，watch和update。</p>
<p>V1 /服务：</p>
<ul>
<li>List</li>
<li>Get</li>
<li>Watch</li>
<li>Patch</li>
<li>Update</li>
</ul>
<h5 id="PersistentVolumeLabels控制器-1"><a href="#PersistentVolumeLabels控制器-1" class="headerlink" title="PersistentVolumeLabels控制器"></a>PersistentVolumeLabels控制器</h5><p>PersistentVolumeLabels控制器侦听PersistentVolume（PV）创建事件，然后更新它们。该控制器需要访问以获取和更新PV。</p>
<p>V1 / PersistentVolume：</p>
<ul>
<li>Get</li>
<li>List</li>
<li>Watch</li>
<li>Update</li>
</ul>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>CCM核心的实现需要访问以创建事件，并且为了确保安全操作，它需要访问以创建ServiceAccounts。</p>
<p>V1 /事件：</p>
<ul>
<li>Create</li>
<li>Patch</li>
<li>Update</li>
</ul>
<p>V1 / ServiceAccount：</p>
<ul>
<li>Create</li>
</ul>
<p>CCM的RBAC ClusterRole如下所示：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: cloud-controller-manager</span><br><span class="line">rules:</span><br><span class="line">-<span class="ruby"> <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - events</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - create</span></span><br><span class="line"><span class="ruby">  - patch</span></span><br><span class="line"><span class="ruby">  - update</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - nodes</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">'*'</span></span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - nodes/status</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - patch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - services</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - patch</span></span><br><span class="line"><span class="ruby">  - update</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - serviceaccounts</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - create</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - persistentvolumes</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - update</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">- <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - endpoints</span></span><br><span class="line"><span class="ruby">  <span class="symbol">verbs:</span></span></span><br><span class="line"><span class="ruby">  - create</span></span><br><span class="line"><span class="ruby">  - get</span></span><br><span class="line"><span class="ruby">  - list</span></span><br><span class="line"><span class="ruby">  - watch</span></span><br><span class="line"><span class="ruby">  - update</span></span><br></pre></td></tr></table></figure></p>
<h4 id="供应商实施"><a href="#供应商实施" class="headerlink" title="供应商实施"></a>供应商实施</h4><p>以下云提供商已实施CCM：</p>
<ul>
<li><a href="https://github.com/digitalocean/digitalocean-cloud-controller-manager" target="_blank" rel="noopener">Digital Ocean</a></li>
<li><a href="https://github.com/oracle/oci-cloud-controller-manager" target="_blank" rel="noopener">Oracle</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/tree/master/pkg/cloudprovider/providers/azure" target="_blank" rel="noopener">Azure</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/tree/master/pkg/cloudprovider/providers/gce" target="_blank" rel="noopener">GCE</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/tree/master/pkg/cloudprovider/providers/aws" target="_blank" rel="noopener">AWS</a></li>
</ul>
<h4 id="群集管理"><a href="#群集管理" class="headerlink" title="群集管理"></a>群集管理</h4><p><a href="https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager" target="_blank" rel="noopener">此处</a>提供了有关配置和运行CCM的完整说明 </p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>您创建Docker镜像并将其推送到仓库，然后在Kubernetes的pod中引用它。</p>
<p><code>image</code>容器的属性支持与<code>docker</code>命令相同的语法，包括私有仓库和标记。</p>
<ul>
<li>更新镜像</li>
<li>用清单构建多架构镜像</li>
<li>使用私人仓库</li>
</ul>
<h4 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h4><p>默认拉取策略<code>IfNotPresent</code>会导致Kubelet跳过拉动镜像（如果已存在）。如果您想总是强制Docker拉动，可以执行以下操作之一：</p>
<ul>
<li>将<code>imagePullPolicy</code>容器设置为Always。</li>
<li>省略<code>imagePullPolicy</code>并使用它<code>:latest</code>作为要使用的镜像的标记。</li>
<li>省略<code>imagePullPolicy</code>要使用的镜像和标记。</li>
<li>启用<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages" target="_blank" rel="noopener">AlwaysPullImages</a>准入控制器。</li>
</ul>
<p>请注意，您应该避免使用<code>:latest</code>标记，有关详细信息，请<a href="https://kubernetes.io/docs/concepts/configuration/overview/#container-images" target="_blank" rel="noopener">参阅配置的最佳实践</a>。</p>
<h4 id="用清单构建多架构图像"><a href="#用清单构建多架构图像" class="headerlink" title="用清单构建多架构图像"></a>用清单构建多架构图像</h4><p>Docker CLI现在支持以下命令<code>docker manifest</code>中包含的子命令<code>create</code>，<code>annotate</code>并<code>push</code>。这些命令可用于构建和推送清单。您可以使用<code>docker manifest inspect</code>查看清单。</p>
<p>请在此处查看<a href="https://docs.docker.com/edge/engine/reference/commandline/manifest/" target="_blank" rel="noopener">docker文档</a>，<br>请参阅我们在构建工具中如何使用它的<a href="https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate" target="_blank" rel="noopener">示例</a>&amp;i=nope&amp;files=&amp;repos=)。</p>
<p>这些命令完全依赖于Docker CLI，并且完全在Docker CLI上实现。您需要编辑<code>$HOME/.docker/config.json</code>和设置<code>experimental</code>密钥，<code>enabled</code>或者只需在调用CLI命令时将<code>DOCKER_CLI_EXPERIMENTAL</code>环境变量设置为<code>enabled</code>。</p>
<blockquote>
<p>注意：请使用Docker 18.06或更高版本，以下版本有错误或不支持实验命令行选项。<a href="https://github.com/docker/cli/issues/1135" target="_blank" rel="noopener">示例</a>会在containerd下导致问题。</p>
</blockquote>
<p>如果您在上传陈旧的清单时遇到问题，只需清理旧的清单<code>$HOME/.docker/manifests</code>即可重新开始。</p>
<p>对于Kubernetes，我们通常使用带后缀的镜像<code>-$(ARCH)</code>。为了向后兼容，请生成带有后缀的旧镜像。我们的想法是生成<code>pause</code>具有所有拱形清单的说明镜像，并说出<code>pause-amd64</code>哪些向后兼容旧配置或YAML文件，这些文件可能硬编码带有后缀的镜像。</p>
<h4 id="使用私人仓库"><a href="#使用私人仓库" class="headerlink" title="使用私人仓库"></a>使用私人仓库</h4><p>私人仓库管理可能需要密钥才能从中读取图像。凭证可以通过多种方式提供：</p>
<ul>
<li>使用Google Container Registry<ul>
<li>Per-cluster</li>
<li>在Google Compute Engine或Google Kubernetes Engine上自动配置</li>
<li>所有pod都可以读取项目的私有仓库</li>
</ul>
</li>
<li>使用AWS EC2容器仓库（ECR）<ul>
<li>使用IAM角色和策略来控制对ECR存储库的访问</li>
<li>自动刷新ECR登录凭据</li>
</ul>
</li>
<li>使用Azure容器仓库（ACR）</li>
<li>使用IBM Cloud Container Registry</li>
<li>配置节点以验证私有仓库<ul>
<li>所有pod都可以读取任何已配置的私有仓库</li>
<li>需要集群管理员进行节点配置</li>
</ul>
</li>
<li>预拉镜像<ul>
<li>所有pod都可以使用节点上缓存的任何镜像</li>
<li>需要root权限才能设置所有节点</li>
</ul>
</li>
<li>在Pod上指定ImagePullSecrets<ul>
<li>只有提供自己密钥的pod才能访问私有仓库</li>
</ul>
</li>
</ul>
<p>下面更详细地描述每个选项。</p>
<h5 id="使用Google-Container-Registry"><a href="#使用Google-Container-Registry" class="headerlink" title="使用Google Container Registry"></a>使用Google Container Registry</h5><p>在Google Compute Engine（GCE）上运行时，Kubernetes对<a href="https://cloud.google.com/tools/container-registry/" target="_blank" rel="noopener">Google Container Registry（GCR）</a>提供原生支持。如果您在GCE或Google Kubernetes Engine上运行群集，只需使用完整的镜像名称（例如gcr.io/my_project/image：tag）。</p>
<p>群集中的所有pod都具有此仓库中镜像的读取权限。</p>
<p>kubelet将使用实例的Google服务帐户向GCR进行身份验证。实例上的服务帐户将具有一个 <code>https://www.googleapis.com/auth/devstorage.read_only</code>，因此它可以从项目的GCR中提取，但不能推送。</p>
<h5 id="使用AWS-EC2-Container-Registry"><a href="#使用AWS-EC2-Container-Registry" class="headerlink" title="使用AWS EC2 Container Registry"></a>使用AWS EC2 Container Registry</h5><p>当节点是AWS EC2实例时，Kubernetes对<a href="https://aws.amazon.com/ecr/" target="_blank" rel="noopener">AWS EC2 Container Registry</a>具有本机支持。</p>
<p>只需<code>ACCOUNT.dkr.ecr.REGION.amazonaws.com/imagename:tag</code>在Pod定义中使用完整的图像名称（例如）。</p>
<p>可以创建pod的群集的所有用户都可以运行使用ECR仓库中任何镜像的pod。</p>
<p>kubelet将获取并定期刷新ECR凭据。它需要以下权限才能执行此操作：</p>
<ul>
<li>ecr:GetAuthorizationToken</li>
<li>ecr:BatchCheckLayerAvailability</li>
<li>ecr:GetDownloadUrlForLayer</li>
<li>ecr:GetRepositoryPolicy</li>
<li>ecr:DescribeRepositories</li>
<li>ecr:ListImages</li>
<li>ecr:BatchGetImage</li>
</ul>
<p>要求：</p>
<ul>
<li>您必须使用kubelet版本<code>v1.2.0</code>或更新版本。（例如run <code>/usr/bin/kubelet --version=true</code>）。</li>
<li>如果您的节点位于区域A中且您的注册表位于不同的区域B中，则需要<code>v1.3.0</code>更新版本或更新版本。</li>
<li>ECR必须在您所在的地区提供</li>
</ul>
<p>故障排除：</p>
<ul>
<li>验证上述所有要求。</li>
<li><code>us-west-2</code>在工作站上获取$ REGION（例如）凭据。SSH进入主机并使用这些信用卡手动运行Docker。它有用吗？</li>
<li>验证kubelet是否正在运行<code>--cloud-provider=aws</code>。</li>
<li>检查kubelet日志（例如<code>journalctl -u kubelet</code>）以获取日志行，例如：<ul>
<li><code>plugins.go:56] Registering credential provider: aws-ecr-key</code></li>
<li><code>provider.go:91] Refreshing cache for provider: *aws_credentials.ecrProvider</code></li>
</ul>
</li>
</ul>
<h5 id="使用Azure容器仓库（ACR）"><a href="#使用Azure容器仓库（ACR）" class="headerlink" title="使用Azure容器仓库（ACR）"></a>使用Azure容器仓库（ACR）</h5><p>使用<a href="https://azure.microsoft.com/en-us/services/container-registry/" target="_blank" rel="noopener">Azure容器仓库</a>时， 您可以使用管理员用户或服务主体进行身份验证。在任何一种情况下，身份验证都通过标准Docker身份验证完成 这些说明假定使用 <a href="https://github.com/azure/azure-cli" target="_blank" rel="noopener">azure-cli</a>命令行工具。</p>
<p>您首先需要创建一个仓库并生成凭据，完整的文档可以在<a href="https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-azure-cli" target="_blank" rel="noopener">Azure容器仓库文档</a>中找到。</p>
<p>创建容器仓库后，您将使用以下凭据登录：</p>
<ul>
<li><code>DOCKER_USER</code> ：服务主体或管理员用户名</li>
<li><code>DOCKER_PASSWORD</code>：服务主体密码或管理员用户密码</li>
<li><code>DOCKER_REGISTRY_SERVER</code>： <code>${some-registry-name}.azurecr.io</code></li>
<li><code>DOCKER_EMAIL</code>：<code>${some-email-address}</code></li>
</ul>
<p>填好这些变量后，您可以<a href="https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod" target="_blank" rel="noopener">配置Kubernetes Secret并使用它来部署Pod</a>。</p>
<h5 id="使用IBM-Cloud-Container-Registry"><a href="#使用IBM-Cloud-Container-Registry" class="headerlink" title="使用IBM Cloud Container Registry"></a>使用IBM Cloud Container Registry</h5><p>IBM Cloud Container Registry提供了一个多租户私有镜像仓库，您可以使用它来安全地存储和共享Docker镜像。默认情况下，集成的漏洞顾问会扫描私有仓库中的镜像，以检测安全问题和潜在漏洞。IBM Cloud帐户中的用户可以访问您的镜像，也可以创建令牌以授予对仓库命名空间的访问权限。</p>
<p>要安装IBM Cloud Container Registry CLI插件并为镜像创建命名空间，请参阅<a href="https://console.bluemix.net/docs/services/Registry/index.html#index" target="_blank" rel="noopener">IBM Cloud Container Registry入门</a>。</p>
<p>您可以使用IBM Cloud Container Registry将容器从<a href="https://console.bluemix.net/docs/services/RegistryImages/index.html#ibm_images" target="_blank" rel="noopener">IBM Cloud公共镜像</a>和私有镜像部署到<code>default</code>IBM Cloud Kubernetes Service集群的命名空间中。要将容器部署到其他名称空间，或使用来自其他IBM Cloud Container Registry区域或IBM Cloud帐户的镜像，请创建Kubernetes <code>imagePullSecret</code>。有关更多信息，请参阅<a href="https://console.bluemix.net/docs/containers/cs_images.html#images" target="_blank" rel="noopener">从镜像构建容器</a>。</p>
<h5 id="配置节点以验证私有仓库"><a href="#配置节点以验证私有仓库" class="headerlink" title="配置节点以验证私有仓库"></a>配置节点以验证私有仓库</h5><blockquote>
<p>注意：如果您在Google Kubernetes Engine上运行，则<code>.dockercfg</code>每个节点上都会有一个包含Google Container Registry凭据的节点。你不能使用这种方法。</p>
</blockquote>
<blockquote>
<p>注意：如果您在AWS EC2上运行并且正在使用EC2容器仓库（ECR），则每个节点上的kubelet将管理和更新ECR登录凭据。你不能使用这种方法</p>
</blockquote>
<blockquote>
<p>注意：如果您可以控制节点配置，则此方法是合适的。它不能可靠地在GCE和任何其他进行自动节点替换的云提供商上运行。</p>
</blockquote>
<p>Docker将私有仓库的密钥存储在<code>$HOME/.dockercfg</code>或<code>$HOME/.docker/config.json</code>文件中。如果您将相同的文件放在下面的搜索路径列表中，则kubelet会在拉取镜像时将其用作凭据提供程序。</p>
<ul>
<li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li>
<li><code>{cwd of kubelet}/config.json</code></li>
<li><code>${HOME}/.docker/config.json</code></li>
<li><code>/.docker/config.json</code></li>
<li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li>
<li><code>{cwd of kubelet}/.dockercfg</code></li>
<li><code>${HOME}/.dockercfg</code></li>
<li><code>/.dockercfg</code></li>
</ul>
<blockquote>
<p>注意：您可能必须<code>HOME=/root</code>在环境文件中明确设置kubelet。</p>
</blockquote>
<p>以下是配置节点以使用私有仓库的建议步骤。在此示例中，在桌面/笔记本电脑上运行这些：</p>
<ol>
<li><code>docker login [server]</code>针对要使用的每组凭据运行。这更新<code>$HOME/.docker/config.json</code>。</li>
<li><code>$HOME/.docker/config.json</code>在编辑器中查看以确保它仅包含您要使用的凭据。</li>
<li>获取节点列表，例如：</li>
</ol>
<ul>
<li>如果你想要这些名字： <code>nodes=$(kubectl get nodes -o jsonpath=&#39;{range.items[*].metadata}{.name} {end}&#39;)</code></li>
<li>如果你想获得IP： <code>nodes=$(kubectl get nodes -o jsonpath=&#39;{range .items[*].status.addresses[?(@.type==&quot;ExternalIP&quot;)]}{.address} {end}&#39;)</code></li>
</ul>
<ol start="4">
<li>将本地复制<code>.docker/config.json</code>到上面的搜索路径列表之一。</li>
</ol>
<ul>
<li>例如： <code>for n in $nodes; do scp ~/.docker/config.json root@$n:/var/lib/kubelet/config.json; done</code></li>
</ul>
<p>通过创建使用私有镜像的pod进行验证，例如：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f - &lt;&lt;EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  <span class="built_in">name</span>: <span class="built_in">private</span>-<span class="built_in">image</span>-test-<span class="number">1</span></span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - <span class="built_in">name</span>: uses-<span class="built_in">private</span>-<span class="built_in">image</span></span><br><span class="line">      <span class="built_in">image</span>: $PRIVATE_IMAGE_NAME</span><br><span class="line">      imagePullPolicy: Always</span><br><span class="line">      command: [ <span class="string">"echo"</span>, <span class="string">"SUCCESS"</span> ]</span><br><span class="line">EOF</span><br><span class="line">pod/<span class="built_in">private</span>-<span class="built_in">image</span>-test-<span class="number">1</span> created</span><br></pre></td></tr></table></figure></p>
<p>如果一切正常，那么过了一会儿，你应该看到：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs <span class="keyword">private</span>-<span class="built_in">image</span>-test<span class="number">-1</span></span><br><span class="line">SUCCESS</span><br></pre></td></tr></table></figure></p>
<p>如果失败了，那么你会看到：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">describe</span> pods/<span class="keyword">private</span>-image-<span class="keyword">test</span><span class="number">-1</span> | grep <span class="string">"Failed"</span></span><br><span class="line">  Fri, <span class="number">26</span> Jun <span class="number">2015</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">13</span> <span class="number">-0700</span>    Fri, <span class="number">26</span> Jun <span class="number">2015</span> <span class="number">15</span>:<span class="number">39</span>:<span class="number">13</span> <span class="number">-0700</span>    <span class="number">19</span>    &#123;kubelet node-i2hq&#125;    spec.containers&#123;uses-<span class="keyword">private</span>-image&#125;    <span class="keyword">failed</span>        <span class="keyword">Failed</span> <span class="keyword">to</span> pull image <span class="string">"user/privaterepo:v1"</span>: <span class="keyword">Error</span>: image <span class="keyword">user</span>/privaterepo:v1 <span class="keyword">not</span> <span class="keyword">found</span></span><br></pre></td></tr></table></figure></p>
<p>您必须确保群集中的所有节点都具有相同的节点<code>.docker/config.json</code>。否则，pod将在某些节点上运行，而无法在其他节点上运行。例如，如果使用节点自动缩放，则每个实例模板都需要包含<code>.docker/config.json</code>或装载包含它的驱动器。</p>
<p>将私有仓库项添加到任何私有仓库中后，所有pod都将具有对镜像的读访问权限<code>.docker/config.json</code>。</p>
<h5 id="预拉图像"><a href="#预拉图像" class="headerlink" title="预拉图像"></a>预拉图像</h5><blockquote>
<p>注意：如果您在Google Kubernetes Engine上运行，则.dockercfg每个节点上都会有一个包含Google Container Registry凭据的节点。你不能使用这种方法。</p>
</blockquote>
<blockquote>
<p>注意：如果您可以控制节点配置，则此方法是合适的。它不能可靠地在GCE和任何其他进行自动节点替换的云提供商上运行。</p>
</blockquote>
<p>默认情况下，kubelet将尝试从指定的仓库中提取每个镜像。但是，如果<code>imagePullPolicy</code>容器的属性设置为<code>IfNotPresent</code>或<code>Never</code>，则使用本地镜像（分别优先或排他）。</p>
<p>如果您希望依赖预先提取的镜像作为仓库身份验证的替代，则必须确保群集中的所有节点都具有相同的预拉镜像。</p>
<p>这可以用于预加载某些镜像以提高速度，或者作为对私有仓库进行身份验证的替代方法。</p>
<p>所有pod都可以读取任何预拉镜像。</p>
<h5 id="在Pod上指定ImagePullSecrets"><a href="#在Pod上指定ImagePullSecrets" class="headerlink" title="在Pod上指定ImagePullSecrets"></a>在Pod上指定ImagePullSecrets</h5><blockquote>
<p>注意：此方法目前是Google Kubernetes Engine，GCE以及自动创建节点的任何云提供商的推荐方法。</p>
</blockquote>
<p>Kubernetes支持在pod上指定仓库项。</p>
<h5 id="使用Docker配置创建机密"><a href="#使用Docker配置创建机密" class="headerlink" title="使用Docker配置创建机密"></a>使用Docker配置创建机密</h5><p>运行以下命令，替换相应的大写值：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create<span class="built_in"> secret </span>docker-registry myregistrykey <span class="attribute">--docker-server</span>=DOCKER_REGISTRY_SERVER <span class="attribute">--docker-username</span>=DOCKER_USER <span class="attribute">--docker-password</span>=DOCKER_PASSWORD <span class="attribute">--docker-email</span>=DOCKER_EMAIL</span><br><span class="line">secret/myregistrykey created.</span><br></pre></td></tr></table></figure></p>
<p>如果需要访问多个仓库，则可以为每个仓库创建一个秘密。 在为Pods提取镜像时，Kubelet会将任何内容合并<code>imagePullSecrets</code>为一个虚拟内容<code>.docker/config.json</code>。</p>
<p>Pod只能在自己的命名空间中引用镜像拉取秘密，因此每个命名空间需要执行一次此过程。</p>
<h6 id="绕过kubectl会产生秘密"><a href="#绕过kubectl会产生秘密" class="headerlink" title="绕过kubectl会产生秘密"></a>绕过kubectl会产生秘密</h6><p>如果由于某种原因，您需要单个项目中的多个项目<code>.docker/config.json</code>或需要上述命令未给出的控制，那么您可以<a href="https://kubernetes.io/docs/user-guide/secrets/#creating-a-secret-manually" target="_blank" rel="noopener">使用json或yaml创建一个秘密</a>。</p>
<p>务必：</p>
<ul>
<li>设置数据项的名称 <code>.dockerconfigjson</code></li>
<li>base64编码docker文件并粘贴该字符串，不间断作为字段的值 <code>data[&quot;.dockerconfigjson&quot;]</code></li>
<li>设置<code>type</code>为<code>kubernetes.io/dockerconfigjson</code></li>
</ul>
<p>例：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: myregistrykey</span><br><span class="line">  namespace: awesomeapps</span><br><span class="line">data:</span><br><span class="line">  .dockerconfigjson: <span class="attribute">UmVhbGx5IHJlYWxseSByZWVlZWVlZWVlZWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGx5eXl5eXl5eXl5eXl5eXl5eXl5eSBsbGxsbGxsbGxsbGxsbG9vb29vb29vb29vb29vb29vb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg</span>==</span><br><span class="line">type: kubernetes.io/dockerconfigjson</span><br></pre></td></tr></table></figure></p>
<p>如果收到错误消息<code>error: no objects passed to create</code>，则可能表示base64编码的字符串无效。如果收到类似的错误消息<code>Secret &quot;myregistrykey&quot; is invalid: data[.dockerconfigjson]: invalid value ...</code>，则表示数据已成功取消base64编码，但无法解析为<code>.docker/config.json</code>文件。</p>
<h5 id="参考Pod上的imagePullSecrets"><a href="#参考Pod上的imagePullSecrets" class="headerlink" title="参考Pod上的imagePullSecrets"></a>参考Pod上的imagePullSecrets</h5><p>现在，您可以通过向<code>imagePullSecrets</code> pod定义添加一个部分来创建引用该秘密的pod。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: v1</span><br><span class="line"><span class="attribute">kind</span>: Pod</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">name</span>: foo</span><br><span class="line">  <span class="attribute">namespace</span>: awesomeapps</span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">containers</span>:</span><br><span class="line">    - <span class="attribute">name</span>: foo</span><br><span class="line">      <span class="attribute">image</span>: janedoe/<span class="attribute">awesomeapp</span>:v1</span><br><span class="line">  <span class="attribute">imagePullSecrets</span>:</span><br><span class="line">    - <span class="attribute">name</span>: myregistrykey</span><br></pre></td></tr></table></figure></p>
<p>需要对使用私有仓库的每个pod执行此操作。</p>
<p>但是，可以通过在<a href="https://kubernetes.io/docs/user-guide/service-accounts" target="_blank" rel="noopener">serviceAccount</a>资源中设置imagePullSecrets来自动设置此字段。检查将<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account" target="_blank" rel="noopener">ImagePullSecrets添加到服务帐户</a>以获取详细说明。</p>
<p>您可以将其与每个节点结合使用<code>.docker/config.json</code>。凭证将被合并。这种方法适用于Google Kubernetes Engine。</p>
<h6 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h6><p>有许多配置私有仓库的解决方案。以下是一些常见用例和建议的解决方案。</p>
<ol>
<li>群集仅运行非专有（例如开源）镜像。无需隐藏镜像。</li>
</ol>
<ul>
<li>在Docker hub上使用公共镜像。<ul>
<li>无需配置。</li>
<li>在GCE / Google Kubernetes Engine上，自动使用本地镜像来提高速度和可用性。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>群集运行一些专有镜像，这些镜像像应隐藏给公司外部的人员，但对所有群集用户可见。</li>
</ol>
<ul>
<li>使用托管的私有<a href="https://docs.docker.com/registry/" target="_blank" rel="noopener">Docker仓库</a>。<ul>
<li>它可能托管在<a href="https://hub.docker.com/signup" target="_blank" rel="noopener">Docker Hub</a>或其他地方。</li>
<li>如上所述，在每个节点上手动配置<code>.docker / config.json</code>。</li>
</ul>
</li>
<li>或者，使用开放读取访问权限在防火墙后面运行内部私有仓库。<ul>
<li>不需要Kubernetes配置。</li>
</ul>
</li>
<li>或者，在使用GCE / Google Kubernetes Engine时，请使用该项目的Google Container Registry。<ul>
<li>与集群自动调节相比，它可以比手动节点配置更好地工作。</li>
</ul>
</li>
<li>或者，在更改节点配置不方便的群集上，请使用<code>imagePullSecrets</code>。</li>
</ul>
<ol start="3">
<li>具有专有镜像的集群，其中一些需要更严格的访问控制。</li>
</ol>
<ul>
<li>确保<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages" target="_blank" rel="noopener">AlwaysPullImages准入控制器</a>处于活动状态。否则，所有Pod都可能访问所有镜像。</li>
<li>将敏感数据移动到“秘密”资源中，而不是将其打包在镜像中。</li>
</ul>
<ol start="4">
<li>一个多租户群集，每个租户都需要拥有私有仓库。</li>
</ol>
<ul>
<li>确<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages" target="_blank" rel="noopener">保AlwaysPullImages准入控制器</a>处于活动状态。否则，所有租户的所有Pod都可能访问所有图像。</li>
<li>运行需要授权的私有仓库。</li>
<li>为每个租户生成仓库凭据，保密，并为每个租户命名空间填充机密。</li>
<li>租户将这个秘密添加到每个命名空间的imagePullSecrets。</li>
</ul>
<h3 id="容器环境变量"><a href="#容器环境变量" class="headerlink" title="容器环境变量"></a>容器环境变量</h3><p>此页面描述Container环境中Container可用的资源。</p>
<h4 id="容器环境"><a href="#容器环境" class="headerlink" title="容器环境"></a>容器环境</h4><p>Kubernetes Container环境为容器提供了几个重要资源：</p>
<ul>
<li>文件系统，是镜像和一个或多个卷的组合。</li>
<li>有关Container本身的信息。</li>
<li>有关群集中其他对象的信息。</li>
</ul>
<h5 id="容器信息"><a href="#容器信息" class="headerlink" title="容器信息"></a>容器信息</h5><p>Container 的主机名是运行Container的Pod的名称。它可以通过 libc中的<code>hostname</code>命令或 <a href="http://man7.org/linux/man-pages/man2/gethostname.2.html" target="_blank" rel="noopener"><code>gethostname</code></a>函数调用获得。</p>
<p>Pod名称和命名空间可通过<a href="https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/" target="_blank" rel="noopener">向下API</a>作为环境变量使用 。</p>
<p>Pod定义中的用户定义环境变量也可用于Container，Docker镜像中静态指定的任何环境变量也是如此。</p>
<h5 id="群集信息"><a href="#群集信息" class="headerlink" title="群集信息"></a>群集信息</h5><p>创建Container时运行的所有服务的列表可作为环境变量用于该Container。这些环境变量与Docker链接的语法相匹配。</p>
<p>对于名为foo的映射到名为bar的Container 的服务，定义了以下变量：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">FOO_SERVICE_HOST</span>=&lt;the host the<span class="built_in"> service </span>is running on&gt;</span><br><span class="line"><span class="attribute">FOO_SERVICE_PORT</span>=&lt;the<span class="built_in"> port </span>the<span class="built_in"> service </span>is running on&gt;</span><br></pre></td></tr></table></figure></p>
<p>服务具有专用IP地址，如果启用了<a href="http://releases.k8s.io/master/cluster/addons/dns/" target="_blank" rel="noopener">DNS插件</a>，则可通过DNS使用Container 。 </p>
<h3 id="运行时类"><a href="#运行时类" class="headerlink" title="运行时类"></a>运行时类</h3><p>特征状态： Kubernetes v1.12<br>该页面描述了RuntimeClass资源和运行时选择机制。</p>
<blockquote>
<p>此功能目前处于alpha状态，意思是：<br>版本名称包含alpha（例如v1alpha1）。<br>可能是马车。启用该功能可能会暴露错误。默认情况下禁用。<br>可随时删除对功能的支持，恕不另行通知。<br>API可能会在以后的软件版本中以不兼容的方式更改，恕不另行通知。<br>由于错误风险增加和缺乏长期支持，建议仅在短期测试集群中使用。</p>
</blockquote>
<h4 id="运行时类-1"><a href="#运行时类-1" class="headerlink" title="运行时类"></a>运行时类</h4><p>RuntimeClass是一个alpha功能，用于选择用于运行pod容器的容器运行时配置。</p>
<h5 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h5><p>作为早期的alpha功能，必须采取一些额外的设置步骤才能使用RuntimeClass功能：</p>
<ol>
<li>启用RuntimeClass功能门（在apiservers＆kubelets上，需要1.12+版本）</li>
<li>安装RuntimeClass CRD</li>
<li>在节点上配置CRI实现（取决于运行时）</li>
<li>创建相应的RuntimeClass资源</li>
</ol>
<h5 id="1-启用RuntimeClass-feature-gate"><a href="#1-启用RuntimeClass-feature-gate" class="headerlink" title="1.启用RuntimeClass feature gate"></a>1.启用RuntimeClass feature gate</h5><p>有关启用feature gates的说明，请参见<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/" target="_blank" rel="noopener">feature gates</a>。必须在apiservers和kubelet上启用<code>RuntimeClass</code>功能门。</p>
<h5 id="2-安装RuntimeClass-CRD"><a href="#2-安装RuntimeClass-CRD" class="headerlink" title="2.安装RuntimeClass CRD"></a>2.安装RuntimeClass CRD</h5><p>RuntimeClass <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/" target="_blank" rel="noopener">CustomResourceDefinition</a>（CRD）可以在Kubernetes git repo的addons目录中找到：<code>kubernetes / cluster / addons / runtimeclass / runtimeclass_crd.yaml</code></p>
<p>安装CRD <code>kubectl apply -f runtimeclass_crd.yaml</code>。</p>
<h5 id="3-在节点上配置CRI实现"><a href="#3-在节点上配置CRI实现" class="headerlink" title="3.在节点上配置CRI实现"></a>3.在节点上配置CRI实现</h5><p>使用RuntimeClass进行选择的配置取决于CRI实现。有关如何配置的信息，请参阅CRI实现的相应文档。由于这是一个alpha功能，并非所有CRI都支持多个RuntimeClasses。</p>
<blockquote>
<p>注意： RuntimeClass当前假定整个集群中的同类节点配置（这意味着所有节点的配置方式与容器运行时相同）。任何异构性（变化的配置）必须通过调度功能独立于RuntimeClass进行管理（请参阅<a href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/" target="_blank" rel="noopener">将Pod分配给节点</a>）。</p>
</blockquote>
<p>配置具有相应的<code>RuntimeHandler</code>名称，由RuntimeClass引用。RuntimeHandler必须是有效的DNS 1123子域（字母数字<code>+</code> <code>-</code>和<code>.</code>字符）。</p>
<h5 id="4-创建相应的RuntimeClass资源"><a href="#4-创建相应的RuntimeClass资源" class="headerlink" title="4.创建相应的RuntimeClass资源"></a>4.创建相应的RuntimeClass资源</h5><p>步骤3中的配置设置应各自具有关联的<code>RuntimeHandler</code>名称，用于标识配置。对于每个RuntimeHandler（以及可选的空””处理程序），创建相应的RuntimeClass对象。</p>
<p>RuntimeClass资源当前只有2个重要字段：RuntimeClass name（<code>metadata.name</code>）和RuntimeHandler（<code>spec.runtimeHandler</code>）。对象定义如下所示：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: node.k8s.io/v1alpha1  # RuntimeClass is defined <span class="keyword">in</span> the node.k8s.io API group</span><br><span class="line">kind: RuntimeClass</span><br><span class="line">metadata:</span><br><span class="line">  name: myclass  # The name the RuntimeClass will be referenced by</span><br><span class="line">  # RuntimeClass is a non-namespaced resource</span><br><span class="line">spec:</span><br><span class="line">  runtimeHandler: myconfiguration  # The name of the corresponding CRI configuration</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：建议将RuntimeClass写入操作（create / update / patch / delete）限制为群集管理员。这通常是默认值。有关详细信息，请参阅<a href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/" target="_blank" rel="noopener">授权概述</a>。</p>
</blockquote>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p>为集群配置RuntimeClasses后，使用它们非常简单。runtimeClassName在Pod规范中指定a 。例如：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">apiVersion:</span> v1</span><br><span class="line"><span class="symbol">kind:</span> Pod</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  name:</span> mypod</span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  runtimeClassName:</span> myclass</span><br><span class="line">  <span class="meta"># ...</span></span><br></pre></td></tr></table></figure></p>
<p>这将指示Kubelet使用命名的RuntimeClass来运行此pod。如果命名的RuntimeClass不存在，或者CRI无法运行相应的处理程序，则pod将进入 <code>Failed</code>终端<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase" target="_blank" rel="noopener">阶段</a>。查找错误消息的相应<a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-application-introspection/" target="_blank" rel="noopener">事件</a>。</p>
<p>如果未<code>runtimeClassName</code>指定，则将使用默认的RuntimeHandler，这相当于禁用RuntimeClass功能时的行为。</p>
<h3 id="容器生命周期钩子"><a href="#容器生命周期钩子" class="headerlink" title="容器生命周期钩子"></a>容器生命周期钩子</h3><p>此页面描述了kubelet管理的容器如何使用Container生命周期钩子框架来运行在管理生命周期中由事件触发的代码。</p>
<ul>
<li>概观</li>
<li>集装箱挂钩</li>
</ul>
<h4 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h4><p>类似于许多具有组件生命周期钩子的编程语言框架，例如Angular，Kubernetes为Containers提供了生命周期钩子。钩子使Container能够了解其管理生命周期中的事件，并在执行相应的生命周期钩子时运行在处理程序中实现的代码。</p>
<h4 id="容器钩子"><a href="#容器钩子" class="headerlink" title="容器钩子"></a>容器钩子</h4><p>有两个暴露给容器的钩子：</p>
<p><code>PostStart</code></p>
<p>在创建容器后立即执行此挂钩。但是，无法保证挂钩将在容器ENTRYPOINT之前执行。没有参数传递给处理程序。</p>
<p><code>PreStop</code></p>
<p>在容器终止之前立即调用此挂钩。它是阻塞的，意味着它是同步的，所以它必须在删除容器的调用之前完成。没有参数传递给处理程序。</p>
<p>终止行为的更详细描述可以在<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods" target="_blank" rel="noopener">终端中</a>找到 。</p>
<h5 id="钩子处理程序实现"><a href="#钩子处理程序实现" class="headerlink" title="钩子处理程序实现"></a>钩子处理程序实现</h5><p>容器可以通过实现和注册该钩子的处理程序来访问钩子。可以为Container实现两种类型的钩子处理程序：</p>
<ul>
<li>Exec - 执行特定命令，例如<code>pre-stop.sh</code>，在Container的cgroups和名称空间内。命令消耗的资源将根据Container计算。</li>
<li>HTTP - 对Container上的特定端点执行HTTP请求。</li>
</ul>
<h5 id="钩子处理程序执行"><a href="#钩子处理程序执行" class="headerlink" title="钩子处理程序执行"></a>钩子处理程序执行</h5><p>调用Container生命周期管理挂钩时，Kubernetes管理系统会在为该挂钩注册的Container中执行处理程序。 </p>
<p>钩子处理程序调用在包含Container的Pod的上下文中是同步的。这意味着对于一个<code>PostStart</code>钩子，Container ENTRYPOINT和钩子异步发射。但是，如果挂钩运行或挂起太长时间，则Container无法达到某种<code>running</code>状态。</p>
<p><code>PreStop</code>钩子的行为类似。如果钩子在执行期间挂起，则Pod阶段将保持<code>Terminating</code>状态并在<code>terminationGracePeriodSecondspod</code>结束后被杀死。如果一个 <code>PostStart</code>或<code>PreStophook</code>失败，则会终止Container。</p>
<p>用户应使其钩子处理程序尽可能轻量级。但是，有些情况下，长时间运行的命令是有意义的，例如在停止Container之前保存状态。</p>
<h5 id="挂钩送货保证"><a href="#挂钩送货保证" class="headerlink" title="挂钩送货保证"></a>挂钩送货保证</h5><p>钩子传递至少是一次，这意味着可以为任何给定事件多次调用钩子，例如for <code>PostStart</code>或<code>PreStop</code>。由钩子实现来正确处理这个问题。</p>
<p>通常，只进行单次交付。例如，如果HTTP挂钩接收器关闭且无法获取流量，则不会尝试重新发送。然而，在一些罕见的情况下，可能会发生双重递送。例如，如果一个kubelet在发送一个钩子的过程中重新启动，那么在该kubelet重新启动后可能会重新发送一个钩子。</p>
<h5 id="调试Hook处理程序"><a href="#调试Hook处理程序" class="headerlink" title="调试Hook处理程序"></a>调试Hook处理程序</h5><p>在Pod事件中不公开Hook处理程序的日志。如果处理程序由于某种原因失败，它会广播一个事件。因为<code>PostStart</code>，这是<code>FailedPostStartHook</code>事件，因为<code>PreStop</code>这是<code>FailedPreStopHook</code>事件。您可以通过运行来查看这些事件<code>kubectl describe pod &lt;pod_name&gt;</code>。以下是运行此命令的一些事件输出示例：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Events:</span><br><span class="line">  FirstSeen    LastSeen    Count    From                            SubobjectPath        Type        Reason        Message</span><br><span class="line">  ---------    --------    -----    ----                            -------------        --------    ------        -------</span><br><span class="line">  <span class="number">1</span>m        <span class="number">1</span>m        <span class="number">1</span>    &#123;<span class="keyword">default</span>-scheduler &#125;                                Normal        Scheduled    Successfully assigned test<span class="number">-1730497541</span>-cq1d2 to gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd</span><br><span class="line">  <span class="number">1</span>m        <span class="number">1</span>m        <span class="number">1</span>    &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;    spec.containers&#123;main&#125;    Normal        Pulling        pulling <span class="keyword">image</span> <span class="string">"test:1.0"</span></span><br><span class="line">  <span class="number">1</span>m        <span class="number">1</span>m        <span class="number">1</span>    &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;    spec.containers&#123;main&#125;    Normal        Created        Created <span class="keyword">container</span> with docker id <span class="number">5</span>c6a256a2567; Security:[seccomp=unconfined]</span><br><span class="line">  <span class="number">1</span>m        <span class="number">1</span>m        <span class="number">1</span>    &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;    spec.containers&#123;main&#125;    Normal        Pulled        Successfully pulled <span class="keyword">image</span> <span class="string">"test:1.0"</span></span><br><span class="line">  <span class="number">1</span>m        <span class="number">1</span>m        <span class="number">1</span>    &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;    spec.containers&#123;main&#125;    Normal        Started        Started <span class="keyword">container</span> with docker id <span class="number">5</span>c6a256a2567</span><br><span class="line">  <span class="number">38</span>s        <span class="number">38</span>s        <span class="number">1</span>    &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;    spec.containers&#123;main&#125;    Normal        Killing        Killing <span class="keyword">container</span> with docker id <span class="number">5</span>c6a256a2567: PostStart handler: Error executing <span class="keyword">in</span> Docker Container: <span class="number">1</span></span><br><span class="line">  <span class="number">37</span>s        <span class="number">37</span>s        <span class="number">1</span>    &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;    spec.containers&#123;main&#125;    Normal        Killing        Killing <span class="keyword">container</span> with docker id <span class="number">8</span>df9fdfd7054: PostStart handler: Error executing <span class="keyword">in</span> Docker Container: <span class="number">1</span></span><br><span class="line">  <span class="number">38</span>s        <span class="number">37</span>s        <span class="number">2</span>    &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;                Warning        FailedSync    Error syncing pod, skipping: failed to <span class="string">"StartContainer"</span> <span class="keyword">for</span> <span class="string">"main"</span> with RunContainerError: <span class="string">"PostStart handler: Error executing in Docker Container: 1"</span></span><br><span class="line">  <span class="number">1</span>m         <span class="number">22</span>s         <span class="number">2</span>     &#123;kubelet gke-test-<span class="keyword">cluster</span>-<span class="keyword">default</span>-pool-a07e5d30-siqd&#125;    spec.containers&#123;main&#125;    Warning        FailedPostStartHook</span><br></pre></td></tr></table></figure></p>
<h2 id="Workloads"><a href="#Workloads" class="headerlink" title="Workloads"></a>Workloads</h2><h3 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h3><h4 id="Pod概述"><a href="#Pod概述" class="headerlink" title="Pod概述"></a>Pod概述</h4><p>此页面概述Pod了Kubernetes对象模型中最小的可部署对象。</p>
<ul>
<li>了解Pods</li>
<li>使用Pods</li>
<li>Pod模板</li>
</ul>
<h5 id="了解Pods"><a href="#了解Pods" class="headerlink" title="了解Pods"></a>了解Pods</h5><p>一个pod是在创建或部署Kubernetes对象模型Kubernetes-最小最简单的单元的基本构建块。Pod表示群集上正在运行的进程。</p>
<p>Pod封装了一个应用程序容器（或者，在某些情况下，多个容器），存储资源，一个唯一的网络IP以及控制容器应该如何运行的选项。Pod表示部署单元：Kubernetes中的单个应用程序实例，可能包含单个容器或少量紧密耦合且共享资源的容器。</p>
<p><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a>是Kubernetes Pod中最常用的容器运行时，但Pods也支持其他容器运行时。</p>
<p>Kubernetes集群中的Pod可以以两种主要方式使用：</p>
<ul>
<li><strong>运行单个容器的Pod</strong>。“one-container-per-Pod”模型是最常见的Kubernetes用例; 在这种情况下，您可以将Pod视为单个容器的包装，而Kubernetes直接管理Pod而不是容器。</li>
<li><strong>运行多个需要协同工作的容器的Pod</strong>。Pod可以封装由多个共址容器组成的应用程序，这些容器紧密耦合并需要共享资源。这些共处一地的容器可能形成一个统一的服务单元 - 一个容器从共享卷向公众提供文件，而一个单独的“sidecar”容器刷新或更新这些文件。Pod将这些容器和存储资源作为单个可管理实体包装在一起。</li>
</ul>
<p>该<a href="http://kubernetes.io/blog" target="_blank" rel="noopener">Kubernetes博客</a>对pod用例一些额外的信息。有关更多信息，请参阅：</p>
<ul>
<li><a href="https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns" target="_blank" rel="noopener">分布式系统工具包：复合容器的模式</a></li>
<li><a href="https://kubernetes.io/blog/2016/06/container-design-patterns" target="_blank" rel="noopener">容器设计模式</a></li>
</ul>
<p>每个Pod都用于运行给定应用程序的单个实例。如果要水平扩展应用程序（例如，运行多个实例），则应使用多个Pod，每个实例一个。在Kubernetes中，这通常被称为复制。复制Pod通常由称为Controller的抽象创建和管理。有关更多信息，请参阅<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#pods-and-controllers" target="_blank" rel="noopener">Pod和控制器</a>。</p>
<h6 id="Pod如何管理多个容器"><a href="#Pod如何管理多个容器" class="headerlink" title="Pod如何管理多个容器"></a>Pod如何管理多个容器</h6><p>Pod旨在支持多个协作流程（作为容器），形成一个有凝聚力的服务单元。Pod中的容器自动位于群集中的同一物理或虚拟机上，并共同调度。容器可以共享资源和依赖关系，彼此通信，并协调它们何时以及如何终止。</p>
<p>请注意，在单个Pod中对多个共存和共同管理的容器进行分组是一个相对高级的用例。您应该仅在容器紧密耦合的特定实例中使用此模式。例如，您可能有一个容器充当共享卷中文件的Web服务器，以及一个单独的“sidecar”容器，用于从远程源更新这些文件，如下图所示：<br><img src="https://d33wubrfki0l68.cloudfront.net/aecab1f649bc640ebef1f05581bfcc91a48038c4/728d6/images/docs/pod.svg" alt="image"></p>
<p><strong>pod diagram</strong></p>
<p>Pod为其组成容器提供两种共享资源：网络和存储。</p>
<p><strong>联网</strong></p>
<p>每个Pod都分配有唯一的IP地址。Pod中的每个容器都共享网络命名空间，包括IP地址和网络端口。Pod内的容器可以使用相互通信<code>localhost</code>。当Pod中的容器与Pod 外部的实体通信时，它们必须协调它们如何使用共享网络资源（例如端口）。</p>
<p><strong>存储</strong></p>
<p>Pod可以指定一组共享存储卷。Pod中的所有容器都可以访问共享卷，允许这些容器共享数据。如果需要重新启动其中一个容器，则卷还允许Pod中的持久数据存活。见卷上Kubernetes如何实现一个pod里的共享存储更多的信息。</p>
<h5 id="使用Pods"><a href="#使用Pods" class="headerlink" title="使用Pods"></a>使用Pods</h5><p>你很少直接在Kubernetes - 甚至是单身Pod中创建单独的Pod。这是因为Pods被设计为相对短暂的一次性实体。当创建Pod（由您直接创建或由Controller间接创建）时，它将被安排在群集中的节点上运行。Pod保留在该节点上，直到进程终止，pod对象被删除，pod 因资源不足而被驱逐，或者Node失败。</p>
<blockquote>
<p>注意：不应将重新启动Pod重新启动Pod中的容器。Pod本身不会运行，但是容器运行的环境会持续存在，直到删除为止。</p>
</blockquote>
<p>pod本身不能自我修复。如果将Pod调度到失败的节点，或者调度操作本身失败，则删除Pod; 同样，由于缺乏资源或节点维护，Pod将无法在驱逐中存活。Kubernetes使用更高级别的抽象，称为Controller，它处理管理相对可处理的Pod实例的工作。因此，虽然可以直接使用Pod，但在Kubernetes中使用Controller管理pod更为常见。见<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#pods-and-controllers" target="_blank" rel="noopener">pod和控制器</a>上Kubernetes如何使用控制器来实现pod缩放和愈合的更多信息。</p>
<h6 id="pod和控制器"><a href="#pod和控制器" class="headerlink" title="pod和控制器"></a>pod和控制器</h6><p>Controller可以为您创建和管理多个Pod，处理复制和部署，并在集群范围内提供自我修复功能。例如，如果节点发生故障，Controller可能会通过在不同节点上安排相同的替换来自动替换Pod。</p>
<p>包含一个或多个pod的控制器的一些示例包括：</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">部署</a></li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">StatefulSet</a></li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">DaemonSet</a></li>
</ul>
<p>通常，控制器使用您提供的Pod模板来创建它负责的Pod。</p>
<h5 id="Pod模板"><a href="#Pod模板" class="headerlink" title="Pod模板"></a>Pod模板</h5><p>Pod模板是pod规范，包含在其他对象中，例如 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" target="_blank" rel="noopener">Replication Controllers</a>，<a href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/" target="_blank" rel="noopener">Jobs</a>和 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">DaemonSets</a>。控制器使用Pod模板制作实际的pod。下面的示例是Pod的简单清单，其中包含一个打印消息的容器。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: v1</span><br><span class="line"><span class="attribute">kind</span>: Pod</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">name</span>: myapp-pod</span><br><span class="line">  <span class="attribute">labels</span>:</span><br><span class="line">    <span class="attribute">app</span>: myapp</span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">containers</span>:</span><br><span class="line">  - <span class="attribute">name</span>: myapp-container</span><br><span class="line">    <span class="attribute">image</span>: busybox</span><br><span class="line">    <span class="attribute">command</span>: [<span class="string">'sh'</span>, <span class="string">'-c'</span>, <span class="string">'echo Hello Kubernetes! &amp;&amp; sleep 3600'</span>]</span><br></pre></td></tr></table></figure></p>
<p>pod模板不是指定所有副本的当前所需状态，而是像cookie 切割机。切割 cookie后，cookie与切割机无关。没有“量子纠缠”。对模板的后续更改甚至切换到新模板对已创建的pod没有直接影响。类似地，随后可以直接更新由复制控制器创建的pod。这与pod有意对比，pod确实指定了属于pod的所有容器的当前所需状态。这种方法从根本上简化了系统语义并增加了原语的灵活性。</p>
<h4 id="Pods-1"><a href="#Pods-1" class="headerlink" title="Pods"></a>Pods</h4><p>pods是可以创建和管理Kubernetes计算的最小可部署单元。</p>
<ul>
<li>什么是Pod？</li>
<li>pod的动机</li>
<li>pod的使用</li>
<li>考虑的替代方案</li>
<li>pod的耐久性（或缺乏）</li>
<li>终止pod</li>
<li>pod容器的特权模式</li>
<li>API对象</li>
</ul>
<h5 id="什么是Pod？"><a href="#什么是Pod？" class="headerlink" title="什么是Pod？"></a>什么是Pod？</h5><p>一个pod（如在whales或pea pod中）是一组一个或多个容器（如Docker容器），具有共享存储/网络，以及如何运行容器的规范。pod的内容始终位于同一位置并共同调度，并在共享上下文中运行。pod模拟特定于应用程序的“逻辑主机” - 它包含一个或多个相对紧密耦合的应用程序容器 - 在预容器世界中，在同一物理或虚拟机上执行意味着在同一逻辑主机上执行。</p>
<p>虽然Kubernetes支持的容器运行时间多于Docker，但Docker是最常见的运行时，它有助于用Docker术语描述pod。</p>
<p>pod的共享上下文是一组Linux命名空间，cgroup，以及可能的隔离方面 - 与隔离Docker容器相同的东西。在pod的上下文中，各个应用程序可能会应用进一步的子隔离。</p>
<p>Pod中的容器共享IP地址和端口空间，并且可以通过它们找到彼此localhost。他们还可以使用标准的进程间通信（如SystemV信号量或POSIX共享内存）相互通信。不同pod中的容器具有不同的IP地址，并且在没有<a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/" target="_blank" rel="noopener">特殊配置</a>的情况下无法通过IPC进行通信 。这些容器通常通过Pod IP地址相互通信。</p>
<p>pod中的应用程序还可以访问共享卷，共享卷被定义为pod的一部分，可以安装到每个应用程序的文件系统中。</p>
<p>就<a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a>构造而言，pod被建模为一组具有共享命名空间和共享<a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="noopener">卷</a>的Docker容器 。</p>
<p>与单个应用程序容器一样，pod被认为是相对短暂的（而不是持久的）实体。正如在pod的生命周期中所讨论的，创建pod，分配唯一ID（UID），并调度到它们保留的节点，直到终止（根据重启策略）或删除。如果节点终止，则在超时期限之后，将调度计划到该节点的Pod进行删除。给定的pod（由UID定义）不会“重新安排”到新节点; 相反，它可以被相同的pod替换，如果需要，甚至可以使用相同的名称，但是使用新的UID（有关更多详细信息，请参阅<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" target="_blank" rel="noopener">复制控制器</a>）。</p>
<p>当某些东西被认为具有与容量相同的生命周期时，例如卷，这意味着只要该容器（具有该UID）存在就存在。如果由于任何原因删除了该pod，即使创建了相同的替换，相关的东西（例如卷）也会被销毁并重新创建。<br><img src="https://d33wubrfki0l68.cloudfront.net/aecab1f649bc640ebef1f05581bfcc91a48038c4/728d6/images/docs/pod.svg" alt="image"></p>
<h6 id="pod图"><a href="#pod图" class="headerlink" title="pod图"></a>pod图</h6><p>一个多容器窗格，包含文件提取程序和Web服务器，该服务器使用持久卷在容器之间共享存储。</p>
<h5 id="pod的动机"><a href="#pod的动机" class="headerlink" title="pod的动机"></a>pod的动机</h5><h6 id="管理-1"><a href="#管理-1" class="headerlink" title="管理"></a>管理</h6><p>Pod是多个合作过程模式的模型，形成了一个有凝聚力的服务单元。它们通过提供比其组成应用程序集更高级别的抽象来简化应用程序部署和管理。Pod用作部署，水平扩展和复制的单元。对容器中的容器自动处理共置（共同调度），共享命运（例如终止），协调复制，资源共享和依赖关系管理。</p>
<h6 id="资源共享和沟通"><a href="#资源共享和沟通" class="headerlink" title="资源共享和沟通"></a>资源共享和沟通</h6><p>Pod可以实现其成员之间的数据共享和通信。</p>
<p>pod中的应用程序都使用相同的网络命名空间（相同的IP和端口空间），因此可以相互“找到”并使用它们进行通信<code>localhost</code>。因此，pod中的应用程序必须协调它们对端口的使用。每个pod在平面共享网络空间中具有IP地址，该网络空间与网络上的其他物理计算机和pod完全通信。</p>
<p>主机名设置为pod中应用程序容器的pod名称。<a href="https://kubernetes.io/docs/concepts/cluster-administration/networking/" target="_blank" rel="noopener">关于网络的更多细节</a>。</p>
<p>除了定义在pod中运行的应用程序容器之外，pod还指定了一组共享存储卷。卷使数据能够在容器重新启动后继续存在，并在容器内的应用程序之间共享。</p>
<h5 id="pod的使用"><a href="#pod的使用" class="headerlink" title="pod的使用"></a>pod的使用</h5><p>Pod可用于托管垂直集成的应用程序堆栈（例如LAMP），但其主要动机是支持共址，共同管理的帮助程序，例如：</p>
<ul>
<li>内容管理系统，文件和数据加载器，本地缓存管理器等。</li>
<li>日志和检查点备份，压缩，旋转，快照等</li>
<li>数据变更观察者，日志零售商，日志和监控适配器，活动发布者等。</li>
<li>代理，网桥和适配器</li>
<li>控制器，管理器，配置器和更新器</li>
</ul>
<p>通常，单个pod不用于运行同一应用程序的多个实例。</p>
<p>有关更长的说明，请参阅<a href="https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns" target="_blank" rel="noopener">分布式系统工具包：复合容器的模式</a>。</p>
<h5 id="考虑的替代方案"><a href="#考虑的替代方案" class="headerlink" title="考虑的替代方案"></a>考虑的替代方案</h5><p>为什么不在一个（Docker）容器中运行多个程序？</p>
<ol>
<li>透明度。使基础架构内的容器对基础架构可见，使基础架构能够为这些容器提供服务，例如进程管理和资源监视。这为用户提供了许多便利。</li>
<li>解耦软件依赖关系。各个容器可以独立地进行版本化，重建和重新部署。Kubernetes甚至有一天可能会支持单个容器的实时更新。</li>
<li>便于使用。用户无需运行自己的流程管理器，担心信号和退出代码传播等。</li>
<li>效率。由于基础设施承担更多责任，因此集装箱的重量可以更轻。</li>
</ol>
<p>为什么不支持基于亲和力的容器协同调度？</p>
<p>这种方法可以提供协同定位，但不会提供pod的大部分好处，例如资源共享，IPC，保证命运共享和简化管理。</p>
<h5 id="pod的耐久性（或缺乏）"><a href="#pod的耐久性（或缺乏）" class="headerlink" title="pod的耐久性（或缺乏）"></a>pod的耐久性（或缺乏）</h5><p>pod不应被视为耐用实体。它们将无法在调度故障，节点故障或其他驱逐（例如由于缺乏资源）或节点维护的情况下存活。</p>
<p>通常，用户不需要直接创建pod。他们应该几乎总是使用控制器，即使是singletons，例如， <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">部署</a>。控制器提供集群范围的自我修复，以及复制和部署管理。像<a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset.md" target="_blank" rel="noopener">StatefulSet</a>这样的控制器 也可以为有状态的pod提供支持。</p>
<p>使用集合API作为主要的面向用户的原语在集群调度系统中相对常见，包括<a href="https://research.google.com/pubs/pub43438.html" target="_blank" rel="noopener">Borg</a>，<a href="https://mesosphere.github.io/marathon/docs/rest-api.html" target="_blank" rel="noopener">Marathon</a>，<a href="http://aurora.apache.org/documentation/latest/reference/configuration/#job-schema" target="_blank" rel="noopener">Aurora</a>和<a href="http://www.slideshare.net/Docker/aravindnarayanan-facebook140613153626phpapp02-37588997" target="_blank" rel="noopener">Tupperware</a>。</p>
<p>Pod作为基元公开，以便于：</p>
<ul>
<li>调度程序和控制器可插拔性</li>
<li>支持pod级操作，无需通过控制器API“代理”它们</li>
<li>pod生命周期与控制器生命周期的解耦，例如引导</li>
<li>控制器和服务的分离 - 端点控制器只是监视pod</li>
<li>具有集群级功能的Kubelet级功能的清晰组合 - Kubelet实际上是“pod控制器”</li>
<li>高可用性应用程序，它们将期望在终止之前更换pod，并且肯定在删除之前，例如在计划驱逐或图像预取的情况下。</li>
</ul>
<h5 id="终止pod"><a href="#终止pod" class="headerlink" title="终止pod"></a>终止pod</h5><p>因为pod表示集群中节点上的正在运行的进程，所以允许这些进程在不再需要时优雅地终止（与使用KILL信号猛烈杀死并且没有机会清理）非常重要。用户应该能够请求删除并知道进程何时终止，但也能够确保删除最终完成。当用户请求删除pod时，系统会在允许pod强制终止之前记录预期的宽限期，并将TERM信号发送到每个容器中的主进程。宽限期到期后，KILL信号将发送到这些进程，然后从API服务器中删除该pod。如果在等待进程终止时重新启动Kubelet或容器管理器，</p>
<p>一个示例流程：</p>
<ol>
<li>用户发送删除Pod的命令，默认宽限期（30秒）</li>
<li>API服务器中的Pod随着时间的推移而更新，其中Pod被视为“死”以及宽限期。</li>
<li>在客户端命令中列出时，Pod显示为“终止”</li>
<li>（与3同时）当Kubelet看到Pod已被标记为终止，因为已经设置了2中的时间，它开始了pod关闭过程。<ol>
<li>如果其中一个Pod的容器定义了一个<a href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#hook-details" target="_blank" rel="noopener">preStop挂钩</a>，则会在容器内部调用它。如果在<code>preStop</code>宽限期到期后钩子仍在运行，则以小（2秒）延长的宽限期调用步骤2。</li>
<li>容器被发送TERM信号。请注意，并非Pod中的所有容器都会同时收到TERM信号，并且<code>preStop</code>如果它们关闭的顺序很重要，则每个容器都需要一个钩子。</li>
</ol>
</li>
<li>（与3同时）Pod从端点列表中删除以进行维护，并且不再被视为复制控制器的运行pod集的一部分。缓慢关闭的窗格无法继续提供流量，因为负载平衡器（如服务代理）会将其从旋转中移除。</li>
<li>当宽限期到期时，仍然在Pod中运行的任何进程都将被SIGKILL杀死。</li>
<li>Kubelet将通过设置宽限期0（立即删除）完成删除API服务器上的Pod。Pod从API中消失，不再从客户端可见。</li>
</ol>
<p>默认情况下，所有删除在30秒内都是正常的。该<code>kubectl delete</code>命令支持<code>--grace-period=&lt;seconds&gt;</code>允许用户覆盖默认值并指定其自己的值的选项。值<code>0</code><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/#force-deletion-of-pods" target="_blank" rel="noopener">force删除</a> pod。在kubectl版本&gt; = 1.5时，必须指定一个额外的标志<code>--force</code>一起<code>--grace-period=0</code>，以执行力的缺失。</p>
<h6 id="强制删除pod"><a href="#强制删除pod" class="headerlink" title="强制删除pod"></a>强制删除pod</h6><p>强制删除pod被定义为立即从群集状态和etcd删除pod。当执行强制删除时，许可证持有者不会等待来自kubelet的确认该pod已在其运行的节点上终止。它会立即删除API中的pod，以便可以使用相同的名称创建新的pod。在节点上，设置为立即终止的pod在被强制终止之前仍将被给予一个小的宽限期。</p>
<p>强制删除可能对某些pod有潜在危险，应谨慎执行。如果是StatefulSet pod，请参阅任务文档以<a href="https://kubernetes.io/docs/tasks/run-application/force-delete-stateful-set-pod/" target="_blank" rel="noopener">从StatefulSet中删除</a> Pod 。</p>
<h5 id="pod容器的特权模式"><a href="#pod容器的特权模式" class="headerlink" title="pod容器的特权模式"></a>pod容器的特权模式</h5><p>从Kubernetes v1.1开始，pod中的任何容器都可以使用容器规范中的<code>privileged</code>标志启用特权模式<code>SecurityContext</code>。这对于想要使用Linux功能（如操作网络堆栈和访问设备）的容器非常有用。容器内的进程获得与容器外部进程可用的几乎相同的权限。使用特权模式，将网络和卷插件编写为不需要编译到kubelet的独立窗格应该更容易。</p>
<p>如果主服务器正在运行Kubernetes v1.1或更高版本，并且节点运行的版本低于v1.1，那么api-server将接受新的特权pod，但不会启动。他们将处于待决状态。如果用户呼叫<code>kubectl describe pod FooPodName</code>，用户可以查看pod处于暂挂状态的原因。describe命令输出中的events表将说：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error </span>validating pod "FooPodName"."FooPodNamespace" from api, ignoring: spec.containers[0].securityContext.privileged: forbidden '&lt;*&gt;(0xc2089d3248)true'</span><br></pre></td></tr></table></figure></p>
<p>如果主服务器运行的版本低于v1.1，则无法创建特权pod。如果用户尝试创建具有特权容器的pod，则用户将收到以下错误：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Pod <span class="string">"FooPodName"</span> is invalid. spec<span class="selector-class">.containers</span>[<span class="number">0</span>]<span class="selector-class">.securityContext</span><span class="selector-class">.privileged</span>: forbidden <span class="string">'&lt;*&gt;(0xc20b222db0)true'</span></span><br></pre></td></tr></table></figure></p>
<h5 id="API对象-1"><a href="#API对象-1" class="headerlink" title="API对象"></a>API对象</h5><p>Pod是Kubernetes REST API中的顶级资源。有关API对象的更多详细信息，请参阅： <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#pod-v1-core" target="_blank" rel="noopener">Pod API对象</a>。</p>
<h4 id="Pod生命周期"><a href="#Pod生命周期" class="headerlink" title="Pod生命周期"></a>Pod生命周期</h4><p>该页面描述了Pod的生命周期。</p>
<ul>
<li>Pod阶段</li>
<li>Pod条件</li>
<li>容器探针</li>
<li>Pod和Container状态</li>
<li>Pod准备gate</li>
<li>重启政策</li>
<li>Pod寿命</li>
<li>例子</li>
</ul>
<h5 id="Pod阶段"><a href="#Pod阶段" class="headerlink" title="Pod阶段"></a>Pod阶段</h5><p>Pod的<code>status</code>字段是 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#podstatus-v1-core" target="_blank" rel="noopener">PodStatus</a> 对象，它有一个<code>phase</code>字段。</p>
<p>Pod的阶段是Pod在其生命周期中的简单，高级摘要。该阶段不是对Container或Pod状态的全面观察汇总，也不是一个综合状态机。</p>
<p>Pod阶段值的数量和含义受到严密保护。除了这里记录的内容之外，没有任何关于具有给定<code>phase</code>值的Pod的假设。</p>
<p>以下是可能的值<code>phase</code>：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Pending</code></td>
<td>Pod已被Kubernetes系统接受，但尚未创建一个或多个Container图像。这包括计划之前的时间以及通过网络下载图像所花费的时间，这可能需要一段时间。</td>
</tr>
<tr>
<td><code>Running</code></td>
<td>Pod已绑定到节点，并且已创建所有Container。至少有一个Container仍在运行，或者正在启动或重新启动。</td>
</tr>
<tr>
<td><code>Succeeded</code></td>
<td>Pod中的所有容器都已成功终止，并且不会重新启动。</td>
</tr>
<tr>
<td><code>Failed</code></td>
<td>Pod中的所有容器都已终止，并且至少有一个Container已终止失败。也就是说，Container要么退出非零状态，要么被系统终止。</td>
</tr>
<tr>
<td><code>Unknown</code></td>
<td>由于某种原因，无法获得Pod的状态，这通常是由于与Pod的主机通信时出错。</td>
</tr>
</tbody>
</table>
<h5 id="Pod条件"><a href="#Pod条件" class="headerlink" title="Pod条件"></a>Pod条件</h5><p>Pod有一个PodStatus，它有一个<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#podcondition-v1-core" target="_blank" rel="noopener">PodConditions</a>数组， Pod已经或没有通过它。PodCondition数组的每个元素都有六个可能的字段：</p>
<ul>
<li>该<code>lastProbeTime</code>字段提供上次探测Pod条件的时间戳。</li>
<li>该<code>lastTransitionTime</code>字段提供Pod最后从一个状态转换到另一个状态的时间戳。</li>
<li>该<code>message</code>字段是人类可读的消息，指示有关转换的详细信息。</li>
<li>该<code>reason</code>字段是该条件最后一次转换的唯一，单字，CamelCase原因。</li>
<li>该<code>status</code>字段是一个字符串，可能的值为“ <code>True</code>”，“ <code>False</code>”和“ <code>Unknown</code>”。</li>
<li>该<code>type</code>字段是一个包含以下可能值的字符串：<ul>
<li><code>PodScheduled</code>：Pod已被安排到一个节点;</li>
<li><code>Ready</code>：Pod可以提供请求，应该添加到所有匹配服务的负载平衡池中;</li>
<li><code>Initialized</code>：所有<a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers" target="_blank" rel="noopener">init容器</a> 都已成功启动;</li>
<li><code>Unschedulable</code>：调度程序现在无法调度Pod，例如由于缺少资源或其他限制;</li>
<li><code>ContainersReady</code>：Pod中的所有容器都已准备就绪。</li>
</ul>
</li>
</ul>
<h5 id="容器探针"><a href="#容器探针" class="headerlink" title="容器探针"></a>容器探针</h5><p>一个<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#probe-v1-core" target="_blank" rel="noopener">探头</a>是通过周期性地执行的诊断<a href="https://kubernetes.io/docs/admin/kubelet/" target="_blank" rel="noopener">kubelet </a>上的容器。为了执行诊断，kubelet调用Container实现的 <a href="https://godoc.org/k8s.io/kubernetes/pkg/api/v1#Handler" target="_blank" rel="noopener">Handler</a>。有三种类型的处理程序：</p>
<ul>
<li><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#execaction-v1-core" target="_blank" rel="noopener">ExecAction</a>：在Container内执行指定的命令。如果命令以状态代码0退出，则认为诊断成功。</li>
<li><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#tcpsocketaction-v1-core" target="_blank" rel="noopener">TCPSocketAction</a>：对指定端口上的Container的IP地址执行TCP检查。如果端口打开，则诊断被认为是成功的。</li>
<li><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#httpgetaction-v1-core" target="_blank" rel="noopener">HTTPGetAction</a>：对指定端口和路径上的Container的IP地址执行HTTP Get请求。如果响应的状态代码大于或等于200且小于400，则认为诊断成功。</li>
</ul>
<p>每个探针都有三个结果之一：</p>
<ul>
<li>成功：Container通过了诊断。</li>
<li>失败：容器未通过诊断。</li>
<li>未知：诊断失败，因此不应采取任何措施。</li>
</ul>
<p>在运行容器时，kubelet可以选择性地执行和响应两种探测器：</p>
<ul>
<li><code>livenessProbe</code>：指示Container是否正在运行。如果活动探测失败，则kubelet会杀死Container，并且Container将受其重启策略的约束。如果Container未提供活动探测，则默认状态为<code>Success</code>。</li>
<li><code>readinessProbe</code>：指示Container是否已准备好为请求提供服务。如果准备就绪探测失败，则端点控制器会从与Pod匹配的所有服务的端点中删除Pod的IP地址。初始延迟之前的默认准备状态是<code>Failure</code>。如果Container未提供就绪探测，则默认状态为<code>Success</code>。</li>
</ul>
<h5 id="什么时候应该使用活力或准备探针？"><a href="#什么时候应该使用活力或准备探针？" class="headerlink" title="什么时候应该使用活力或准备探针？"></a>什么时候应该使用活力或准备探针？</h5><p>如果您的Container中的进程在遇到问题或变得不健康时能够自行崩溃，则您不一定需要活动探测器; kubelet将根据Pod的内容自动执行正确的操作<code>restartPolicy</code>。</p>
<p>如果您希望在探测失败时杀死并重新启动Container，则指定活动探测，并指定<code>restartPolicy</code>Always或OnFailure。</p>
<p>如果您只想在探测成功时开始向Pod发送流量，请指定准备探测。在这种情况下，准备情况探测可能与活动探测相同，但规范中存在准备探测意味着Pod将在不接收任何流量的情况下启动，并且仅在探测开始成功后才开始接收流量。</p>
<p>如果Container需要在启动期间处理大型数据，配置文件或迁移，请指定就绪性探针。</p>
<p>如果您希望Container能够自行维护，您可以指定一个就绪探针，用于检查特定于就绪状态的端点，该端点与活动探针不同。</p>
<p>请注意，如果您只想在删除Pod时排除请求，则不一定需要准备探测; 在删除时，无论准备情况探测是否存在，Pod都会自动将其置于未准备状态。Pod在等待Pod中的容器停止时仍处于未准备状态。</p>
<p>有关如何设置活动或准备情况探测的详细信息，请参阅 <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" target="_blank" rel="noopener">配置活动和准备探测</a>。</p>
<h5 id="Pod和Container状态"><a href="#Pod和Container状态" class="headerlink" title="Pod和Container状态"></a>Pod和Container状态</h5><p>有关Pod容器状态的详细信息，请参阅 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#podstatus-v1-core" target="_blank" rel="noopener">PodStatus </a>和 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#containerstatus-v1-core" target="_blank" rel="noopener">ContainerStatus</a>。请注意，报告为Pod状态的信息取决于当前的 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#containerstatus-v1-core" target="_blank" rel="noopener">ContainerState</a>。</p>
<h5 id="Pod准备gate"><a href="#Pod准备gate" class="headerlink" title="Pod准备gate"></a>Pod准备gate</h5><p>特征状态： <code>Kubernetes v1.12</code></p>
<blockquote>
<p>此功能目前处于测试状态</p>
</blockquote>
<p>为了通过注入额外的反馈或信号来增加Pod准备的可扩展性<code>PodStatus</code>，Kubernetes 1.11引入了一个名为<a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/0007-pod-ready%2B%2B.md" target="_blank" rel="noopener">Pod ready ++</a>的功能。您可以使用新的字段<code>ReadinessGate</code>中<code>PodSpec</code>指定波德准备进行评估附加条件。如果Kubernetes在<code>status.conditionsPod</code> 的字段中找不到这样的条件，则条件的状态默认为“ <code>False</code>”。以下是一个例子：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  readinessGates:</span></span><br><span class="line"><span class="attr">    - conditionType:</span> <span class="string">"www.example.com/feature-1"</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line"><span class="attr">  conditions:</span></span><br><span class="line"><span class="attr">    - type:</span> <span class="string">Ready</span>  <span class="comment"># this is a builtin PodCondition</span></span><br><span class="line"><span class="attr">      status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">      lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">      lastTransitionTime:</span> <span class="number">2018</span><span class="bullet">-01</span><span class="bullet">-01</span><span class="attr">T00:00:00Z</span></span><br><span class="line"><span class="attr">    - type:</span> <span class="string">"www.example.com/feature-1"</span>   <span class="comment"># an extra PodCondition</span></span><br><span class="line"><span class="attr">      status:</span> <span class="string">"False"</span></span><br><span class="line"><span class="attr">      lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">      lastTransitionTime:</span> <span class="number">2018</span><span class="bullet">-01</span><span class="bullet">-01</span><span class="attr">T00:00:00Z</span></span><br><span class="line"><span class="attr">  containerStatuses:</span></span><br><span class="line"><span class="attr">    - containerID:</span> <span class="attr">docker://abcd...</span></span><br><span class="line"><span class="attr">      ready:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure></p>
<p>新Pod条件必须符合Kubernetes <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set" target="_blank" rel="noopener">标签密钥格式</a>。由于该<code>kubectl patch</code>命令仍然不支持修补对象状态，因此必须<code>PATCH</code>使用其中一个<a href="https://kubernetes.io/docs/reference/using-api/client-libraries/" target="_blank" rel="noopener">KubeClient库</a>通过操作注入新的Pod条件。</p>
<p>随着新Pod条件的引入，<strong>只有</strong> 当以下两个语句都成立时，<strong>才会</strong>评估Pod是否就绪：</p>
<ul>
<li>Pod中的所有容器都已准备就绪。</li>
<li>指定的所有条件<code>ReadinessGates</code>均为“ <code>True</code>”。</li>
</ul>
<p>为了便于对Pod准备评估进行此更改，<code>ContainersReady</code>引入了一个新的Pod条件 来捕获旧的Pod <code>Ready</code>条件。</p>
<p>在K8s 1.11中，作为alpha功能，必须通过将<code>PodReadinessGates</code> 功能门设置 为true 来明确启用“Pod Ready ++”功能。</p>
<p>在K8s 1.12中，默认情况下启用该功能。</p>
<h5 id="重启政策"><a href="#重启政策" class="headerlink" title="重启政策"></a>重启政策</h5><p>PodSpec的<code>restartPolicy</code>字段可能包含Always，OnFailure和Never。默认值为Always。 <code>restartPolicy</code>适用于Pod中的所有容器。<code>restartPolicy</code>仅指由同一节点上的kubelet重新启动Container。由kubelet重新启动的已退出容器将以指数退避延迟（10秒，20秒，40秒……）重新启动，上限为五分钟，并在成功执行十分钟后重置。正如<a href="https://kubernetes.io/docs/user-guide/pods/#durability-of-pods-or-lack-thereof" target="_blank" rel="noopener">Pods文档</a>中所讨论的 ，一旦绑定到节点，Pod将永远不会被反弹到另一个节点。</p>
<h5 id="Pod寿命"><a href="#Pod寿命" class="headerlink" title="Pod寿命"></a>Pod寿命</h5><p>一般来说，pod不会消失，直到有人摧毁它们。这可能是人或控制者。此规则的唯一例外是具有<code>phase</code>成功或失败超过一定持续时间（由<code>terminated-pod-gc-threshold</code>master确定）的Pod将过期并自动销毁。</p>
<p>有三种控制器可供选择：</p>
<ul>
<li>使用<a href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/" target="_blank" rel="noopener">Job</a> for Pods预期终止，例如批量计算。作业仅适用于 <code>restartPolicy</code>等于OnFailure或Never的Pod。</li>
<li>对不希望终止的<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">Pod</a>（例如，Web服务器）使用<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" target="_blank" rel="noopener">ReplicationController</a>， <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">ReplicaSet</a>或 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployment</a>。ReplicationControllers仅适用于具有<code>restartPolicy</code>Always的Pod。</li>
<li>使用需要为每台计算机运行一个的<a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">Pod的DaemonSet</a>，因为它们提供特定于计算机的系统服务。</li>
</ul>
<p>所有三种类型的控制器都包含PodTemplate。建议创建适当的控制器并让它创建Pod，而不是自己直接创建Pod。这是因为Pods单独对机器故障没有弹性，但是控制器是。</p>
<p>如果节点死亡或与群集的其余部分断开连接，Kubernetes会应用策略<code>phase</code>将丢失节点上的所有Pod设置为Failed。</p>
<h5 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h5><h6 id="高级活动探测示例"><a href="#高级活动探测示例" class="headerlink" title="高级活动探测示例"></a>高级活动探测示例</h6><p>活动探测由kubelet执行，因此所有请求都在kubelet网络名称空间中进行。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">apiVersion:</span> v1</span><br><span class="line"><span class="symbol">kind:</span> Pod</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  labels:</span></span><br><span class="line"><span class="symbol">    test:</span> liveness</span><br><span class="line"><span class="symbol">  name:</span> liveness-http</span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  containers:</span></span><br><span class="line">  - args:</span><br><span class="line">    - /server</span><br><span class="line"><span class="symbol">    image:</span> k8s.gcr.io/liveness</span><br><span class="line"><span class="symbol">    livenessProbe:</span></span><br><span class="line"><span class="symbol">      httpGet:</span></span><br><span class="line">        <span class="meta"># when <span class="string">"host"</span> is not defined, <span class="string">"PodIP"</span> will be used</span></span><br><span class="line">        <span class="meta"># host: my-host</span></span><br><span class="line">        <span class="meta"># when <span class="string">"scheme"</span> is not defined, <span class="string">"HTTP"</span> scheme will be used. Only <span class="string">"HTTP"</span> and <span class="string">"HTTPS"</span> are allowed</span></span><br><span class="line">        <span class="meta"># scheme: HTTPS</span></span><br><span class="line"><span class="symbol">        path:</span> /healthz</span><br><span class="line"><span class="symbol">        port:</span> <span class="number">8080</span></span><br><span class="line"><span class="symbol">        httpHeaders:</span></span><br><span class="line">        - name: X-Custom-Header</span><br><span class="line"><span class="symbol">          value:</span> Awesome</span><br><span class="line"><span class="symbol">      initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line"><span class="symbol">      timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">    name:</span> liveness</span><br></pre></td></tr></table></figure></p>
<h6 id="示例状态"><a href="#示例状态" class="headerlink" title="示例状态"></a>示例状态</h6><ul>
<li>Pod正在运行并有一个Container。集装箱出口成功。<ul>
<li>记录完成事件。</li>
<li>如果<code>restartPolicy</code>是：<ul>
<li>始终：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>OnFailure：Pod <code>phase</code>成功。</li>
<li>从不：Pod <code>phase</code>成功。</li>
</ul>
</li>
</ul>
</li>
<li>Pod正在运行并有一个Container。容器退出失败。<ul>
<li>记录失败事件。</li>
<li>如果<code>restartPolicy</code>是：<ul>
<li>始终：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>OnFailure：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>从不：Pod <code>phase</code>变得失败。</li>
</ul>
</li>
</ul>
</li>
<li>Pod正在运行并有两个容器。容器1出现故障。<ul>
<li>记录失败事件。</li>
<li>如果<code>restartPolicy</code>是：<ul>
<li>始终：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>OnFailure：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>从不：不要重启容器; Pod <code>phase</code>保持运行状态。</li>
</ul>
</li>
<li>如果Container 1未运行，并且Container 2退出：<ul>
<li>记录失败事件。</li>
<li>如果<code>restartPolicy</code>是：<ul>
<li>始终：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>OnFailure：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>从不：Pod <code>phase</code>变得失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Pod正在运行并有一个Container。容器耗尽内存。<ul>
<li>记录失败事件。</li>
<li>记录OOM事件。</li>
<li>如果<code>restartPolicy</code>是：<ul>
<li>始终：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>OnFailure：重启容器; Pod <code>phase</code>保持运行状态。</li>
<li>从不：记录失败事件; Pod <code>phase</code>保持运行状态。</li>
</ul>
</li>
</ul>
</li>
<li>Pod正在运行，磁盘已经死亡。<ul>
<li>杀死所有容器。</li>
<li>记录适当的事件。</li>
<li>Pod <code>phase</code>变得失败。</li>
<li>如果在控制器下运行，Pod将在其他位置重新创建。</li>
</ul>
</li>
<li>Pod正在运行，其节点已分段。<ul>
<li>杀死所有容器。</li>
<li>记录适当的事件。</li>
<li>Pod <code>phase</code>变得失败。</li>
<li>如果在控制器下运行，Pod将在其他位置重新创建。</li>
</ul>
</li>
</ul>
<h4 id="初始容器"><a href="#初始容器" class="headerlink" title="初始容器"></a>初始容器</h4><p>此页面提供了Init Containers的概述，它是在应用程序容器之前运行的专用容器，可以包含应用程序映像中不存在的实用程序或设置脚本。</p>
<ul>
<li>了解Init容器</li>
<li>Init容器可以用于什么？</li>
<li>详细的行为</li>
<li>支持和兼容性</li>
</ul>
<h5 id="了解Init容器"><a href="#了解Init容器" class="headerlink" title="了解Init容器"></a>了解Init容器</h5><p>一个<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener">pod</a>能够在其内运行的应用程序的多个容器，但它也可以有一个或多个初始化容器，该容器的应用容器启动之前运行。</p>
<p>Init容器与常规容器完全相同，除了：</p>
<ul>
<li>他们总是跑完成。</li>
<li>每个人必须在下一个启动之前成功完成。</li>
</ul>
<p>如果Init容器的Init容器失败，Kubernetes会重复重启Pod，直到Init容器成功。但是，如果Pod具有<code>restartPolicy</code>Never，则不会重新启动。</p>
<p>要将Container指定为Init容器，请将<code>initContainers</code>PodSpec上的字段添加 为应用程序数组旁边的<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#container-v1-core" target="_blank" rel="noopener">Container</a>类型的JSON containers数组。init容器的状态在<code>.status.initContainerStatuses</code>字段中作为容器状态的数组返回（类似于<code>.status.containerStatuses</code>字段）。</p>
<h6 id="与常规容器的差异"><a href="#与常规容器的差异" class="headerlink" title="与常规容器的差异"></a>与常规容器的差异</h6><p>Init Containers支持应用容器的所有字段和功能，包括资源限制，卷和安全设置。但是，Init容器的资源请求和限制的处理方式略有不同，这些内容在下面的<a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#resources" target="_blank" rel="noopener">参考资料</a>中有说明。此外，Init Containers不支持就绪探针，因为它们必须在Pod准备好之前运行完成。</p>
<p>如果为Pod指定了多个Init容器，则按顺序一次运行一个Container。每一个都必须在下一次运行之前成功。当所有Init容器都运行完成后，Kubernetes会初始化Pod并像往常一样运行应用程序容器。</p>
<h5 id="Init容器可以用于什么？"><a href="#Init容器可以用于什么？" class="headerlink" title="Init容器可以用于什么？"></a>Init容器可以用于什么？</h5><p>由于Init Containers具有来自应用容器的单独镜像，因此它们对于启动相关代码具有一些优势：</p>
<ul>
<li>出于安全原因，它们可以包含并运行不希望包含在应用容器镜像中的实用程序。</li>
<li>它们可以包含应用程序镜像中不存在的用于设置的实用程序或自定义代码。例如，没有必要使镜像<code>FROM</code>的另一个镜像只使用像工具 <code>sed</code>，<code>awk</code>，<code>python</code>，或<code>dig</code>在安装过程中。</li>
<li>应用程序映像构建器和部署者角色可以独立工作，而无需共同构建单个应用程序镜像。</li>
<li>他们使用Linux命名空间，以便他们从应用程序容器中获得不同的文件系统视图。因此，他们可以访问应用容器无法访问的秘密。</li>
<li>它们在任何应用程序容器启动之前运行完成，而应用程序容器并行运行，因此Init容器提供了一种简单的方法来阻止或延迟应用容器的启动，直到满足一组前置条件。</li>
</ul>
<h6 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h6><p>以下是有关如何使用Init Containers的一些想法：</p>
<ul>
<li>等待使用shell命令创建服务，例如：</li>
<li>我在{1..100}; 做睡觉1; 如果挖我的服务; 然后退出0; 网络连接; 完成; 退出1</li>
<li><p>使用以下命令从向下API向远程服务器注册此Pod：</p>
<p>  curl -X POST http：// $ MANAGEMENT_SERVICE_HOST：$ MANAGEMENT_SERVICE_PORT / register -d’instal = $（）IP = $（）”</p>
</li>
<li>等待一段时间，然后使用类似命令启动app Container <code>sleep 60</code>。</li>
<li>将git存储库克隆到卷中。</li>
<li>将值放入配置文件并运行模板工具以动态生成主应用程序Container的配置文件。例如，将POD_IP值放在配置中，并使用Jinja生成主应用程序配置文件。</li>
</ul>
<p>可以在<a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">StatefulSets</a>文档 和<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-initialization/" target="_blank" rel="noopener">Production Pods指南</a>中找到更详细的用法示例。</p>
<h6 id="初始容器正在使用中"><a href="#初始容器正在使用中" class="headerlink" title="初始容器正在使用中"></a>初始容器正在使用中</h6><p>以下针对Kubernetes 1.5的yaml文件概述了一个具有两个Init容器的简单Pod。第一个等待，<code>myservice</code>第二个等待<code>mydb</code>。一旦两个容器完成，Pod就会开始。<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-pod</span><br><span class="line">  labels:</span><br><span class="line">    app: myapp</span><br><span class="line">  annotations:</span><br><span class="line">    pod.beta.kubernetes.io/init-containers: <span class="string">'[</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            "</span>name<span class="string">": "</span>init-myservice<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>image<span class="string">": "</span>busybox<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>command<span class="string">": ["</span>sh<span class="string">", "</span>-c<span class="string">", "</span>until nslookup myservice; <span class="keyword">do</span> echo waiting <span class="keyword">for</span> myservice; sleep <span class="number">2</span>; done;<span class="string">"]</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            "</span>name<span class="string">": "</span>init-mydb<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>image<span class="string">": "</span>busybox<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>command<span class="string">": ["</span>sh<span class="string">", "</span>-c<span class="string">", "</span>until nslookup mydb; <span class="keyword">do</span> echo waiting <span class="keyword">for</span> mydb; sleep <span class="number">2</span>; done;<span class="string">"]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]'</span></span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp-container</span><br><span class="line">    image: busybox</span><br><span class="line">    command: [<span class="string">'sh'</span>, <span class="string">'-c'</span>, <span class="string">'echo The app is running! &amp;&amp; sleep 3600'</span>]</span><br></pre></td></tr></table></figure></p>
<p>Kubernetes 1.6中有一种新语法，尽管旧的注释语法仍适用于1.6和1.7。新语法必须用于1.8或更高版本。我们已将Init Containers的声明移至<code>spec</code>：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: v1</span><br><span class="line"><span class="attribute">kind</span>: Pod</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">name</span>: myapp-pod</span><br><span class="line">  <span class="attribute">labels</span>:</span><br><span class="line">    <span class="attribute">app</span>: myapp</span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">containers</span>:</span><br><span class="line">  - <span class="attribute">name</span>: myapp-container</span><br><span class="line">    <span class="attribute">image</span>: busybox</span><br><span class="line">    <span class="attribute">command</span>: [<span class="string">'sh'</span>, <span class="string">'-c'</span>, <span class="string">'echo The app is running! &amp;&amp; sleep 3600'</span>]</span><br><span class="line">  <span class="attribute">initContainers</span>:</span><br><span class="line">  - <span class="attribute">name</span>: init-myservice</span><br><span class="line">    <span class="attribute">image</span>: busybox</span><br><span class="line">    <span class="attribute">command</span>: [<span class="string">'sh'</span>, <span class="string">'-c'</span>, <span class="string">'until nslookup myservice; do echo waiting for myservice; sleep 2; done;'</span>]</span><br><span class="line">  - <span class="attribute">name</span>: init-mydb</span><br><span class="line">    <span class="attribute">image</span>: busybox</span><br><span class="line">    <span class="attribute">command</span>: [<span class="string">'sh'</span>, <span class="string">'-c'</span>, <span class="string">'until nslookup mydb; do echo waiting for mydb; sleep 2; done;'</span>]</span><br></pre></td></tr></table></figure></p>
<p>1.5语法仍适用于1.6，但我们建议使用1.6语法。在Kubernetes 1.6中，Init Containers在API中成为了一个领域。beta注释在1.6和1.7中仍然受到尊重，但在1.8或更高版本中不受支持。</p>
<p>下面YAML文件概述了<code>mydb</code>与<code>myservice</code>服务：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myservice</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">9376</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mydb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">9377</span></span><br></pre></td></tr></table></figure></p>
<p>可以使用以下命令启动和调试此Pod：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f myapp.yaml</span><br><span class="line">pod/myapp-pod created</span><br><span class="line">$ kubectl <span class="builtin-name">get</span> -f myapp.yaml</span><br><span class="line">NAME        READY     STATUS     RESTARTS   AGE</span><br><span class="line">myapp-pod   0/1       Init:0/2   0          6m</span><br><span class="line">$ kubectl describe -f myapp.yaml</span><br><span class="line">Name:          myapp-pod</span><br><span class="line">Namespace:     default</span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">Labels:        <span class="attribute">app</span>=myapp</span><br><span class="line">Status:        Pending</span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">Init Containers:</span><br><span class="line">  init-myservice:</span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">    State:         Running</span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">  init-mydb:</span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">    State:         Waiting</span><br><span class="line">      Reason:      PodInitializing</span><br><span class="line">    Ready:         <span class="literal">False</span></span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">Containers:</span><br><span class="line">  myapp-container:</span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">    State:         Waiting</span><br><span class="line">      Reason:      PodInitializing</span><br><span class="line">    Ready:         <span class="literal">False</span></span><br><span class="line">[<span class="built_in">..</span>.]</span><br><span class="line">Events:</span><br><span class="line">  FirstSeen    LastSeen    Count    <span class="keyword">From</span>                      SubObjectPath                          <span class="built_in"> Type </span>         Reason        Message</span><br><span class="line">  ---------    --------    -----    ----                      -------------                           --------      ------        -------</span><br><span class="line">  16s          16s         1        &#123;default-scheduler &#125;                                              Normal        Scheduled     Successfully assigned myapp-pod <span class="keyword">to</span> 172.17.4.201</span><br><span class="line">  16s          16s         1        &#123;kubelet 172.17.4.201&#125;    spec.initContainers&#123;init-myservice&#125;     Normal        Pulling       pulling image <span class="string">"busybox"</span></span><br><span class="line">  13s          13s         1        &#123;kubelet 172.17.4.201&#125;    spec.initContainers&#123;init-myservice&#125;     Normal        Pulled        Successfully pulled image <span class="string">"busybox"</span></span><br><span class="line">  13s          13s         1        &#123;kubelet 172.17.4.201&#125;    spec.initContainers&#123;init-myservice&#125;     Normal        Created       Created container with docker id 5ced34a04634; Security:[<span class="attribute">seccomp</span>=unconfined]</span><br><span class="line">  13s          13s         1        &#123;kubelet 172.17.4.201&#125;    spec.initContainers&#123;init-myservice&#125;     Normal        Started       Started container with docker id 5ced34a04634</span><br><span class="line">$ kubectl logs myapp-pod -c init-myservice # Inspect the first init container</span><br><span class="line">$ kubectl logs myapp-pod -c init-mydb      # Inspect the second init container</span><br></pre></td></tr></table></figure></p>
<p>一旦我们启动mydb和myservice服务，我们就可以看到Init Containers完成并myapp-pod创建了：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f services.yaml</span><br><span class="line">service/myservice created</span><br><span class="line">service/mydb created</span><br><span class="line">$ kubectl get -f myapp.yaml</span><br><span class="line">NAME        READY     STATUS    RESTARTS   AGE</span><br><span class="line">myapp-pod   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">9</span>m</span><br></pre></td></tr></table></figure></p>
<p>这个例子非常简单，但应该为您创建自己的Init容器提供一些灵感。</p>
<h5 id="详细的行为"><a href="#详细的行为" class="headerlink" title="详细的行为"></a>详细的行为</h5><p>在Pod启动期间，初始化网络和卷后，初始容器将按顺序启动。每个Container必须在下一个Container启动之前成功退出。如果Container由于运行时未能启动或因故障退出，则根据Pod重试<code>restartPolicy</code>。但是，如果将Pod <code>restartPolicy</code>设置为Always，则Init Containers将使用 <code>RestartPolicy</code>OnFailure。</p>
<p>在<code>Ready</code>所有Init容器都成功之前，Pod不能。Init容器上的端口不在服务下聚合。正在初始化的Pod处于<code>Pending</code>状态，但应将条件<code>Initializing</code>设置为true。</p>
<p>如果<a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#pod-restart-reasons" target="_blank" rel="noopener">重新启动</a> Pod，则必须再次执行所有Init Containers。</p>
<p>Init容器规范的更改仅限于容器镜像字段。更改Init Container镜像字段相当于重新启动Pod。</p>
<p>由于Init Containers可以重新启动，重试或重新执行，因此Init Container代码应该是幂等的。特别是，<code>EmptyDirs</code> 应该为输出文件已经存在的可能性准备写入文件的代码。</p>
<p>Init Containers具有应用Container的所有字段。但是，Kubernetes禁止<code>readinessProbe</code>使用，因为Init Containers无法定义与完成不同的准备情况。这在验证期间强制执行。</p>
<p>使用<code>activeDeadlineSeconds</code>上pod<code>livenessProbe</code>的容器，以防止初始化容器从永远失败。活动截止日期包括Init Containers。</p>
<p>Pod中每个应用程序和Init容器的名称必须是唯一的; 任何与另一个名称共享名称的Container都会引发验证错误。</p>
<h6 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h6><p>给定Init Containers的排序和执行，适用以下资源使用规则：</p>
<ul>
<li>在所有Init Containers上定义的任何特定资源请求或限制的最高值是有效的init请求/限制</li>
<li>Pod 对资源的有效请求/限制是以下值中的较高者：</li>
<li>资源的所有应用容器请求/限制的总和</li>
<li>资源的有效init请求/限制</li>
<li>调度是基于有效的请求/限制完成的，这意味着Init Containers可以预留在Pod生命周期内未使用的初始化资源。</li>
<li>Pod的有效QoS层的QoS层是Init Containers和app容器的QoS层。</li>
</ul>
<p>根据有效的Pod请求和限制应用配额和限制。</p>
<p>Pod级别cgroup基于有效的Pod请求和限制，与调度程序相同。</p>
<h6 id="Pod重启原因"><a href="#Pod重启原因" class="headerlink" title="Pod重启原因"></a>Pod重启原因</h6><p>Pod可以重新启动，导致重新执行Init Containers，原因如下：</p>
<ul>
<li>用户更新PodSpec，导致Init容器映像发生更改。App Container图像更改仅重新启动应用程序Container。</li>
<li>Pod基础架构容器重新启动。这种情况并不常见，必须由对节点具有root访问权限的人员来完成。</li>
<li>Pod中的所有容器都被终止，同时<code>restartPolicy</code>设置为Always，强制重新启动，并且Init Container完成记录由于垃圾回收而丢失。</li>
</ul>
<h5 id="支持和兼容性"><a href="#支持和兼容性" class="headerlink" title="支持和兼容性"></a>支持和兼容性</h5><p>具有Apiserver 1.6.0或更高版本的群集支持使用该<code>.spec.initContainers</code>字段的Init Containers 。以前的版本使用alpha或beta注释支持Init Containers。该<code>.spec.initContainers</code>字段还镜像为alpha和beta注释，以便Kubelet 1.3.0或更高版本可以执行Init Containers，因此版本1.6 apiserver可以安全地回滚到1.5.x版，而不会丢失现有创建的pod的Init Container功能。</p>
<p>在Apiserver和Kubelet 1.8.0或更高版本中，删除了对alpha和beta注释的支持，需要从不推荐的注释转换到 <code>.spec.initContainers</code>字段。</p>
<p>此功能已在1.6中退出测试版。可以在应用程序<code>containers</code>阵列旁边的PodSpec中指定Init容器。beta注释值仍将受到尊重并覆盖PodSpec字段值，但是，它们在1.6和1.7中已弃用。在1.8中，不再支持注释，必须将其转换为PodSpec字段。</p>
<h4 id="Pod-Preset"><a href="#Pod-Preset" class="headerlink" title="Pod Preset"></a>Pod Preset</h4><p>此页面提供PodPresets的概述，PodPresets是在创建时将特定信息注入pod的对象。信息可以包括秘密，卷，卷安装和环境变量。</p>
<ul>
<li>了解Pod预设</li>
<li>这个怎么运作</li>
<li>启用Pod预设</li>
</ul>
<h5 id="了解Pod预设"><a href="#了解Pod预设" class="headerlink" title="了解Pod预设"></a>了解Pod预设</h5><p><code>Pod Preset</code>是一种API资源，用于在创建时将其他运行时需求注入Pod。您可以使用<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors" target="_blank" rel="noopener">标签选择器</a> 指定应用给定Pod预设的Pod。</p>
<p>使用Pod预设允许pod模板作者不必显式提供每个pod的所有信息。这样，使用特定服务的pod模板的作者不需要知道有关该服务的所有详细信息。</p>
<p>有关背景的更多信息，请参阅<a href="https://git.k8s.io/community/contributors/design-proposals/service-catalog/pod-preset.md" target="_blank" rel="noopener">PodPreset</a>的<a href="https://git.k8s.io/community/contributors/design-proposals/service-catalog/pod-preset.md" target="_blank" rel="noopener">设计方案</a>。</p>
<h5 id="这个怎么运作"><a href="#这个怎么运作" class="headerlink" title="这个怎么运作"></a>这个怎么运作</h5><p>Kubernetes提供了一个准入控制器（<code>PodPreset</code>），当启用时，它将Pod Presets应用于传入的pod创建请求。发生pod创建请求时，系统会执行以下操作：</p>
<ol>
<li>检索所有<code>PodPresets</code>可用的。</li>
<li>检查任何标签选择器是否<code>PodPreset</code>与正在创建的pod上的标签匹配。</li>
<li>尝试将所定义的各种资源合并<code>PodPreset</code>到正在创建的Pod中。</li>
<li>出错时，抛出一个记录pod上合并错误的事件，并创建pod 而不从中注入任何资源<code>PodPreset</code>。</li>
<li>注释生成的修改后的Pod规范，以指示它已被修改<code>PodPreset</code>。注释是形式的 <code>podpreset.admission.kubernetes.io/podpreset-&lt;pod-preset name&gt;: &quot;&lt;resource version&gt;&quot;</code>。</li>
</ol>
<p>每个Pod可以匹配零个或多个Pod Presets; 并且每个<code>PodPreset</code>都可以应用于零个或多个pod。当 <code>PodPreset</code>应用于一个或多个Pod时，Kubernetes会修改Pod规范。对于更改<code>Env</code>，<code>EnvFrom</code>和 <code>VolumeMounts</code>，Kubernetes修改在波德所有容器容器规范; 对于更改<code>Volume</code>，Kubernetes修改Pod规范。</p>
<blockquote>
<p>注意： Pod Preset能够<code>.spec.containers</code>在适当的时候修改Pod规范中的字段。没有从POD预置资源定义将被应用到initContainers外地。</p>
</blockquote>
<h6 id="禁用特定Pod的Pod预设"><a href="#禁用特定Pod的Pod预设" class="headerlink" title="禁用特定Pod的Pod预设"></a>禁用特定Pod的Pod预设</h6><p>在某些情况下，您希望Pod不会被任何Pod Preset突变改变。在这些情况下，您可以在表单的Pod Spec中添加注释：<code>podpreset.admission.kubernetes.io/exclude: &quot;true&quot;</code>。</p>
<h5 id="启用Pod预设"><a href="#启用Pod预设" class="headerlink" title="启用Pod预设"></a>启用Pod预设</h5><p>要在群集中使用Pod Presets，您必须确保以下内容：</p>
<ol>
<li>您已启用API类型<code>settings.k8s.io/v1alpha1/podpreset</code>。例如，这可以通过包含<code>settings.k8s.io/v1alpha1=true</code>在<code>--runtime-config</code>API服务器的选项中来完成。在minikube中，<code>--extra-config=apiserver.runtime-config=settings.k8s.io/v1alpha1=true</code>在启动集群时添加此标志 。</li>
<li>您已启用准入控制器<code>PodPreset</code>。执行此操作的一种方法是包含<code>PodPreset</code>在<code>--enable-admission-plugins</code>为API服务器指定的选项值中。在minikube中，<code>--extra-config=apiserver.enable-admission-plugins=Initializers,NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodPreset</code> 在启动集群时添加此标志 。</li>
<li>您已通过<code>PodPreset</code>在将使用的命名空间中创建对象来定义Pod预设。</li>
</ol>
<h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>本指南适用于想要构建高可用性应用程序的应用程序所有者，因此需要了解Pod可能发生的中断类型。</p>
<p>它也适用于希望执行自动群集操作的群集管理员，例如升级和自动缩放群集。</p>
<ul>
<li>自愿和非自愿中断</li>
<li>处理中断</li>
<li>中断预算如何运作</li>
<li>PDB示例</li>
<li>分离群集所有者和应用程序所有者角色</li>
<li>如何在群集上执行破坏性操作</li>
</ul>
<h5 id="自愿和非自愿中断"><a href="#自愿和非自愿中断" class="headerlink" title="自愿和非自愿中断"></a>自愿和非自愿中断</h5><p>在有人（一个人或一个控制器）摧毁它们，或者存在不可避免的硬件或系统软件错误之前，Pod不会消失。</p>
<p>我们将这些不可避免的案例称为对应用程序的非自愿中断。例如：</p>
<ul>
<li>支持节点的物理机的硬件故障</li>
<li>集群管理员错误地删除了VM（实例）</li>
<li>云提供商或虚拟机管理程序故障使虚拟机消失</li>
<li>内核恐慌</li>
<li>由于群集网络分区，节点从群集中消失</li>
<li>由于节点<a href="https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/" target="_blank" rel="noopener">资源不足</a>而导致pod被驱逐。</li>
</ul>
<p>除资源不足外，大多数用户都应熟悉所有这些条件; 它们不是Kubernetes特有的。</p>
<p>我们将其他案件称为自愿中断。其中包括应用程序所有者启动的操作和群集管理员启动的操作。典型应用程序所有者操作包</p>
<ul>
<li>删除管理pod的部署或其他控制器</li>
<li>更新部署的pod模板导致重新启动</li>
<li>直接删除pod（例如意外）</li>
</ul>
<p>群集管理员操作包括：<br>-<a href="https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/" target="_blank" rel="noopener"> 耗尽节点</a>进行修复或升级。</p>
<ul>
<li>从群集中排出节点以缩小群集（了解<a href="https://kubernetes.io/docs/tasks/administer-cluster/cluster-management/#cluster-autoscaler" target="_blank" rel="noopener">群集自动缩放</a> ）。</li>
<li>从节点中删除pod以允许其他内容适合该节点。</li>
</ul>
<p>这些操作可以由集群管理员直接执行，也可以由集群管理员或集群主机提供商自动运行。</p>
<p>请咨询您的集群管理员或咨询您的云提供商或分发文档，以确定是否为您的集群启用了任何自愿中断源。如果未启用，则可以跳过创建Pod中断预算。</p>
<h5 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h5><p>以下是一些缓解非自愿中断的方法：</p>
<ul>
<li>确保您的pod <a href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-ram-container" target="_blank" rel="noopener">请求所需的资源</a>。</li>
<li>如果需要更高的可用性，请复制应用程序。（了解运行复制的 <a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/" target="_blank" rel="noopener">无状态</a> 和<a href="https://kubernetes.io/docs/tasks/run-application/run-replicated-stateful-application/" target="_blank" rel="noopener">有状态</a>应用程序。）</li>
<li>为了在运行复制的应用程序时获得更高的可用性，可以跨机架（使用<a href="https://kubernetes.io/docs/user-guide/node-selection/#inter-pod-affinity-and-anti-affinity-beta-feature" target="_blank" rel="noopener">反关联</a>）或跨区域（如果使用 <a href="https://kubernetes.io/docs/setup/multiple-zones" target="_blank" rel="noopener">多区域群集</a>）分布应用程序 。</li>
</ul>
<p>自愿中断的频率各不相同。在基本的Kubernetes集群上，根本没有自愿中断。但是，您的群集管理员或托管服务提供商可能会运行一些导致自愿中断的其他服务。例如，推出节点软件更新可能会导致自愿中断。此外，群集（节点）自动缩放的某些实现可能会导致自动中断以进行碎片整理和压缩节点。您的集群管理员或托管服务提供商应记录预期的自愿中断级别（如果有）。</p>
<p>Kubernetes提供的功能可以帮助您在频繁的自愿中断的同时运行高可用性应用程序。我们将这组功能称为 中断预算。</p>
<h5 id="中断预算如何运作"><a href="#中断预算如何运作" class="headerlink" title="中断预算如何运作"></a>中断预算如何运作</h5><p>应用程序所有者可以<code>PodDisruptionBudget</code>为每个应用程序创建一个对象（PDB）。PDB限制复制应用程序的pod的数量，这些pod与自愿中断同时发生故障。例如，基于仲裁的应用程序希望确保运行的副本数量永远不会低于仲裁所需的数量。Web前端可能希望确保服务负载的副本数量永远不会低于总数的某个百分比。</p>
<p>集群管理器和托管提供商应使用通过调用<a href="https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/#the-eviction-api" target="_blank" rel="noopener">Eviction API</a> 而不是直接删除pod来遵守Pod Disruption Budgets的工具。示例是<code>kubectl drain</code>命令和Kubernetes-on-GCE集群升级脚本（<code>cluster/gce/upgrade.sh</code>）。</p>
<p>当集群管理员想要耗尽节点时，他们使用<code>该kubectl drain</code>命令。该工具试图驱逐机器上的所有pod。可以暂时拒绝逐出请求，并且该工具定期重试所有失败的请求，直到所有pod终止，或者直到达到可配置的超时。</p>
<p>PDB指定应用程序可以容忍的副本数量，相对于预期的副本数量。例如，具有部署<code>.spec.replicas: 5</code>应该在任何给定时间具有5个pod。如果其PDB允许一次有4个，则Eviction API将允许一次自动中断一个而不是两个pod。</p>
<p>组成应用程序的pod组使用标签选择器指定，与应用程序控制器使用的标签选择器相同（部署，有状态集等）。</p>
<p>“预期”数量的pod是根据<code>.spec.replicaspods</code>控制器计算出来的。使用<code>.metadata.ownerReferences</code>对象的pod从pod中发现控制器。</p>
<p>PDB不能防止<a href="https://kubernetes.io/docs/concepts/workloads/pods/disruptions/#voluntary-and-involuntary-disruptions" target="_blank" rel="noopener">非自愿中断</a>发生，但它们确实违背了预算。</p>
<p>由于滚动升级到应用程序而被删除或不可用的Pod确实会计入中断预算，但是在执行滚动升级时，控制器（如部署和有状态集）不受PDB限制 - 在应用程序更新期间处理故障在控制器规范中。（了解有关<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#updating-a-deployment" target="_blank" rel="noopener">更新部署的信息</a>。）</p>
<p>当吊舱使用驱逐API逐出，它是正常终止（见 <code>terminationGracePeriodSeconds</code>在<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#podspec-v1-core" target="_blank" rel="noopener">PodSpec</a>。）</p>
<p>PDB示例<br>考虑具有3个节点的群集中，<code>node-1</code>通过<code>node-3</code>。群集正在运行多个应用程序。其中一人有3个副本最初称 <code>pod-a</code>，<code>pod-b</code>和<code>pod-c</code>。<code>pod-x</code>还示出了另一个没有PDB的不相关的pod。最初，pod的布局如下：</p>
<table>
<thead>
<tr>
<th>节点-1</th>
<th>节点-2-</th>
<th>节点-3-</th>
</tr>
</thead>
<tbody>
<tr>
<td>pod-a 可用</td>
<td>pod-b 可用</td>
<td>pod-c 可用</td>
</tr>
<tr>
<td>pod-x 可用</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>所有3个pod都是部署的一部分，它们共同拥有一个PDB，要求所有3个pod中至少有2个可用。</p>
<p>例如，假设集群管理员想要重新启动到新的内核版本来修复内核中的错误。群集管理员首先尝试<code>node-1</code>使用该<code>kubectl drain</code>命令消耗。该工具试图驱逐<code>pod-a</code>和<code>pod-x</code>。这立即成功。两个pod同时进入该<code>terminating</code>。这使集群处于以下状态</p>
<table>
<thead>
<tr>
<th>节点-1 耗尽</th>
<th>节点-2-</th>
<th>节点-3-</th>
</tr>
</thead>
<tbody>
<tr>
<td>pod-a  终止</td>
<td>pod-b 可用</td>
<td>pod-c 可用</td>
</tr>
<tr>
<td>pod-x  终止</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>部署注意到其中一个pod正在终止，因此它会创建一个名为的替换<code>pod-d</code>。由于<code>node-1</code>是封锁的，它落在另一个节点上。还创造<code>pod-y</code>了一些替代品<code>pod-x</code>。</p>
<p>（注意：对于一个StatefulSet，<code>pod-a</code>它将被称为类似的东西<code>pod-1</code>，需要在它被替换之前完全终止，也可以被调用，<code>pod-1</code>但是可以创建不同的UID。否则，该示例也适用于StatefulSet。）</p>
<p>现在集群处于以下状态：</p>
<table>
<thead>
<tr>
<th>节点-1 耗尽</th>
<th>节点-2-</th>
<th>节点-3-</th>
</tr>
</thead>
<tbody>
<tr>
<td>pod-a  终止</td>
<td>pod-b 可用</td>
<td>pod-c 可用</td>
</tr>
<tr>
<td>pod-x  终止</td>
<td>pod-b 开始</td>
<td>POD-Y</td>
</tr>
</tbody>
</table>
<p>在某些时候，pod终止，集群看起来像这样：</p>
<table>
<thead>
<tr>
<th>节点-1 耗尽</th>
<th>节点-2-</th>
<th>节点-3-</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>pod-b 可用</td>
<td>pod-c 可用</td>
</tr>
<tr>
<td></td>
<td>pod-b 开始</td>
<td>POD-Y</td>
</tr>
</tbody>
</table>
<p> 此时，如果一个不耐烦的集群管理员试图耗尽，<code>node-2</code>或者 <code>node-3</code>排除命令将阻塞，因为部署只有2个可用的pod，并且其PDB至少需要2.经过一段时间后，<code>pod-d</code>变为可用。</p>
<p>群集状态现在看起来像这样：</p>
<table>
<thead>
<tr>
<th>节点-1 耗尽</th>
<th>节点-2-</th>
<th>节点-3-</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>pod-b 可用</td>
<td>pod-c 可用</td>
</tr>
<tr>
<td></td>
<td>pod-b 可用</td>
<td>POD-Y</td>
</tr>
</tbody>
</table>
<p> 现在，集群管理员试图耗尽<code>node-2</code>。drain命令将尝试以某种顺序驱逐两个pod，<code>pod-b</code>先说然后再说 <code>pod-d</code>。它将成功驱逐<code>pod-b</code>。但是，当它试图逐出时<code>pod-d</code>，它将被拒绝，因为这将只留下一个可用于部署的pod。</p>
<p>部署创建了<code>pod-b</code>被叫的替代品<code>pod-e</code>。因为集群中没有足够的资源来安排 <code>pod-e</code>排水将再次阻塞。群集可能最终处于此状态：</p>
<table>
<thead>
<tr>
<th>节点-1 耗尽</th>
<th>节点-2-</th>
<th>节点-3-</th>
<th>没有节点</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>pod-b 可用</td>
<td>pod-c 可用</td>
<td>pod-e 待定</td>
</tr>
<tr>
<td></td>
<td>pod-b 可用</td>
<td>POD-Y</td>
<td></td>
</tr>
</tbody>
</table>
<p> 此时，集群管理员需要将节点添加回集群以继续升级。</p>
<p>你可以看到Kubernetes如何改变发生中断的速度，根据：</p>
<ul>
<li>应用程序需要多少个副本</li>
<li>优雅地关闭实例需要多长时间</li>
<li>启动新实例需要多长时间</li>
<li>控制器的类型</li>
<li>集群的资源容量</li>
</ul>
<h5 id="分离群集所有者和应用程序所有者角色"><a href="#分离群集所有者和应用程序所有者角色" class="headerlink" title="分离群集所有者和应用程序所有者角色"></a>分离群集所有者和应用程序所有者角色</h5><p>通常，将群集管理器和应用程序所有者视为彼此知之甚少的单独角色很有用。在这些情况下，这种职责分离可能有意义：</p>
<ul>
<li>当有许多应用程序团队共享Kubernetes集群时，角色有自然的专业化</li>
<li>当第三方工具或服务用于自动化集群管理时</li>
</ul>
<p>Pod Disruption Budgets通过在角色之间提供接口来支持这种角色分离。</p>
<p>如果您的组织中没有这样的责任分离，则可能不需要使用Pod Disruption Budgets。</p>
<h5 id="如何在群集上执行破坏性操作"><a href="#如何在群集上执行破坏性操作" class="headerlink" title="如何在群集上执行破坏性操作"></a>如何在群集上执行破坏性操作</h5><p>如果您是群集管理员，并且需要对群集中的所有节点执行中断操作，例如节点或系统软件升级，则可以使用以下选项：</p>
<ul>
<li>在升级期间接受停机时间。</li>
<li>故障转移到另一个完整的副本群集。<ul>
<li>没有停机时间，但对于重复的节点以及人类协调切换的努力可能都是昂贵的。</li>
</ul>
</li>
<li>编写容错中断应用程序并使用PDB。<ul>
<li>没有停机时间。</li>
<li>最小的资源重复。</li>
<li>允许更多自动化群集管理。</li>
<li>编写容忍破坏性的应用程序很棘手，但容忍自愿中断的工作很大程度上与支持自动缩放和容忍非自愿中断的工作重叠。</li>
</ul>
</li>
</ul>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h4><p>ReplicaSet是下一代复制控制器。现在ReplicaSet和 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" target="_blank" rel="noopener">Replication Controller</a>之间的唯一区别是选择器支持。ReplicaSet支持新的基于集合的选择器要求，如<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors" target="_blank" rel="noopener">标签用户指南</a>中所述， 而Replication Controller仅支持基于等同的选择器要求。</p>
<ul>
<li>如何使用ReplicaSet</li>
<li>何时使用ReplicaSet</li>
<li>例</li>
<li>编写副本集规范</li>
<li>使用ReplicaSet</li>
<li>ReplicaSet的替代品</li>
</ul>
<h5 id="如何使用ReplicaSet"><a href="#如何使用ReplicaSet" class="headerlink" title="如何使用ReplicaSet"></a>如何使用ReplicaSet</h5><p>大多数<a href="https://kubernetes.io/docs/user-guide/kubectl/" target="_blank" rel="noopener">kubectl</a>支持复制控制器的命令也支持ReplicaSet。<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rolling-update" target="_blank" rel="noopener">rolling-update</a>命令是一个例外 。如果您想要滚动更新功能，请考虑使用部署。此外， <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rolling-update" target="_blank" rel="noopener">rolling-update</a>命令是必需的，而Deployments是声明性的，因此我们建议通过<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rollout" target="_blank" rel="noopener">rollout</a>命令使用Deployments 。</p>
<p>虽然ReplicaSet可以独立使用，但今天它主要被 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployments</a>用作协调pod创建，删除和更新的机制。使用“部署”时，您不必担心管理它们创建的副本集。部署拥有并管理其ReplicaSet。</p>
<h5 id="何时使用ReplicaSet"><a href="#何时使用ReplicaSet" class="headerlink" title="何时使用ReplicaSet"></a>何时使用ReplicaSet</h5><p>ReplicaSet确保在任何给定时间运行指定数量的pod副本。但是，Deployment是一个更高级别的概念，它管理ReplicaSet并为pod提供声明性更新以及许多其他有用的功能。因此，除非您需要自定义更新编排或根本不需要更新，否则我们建议使用部署而不是直接使用ReplicaSet。</p>
<p>这实际上意味着您可能永远不需要操作ReplicaSet对象：改为使用Deployment，并在spec部分中定义您的应用程序。</p>
<p>例<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#controllers/frontend.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">guestbook</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># modify replicas according to your case</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">    matchExpressions:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">&#123;key:</span> <span class="string">tier,</span> <span class="attr">operator:</span> <span class="string">In,</span> <span class="attr">values:</span> <span class="string">[frontend]&#125;</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">guestbook</span></span><br><span class="line"><span class="attr">        tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">php-redis</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">gcr.io/google_samples/gb-frontend:v3</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">100</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">GET_HOSTS_FROM</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">dns</span></span><br><span class="line">          <span class="comment"># If your cluster config does not include a dns service, then to</span></span><br><span class="line">          <span class="comment"># instead access environment variables to find service host</span></span><br><span class="line">          <span class="comment"># info, comment out the 'value: dns' line above, and uncomment the</span></span><br><span class="line">          <span class="comment"># line below.</span></span><br><span class="line">          <span class="comment"># value: env</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>将此清单保存<code>frontend.yaml</code>到Kubernetes集群并将其提交到Kubernetes集群应该创建已定义的ReplicaSet及其管理的pod。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="keyword">create</span> -f <span class="keyword">http</span>://k8s.io/examples/controllers/frontend.yaml</span><br><span class="line">replicaset.apps/frontend created</span><br><span class="line">$ kubectl <span class="keyword">describe</span> rs/frontend</span><br><span class="line"><span class="keyword">Name</span>:		frontend</span><br><span class="line">Namespace:	<span class="keyword">default</span></span><br><span class="line">Selector:	<span class="keyword">tier</span>=frontend,<span class="keyword">tier</span> <span class="keyword">in</span> (frontend)</span><br><span class="line">Labels:		app=guestbook</span><br><span class="line">		<span class="keyword">tier</span>=frontend</span><br><span class="line">Annotations:	&lt;<span class="keyword">none</span>&gt;</span><br><span class="line">Replicas:	<span class="number">3</span> <span class="keyword">current</span> / <span class="number">3</span> desired</span><br><span class="line">Pods <span class="keyword">Status</span>:	<span class="number">3</span> Running / <span class="number">0</span> Waiting / <span class="number">0</span> Succeeded / <span class="number">0</span> <span class="keyword">Failed</span></span><br><span class="line">Pod <span class="keyword">Template</span>:</span><br><span class="line">  Labels:       app=guestbook</span><br><span class="line">                <span class="keyword">tier</span>=frontend</span><br><span class="line">  Containers:</span><br><span class="line">   php-redis:</span><br><span class="line">    Image:      gcr.io/google_samples/gb-frontend:v3</span><br><span class="line">    Port:       <span class="number">80</span>/TCP</span><br><span class="line">    Requests:</span><br><span class="line">      cpu:      <span class="number">100</span>m</span><br><span class="line">      <span class="keyword">memory</span>:   <span class="number">100</span>Mi</span><br><span class="line">    Environment:</span><br><span class="line">      GET_HOSTS_FROM:   dns</span><br><span class="line">    Mounts:             &lt;<span class="keyword">none</span>&gt;</span><br><span class="line">  Volumes:              &lt;<span class="keyword">none</span>&gt;</span><br><span class="line"><span class="keyword">Events</span>:</span><br><span class="line">  FirstSeen    LastSeen    <span class="keyword">Count</span>    <span class="keyword">From</span>                SubobjectPath    <span class="keyword">Type</span>        Reason            Message</span><br><span class="line">  <span class="comment">---------    --------    -----    ----                -------------    --------    ------            -------</span></span><br><span class="line">  <span class="number">1</span>m           <span class="number">1</span>m          <span class="number">1</span>        &#123;replicaset-controller &#125;             <span class="keyword">Normal</span>      SuccessfulCreate  Created pod: frontend-qhloh</span><br><span class="line">  <span class="number">1</span>m           <span class="number">1</span>m          <span class="number">1</span>        &#123;replicaset-controller &#125;             <span class="keyword">Normal</span>      SuccessfulCreate  Created pod: frontend-dnjpy</span><br><span class="line">  <span class="number">1</span>m           <span class="number">1</span>m          <span class="number">1</span>        &#123;replicaset-controller &#125;             <span class="keyword">Normal</span>      SuccessfulCreate  Created pod: frontend<span class="number">-9</span>si5l</span><br><span class="line">$ kubectl <span class="keyword">get</span> pods</span><br><span class="line"><span class="keyword">NAME</span>             READY     <span class="keyword">STATUS</span>    RESTARTS   AGE</span><br><span class="line">frontend<span class="number">-9</span>si5l   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>m</span><br><span class="line">frontend-dnjpy   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>m</span><br><span class="line">frontend-qhloh   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">1</span>m</span><br></pre></td></tr></table></figure></p>
<h5 id="编写副本集规范"><a href="#编写副本集规范" class="headerlink" title="编写副本集规范"></a>编写副本集规范</h5><p>与所有其他Kubernetes API对象，一个ReplicaSet需要<code>apiVersion</code>，<code>kind</code>和<code>metadata</code>领域。有关使用清单的一般信息，请参阅<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">使用kubectl进行对象管理</a>。</p>
<p>ReplicaSet还需要一个<a href="https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status" target="_blank" rel="noopener"><code>.spec</code>部分</a>。</p>
<h6 id="Pod模板-1"><a href="#Pod模板-1" class="headerlink" title="Pod模板"></a>Pod模板</h6><p>这<code>.spec.template</code>是唯一必需的领域<code>.spec</code>。这<code>.spec.template</code>是一个 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#pod-templates" target="_blank" rel="noopener">pod模板</a>。它与pod具有完全相同的架构 ，除了它是嵌套的并且没有<code>apiVersion</code>或<code>kind</code>。</p>
<p>除了pod的必填字段外，ReplicaSet中的pod模板还必须指定适当的标签和适当的重新启动策略。</p>
<p>对于标签，请确保不与其他控制器重叠。有关更多信息，请参阅<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/#pod-selector" target="_blank" rel="noopener">pod选择器</a>。</p>
<p>对于<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy" target="_blank" rel="noopener">重新启动策略</a>，唯一允许的值<code>.spec.template.spec.restartPolicy</code>是<code>Always</code>，这是默认值。</p>
<p>对于本地容器重新启动，ReplicaSet委托给节点上的代理程序，例如<a href="https://kubernetes.io/docs/admin/kubelet/" target="_blank" rel="noopener">Kubelet</a>或Docker。</p>
<h6 id="Pod选择器"><a href="#Pod选择器" class="headerlink" title="Pod选择器"></a>Pod选择器</h6><p>该<code>.spec.selector</code>字段是<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" target="_blank" rel="noopener">标签选择器</a>。ReplicaSet使用与选择器匹配的标签管理所有pod。它不区分它创建或删除的pod以及另一个人或进程创建或删除的pod。这允许替换ReplicaSet而不影响正在运行的pod。</p>
<p>在<code>.spec.template.metadata.labels</code>必须匹配<code>.spec.selector</code>，否则会被API被拒绝。</p>
<p>在Kubernetes 1.9中，<code>apps/v1</code>ReplicaSet类型的API版本是当前版本，默认情况下已启用。<code>apps/v1beta2</code>不推荐使用API版本。</p>
<p>此外，您通常不应创建任何标签与此选择器匹配的pod，可以直接与另一个ReplicaSet一起创建，也可以与其他控制器（如Deployment）一起创建。如果这样做，ReplicaSet会认为它创建了其他pod。Kubernetes并没有阻止你这样做。</p>
<p>如果最终有多个具有重叠选择器的控制器，则必须自己管理删除。</p>
<h6 id="副本集上的标签"><a href="#副本集上的标签" class="headerlink" title="副本集上的标签"></a>副本集上的标签</h6><p>ReplicaSet本身可以有标签（<code>.metadata.labels</code>）。通常，您可以将它们设置为相同<code>.spec.template.metadata.labels</code>。但是，允许它们不同，并且<code>.metadata.labels</code>不会影响ReplicaSet的行为。</p>
<h6 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h6><p>您可以通过设置指定应同时运行的pod数量<code>.spec.replicas</code>。在任何时间运行的数字可能更高或更低，例如，如果副本只是增加或减少，或者如果正常关闭吊舱，并且提前开始更换。</p>
<p>如果未指定<code>.spec.replicas</code>，则默认为1。</p>
<h5 id="使用ReplicaSet"><a href="#使用ReplicaSet" class="headerlink" title="使用ReplicaSet"></a>使用ReplicaSet</h5><h6 id="删除ReplicaSet及其Pod"><a href="#删除ReplicaSet及其Pod" class="headerlink" title="删除ReplicaSet及其Pod"></a>删除ReplicaSet及其Pod</h6><p>要删除ReplicaSet及其所有Pod，请使用<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#delete" target="_blank" rel="noopener"><code>kubectl delete</code></a>。该<a href="https://kubernetes.io/docs/concepts/workloads/controllers/garbage-collection/" target="_blank" rel="noopener">垃圾收集器</a>在默认情况下会自动删除所有相关的荚。</p>
<p>使用REST API或<code>client-go</code>库时，必须设置<code>propagationPolicy</code>为<code>Background</code>或<code>Foreground</code>删除选项。例如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">kubectl</span> proxy <span class="comment">--port=8080</span></span><br><span class="line"><span class="title">curl</span> -<span class="type">X</span> <span class="type">DELETE</span>  'localhost:<span class="number">8080</span>/apis/extensions/v1beta1/namespaces/<span class="keyword">default</span>/replicasets/frontend' \</span><br><span class="line">&gt; -d '&#123;<span class="string">"kind"</span>:<span class="string">"DeleteOptions"</span>,<span class="string">"apiVersion"</span>:<span class="string">"v1"</span>,<span class="string">"propagationPolicy"</span>:<span class="string">"Foreground"</span>&#125;' \</span><br><span class="line">&gt; -<span class="type">H</span> <span class="string">"Content-Type: application/json"</span></span><br></pre></td></tr></table></figure></p>
<h6 id="仅删除副本集"><a href="#仅删除副本集" class="headerlink" title="仅删除副本集"></a>仅删除副本集</h6><p>您可以删除副本集，而不会影响使用<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#delete" target="_blank" rel="noopener"><code>kubectl delete</code></a>该<code>--cascade=false</code>选项的任何pod 。使用REST API或<code>client-go</code>库时，必须设置<code>propagationPolicy</code>为<code>Orphan</code>，例如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">kubectl</span> proxy <span class="comment">--port=8080</span></span><br><span class="line"><span class="title">curl</span> -<span class="type">X</span> <span class="type">DELETE</span>  'localhost:<span class="number">8080</span>/apis/extensions/v1beta1/namespaces/<span class="keyword">default</span>/replicasets/frontend' \</span><br><span class="line">&gt; -d '&#123;<span class="string">"kind"</span>:<span class="string">"DeleteOptions"</span>,<span class="string">"apiVersion"</span>:<span class="string">"v1"</span>,<span class="string">"propagationPolicy"</span>:<span class="string">"Orphan"</span>&#125;' \</span><br><span class="line">&gt; -<span class="type">H</span> <span class="string">"Content-Type: application/json"</span></span><br></pre></td></tr></table></figure></p>
<p>删除原始文件后，您可以创建一个新的ReplicaSet来替换它。只要旧的和新<code>.spec.selector</code>的相同，那么新的将采用旧的豆荚。但是，它不会做任何努力使现有的pod匹配一个新的，不同的pod模板。要以受控方式将pod更新为新规范，请使用<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/#rolling-updates" target="_blank" rel="noopener">滚动更新</a>。</p>
<h6 id="从副本集隔离pod"><a href="#从副本集隔离pod" class="headerlink" title="从副本集隔离pod"></a>从副本集隔离pod</h6><p>可以通过更改标签来从ReplicaSet的目标集中删除Pod。此技术可用于从服务中删除pod以进行调试，数据恢复等。以这种方式删除的Pod将自动替换（假设副本的数量也未更改）。</p>
<h6 id="缩放副本集"><a href="#缩放副本集" class="headerlink" title="缩放副本集"></a>缩放副本集</h6><p>只需更新<code>.spec.replicas</code>字段即可轻松扩展或缩小ReplicaSet 。ReplicaSet控制器确保具有匹配标签选择器的所需数量的pod可用且可操作。</p>
<h6 id="ReplicaSet作为水平Pod自动缩放器目标"><a href="#ReplicaSet作为水平Pod自动缩放器目标" class="headerlink" title="ReplicaSet作为水平Pod自动缩放器目标"></a>ReplicaSet作为水平Pod自动缩放器目标</h6><p>ReplicaSet也可以是 <a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" target="_blank" rel="noopener">Horizontal Pod Autoscalers (HPA)</a>的目标 。也就是说，HPA可以自动缩放ReplicaSet。以下是针对我们在上一个示例中创建的ReplicaSet的示例HPA。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#controllers/hpa-rs.yaml </span></span><br><span class="line"><span class="symbol">apiVersion:</span> autoscaling/v1</span><br><span class="line"><span class="symbol">kind:</span> HorizontalPodAutoscaler</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  name:</span> frontend-scaler</span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  scaleTargetRef:</span></span><br><span class="line"><span class="symbol">    kind:</span> ReplicaSet</span><br><span class="line"><span class="symbol">    name:</span> frontend</span><br><span class="line"><span class="symbol">  minReplicas:</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">  maxReplicas:</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">  targetCPUUtilizationPercentage:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure></p>
<p>将此清单保存<code>hpa-rs.yaml</code>到Kubernetes集群并将其提交到Kubernetes集群应该创建定义的HPA，该HPA根据复制的pod的CPU使用情况自动调整目标ReplicaSet。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f https:<span class="regexp">//</span>k8s.io<span class="regexp">/examples/</span>controllers<span class="regexp">/hpa-rs.yaml</span></span><br></pre></td></tr></table></figure></p>
<p>或者，您可以使用该<code>kubectl autoscale</code>命令来完成相同的操作（并且它更容易！）<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl autoscale rs frontend <span class="attribute">--max</span>=10</span><br></pre></td></tr></table></figure></p>
<h5 id="ReplicaSet的替代品"><a href="#ReplicaSet的替代品" class="headerlink" title="ReplicaSet的替代品"></a>ReplicaSet的替代品</h5><h6 id="部署（推荐）"><a href="#部署（推荐）" class="headerlink" title="部署（推荐）"></a>部署（推荐）</h6><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener"><code>Deployment</code></a>是一个更高级别的API对象，它以类似的方式更新其底层ReplicaSet及其Pod <code>kubectl rolling-update</code>。如果您需要此滚动更新功能，则建议进行部署，因为<code>kubectl rolling-update</code>它们不同于声明式，服务器端，并具有其他功能。有关使用部署运行无状态应用程序的更多信息，请阅读使用部署<a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/" target="_blank" rel="noopener">运行无状态应用程序</a>。</p>
<h6 id="Bare-Pods"><a href="#Bare-Pods" class="headerlink" title="Bare Pods"></a>Bare Pods</h6><p>与用户直接创建pod的情况不同，ReplicaSet会替换因任何原因而被删除或终止的pod，例如在节点故障或破坏性节点维护（例如内核升级）的情况下。因此，即使您的应用程序只需要一个pod，我们也建议您使用ReplicaSet。可以想象它与流程主管类似，只是它监控多个节点上的多个pod而不是单个节点上的单个进程。ReplicaSet将本地容器重新启动委派给节点上的某个代理程序（例如，Kubelet或Docker）。</p>
<h6 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h6><p>对于预期会自行终止的pod（即批处理作业），请使用<a href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/" target="_blank" rel="noopener"><code>Job</code></a>而不是ReplicaSet。</p>
<h6 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h6><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener"><code>DaemonSet</code></a>对于提供机器级功能的pod，例如机器监视或机器日志记录，请使用ReplicaSet而不是ReplicaSet。这些pod的生命周期与机器生命周期相关：pod需要在其他pod启动之前在机器上运行，并且当机器准备好重新启动/关闭时可以安全终止。</p>
<h4 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h4><blockquote>
<p>注意：现在建议使用配置ReplicaSet的Deployment来设置复制。</p>
</blockquote>
<p>ReplicationController确保pod副本的指定数量的在任何一个时间运行。换句话说，ReplicationController确保一个pod或一组同类pod总是可用。</p>
<ul>
<li>ReplicationController的工作原理</li>
<li>运行示例ReplicationController</li>
<li>编写ReplicationController规范</li>
<li>使用ReplicationControllers</li>
<li>常见的使用模式</li>
<li>编写复制程序</li>
<li>ReplicationController的职责</li>
<li>API对象</li>
<li>ReplicationController的替代品</li>
<li>欲获得更多信息</li>
</ul>
<h5 id="ReplicationController的工作原理"><a href="#ReplicationController的工作原理" class="headerlink" title="ReplicationController的工作原理"></a>ReplicationController的工作原理</h5><p>如果存在太多pod，则ReplicationController将终止额外的pod。如果太少，ReplicationController将启动更多pod。与手动创建的pod不同，ReplicationController维护的pod在失败，删除或终止时会自动替换。例如，在内核升级等破坏性维护之后，会在节点上重新创建pod。因此，即使应用程序只需要一个pod，也应该使用ReplicationController。ReplicationController类似于进程管理程序，但是ReplicationController不是监视单个节点上的各个进程，而是监视多个节点上的多个pod。</p>
<p>在讨论中，ReplicationController通常缩写为“rc”或“rcs”，并且作为kubectl命令中的快捷方式。</p>
<p>一个简单的例子是创建一个ReplicationController对象，以无限期地可靠地运行Pod的一个实例。更复杂的用例是运行复制服务的几个相同副本，例如Web服务器。</p>
<h5 id="运行示例ReplicationController"><a href="#运行示例ReplicationController" class="headerlink" title="运行示例ReplicationController"></a>运行示例ReplicationController</h5><p>此示例ReplicationController配置运行nginx Web服务器的三个副本。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#controllers/replication.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>通过下载示例文件然后运行此命令来运行示例作业：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>kubectl create -f <span class="symbol">https:</span>/<span class="regexp">/k8s.io/examples</span><span class="regexp">/controllers/replication</span>.yaml</span><br><span class="line">replicationcontroller/nginx created</span><br></pre></td></tr></table></figure></p>
<p>使用以下命令检查ReplicationController的状态：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe replicationcontrollers/nginx</span><br><span class="line">Name:        nginx</span><br><span class="line">Namespace:   default</span><br><span class="line">Selector:    <span class="attribute">app</span>=nginx</span><br><span class="line">Labels:      <span class="attribute">app</span>=nginx</span><br><span class="line">Annotations:    &lt;none&gt;</span><br><span class="line">Replicas:    3 current / 3 desired</span><br><span class="line">Pods Status: 0 Running / 3 Waiting / 0 Succeeded / 0 Failed</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:       <span class="attribute">app</span>=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:              nginx</span><br><span class="line">    Port:               80/TCP</span><br><span class="line">    Environment:        &lt;none&gt;</span><br><span class="line">    Mounts:             &lt;none&gt;</span><br><span class="line">  Volumes:              &lt;none&gt;</span><br><span class="line">Events:</span><br><span class="line">  FirstSeen       LastSeen     Count    <span class="keyword">From</span>                        SubobjectPath   <span class="built_in"> Type </span>     Reason              Message</span><br><span class="line">  ---------       --------     -----    ----                        -------------    ----      ------              -------</span><br><span class="line">  20s             20s          1        &#123;replication-controller &#125;                    Normal    SuccessfulCreate    Created pod: nginx-qrm3m</span><br><span class="line">  20s             20s          1        &#123;replication-controller &#125;                    Normal    SuccessfulCreate    Created pod: nginx-3ntk0</span><br><span class="line">  20s             20s          1        &#123;replication-controller &#125;                    Normal    SuccessfulCreate    Created pod: nginx-4ok8v</span><br></pre></td></tr></table></figure></p>
<p>  这里创建了三个pod，但没有一个正在运行，可能是因为正在拉动图像。稍后，相同的命令可能会显示：<br>  <figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pods Status:   <span class="number"> 3 </span>Running /<span class="number"> 0 </span>Waiting /<span class="number"> 0 </span>Succeeded /<span class="number"> 0 </span>Failed</span><br></pre></td></tr></table></figure></p>
<p>要以机器可读的形式列出属于ReplicationController的所有pod，可以使用如下命令：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  $ <span class="attribute">pods</span>=$(kubectl <span class="builtin-name">get</span> pods <span class="attribute">--selector</span>=app=nginx <span class="attribute">--output</span>=jsonpath=&#123;.items<span class="built_in">..</span>metadata.name&#125;)</span><br><span class="line">echo <span class="variable">$pods</span></span><br><span class="line">nginx-3ntk0 nginx-4ok8v nginx-qrm3m</span><br></pre></td></tr></table></figure></p>
<p>这里，选择器与ReplicationController的选择器相同（在<code>kubectl describe</code>输出中看到 ，并以不同的形式显示<code>replication.yaml</code>。该<code>--output=jsonpath</code>选项指定一个表达式，它只从返回列表中的每个pod获取名称。</p>
<h5 id="编写ReplicationController规范"><a href="#编写ReplicationController规范" class="headerlink" title="编写ReplicationController规范"></a>编写ReplicationController规范</h5><p>与所有其他Kubernetes配置，一个ReplicationController需要<code>apiVersion</code>，<code>kind</code>和<code>metadata</code>领域。有关使用配置文件的一般信息，请参阅<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">对象管理</a>。</p>
<p>ReplicationController还需要一个<a href="https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status" target="_blank" rel="noopener"><code>.spec</code>部分</a>。</p>
<h6 id="Pod模板-2"><a href="#Pod模板-2" class="headerlink" title="Pod模板"></a>Pod模板</h6><p>这<code>.spec.template</code>是唯一必需的领域<code>.spec</code>。</p>
<p>这<code>.spec.template</code>是一个<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#pod-templates" target="_blank" rel="noopener">pod模板</a>。它与pod具有完全相同的架构，除了它是嵌套的并且没有<code>apiVersion</code>或<code>kind</code>。</p>
<p>除了Pod的必需字段之外，ReplicationController中的pod模板还必须指定适当的标签和适当的重新启动策略。对于标签，请确保不要与其他控制器重叠。请参阅<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#pod-selector" target="_blank" rel="noopener">pod选择器</a>。</p>
<p>只允许<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy" target="_blank" rel="noopener"><code>.spec.template.spec.restartPolicy</code></a>等于<code>Always</code>，如果未指定，则为默认值。</p>
<p>对于本地容器重新启动，ReplicationControllers委托给节点上的代理程序，例如<a href="https://kubernetes.io/docs/admin/kubelet/" target="_blank" rel="noopener"><code>Kubelet</code></a>或Docker。</p>
<h6 id="ReplicationController上的标签"><a href="#ReplicationController上的标签" class="headerlink" title="ReplicationController上的标签"></a>ReplicationController上的标签</h6><p>ReplicationController本身可以有labels（<code>.metadata.labels</code>）。通常，您可以将它们设置为相同<code>.spec.template.metadata.labels</code>; 如果<code>.metadata.labels</code>未指定，则默认为<code>.spec.template.metadata.labels</code>。但是，允许它们不同，并且<code>.metadata.labels</code>不会影响ReplicationController的行为。</p>
<h6 id="Pod选择器-1"><a href="#Pod选择器-1" class="headerlink" title="Pod选择器"></a>Pod选择器</h6><p>该<code>.spec.selector</code>字段是<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors" target="_blank" rel="noopener">标签选择器</a>。ReplicationController管理具有与选择器匹配的标签的所有pod。它不区分它创建或删除的pod以及另一个人或进程创建或删除的pod。这允许在不影响正在运行的pod的情况下替换ReplicationController。</p>
<p>如果指定，则<code>.spec.template.metadata.labels</code>必须等于<code>.spec.selector</code>，否则将被API拒绝。如果<code>.spec.selector</code>未指定，则默认为<code>.spec.template.metadata.labels</code>。</p>
<p>此外，您通常不应创建任何标签与此选择器匹配的pod，可以直接创建，与另一个ReplicationController或其他控制器（如Job）匹配。如果这样做，ReplicationController会认为它创建了其他pod。Kubernetes并没有阻止你这样做。</p>
<p>如果最终有多个具有重叠选择器的控制器，则必须自己管理删除（见<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#working-with-replicationcontrollers" target="_blank" rel="noopener">下文</a>）。</p>
<h6 id="多个副本"><a href="#多个副本" class="headerlink" title="多个副本"></a>多个副本</h6><p>您可以通过设置<code>.spec.replicas</code>要同时运行的窗格数来指定应同时运行的窗格数。在任何时间运行的数字可能更高或更低，例如，如果副本只是增加或减少，或者如果正常关闭吊舱，并且提前开始更换。</p>
<p>如果未指定<code>.spec.replicas</code>，则默认为1。</p>
<h5 id="使用ReplicationControllers"><a href="#使用ReplicationControllers" class="headerlink" title="使用ReplicationControllers"></a>使用ReplicationControllers</h5><h6 id="删除ReplicationController及其Pod"><a href="#删除ReplicationController及其Pod" class="headerlink" title="删除ReplicationController及其Pod"></a>删除ReplicationController及其Pod</h6><p>要删除ReplicationController及其所有pod，请使用<code>kubectl delete</code>。在删除ReplicationController本身之前，Kubectl会将ReplicationController缩放为零并等待它删除每个pod。如果此kubectl命令被中断，则可以重新启动它。</p>
<p>使用REST API或转到客户端库时，需要显式执行这些步骤（将副本扩展为0，等待窗格删除，然后删除ReplicationController）。</p>
<h6 id="仅删除ReplicationController"><a href="#仅删除ReplicationController" class="headerlink" title="仅删除ReplicationController"></a>仅删除ReplicationController</h6><p>您可以删除ReplicationController而不影响其任何pod。</p>
<p>使用kubectl，指定<code>--cascade=false</code>选项<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#delete" target="_blank" rel="noopener"><code>kubectl delete</code></a>。</p>
<p>使用REST API或转到客户端库时，只需删除ReplicationController对象即可。</p>
<p>删除原始文件后，您可以创建一个新的ReplicationController来替换它。只要旧的和新<code>.spec.selector</code>的相同，那么新的将采用旧的pod。但是，它不会做任何努力使现有的pod匹配一个新的，不同的pod模板。要以受控方式将pod更新为新规范，请使用<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#rolling-updates" target="_blank" rel="noopener">滚动更新</a>。</p>
<h6 id="从ReplicationController中隔离pod"><a href="#从ReplicationController中隔离pod" class="headerlink" title="从ReplicationController中隔离pod"></a>从ReplicationController中隔离pod</h6><p>可以通过更改标签来从ReplicationController的目标集中删除Pod。此技术可用于从服务中删除pod以进行调试，数据恢复等。以这种方式删除的Pod将自动替换（假设副本的数量也未更改）。</p>
<h5 id="常见的使用模式"><a href="#常见的使用模式" class="headerlink" title="常见的使用模式"></a>常见的使用模式</h5><h6 id="重新安排"><a href="#重新安排" class="headerlink" title="重新安排"></a>重新安排</h6><p>如上所述，无论您是要保持运行1个pod还是1000个，ReplicationController都将确保存在指定数量的pod，即使在节点发生故障或pod终止时（例如，由于另一个控制剂）。</p>
<h6 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h6><p>通过简单地更新<code>replicas</code>字段，ReplicationController可以手动或通过自动缩放控制代理轻松扩展或缩小副本数量。</p>
<h6 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h6><p>ReplicationController旨在通过逐个替换pod来促进对服务的滚动更新。</p>
<p>如<a href="http://issue.k8s.io/1353" target="_blank" rel="noopener">＃1353</a>中所述，建议的方法是创建一个具有1个副本的新ReplicationController，逐个扩展新的（+1）和旧（-1）控制器，然后在它达到0个副本后删除旧控制器。无论意外故障如何，这都可以预测更新pod的集合。</p>
<p>理想情况下，滚动更新控制器会考虑应用程序准备情况，并确保在任何给定时间内有足够数量的pod可以高效地运行。</p>
<p>这两个ReplicationControllers需要创建具有至少一个区分标签的pod，例如pod的主容器的image标签，因为它通常是图像更新，可以激发滚动更新。</p>
<p>滚动更新在客户端工具中实现 <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rolling-update" target="_blank" rel="noopener"><code>kubectl rolling-update</code></a>。访问<a href="https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/" target="_blank" rel="noopener"><code>kubectl rolling-update</code></a>任务以获得更具体的示例。</p>
<h6 id="多个发行tracks"><a href="#多个发行tracks" class="headerlink" title="多个发行tracks"></a>多个发行tracks</h6><p>除了在滚动更新正在进行时运行多个版本的应用程序之外，通常使用多个版本跟踪长时间运行多个版本，甚至连续运行多个版本。轨道将按标签区分。</p>
<p>例如，服务可能会定位所有pod <code>tier in (frontend), environment in (prod)</code>。现在说你有10个复制的pod组成这个层。但是你希望能够’canary’这个组件的新版本。您可以<code>replicas</code>为大部分副本设置一个设置为9 的ReplicationController ，带有标签<code>tier=frontend, environment=prod, track=stable</code>，另一个<code>replicas</code>设置为1的带有标签的ReplicationController 用于canary<code>tier=frontend, environment=prod, track=canary</code>。现在该服务涵盖了canary和non-canary pods。但是你可以分别搞乱ReplicationControllers来测试，监视结果等。</p>
<h6 id="将ReplicationControllers与Services一起使用"><a href="#将ReplicationControllers与Services一起使用" class="headerlink" title="将ReplicationControllers与Services一起使用"></a>将ReplicationControllers与Services一起使用</h6><p>多个ReplicationControllers可以位于单个服务之后，例如，某些流量转到旧版本，有些流量转到新版本。</p>
<p>ReplicationController永远不会自行终止，但预计它不会像服务一样长寿。服务可以由多个ReplicationControllers控制的pod组成，并且预计可以在服务的生命周期内创建和销毁许多ReplicationController（例如，执行运行服务的pod的更新）。服务本身及其客户端都应该忽略维护服务pod的ReplicationControllers。</p>
<h5 id="编写复制程序"><a href="#编写复制程序" class="headerlink" title="编写复制程序"></a>编写复制程序</h5><p>由ReplicationController创建的Pod旨在是可互换的和语义相同的，尽管它们的配置可能随着时间的推移变得异构。这显然适用于复制的无状态服务器，但ReplicationControllers也可用于维护主选，分片和工作池应用程序的可用性。此类应用程序应使用动态工作分配机制，例如<a href="https://www.rabbitmq.com/tutorials/tutorial-two-python.html" target="_blank" rel="noopener">RabbitMQ工作队列</a>，而不是静态/一次性定制每个pod的配置，这被视为反模式。执行的任何pod自定义，例如资源的垂直自动调整（例如，cpu或内存），应由另一个在线控制器进程执行，与ReplicationController本身不同。</p>
<h5 id="ReplicationController的职责"><a href="#ReplicationController的职责" class="headerlink" title="ReplicationController的职责"></a>ReplicationController的职责</h5><p>ReplicationController只是确保所需数量的pod与其标签选择器匹配并且可以运行。目前，只有已终止的广告连播从其计数中排除。将来，可以考虑系统提供的<a href="http://issue.k8s.io/620" target="_blank" rel="noopener">准备情况</a>和其他信息，我们可以对替换策略添加更多控制，并且我们计划发出可以由外部客户使用的事件，以实现任意复杂的替换和/或扩展下行政策。</p>
<p>ReplicationController永远受限于这种狭隘的责任。它本身不会执行准备就绪或活力探测。它不是执行自动缩放，而是由外部自动缩放器控制（如<a href="http://issue.k8s.io/492" target="_blank" rel="noopener">＃492中所述</a>），这将改变其<code>replicas</code>字段。我们不会将调度策略（例如，<a href="http://issue.k8s.io/367#issuecomment-48428019" target="_blank" rel="noopener">传播</a>）添加到ReplicationController。它也不应该验证控制的pod与当前指定的模板匹配，因为这会妨碍自动调整大小和其他自动化过程。同样，完成期限，排序依赖性，配置扩展和其他功能属于其他地方。我们甚至计划分析批量pod创建的机制（<a href="http://issue.k8s.io/170" target="_blank" rel="noopener">＃170</a>）。</p>
<p>ReplicationController旨在成为可组合的构建块原语。我们希望在它和其他补充原语之上构建更高级别的API和/或工具，以便将来用户使用。kubectl目前支持的“宏”操作（运行，缩放，滚动更新）是概念验证的例子。例如，我们可以想象像<a href="http://techblog.netflix.com/2012/06/asgard-web-based-cloud-management-and.html" target="_blank" rel="noopener">Asgard</a>管理ReplicationControllers，自动缩放器，服务，调度策略，canary等。</p>
<h5 id="API对象-2"><a href="#API对象-2" class="headerlink" title="API对象"></a>API对象</h5><p>复制控制器是Kubernetes REST API中的顶级资源。有关API对象的更多详细信息，请访问： <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#replicationcontroller-v1-core" target="_blank" rel="noopener">ReplicationController API</a>对象。</p>
<h5 id="ReplicationController的替代品"><a href="#ReplicationController的替代品" class="headerlink" title="ReplicationController的替代品"></a>ReplicationController的替代品</h5><h6 id="ReplicaSet-1"><a href="#ReplicaSet-1" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h6><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener"><code>ReplicaSet</code></a>是支持新的<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#set-based-requirement" target="_blank" rel="noopener">基于集合的标签选择器</a>的下一代ReplicationController 。它主要用作<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener"><code>Deployment</code></a>协调pod创建，删除和更新的机制。请注意，除非您需要自定义更新编排或根本不需要更新，否则我们建议您使用“部署”而不是直接使用“副本集”。</p>
<h6 id="部署（推荐）-1"><a href="#部署（推荐）-1" class="headerlink" title="部署（推荐）"></a>部署（推荐）</h6><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener"><code>Deployment</code></a>是一个更高级别的API对象，它以类似的方式更新其基础副本集及其Pod <code>kubectl rolling-update</code>。如果您需要此滚动更新功能，则建议进行部署，因为<code>kubectl rolling-update</code>它们不同于声明式，服务器端，并具有其他功能。</p>
<h6 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h6><p>与用户直接创建pod的情况不同，ReplicationController替换因任何原因而被删除或终止的pod，例如在节点故障或破坏性节点维护（例如内核升级）的情况下。因此，即使您的应用程序只需要一个pod，我们也建议您使用ReplicationController。可以想象它与流程主管类似，只是它监控多个节点上的多个pod而不是单个节点上的单个进程。ReplicationController将本地容器重新启动委派给节点上的某个代理（例如，Kubelet或Docker）。</p>
<h6 id="job"><a href="#job" class="headerlink" title="job"></a>job</h6><p><a href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/" target="_blank" rel="noopener"><code>Job</code></a>对于预期会自行终止的pod（即批处理作业），请使用而不是ReplicationController。</p>
<h6 id="DaemonSet-1"><a href="#DaemonSet-1" class="headerlink" title="DaemonSet"></a>DaemonSet</h6><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener"><code>DaemonSet</code></a>对于提供机器级功能的pod，例如机器监视或机器日志记录，请使用而不是ReplicationController。这些pod的生命周期与机器生命周期相关：pod需要在其他pod启动之前在机器上运行，并且当机器准备好重新启动/关闭时可以安全终止。</p>
<h5 id="欲获得更多信息"><a href="#欲获得更多信息" class="headerlink" title="欲获得更多信息"></a>欲获得更多信息</h5><p>读取<a href="https://kubernetes.io/docs/tutorials/stateless-application/run-stateless-ap-replication-controller/" target="_blank" rel="noopener">运行无状态AP复制控制器</a>。</p>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>一个部署控制器提供声明更新<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="noopener">pod</a>和 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">ReplicaSets</a>。</p>
<p>您在Deployment对象中描述了所需的状态，Deployment控制器以受控速率将实际状态更改为所需状态。您可以定义部署以创建新的ReplicaSet，或者删除现有的部署并使用新的部署采用所有资源。</p>
<blockquote>
<p>注意：您不应管理部署所拥有的ReplicaSet。应通过操作Deployment对象来涵盖所有用例。如果您的用例未在下面介绍，请考虑在主Kubernetes存储库中打开一个问题。</p>
</blockquote>
<ul>
<li>用例</li>
<li>创建部署</li>
<li>更新部署</li>
<li>回滚部署</li>
<li>扩展部署</li>
<li>暂停和恢复部署</li>
<li>部署状态</li>
<li>清理政策</li>
<li>用例</li>
<li>编写部署规范</li>
<li>部署的替代方案</li>
</ul>
<h5 id="用例-1"><a href="#用例-1" class="headerlink" title="用例"></a>用例</h5><p>以下是部署的典型用例：</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#creating-a-deployment" target="_blank" rel="noopener">创建部署以部署副本集</a>。ReplicaSet在后台创建Pod。检查卷展栏的状态以查看它是否成功。</li>
<li>通过更新Deployment的PodTemplateSpec来<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#updating-a-deployment" target="_blank" rel="noopener">声明</a> Pod 的<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#updating-a-deployment" target="_blank" rel="noopener">新状态</a>。创建一个新的ReplicaSet，Deployment部署管理以受控速率将Pod从旧ReplicaSet移动到新ReplicaSet。每个新的ReplicaSet都会更新Deployment的修订版。</li>
<li>如果<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-back-a-deployment" target="_blank" rel="noopener">部署</a>的当前状态不稳定，则<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-back-a-deployment" target="_blank" rel="noopener">回滚到早期的部署修订版</a>。每次回滚都会更新Deployment的修订版。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#scaling-a-deployment" target="_blank" rel="noopener">扩展部署以促进更多负载</a>。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#pausing-and-resuming-a-deployment" target="_blank" rel="noopener">暂停部署</a>以将多个修复程序应用于其PodTemplateSpec，然后恢复它以启动新的部署。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#deployment-status" target="_blank" rel="noopener">使用部署的状态</a>作为卷展栏卡住的指示符。</li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#clean-up-policy" target="_blank" rel="noopener">清理</a>不再需要的<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#clean-up-policy" target="_blank" rel="noopener">旧ReplicaSet</a>。</li>
</ul>
<h5 id="创建部署"><a href="#创建部署" class="headerlink" title="创建部署"></a>创建部署</h5><p>以下是部署的示例。它创建一个ReplicaSet来调出三个Pod <code>nginx</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#controllers/nginx-deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中：</p>
<ul>
<li><code>nginx-deployment</code>创建名为的部署，由<code>.metadata.name</code>字段指示。</li>
<li>部署创建三个复制的Pod，由<code>replicas</code>字段指示。</li>
<li>该<code>selector</code>字段定义了Deployment如何找到要管理的Pod。在这种情况下，您只需选择Pod模板（<code>app: nginx</code>）中定义的标签。但是，只要Pod模板本身满足规则，就可以使用更复杂的选择规则。</li>
</ul>
<blockquote>
<p>注意： <code>matchLabels</code>是{key，value}对的映射。<code>matchLabels</code>映射中的单个{key，value} 等效<code>matchExpressions</code>于其元素，其键字段为“key”，运算符为“In”，值数组仅包含“value”。要求是AND。</p>
</blockquote>
<ul>
<li>该<code>template</code>字段包含以下子字段：<ul>
<li><code>app: nginx</code>使用该<code>labels</code>字段标记Pod 。</li>
<li>Pod模板的规范或.template.spec字段表示Pod 运行一个容器nginx，该容器在版本1.7.9下运行nginx Docker Hub映像。</li>
<li>创建一个容器并nginx使用该name字段命名。</li>
<li>nginx在版本运行图像1.7.9。</li>
<li>打开端口，80以便容器可以发送和接受流量。</li>
</ul>
</li>
</ul>
<p>要创建此部署，请运行以下命令：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f https:<span class="regexp">//</span>k8s.io<span class="regexp">/examples/</span>controllers<span class="regexp">/nginx-deployment.yaml</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：您可以指定<code>--record</code>标志以写入在资源批注中执行的命令kubernetes.io/change-cause。它对于将来的内省非常有用，例如，可以查看每个Deployment修订版中执行的命令。</p>
</blockquote>
<p>接下来，运行<code>kubectl get deployments</code>。输出类似于以下内容：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment   <span class="number">3</span>         <span class="number">0</span>         <span class="number">0</span>            <span class="number">0</span>           <span class="number">1</span>s</span><br></pre></td></tr></table></figure></p>
<p>检查群集中的“部署”时，将显示以下字段：</p>
<ul>
<li><code>NAME</code> 列出群集中的部署名称。</li>
<li><code>DESIRED</code>显示应用程序的所需副本数，您在创建部署时定义这些副本。这是理想的状态。</li>
<li><code>CURRENT</code> 显示当前正在运行的副本数量。</li>
<li><code>UP-TO-DATE</code> 显示已更新以实现所需状态的副本数。</li>
<li><code>AVAILABLE</code> 显示用户可以使用的应用程序副本数。</li>
<li><code>AGE</code> 显示应用程序运行的时间。</li>
</ul>
<p>请注意每个字段中的值如何与Deployment规范中的值相对应：</p>
<ul>
<li>根据<code>.spec.replicas</code>字段，所需副本的数量为3 。</li>
<li>根据<code>.status.replicas</code>字段，当前副本的数量为0 。</li>
<li>根据<code>.status.updatedReplicas</code>字段，最新副本的数量为0 。</li>
<li>根据<code>.status.availableReplicas</code>字段，可用副本的数量为0 。</li>
</ul>
<p>要查看“部署”卷展栏状态，请运行<code>kubectl rollout status deployment.v1.apps/nginx-deployment</code>。此命令返回以下输出：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Waiting <span class="keyword">for</span> rollout <span class="keyword">to</span> finish: <span class="number">2</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="number">3</span> <span class="keyword">new</span> replicas have been updated...</span><br><span class="line">deployment.apps/nginx-deployment successfully rolled <span class="keyword">out</span></span><br></pre></td></tr></table></figure></p>
<p><code>kubectl get deployments</code>几秒钟后再次运行：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>            <span class="number">3</span>           <span class="number">18</span>s</span><br></pre></td></tr></table></figure></p>
<p>请注意，Deployment已创建所有三个副本，并且所有副本都是最新的（它们包含最新的Pod模板）并且可用（Pod状态至少为Deployment的<code>.spec.minReadySeconds</code>字段值准备就绪）。</p>
<p>要查看<code>rs</code>部署创建的ReplicaSet（），请运行<code>kubectl get rs</code>：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                          DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deployment<span class="number">-2035384211</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>       <span class="number">18</span>s</span><br></pre></td></tr></table></figure></p>
<p>请注意，ReplicaSet的名称始终格式为<code>[DEPLOYMENT-NAME]-[POD-TEMPLATE-HASH-VALUE]</code>。创建部署时会自动生成哈希值。</p>
<p>要查看为每个pod自动生成的标签，请运行<code>kubectl get pods --show-labels</code>。返回以下输出：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                                READY     STATUS    RESTARTS   AGE       LABELS</span><br><span class="line">nginx-deployment<span class="number">-2035384211</span><span class="number">-7</span>ci7o   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">18</span>s       app=nginx,pod-template-hash=<span class="number">2035384211</span></span><br><span class="line">nginx-deployment<span class="number">-2035384211</span>-kzszj   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">18</span>s       app=nginx,pod-template-hash=<span class="number">2035384211</span></span><br><span class="line">nginx-deployment<span class="number">-2035384211</span>-qqcnn   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">18</span>s       app=nginx,pod-template-hash=<span class="number">2035384211</span></span><br></pre></td></tr></table></figure></p>
<p>创建的ReplicaSet确保始终有三个Pod <code>nginx</code>在运行。</p>
<blockquote>
<p>注意：您必须在部署中指定适当的选择器和Pod模板标签（在本例中 <code>app: nginx</code>）。不要将标签或选择器与其他控制器（包括其他部署和StatefulSet）重叠。Kubernetes不会阻止您重叠，如果多个控制器具有重叠的选择器，那么这些控制器可能会发生冲突并出现意外行为。</p>
</blockquote>
<h6 id="Pod-template-hash标签"><a href="#Pod-template-hash标签" class="headerlink" title="Pod-template-hash标签"></a>Pod-template-hash标签</h6><blockquote>
<p>注意：请勿更改此标签。</p>
</blockquote>
<p><code>pod-template-hash</code>部署控制器将标签添加到部署创建或采用的每个ReplicaSet。</p>
<p>此标签可确保部署的子ReplicaSet不重叠。它是通过散列<code>PodTemplate</code>ReplicaSet并使用生成的散列作为添加到ReplicaSet选择器，Pod模板标签以及ReplicaSet可能具有的任何现有Pod中的标签值生成的。</p>
<h5 id="更新部署"><a href="#更新部署" class="headerlink" title="更新部署"></a>更新部署</h5><blockquote>
<p>注意：当且仅当部署的pod模板（即<code>.spec.template</code>）更改时，才会触发Deployment的部署，例如，如果更新模板的标签或容器图像。其他更新（例如扩展部署）不会触发部署。</p>
</blockquote>
<p>假设您现在想要更新nginx Pod以使用<code>nginx:1.9.1</code>镜像而不是<code>nginx:1.7.9</code>图像。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl --record deployment.apps/nginx-deployment <span class="builtin-name">set</span> image deployment.v1.apps/nginx-deployment</span><br><span class="line"><span class="attribute">nginx</span>=nginx:1.9.1 image updated</span><br></pre></td></tr></table></figure></p>
<p>或者，您可以<code>edit</code>部署和改变<code>.spec.template.spec.containers[0].image</code>从<code>nginx:1.7.9</code>到<code>nginx:1.9.1</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl edit deployment<span class="selector-class">.v1</span><span class="selector-class">.apps</span>/nginx-deployment</span><br><span class="line">deployment.apps/nginx-deployment edited</span><br></pre></td></tr></table></figure>
<p>要查看卷展栏状态，请运行：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout status deployment.v1.apps/nginx-deployment</span><br><span class="line">Waiting <span class="keyword">for</span> rollout <span class="keyword">to</span> finish: <span class="number">2</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="number">3</span> <span class="keyword">new</span> replicas have been updated...</span><br><span class="line">deployment.apps/nginx-deployment successfully rolled <span class="keyword">out</span></span><br></pre></td></tr></table></figure></p>
<p>部署成功后，您可能需要<code>get</code>部署：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deployments</span><br><span class="line">NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>            <span class="number">3</span>           <span class="number">36</span>s</span><br></pre></td></tr></table></figure></p>
<p>最新副本的数量表示Deployment已将副本更新为最新配置。当前副本表示此部署管理的副本总数，可用副本表示可用的当前副本数。</p>
<p>您可以运行<code>kubectl get rs</code>以查看部署通过创建新的ReplicaSet并将其扩展到3个副本来更新Pod，以及将旧的ReplicaSet缩减为0个副本。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get rs</span><br><span class="line">NAME                          DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>       <span class="number">6</span>s</span><br><span class="line">nginx-deployment<span class="number">-2035384211</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">36</span>s</span><br></pre></td></tr></table></figure></p>
<p><code>get pods</code>现在运行应该只显示新的Pod：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME                                READY     STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span>-khku8   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>s</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span>-nacti   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>s</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span>-z9gth   <span class="number">1</span>/<span class="number">1</span>       Running   <span class="number">0</span>          <span class="number">14</span>s</span><br></pre></td></tr></table></figure></p>
<p>下次要更新这些Pod时，只需再次更新Deployment的pod模板。</p>
<p>部署可以确保在更新时只有一定数量的Pod可能会关闭。默认情况下，它确保至少比所需的Pod数量少25％（最大不可用25％）。</p>
<p>部署还可以确保在所需数量的Pod之上只能创建一定数量的Pod。默认情况下，它确保最多比所需数量的Pod多25％（最大浪涌25％）。</p>
<p>例如，如果仔细查看上面的部署，您将看到它首先创建了一个新的Pod，然后删除了一些旧的Pod并创建了新的Pod。在有足够数量的新Pod出现之前，它不会杀死旧的Pod，并且在足够数量的旧Pod被杀之前不会创建新的Pod。它确保可用Pod的数量至少为2，并且Pod的总数最多为4。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe deployments</span><br><span class="line">Name:                   nginx-deployment</span><br><span class="line">Namespace:              default</span><br><span class="line">CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000</span><br><span class="line">Labels:                 <span class="attribute">app</span>=nginx</span><br><span class="line">Annotations:            deployment.kubernetes.io/<span class="attribute">revision</span>=2</span><br><span class="line">Selector:               <span class="attribute">app</span>=nginx</span><br><span class="line">Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  <span class="attribute">app</span>=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:        nginx:1.9.1</span><br><span class="line">    Port:         80/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line"> <span class="built_in"> Type </span>          Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      <span class="literal">True</span>    MinimumReplicasAvailable</span><br><span class="line">  Progressing    <span class="literal">True</span>    NewReplicaSetAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   nginx-deployment-1564180365 (3/3 replicas created)</span><br><span class="line">Events:</span><br><span class="line"> <span class="built_in"> Type </span>   Reason             Age   <span class="keyword">From</span>                   Message</span><br><span class="line">  ----    ------             ----  ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 3</span><br><span class="line">  Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-1564180365 <span class="keyword">to</span> 1</span><br><span class="line">  Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 2</span><br><span class="line">  Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-1564180365 <span class="keyword">to</span> 2</span><br><span class="line">  Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 1</span><br><span class="line">  Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-1564180365 <span class="keyword">to</span> 3</span><br><span class="line">  Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 0</span><br></pre></td></tr></table></figure></p>
<p>在这里，您可以看到，当您第一次创建部署时，它创建了一个ReplicaSet（nginx-deployment-2035384211）并直接将其扩展到3个副本。更新部署时，它创建了一个新的ReplicaSet（nginx-deployment-1564180365）并将其扩展为1，然后将旧的ReplicaSet缩小为2，这样至少有2个Pod可用，最多创建了4个Pod一直。然后，它继续使用相同的滚动更新策略向上和向下扩展新旧ReplicaSet。最后，您将在新的ReplicaSet中拥有3个可用副本，并将旧的ReplicaSet缩小为0。</p>
<h6 id="Rollover-aka-multiple-updates-in-flight"><a href="#Rollover-aka-multiple-updates-in-flight" class="headerlink" title="Rollover (aka multiple updates in-flight)"></a>Rollover (aka multiple updates in-flight)</h6><p>每次部署控制器观察到新的部署对象时，如果没有现有的ReplicaSet，则会创建ReplicaSet以显示所需的Pod。现有的ReplicaSet控制其标签匹配<code>.spec.selector</code>但模板不匹配的Pod <code>.spec.template</code>按比例缩小。最终，新的ReplicaSet将缩放到，<code>.spec.replicas</code>并且所有旧的ReplicaSet将缩放为0。</p>
<p>如果在现有部署过程中更新部署，则部署将根据更新创建新的ReplicaSet并开始向上扩展，并将翻转之前正在扩展的ReplicaSet - 它会将其添加到其列表中旧的ReplicaSet和将开始缩小它。</p>
<p>例如，假设您创建了一个部署以创建5个副本<code>nginx:1.7.9</code>，但是<code>nginx:1.9.1</code>当仅创建了3个副本时，则更新部署以创建5个副本<code>nginx:1.7.9</code>。在这种情况下，部署将立即开始杀死<code>nginx:1.7.9</code>它创建的3个Pod，并将开始创建 <code>nginx:1.9.1Pod</code>。<code>nginx:1.7.9</code>在更改课程之前，它不会等待创建5个副本。</p>
<h6 id="标签选择器更新"><a href="#标签选择器更新" class="headerlink" title="标签选择器更新"></a>标签选择器更新</h6><p>通常不鼓励进行标签选择器更新，建议您事先规划选择器。在任何情况下，如果您需要执行标签选择器更新，请务必小心谨慎，并确保您已掌握所有含义。</p>
<blockquote>
<p>注意：在API版本中<code>apps/v1</code>，部署的标签选择器在创建后是不可变的。</p>
</blockquote>
<ul>
<li>选择器添加要求使用新标签更新部署规范中的pod模板标签，否则将返回验证错误。此更改是非重叠的，这意味着新选择器不会选择使用旧选择器创建的ReplicaSet和Pod，从而导致孤立所有旧ReplicaSet并创建新的ReplicaSet。</li>
<li>选择器更新 - 即更改选择器键中的现有值 - 导致与添加相同的行为。</li>
<li>选择器删除 - 即从部署选择器中删除现有密钥 - 不需要对pod模板标签进行任何更改。没有现有的ReplicaSet是孤立的，并且未创建新的ReplicaSet，但请注意，已删除的标签仍存在于任何现有的Pod和ReplicaSet中。</li>
</ul>
<h5 id="回滚部署"><a href="#回滚部署" class="headerlink" title="回滚部署"></a>回滚部署</h5><p>有时您可能想要回滚部署; 例如，当部署不稳定时，例如崩溃循环。默认情况下，所有Deployment的卷展栏历史记录都保留在系统中，以便您可以随时回滚（可以通过修改修订历史记录限制来更改）。</p>
<blockquote>
<p>注意：触发Deployment的部署时会创建Deployment的修订版。这意味着当且仅当部署的pod模板（<code>.spec.template</code>）发生更改时才会创建新修订，例如，如果更新模板的标签或容器图像。其他更新（例如扩展部署）不会创建部署版本，因此您可以方便地同时进行手动或自动扩展。这意味着当您回滚到早期版本时，仅回滚Deployment的pod模板部分。</p>
</blockquote>
<p>假设您在更新部署时输入了拼写错误，方法是将图像名称<code>nginx:1.91</code>替换为<code>nginx:1.9.1</code>：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">set</span> image deployment.v1.apps/nginx-deployment <span class="attribute">nginx</span>=nginx:1.91 <span class="attribute">--record</span>=<span class="literal">true</span></span><br><span class="line">deployment.apps/nginx-deployment image updated</span><br></pre></td></tr></table></figure>
<p>推出将被卡住。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout status deployment.v1.apps/nginx-deployment</span><br><span class="line">Waiting <span class="keyword">for</span> rollout <span class="keyword">to</span> finish: <span class="number">1</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="number">3</span> <span class="keyword">new</span> replicas have been updated...</span><br></pre></td></tr></table></figure></p>
<p>按Ctrl-C可停止上面的卷展状态监视。有关卡片推出的更多信息， <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#deployment-status" target="_blank" rel="noopener">请在此处阅读更多信息</a>。</p>
<p>您将看到旧副本的数量（nginx-deployment-1564180365和nginx-deployment-2035384211）为2，新副本（nginx-deployment-3066724191）为1。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get rs</span><br><span class="line">NAME                          DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>       <span class="number">25</span>s</span><br><span class="line">nginx-deployment<span class="number">-2035384211</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">36</span>s</span><br><span class="line">nginx-deployment<span class="number">-3066724191</span>   <span class="number">1</span>         <span class="number">1</span>         <span class="number">0</span>       <span class="number">6</span>s</span><br></pre></td></tr></table></figure></p>
<p>查看创建的Pod，您将看到由新ReplicaSet创建的1 Pod陷入图像拉环。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME                                READY     STATUS             RESTARTS   AGE</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span><span class="number">-70</span>iae   <span class="number">1</span>/<span class="number">1</span>       Running            <span class="number">0</span>          <span class="number">25</span>s</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span>-jbqqo   <span class="number">1</span>/<span class="number">1</span>       Running            <span class="number">0</span>          <span class="number">25</span>s</span><br><span class="line">nginx-deployment<span class="number">-1564180365</span>-hysrc   <span class="number">1</span>/<span class="number">1</span>       Running            <span class="number">0</span>          <span class="number">25</span>s</span><br><span class="line">nginx-deployment<span class="number">-3066724191</span><span class="number">-08</span>mng   <span class="number">0</span>/<span class="number">1</span>       ImagePullBackOff   <span class="number">0</span>          <span class="number">6</span>s</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意： Deployment控制器将自动停止错误的卷展栏，并将停止扩展新的ReplicaSet。这取决于maxUnavailable您指定的rollingUpdate参数（特别是）。默认情况下，Kubernetes将值设置为25％。</p>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe deployment</span><br><span class="line">Name:           nginx-deployment</span><br><span class="line">Namespace:      default</span><br><span class="line">CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700</span><br><span class="line">Labels:         <span class="attribute">app</span>=nginx</span><br><span class="line">Selector:       <span class="attribute">app</span>=nginx</span><br><span class="line">Replicas:       3 desired | 1 updated | 4 total | 3 available | 1 unavailable</span><br><span class="line">StrategyType:       RollingUpdate</span><br><span class="line">MinReadySeconds:    0</span><br><span class="line">RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  <span class="attribute">app</span>=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:        nginx:1.91</span><br><span class="line">    Port:         80/TCP</span><br><span class="line">    Host Port:    0/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line"> <span class="built_in"> Type </span>          Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      <span class="literal">True</span>    MinimumReplicasAvailable</span><br><span class="line">  Progressing    <span class="literal">True</span>    ReplicaSetUpdated</span><br><span class="line">OldReplicaSets:     nginx-deployment-1564180365 (3/3 replicas created)</span><br><span class="line">NewReplicaSet:      nginx-deployment-3066724191 (1/1 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  FirstSeen LastSeen    Count   <span class="keyword">From</span>                    SubobjectPath  <span class="built_in"> Type </span>       Reason              Message</span><br><span class="line">  --------- --------    -----   ----                    -------------   --------    ------              -------</span><br><span class="line">  1m        1m          1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled up replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 3</span><br><span class="line">  22s       22s         1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled up replica <span class="builtin-name">set</span> nginx-deployment-1564180365 <span class="keyword">to</span> 1</span><br><span class="line">  22s       22s         1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled down replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 2</span><br><span class="line">  22s       22s         1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled up replica <span class="builtin-name">set</span> nginx-deployment-1564180365 <span class="keyword">to</span> 2</span><br><span class="line">  21s       21s         1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled down replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 1</span><br><span class="line">  21s       21s         1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled up replica <span class="builtin-name">set</span> nginx-deployment-1564180365 <span class="keyword">to</span> 3</span><br><span class="line">  13s       13s         1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled down replica <span class="builtin-name">set</span> nginx-deployment-2035384211 <span class="keyword">to</span> 0</span><br><span class="line">  13s       13s         1       &#123;deployment-controller &#125;                Normal      ScalingReplicaSet   Scaled up replica <span class="builtin-name">set</span> nginx-deployment-3066724191 <span class="keyword">to</span> 1</span><br></pre></td></tr></table></figure>
<p>要解决此问题，您需要回滚到稳定的以前版本的Deployment。</p>
<h6 id="检查部署的部署历史记录"><a href="#检查部署的部署历史记录" class="headerlink" title="检查部署的部署历史记录"></a>检查部署的部署历史记录</h6><p>首先，检查此部署的修订版：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout history deployment.v1.apps/nginx-deployment</span><br><span class="line">deployments <span class="string">"nginx-deployment"</span></span><br><span class="line">REVISION    CHANGE-CAUSE</span><br><span class="line">1           kubectl create <span class="attribute">--filename</span>=https://k8s.io/examples/controllers/nginx-deployment.yaml <span class="attribute">--record</span>=<span class="literal">true</span></span><br><span class="line">2           kubectl <span class="builtin-name">set</span> image deployment.v1.apps/nginx-deployment <span class="attribute">nginx</span>=nginx:1.9.1 <span class="attribute">--record</span>=<span class="literal">true</span></span><br><span class="line">3           kube    ctl <span class="builtin-name">set</span> image deployment.v1.apps/nginx-deployment <span class="attribute">nginx</span>=nginx:1.91 <span class="attribute">--record</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p><code>CHANGE-CAUSEkubernetes.io/change-cause</code>在创建时从部署批注复制到其修订版。您可以<code>CHANGE-CAUSE</code>通过以下方式指定消息： </p>
<ul>
<li>注释部署 <code>kubectl annotate deployment.v1.apps/nginx-deployment kubernetes.io/change-cause=&quot;image updated to 1.9.1&quot;</code></li>
<li>附加<code>--record</code>标志以保存<code>kubectl</code>对资源进行更改的命令。</li>
<li>手动编辑资源的清单。</li>
</ul>
<p>要进一步查看每个修订的详细信息，请运行：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout history deployment.v1.apps/nginx-deployment <span class="attribute">--revision</span>=2</span><br><span class="line">deployments <span class="string">"nginx-deployment"</span> revision 2</span><br><span class="line">  Labels:       <span class="attribute">app</span>=nginx</span><br><span class="line">          <span class="attribute">pod-template-hash</span>=1159050644</span><br><span class="line">  Annotations:  kubernetes.io/<span class="attribute">change-cause</span>=kubectl <span class="builtin-name">set</span> image deployment.v1.apps/nginx-deployment <span class="attribute">nginx</span>=nginx:1.9.1 <span class="attribute">--record</span>=<span class="literal">true</span></span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:      nginx:1.9.1</span><br><span class="line">    Port:       80/TCP</span><br><span class="line">     QoS Tier:</span><br><span class="line">        cpu:      BestEffort</span><br><span class="line">        memory:   BestEffort</span><br><span class="line">    Environment Variables:      &lt;none&gt;</span><br><span class="line">  <span class="literal">No</span> volumes.</span><br></pre></td></tr></table></figure></p>
<h6 id="回滚到以前的版本"><a href="#回滚到以前的版本" class="headerlink" title="回滚到以前的版本"></a>回滚到以前的版本</h6><p>现在，您已决定撤消当前的卷展栏并回滚到上一版本：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout undo deployment<span class="selector-class">.v1</span><span class="selector-class">.apps</span>/nginx-deployment</span><br><span class="line">deployment.apps/nginx-deployment</span><br></pre></td></tr></table></figure></p>
<p>或者，您可以通过在<code>--to-revision</code>以下位置指定回滚到特定修订：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout undo deployment<span class="selector-class">.v1</span><span class="selector-class">.apps</span>/nginx-deployment --to-revision=<span class="number">2</span></span><br><span class="line">deployment.apps/nginx-deployment</span><br></pre></td></tr></table></figure></p>
<p>有关与推出相关的命令的更多详细信息，请阅读<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rollout" target="_blank" rel="noopener">kubectl rollout</a>。</p>
<p>部署现在回滚到以前的稳定版本。如您所见，<code>DeploymentRollback</code>从Deployment控制器生成用于回滚到版本2 的事件。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">get</span> deployment nginx-deployment</span><br><span class="line">NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment   3         3         3            3           30m</span><br><span class="line"></span><br><span class="line">$ kubectl describe deployment nginx-deployment</span><br><span class="line">Name:                   nginx-deployment</span><br><span class="line">Namespace:              default</span><br><span class="line">CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500</span><br><span class="line">Labels:                 <span class="attribute">app</span>=nginx</span><br><span class="line">Annotations:            deployment.kubernetes.io/<span class="attribute">revision</span>=4</span><br><span class="line">                        kubernetes.io/<span class="attribute">change-cause</span>=kubectl <span class="builtin-name">set</span> image deployment.v1.apps/nginx-deployment <span class="attribute">nginx</span>=nginx:1.9.1 <span class="attribute">--record</span>=<span class="literal">true</span></span><br><span class="line">Selector:               <span class="attribute">app</span>=nginx</span><br><span class="line">Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  <span class="attribute">app</span>=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:        nginx:1.9.1</span><br><span class="line">    Port:         80/TCP</span><br><span class="line">    Host Port:    0/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line"> <span class="built_in"> Type </span>          Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      <span class="literal">True</span>    MinimumReplicasAvailable</span><br><span class="line">  Progressing    <span class="literal">True</span>    NewReplicaSetAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   nginx-deployment-c4747d96c (3/3 replicas created)</span><br><span class="line">Events:</span><br><span class="line"> <span class="built_in"> Type </span>   Reason              Age   <span class="keyword">From</span>                   Message</span><br><span class="line">  ----    ------              ----  ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-75675f5897 <span class="keyword">to</span> 3</span><br><span class="line">  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-c4747d96c <span class="keyword">to</span> 1</span><br><span class="line">  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica <span class="builtin-name">set</span> nginx-deployment-75675f5897 <span class="keyword">to</span> 2</span><br><span class="line">  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-c4747d96c <span class="keyword">to</span> 2</span><br><span class="line">  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica <span class="builtin-name">set</span> nginx-deployment-75675f5897 <span class="keyword">to</span> 1</span><br><span class="line">  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-c4747d96c <span class="keyword">to</span> 3</span><br><span class="line">  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica <span class="builtin-name">set</span> nginx-deployment-75675f5897 <span class="keyword">to</span> 0</span><br><span class="line">  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica <span class="builtin-name">set</span> nginx-deployment-595696685f <span class="keyword">to</span> 1</span><br><span class="line">  Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment <span class="string">"nginx-deployment"</span> <span class="keyword">to</span> revision 2</span><br><span class="line">  Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica <span class="builtin-name">set</span> nginx-deployment-595696685f <span class="keyword">to</span> 0</span><br></pre></td></tr></table></figure></p>
<h5 id="扩展部署"><a href="#扩展部署" class="headerlink" title="扩展部署"></a>扩展部署</h5><p>您可以使用以下命令扩展部署：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl scale deployment<span class="selector-class">.v1</span><span class="selector-class">.apps</span>/nginx-deployment --replicas=<span class="number">10</span></span><br><span class="line">deployment.apps/nginx-deployment scaled</span><br></pre></td></tr></table></figure></p>
<p>假设在群集中启用了<a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/" target="_blank" rel="noopener">水平pod自动缩放</a>，则可以为Deployment设置自动缩放器，并根据现有Pod的CPU利用率选择要运行的最小和最大<a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/" target="_blank" rel="noopener">Pod</a>数。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl autoscale deployment.v1.apps/nginx-deployment <span class="attribute">--min</span>=10 <span class="attribute">--max</span>=15 <span class="attribute">--cpu-percent</span>=80</span><br><span class="line">deployment.apps/nginx-deployment scaled</span><br></pre></td></tr></table></figure>
<h6 id="比例缩放"><a href="#比例缩放" class="headerlink" title="比例缩放"></a>比例缩放</h6><p>RollingUpdate Deployments支持同时运行多个版本的应用程序。当您或自动扩展器扩展正在部署（正在进行或暂停）的RollingUpdate部署时，部署控制器将平衡现有活动副本集（具有Pod的副本集）中的其他副本，以降低风险。这称为比例缩放。</p>
<p>例如，您正在运行具有10个副本的部署，<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#max-surge" target="_blank" rel="noopener"><code>maxSurge</code></a> = 3和<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#max-unavailable" target="_blank" rel="noopener"><code>maxUnavailable</code></a> = 2。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deploy</span><br><span class="line">NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment     <span class="number">10</span>        <span class="number">10</span>        <span class="number">10</span>           <span class="number">10</span>          <span class="number">50</span>s</span><br></pre></td></tr></table></figure></p>
<p>您更新到一个新的映像，该映像恰好在集群内部无法解析。<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> kubectl <span class="keyword">set</span> image <span class="comment">deployment.v1.apps</span>/nginx-deployment nginx=nginx:sometag</span><br><span class="line">deployment.apps/<span class="comment">nginx-deployment image updated</span></span><br></pre></td></tr></table></figure></p>
<p>图像更新使用ReplicaSet nginx-deployment-1989198191开始新的部署，但由于<code>maxUnavailable</code>您在上面提到的要求而被阻止 。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get rs</span><br><span class="line">NAME                          DESIRED   CURRENT   READY     AGE</span><br><span class="line">nginx-deployment<span class="number">-1989198191</span>   <span class="number">5</span>         <span class="number">5</span>         <span class="number">0</span>         <span class="number">9</span>s</span><br><span class="line">nginx-deployment<span class="number">-618515232</span>    <span class="number">8</span>         <span class="number">8</span>         <span class="number">8</span>         <span class="number">1</span>m</span><br></pre></td></tr></table></figure></p>
<p>然后出现一个新的部署扩展请求。自动缩放器将部署副本增加到15.部署控制器需要决定在哪里添加这些新的5个副本。如果您没有使用比例缩放，则所有5个都将添加到新的ReplicaSet中。通过比例缩放，您可以在所有ReplicaSet上传播其他副本。具有最多副本的ReplicaSets和较低比例的较大比例将转到具有较少副本的ReplicaSet。任何剩余物都会添加到具有最多副本的ReplicaSet中。零副本的ReplicaSet不会按比例放大。</p>
<p>在上面的示例中，3个副本将添加到旧的ReplicaSet中，2个副本将添加到新的ReplicaSet中。假设新副本变得健康，推出过程最终应将所有副本移动到新的ReplicaSet。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deploy</span><br><span class="line">NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment     <span class="number">15</span>        <span class="number">18</span>        <span class="number">7</span>            <span class="number">8</span>           <span class="number">7</span>m</span><br><span class="line">$ kubectl get rs</span><br><span class="line">NAME                          DESIRED   CURRENT   READY     AGE</span><br><span class="line">nginx-deployment<span class="number">-1989198191</span>   <span class="number">7</span>         <span class="number">7</span>         <span class="number">0</span>         <span class="number">7</span>m</span><br><span class="line">nginx-deployment<span class="number">-618515232</span>    <span class="number">11</span>        <span class="number">11</span>        <span class="number">11</span>        <span class="number">7</span>m</span><br></pre></td></tr></table></figure></p>
<h5 id="暂停和恢复部署"><a href="#暂停和恢复部署" class="headerlink" title="暂停和恢复部署"></a>暂停和恢复部署</h5><p>您可以在触发一个或多个更新之前暂停部署，然后恢复它。这将允许您在暂停和恢复之间应用多个修复，而不会触发不必要的部署。</p>
<p>例如，使用刚刚创建的部署：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deploy</span><br><span class="line">NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx     <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>            <span class="number">3</span>           <span class="number">1</span>m</span><br><span class="line">$ kubectl get rs</span><br><span class="line">NAME               DESIRED   CURRENT   READY     AGE</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>         <span class="number">1</span>m</span><br></pre></td></tr></table></figure></p>
<p>通过运行以下命令暂停：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout pause deployment<span class="selector-class">.v1</span><span class="selector-class">.apps</span>/nginx-deployment</span><br><span class="line">deployment.apps/nginx-deployment paused</span><br></pre></td></tr></table></figure></p>
<p>然后更新部署的映像：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> kubectl <span class="keyword">set</span> image <span class="comment">deployment.v1.apps</span>/nginx-deployment nginx=nginx:<span class="number">1.9</span><span class="number">.1</span></span><br><span class="line">deployment.apps/<span class="comment">nginx-deployment image updated</span></span><br></pre></td></tr></table></figure></p>
<p>请注意，没有新的卷展栏开始：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout history deployment.v1.apps/nginx-deployment</span><br><span class="line">deployments <span class="string">"nginx"</span></span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line"><span class="number">1</span>   &lt;none&gt;</span><br><span class="line"></span><br><span class="line">$ kubectl get rs</span><br><span class="line">NAME               DESIRED   CURRENT   READY     AGE</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>         <span class="number">2</span>m</span><br></pre></td></tr></table></figure></p>
<p>您可以根据需要进行更多更新，例如，更新将使用的资源：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="builtin-name">set</span> resources deployment.v1.apps/nginx-deployment <span class="attribute">-c</span>=nginx <span class="attribute">--limits</span>=cpu=200m,memory=512Mi</span><br><span class="line">deployment.apps/nginx-deployment<span class="built_in"> resource </span>requirements updated</span><br></pre></td></tr></table></figure></p>
<p>暂停之前部署的初始状态将继续其功能，但只要部署暂停，部署的新更新将不会产生任何影响。</p>
<p>最后，恢复部署并观察一个新的ReplicaSet，提供所有新的更新：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout resume deployment.v1.apps/nginx-deployment</span><br><span class="line">deployment.apps/nginx-deployment resumed</span><br><span class="line">$ kubectl get rs -w</span><br><span class="line">NAME               DESIRED   CURRENT   READY     AGE</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">2</span>         <span class="number">2</span>         <span class="number">2</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">2</span>         <span class="number">2</span>         <span class="number">0</span>         <span class="number">6</span>s</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">2</span>         <span class="number">2</span>         <span class="number">1</span>         <span class="number">18</span>s</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">1</span>         <span class="number">2</span>         <span class="number">2</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">1</span>         <span class="number">2</span>         <span class="number">2</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">3</span>         <span class="number">2</span>         <span class="number">1</span>         <span class="number">18</span>s</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">3</span>         <span class="number">2</span>         <span class="number">1</span>         <span class="number">18</span>s</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">1</span>         <span class="number">1</span>         <span class="number">1</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">1</span>         <span class="number">18</span>s</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">2</span>         <span class="number">19</span>s</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">0</span>         <span class="number">1</span>         <span class="number">1</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">0</span>         <span class="number">1</span>         <span class="number">1</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>         <span class="number">20</span>s</span><br><span class="line">^C</span><br><span class="line">$ kubectl get rs</span><br><span class="line">NAME               DESIRED   CURRENT   READY     AGE</span><br><span class="line">nginx<span class="number">-2142116321</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>         <span class="number">2</span>m</span><br><span class="line">nginx<span class="number">-3926361531</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>         <span class="number">28</span>s</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：在恢复暂停部署之前，无法回滚暂停部署。</p>
</blockquote>
<h5 id="部署状态"><a href="#部署状态" class="headerlink" title="部署状态"></a>部署状态</h5><p>部署在其生命周期中进入各种状态。它可以<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progressing-deployment" target="_blank" rel="noopener"><code>前进</code></a>，同时推出新ReplicaSet，也可以是<a href="hhttps://kubernetes.io/docs/concepts/workloads/controllers/deployment/#complete-deployment" target="_blank" rel="noopener">完整的</a>，也可以<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#failed-deployment" target="_blank" rel="noopener">不取得进展</a>。</p>
<h6 id="进步部署"><a href="#进步部署" class="headerlink" title="进步部署"></a>进步部署</h6><p>当执行以下任务之一时，Kubernetes将部署标记为进度：</p>
<ul>
<li>部署创建一个新的ReplicaSet。</li>
<li>部署正在扩展其最新的ReplicaSet。</li>
<li>部署正在缩减其旧的ReplicaSet。</li>
<li>新Pod已准备就绪或可用（至少准备<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds" target="_blank" rel="noopener">MinReadySeconds</a>）。</li>
</ul>
<p>您可以使用监视部署的进度<code>kubectl rollout status</code>。</p>
<h6 id="完成部署"><a href="#完成部署" class="headerlink" title="完成部署"></a>完成部署</h6><p>Kubernetes 在具有以下特征时将部署标记为完成：</p>
<ul>
<li>与部署关联的所有副本都已更新为您指定的最新版本，这意味着您已请求的任何更新已完成。</li>
<li>可以使用与部署关联的所有副本。</li>
<li>没有旧的部署副本正在运行。</li>
</ul>
<p>您可以使用检查部署是否已完成<code>kubectl rollout status</code>。如果卷展栏成功完成，则<code>kubectl rollout status</code>返回零退出代码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl rollout status deployment.v1.apps/nginx-deployment</span></span><br><span class="line">Waiting for rollout to finish: 2 of 3 updated replicas are available...</span><br><span class="line">deployment.apps/nginx-deployment successfully rolled out</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h6 id="部署失败"><a href="#部署失败" class="headerlink" title="部署失败"></a>部署失败</h6><p>您的部署可能会在尝试部署其最新的ReplicaSet时遇到困难，而无需完成。这可能是由于以下一些因素造成的：</p>
<ul>
<li>配额不足</li>
<li>准备探针失败</li>
<li>图像拉错误</li>
<li>权限不足</li>
<li>限制范围</li>
<li>应用程序运行时配置错误</li>
</ul>
<p>检测此情况的一种方法是在部署规范中指定截止时间参数:(<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds" target="_blank" rel="noopener"><code>.spec.progressDeadlineSeconds</code></a>）。<code>.spec.progressDeadlineSeconds</code>表示部署控制器在指示（在“部署”状态中）部署进度已停止之前等待的秒数。</p>
<p>以下<code>kubectl</code>命令设置规范<code>progressDeadlineSeconds</code>以使控制器报告在10分钟后缺少部署进度：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl patch deployment<span class="selector-class">.v1</span><span class="selector-class">.apps</span>/nginx-deployment -<span class="selector-tag">p</span> <span class="string">'&#123;"spec":&#123;"progressDeadlineSeconds":600&#125;&#125;'</span></span><br><span class="line">deployment.apps/nginx-deployment patched</span><br></pre></td></tr></table></figure>
<p>超过截止日期后，Deployment控制器会向Deployment部署一个具有以下属性的DeploymentCondition <code>.status.conditions</code>：</p>
<ul>
<li>类型=进展</li>
<li>状态=假</li>
<li>原因= ProgressDeadlineExceeded</li>
</ul>
<p>有关状态条件的更多信息，请参阅<a href="https://git.k8s.io/community/contributors/devel/api-conventions.md#typical-status-properties" target="_blank" rel="noopener">Kubernetes API约定</a>。</p>
<blockquote>
<p>注意：除了报告状态条件之外，Kubernetes不对停顿的部署采取任何操作 <code>Reason=ProgressDeadlineExceeded</code>。更高级别的协调器可以利用它并相应地采取相应措施，例如，将部署回滚到其先前版本。</p>
</blockquote>
<blockquote>
<p>注意：如果您暂停部署，Kubernetes不会根据您指定的截止日期检查进度。您可以安全地在部署和暂停期间暂停部署，而不会触发超出截止日期的条件。</p>
</blockquote>
<p>由于您设置的超时时间较短或者由于任何其他可被视为瞬态的错误，您可能会遇到部署的暂时性错误。例如，假设您的配额不足。如果您描述部署，您将注意到以下部分：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">describe</span> <span class="string">deployment</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="string">&lt;...&gt;</span></span><br><span class="line"><span class="attr">Conditions:</span></span><br><span class="line">  <span class="string">Type</span>            <span class="string">Status</span>  <span class="string">Reason</span></span><br><span class="line"><span class="bullet">  -</span><span class="meta">---</span>            <span class="bullet">------</span>  <span class="bullet">------</span></span><br><span class="line">  <span class="string">Available</span>       <span class="literal">True</span>    <span class="string">MinimumReplicasAvailable</span></span><br><span class="line">  <span class="string">Progressing</span>     <span class="literal">True</span>    <span class="string">ReplicaSetUpdated</span></span><br><span class="line">  <span class="string">ReplicaFailure</span>  <span class="literal">True</span>    <span class="string">FailedCreate</span></span><br><span class="line"><span class="string">&lt;...&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果您运行<code>kubectl get deployment nginx-deployment -o yaml</code>，部署状态可能如下所示：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">status:</span></span><br><span class="line"><span class="attr">  availableReplicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  conditions:</span></span><br><span class="line"><span class="attr">  - lastTransitionTime:</span> <span class="number">2016</span><span class="bullet">-10</span><span class="bullet">-04</span><span class="attr">T12:25:39Z</span></span><br><span class="line"><span class="attr">    lastUpdateTime:</span> <span class="number">2016</span><span class="bullet">-10</span><span class="bullet">-04</span><span class="attr">T12:25:39Z</span></span><br><span class="line"><span class="attr">    message:</span> <span class="string">Replica</span> <span class="string">set</span> <span class="string">"nginx-deployment-4262182780"</span> <span class="string">is</span> <span class="string">progressing.</span></span><br><span class="line"><span class="attr">    reason:</span> <span class="string">ReplicaSetUpdated</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Progressing</span></span><br><span class="line"><span class="attr">  - lastTransitionTime:</span> <span class="number">2016</span><span class="bullet">-10</span><span class="bullet">-04</span><span class="attr">T12:25:42Z</span></span><br><span class="line"><span class="attr">    lastUpdateTime:</span> <span class="number">2016</span><span class="bullet">-10</span><span class="bullet">-04</span><span class="attr">T12:25:42Z</span></span><br><span class="line"><span class="attr">    message:</span> <span class="string">Deployment</span> <span class="string">has</span> <span class="string">minimum</span> <span class="string">availability.</span></span><br><span class="line"><span class="attr">    reason:</span> <span class="string">MinimumReplicasAvailable</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Available</span></span><br><span class="line"><span class="attr">  - lastTransitionTime:</span> <span class="number">2016</span><span class="bullet">-10</span><span class="bullet">-04</span><span class="attr">T12:25:39Z</span></span><br><span class="line"><span class="attr">    lastUpdateTime:</span> <span class="number">2016</span><span class="bullet">-10</span><span class="bullet">-04</span><span class="attr">T12:25:39Z</span></span><br><span class="line"><span class="attr">    message:</span> <span class="string">'Error creating: pods "nginx-deployment-4262182780-" is forbidden: exceeded quota:</span></span><br><span class="line"><span class="string">      object-counts, requested: pods=1, used: pods=3, limited: pods=2'</span></span><br><span class="line"><span class="attr">    reason:</span> <span class="string">FailedCreate</span></span><br><span class="line"><span class="attr">    status:</span> <span class="string">"True"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">ReplicaFailure</span></span><br><span class="line"><span class="attr">  observedGeneration:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  unavailableReplicas:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>最终，一旦超出部署进度截止日期，Kubernetes将更新状态和进度条件的原因：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Conditions:</span></span><br><span class="line">  <span class="string">Type</span>            <span class="string">Status</span>  <span class="string">Reason</span></span><br><span class="line"><span class="bullet">  -</span><span class="meta">---</span>            <span class="bullet">------</span>  <span class="bullet">------</span></span><br><span class="line">  <span class="string">Available</span>       <span class="literal">True</span>    <span class="string">MinimumReplicasAvailable</span></span><br><span class="line">  <span class="string">Progressing</span>     <span class="literal">False</span>   <span class="string">ProgressDeadlineExceeded</span></span><br><span class="line">  <span class="string">ReplicaFailure</span>  <span class="literal">True</span>    <span class="string">FailedCreate</span></span><br></pre></td></tr></table></figure></p>
<p>您可以通过缩小部署，缩小可能正在运行的其他控制器或增加命名空间中的配额来解决配额不足的问题。如果您满足配额条件，然后部署控制器完成“部署”卷展栏，您将看到部署状态更新成功条件（<code>Status=True</code>和<code>Reason=NewReplicaSetAvailable</code>）。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Conditions:</span></span><br><span class="line">  <span class="string">Type</span>          <span class="string">Status</span>  <span class="string">Reason</span></span><br><span class="line"><span class="bullet">  -</span><span class="meta">---</span>          <span class="bullet">------</span>  <span class="bullet">------</span></span><br><span class="line">  <span class="string">Available</span>     <span class="literal">True</span>    <span class="string">MinimumReplicasAvailable</span></span><br><span class="line">  <span class="string">Progressing</span>   <span class="literal">True</span>    <span class="string">NewReplicaSetAvailable</span></span><br></pre></td></tr></table></figure></p>
<p><code>Type=Available</code>与<code>Status=True</code>您的部署具有最小可用性手段。最低可用性由部署策略中指定的参数决定。<code>Type=Progressing</code>和 <code>Status=True</code>表示您的部署正处于推出过程中并且正在进行中或已成功完成其进度并且所需的最小新副本可用（请参阅详细信息的条件原因 - 在我们的情况下 <code>Reason=NewReplicaSetAvailable</code>意味着部署完成）。</p>
<p>您可以使用检查部署是否未能进展<code>kubectl rollout status</code>。<code>kubectl rollout status</code> 如果部署已超过进度截止日期，则返回非零退出代码。</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout status deployment.v1.apps/nginx-deployment</span><br><span class="line">Waiting for rollout to finish: 2 out of 3 new replicas have been updated...</span><br><span class="line"><span class="keyword">error: </span>deployment "nginx" exceeded its progress deadline</span><br><span class="line">$ echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h6 id="在失败的部署上运行"><a href="#在失败的部署上运行" class="headerlink" title="在失败的部署上运行"></a>在失败的部署上运行</h6><p>适用于完整部署的所有操作也适用于失败的部署。如果需要在“部署”窗格模板中应用多个调整，可以向上/向下缩放，回滚到以前的版本，甚至可以暂停它。</p>
<h5 id="清理政策"><a href="#清理政策" class="headerlink" title="清理政策"></a>清理政策</h5><p>您可以<code>.spec.revisionHistoryLimit</code>在部署中设置字段，以指定要保留此部署的旧ReplicaSet数。其余的将在后台进行垃圾收集。默认情况下，它是10。</p>
<blockquote>
<p>注意：将此字段显式设置为0将导致清理部署的所有历史记录，从而部署将无法回滚。</p>
</blockquote>
<h5 id="用例-2"><a href="#用例-2" class="headerlink" title="用例"></a>用例</h5><h6 id="Canary部署"><a href="#Canary部署" class="headerlink" title="Canary部署"></a>Canary部署</h6><p>如果要使用部署将发布部署到用户或服务器的子集，则可以按照<a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments" target="_blank" rel="noopener">管理资源</a>中描述的canary模式创建多个部署，每个版本一个 。</p>
<h5 id="编写部署规范"><a href="#编写部署规范" class="headerlink" title="编写部署规范"></a>编写部署规范</h5><p>与所有其他Kubernetes CONFIGS，部署需求<code>apiVersion</code>，<code>kind</code>以及<code>metadata</code>各个领域。有关使用配置文件的一般信息，请参阅<a href="https://kubernetes.io/docs/tutorials/stateless-application/run-stateless-application-deployment/" target="_blank" rel="noopener">部署应用程序</a>，配置容器以及<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/overview/" target="_blank" rel="noopener">使用kubectl管理资源文档</a>。</p>
<p>部署还需要一个<a href="https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status" target="_blank" rel="noopener"><code>.spec</code>部分</a>。</p>
<h6 id="Pod模板-3"><a href="#Pod模板-3" class="headerlink" title="Pod模板"></a>Pod模板</h6><p>这<code>.spec.template</code>是唯一必需的领域<code>.spec</code>。</p>
<p>这<code>.spec.template</code>是一个<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#pod-templates" target="_blank" rel="noopener">pod模板</a>。它与Pod具有完全相同的架构，除了它是嵌套的并且没有 <code>apiVersion</code>或<code>kind</code>。</p>
<p>除了Pod的必填字段外，部署中的pod模板还必须指定适当的标签和适当的重新启动策略。对于标签，请确保不要与其他控制器重叠。见<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#selector" target="_blank" rel="noopener">选择器</a>）。</p>
<p>只允许<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy" target="_blank" rel="noopener"><code>.spec.template.spec.restartPolicy</code></a>等于<code>Always</code>，如果未指定，则为默认值。</p>
<h6 id="副本-1"><a href="#副本-1" class="headerlink" title="副本"></a>副本</h6><p><code>.spec.replicas</code>是一个可选字段，指定所需Pod的数量。默认为1。</p>
<h6 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h6><p><code>.spec.selector</code>是一个可选字段，用于指定 此部署所针对的Pod 的标签选择器。</p>
<p><code>.spec.selector</code>必须匹配<code>.spec.template.metadata.labels</code>，否则它将被API拒绝。</p>
<p>在API版本<code>apps/v1</code>，<code>.spec.selector</code>并且<code>.metadata.labels</code>不默认<code>.spec.template.metadata.labels</code>，如果没有设置。所以必须明确设置它们。另请注意，<code>.spec.selector</code>在创建部署后，它是不可变的<code>apps/v1</code>。</p>
<p>部署可以终止其标签与选择器匹配的Pod，如果它们的模板不同<code>.spec.template</code>或者此类Pod的总数超过<code>.spec.replicas</code>。<code>.spec.template</code>如果Pod 的数量小于所需的数量，它会调出新的Pod 。</p>
<blockquote>
<p>注意：您不应通过创建另一个部署或通过创建另一个控制器（如ReplicaSet或ReplicationController）来创建其标签与此选择器匹配的其他pod。如果您这样做，第一个部署认为它创建了这些其他pod。Kubernetes并没有阻止你这样做。</p>
</blockquote>
<p>如果您有多个具有重叠选择器的控制器，控制器将相互争斗并且行为不正确。</p>
<h6 id="战略"><a href="#战略" class="headerlink" title="战略"></a>战略</h6><p><code>.spec.strategy</code>指定用于替换旧Pod的策略。 <code>.spec.strategy.type</code>可以是“重新创建”或“RollingUpdate”。“RollingUpdate”是默认值。</p>
<h5 id="重新创建部署"><a href="#重新创建部署" class="headerlink" title="重新创建部署"></a>重新创建部署</h5><p>所有现有的Pod都会在创建新的Pod之前被杀死.spec.strategy.type==Recreate。</p>
<h5 id="滚动更新部署"><a href="#滚动更新部署" class="headerlink" title="滚动更新部署"></a>滚动更新部署</h5><p>部署时会以滚动更新 方式更新Pod <code>.spec.strategy.type==RollingUpdate</code>。您可以指定<code>maxUnavailable</code>并<code>maxSurge</code>控制滚动更新过程。</p>
<p><strong>maxUnavailable</strong></p>
<p><code>.spec.strategy.rollingUpdate.maxUnavailable</code>是一个可选字段，指定更新过程中可用的最大Pod数。该值可以是绝对数（例如，5）或所需Pod的百分比（例如，10％）。通过四舍五入计算绝对数字的百分比。如果<code>.spec.strategy.rollingUpdate.maxSurge</code>为0，则该值不能为0.默认值为25％。</p>
<p>例如，当此值设置为30％时，旧的ReplicaSet可以在滚动更新开始时立即按比例缩小到所需Pod的70％。准备好新的Pod后，可以进一步缩小旧的ReplicaSet，然后扩展新的ReplicaSet，确保在更新期间始终可用的Pod总数至少是所需Pod的70％。</p>
<p><strong>Max Surge</strong></p>
<p><code>.spec.strategy.rollingUpdate.maxSurge</code>是一个可选字段，指定可以在所需数量的Pod上创建的最大Pod数。该值可以是绝对数（例如，5）或所需Pod的百分比（例如，10％）。如果<code>MaxUnavailable</code>为0，则该值不能为0.绝对数量是通过向上舍入的百分比计算的。默认值为25％。</p>
<p>例如，当此值设置为30％时，可以在滚动更新开始时立即按比例放大新的ReplicaSet，这样旧的和新的Pod的总数不会超过所需Pod的130％。一旦旧的Pod被杀死，新的ReplicaSet可以进一步扩展，确保在更新期间随时运行的Pod总数最多为所需Pod的130％。</p>
<h6 id="进度截止日期"><a href="#进度截止日期" class="headerlink" title="进度截止日期"></a>进度截止日期</h6><p><code>.spec.progressDeadlineSeconds</code>是一个可选字段，指定在系统报告部署失败进度之前等待部署进度的秒数 - 表示为带有<code>Type=Progressing</code>，<code>Status=False</code>。的条件。以及<code>Reason=ProgressDeadlineExceeded</code>资源的状态。部署控制器将继续重试部署。将来，一旦实现自动回滚，部署控制器将在观察到这种情况后立即回滚部署。</p>
<p>如果指定，则此字段必须大于<code>.spec.minReadySeconds</code>。</p>
<h6 id="Min-Ready-Seconds"><a href="#Min-Ready-Seconds" class="headerlink" title="Min Ready Seconds"></a>Min Ready Seconds</h6><p><code>.spec.minReadySeconds</code>是一个可选字段，指定新创建的Pod应该在没有任何容器崩溃的情况下准备好的最小秒数，以使其可用。默认为0（Pod一旦准备好就会被视为可用）。要了解有关何时认为Pod已准备就绪的详细信息，请参阅<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes" target="_blank" rel="noopener">容器探测器</a>。</p>
<h6 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h6><p>现场<code>.spec.rollbackTo</code>已被弃用的API版本<code>extensions/v1beta1</code>和<code>apps/v1beta1</code>，并在API版本不再支持开始<code>apps/v1beta2</code>。相反，应该使用<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-back-to-a-previous-revision" target="_blank" rel="noopener">回滚到先前版本</a>中的<code>kubectl rollout undo</code>介绍。</p>
<h6 id="修订历史限制"><a href="#修订历史限制" class="headerlink" title="修订历史限制"></a>修订历史限制</h6><p>部署的修订历史记录存储在它控制的副本集中。</p>
<p><code>.spec.revisionHistoryLimit</code>是一个可选字段，指定要保留以允许回滚的旧ReplicaSet的数量。其理想值取决于新部署的频率和稳定性。如果未设置此字段，则默认情况下将保留所有旧的ReplicaSet，消耗资源<code>etcd</code>并拥挤输出<code>kubectl get rs</code>。每个Deployment修订版的配置都存储在其ReplicaSet中; 因此，一旦删除旧的ReplicaSet，您将无法回滚到该部署版本。</p>
<p>更具体地说，将此字段设置为零意味着将清除所有具有0副本的旧ReplicaSet。在这种情况下，无法撤消新的“部署”卷展栏，因为它的修订历史记录已清除。</p>
<h6 id="已暂停"><a href="#已暂停" class="headerlink" title="已暂停"></a>已暂停</h6><p><code>.spec.paused</code>是一个可选的布尔字段，用于暂停和恢复部署。暂停部署与未暂停部署之间的唯一区别是，暂停部署的PodTemplateSpec的任何更改都不会触发新的部署，只要它暂停即可。默认情况下，部署在创建时不会暂停。</p>
<h5 id="部署的替代方案"><a href="#部署的替代方案" class="headerlink" title="部署的替代方案"></a>部署的替代方案</h5><h6 id="kubectl滚动更新"><a href="#kubectl滚动更新" class="headerlink" title="kubectl滚动更新"></a>kubectl滚动更新</h6><p><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rolling-update" target="_blank" rel="noopener"><code>kubectl rolling update</code></a>以类似的方式更新Pod和ReplicationControllers。但建议使用部署，因为它们是声明性的，服务器端，并且具有其他功能，例如即使在滚动更新完成后回滚到任何先前的修订版。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dinghuang.github.io/2019/01/11/CentOS上安装Shadowsocks客户端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="强壮的病猫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dinghuang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一只病猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/11/CentOS上安装Shadowsocks客户端/" itemprop="url">CentOS上安装Shadowsocks客户端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T15:47:00+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/11/CentOS上安装Shadowsocks客户端/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/01/11/CentOS上安装Shadowsocks客户端/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CentOS上安装Shadowsocks客户端"><a href="#CentOS上安装Shadowsocks客户端" class="headerlink" title="CentOS上安装Shadowsocks客户端"></a>CentOS上安装Shadowsocks客户端</h1><h2 id="Shadowsocks简介"><a href="#Shadowsocks简介" class="headerlink" title="Shadowsocks简介"></a>Shadowsocks简介</h2><p>Shadowsocks，是一种加密的传输方式（一种基于 Socks5 代理方式的网络数据加密传输包）；SS 是目前主流的科学上网方式，是目前最稳定最好用的科学上网工具之一。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h3><p>pip是Python的包管理工具，我们接下来是使用pip安装的Shadowsocks。</p>
<ol>
<li><p>通过yum管理工具安装：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> -y pip</span><br></pre></td></tr></table></figure>
</li>
<li><p>镜像库没有这个包，那么可以手动安装:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">"https://bootstrap.pypa.io/get-pip.py"</span> -<span class="keyword">o</span> <span class="string">"get-pip.py"</span></span><br><span class="line"><span class="keyword">python</span> <span class="built_in">get</span>-pip.<span class="keyword">py</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="安装Shadowsocks客户端"><a href="#安装Shadowsocks客户端" class="headerlink" title="安装Shadowsocks客户端"></a>安装Shadowsocks客户端</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> <span class="comment">--upgrade pip</span></span><br><span class="line">pip <span class="keyword">install</span> shadowsocks</span><br></pre></td></tr></table></figure>
<p>新建配置文件<code>vi /etc/shadowsocks.json</code>：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"server"</span>:<span class="string">"x.x.x.x"</span>,</span><br><span class="line"><span class="attr">"server_port"</span>:<span class="number">25247</span>,</span><br><span class="line"><span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line"><span class="attr">"local_port"</span>:<span class="number">25252</span>,</span><br><span class="line"><span class="attr">"password"</span>:<span class="string">"123456"</span>,</span><br><span class="line"><span class="attr">"timeout"</span>:<span class="number">1000</span>,</span><br><span class="line"><span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line"><span class="attr">"workers"</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编写启动服务<code>vi /etc/systemd/system/shadowsocks.service</code>:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=shadowsocks</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">TimeoutStartSec</span>=<span class="number">30</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/sslocal -c /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>启动服务<code>systemctl start shadowsocks</code>，运行 <code>curl --socks5 127.0.0.1:25252 http://httpbin.org/ip</code> ， 返回你ss服务器ip，则说明Shadowsocks客户端启动成功。</p>
<h2 id="使用Privoxy把shadowsocks转换为Http代理"><a href="#使用Privoxy把shadowsocks转换为Http代理" class="headerlink" title="使用Privoxy把shadowsocks转换为Http代理"></a>使用Privoxy把shadowsocks转换为Http代理</h2><h3 id="Privoxy简介"><a href="#Privoxy简介" class="headerlink" title="Privoxy简介"></a>Privoxy简介</h3><p>Privoxy是一个代理辅助工具，这里用Privoxy把Shadowsocks socks5代理转换为http代理。可以作为kubernetes的docker容器需要访问google的服务，也同时可以作为命令行的代理，本实例用作命令行代理。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>使用yum安装：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> privoxy -y</span><br></pre></td></tr></table></figure></p>
<p>修改配置文件<code>vi /etc/privoxy/config</code>，加入一行代码<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 / <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">25252</span> .</span><br><span class="line">listen-address <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">8118</span>  #这里的<span class="built_in">ip</span>也可以是k8s的<span class="built_in">ip</span></span><br></pre></td></tr></table></figure></p>
<p>启动服务<code>systemctl start privoxy</code>，执行命令<code>curl -x localhost:8118 google.com</code>，返回数据则表示服务启动成功</p>
<h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><p>编辑文件<code>vi /etc/profile</code>：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">http_proxy</span>=http://127.0.0.1:8118</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">https_proxy</span>=http://127.0.0.1:8118</span><br></pre></td></tr></table></figure></p>
<p>使配置生效<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure></p>
<p>测试代码<code>curl www.google.com</code>，返回数据则成功设置全局命令行代理</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/dinghuang.png"
                alt="强壮的病猫" />
            
              <p class="site-author-name" itemprop="name">强壮的病猫</p>
              <p class="site-description motion-element" itemprop="description">学习、生活、闲谈、足球</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dinghuang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">强壮的病猫</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://dinghuang-1.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
